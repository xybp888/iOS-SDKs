// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8 (swiftlang-5.8.0.117.59 clang-1403.0.22.8.50)
// swift-module-flags: -target arm64e-apple-ios16.4 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftFoundation -swift-version 5 -enforce-exclusivity=unchecked -O -library-level api -module-name Foundation
// swift-module-flags-ignorable: -enable-bare-slash-regex -user-module-version 1971
import Combine
import CoreFoundation
import Darwin
import Dispatch
@_exported import Foundation
import ObjectiveC
import Swift
import _Concurrency
import _StringProcessing
import Darwin.uuid
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol _KeyValueCodingAndObservingPublishing {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ObjectiveC.NSObject : Foundation._KeyValueCodingAndObservingPublishing {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation._KeyValueCodingAndObservingPublishing where Self : ObjectiveC.NSObject {
  public func publisher<Value>(for keyPath: Swift.KeyPath<Self, Value>, options: Foundation.NSKeyValueObservingOptions = [.initial, .new]) -> ObjectiveC.NSObject.KeyValueObservingPublisher<Self, Value>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ObjectiveC.NSObject.KeyValueObservingPublisher {
  public func didChange() -> Combine.Publishers.Map<ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>, Swift.Void>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ObjectiveC.NSObject {
  public struct KeyValueObservingPublisher<Subject, Value> : Swift.Equatable where Subject : ObjectiveC.NSObject {
    public let object: Subject
    public let keyPath: Swift.KeyPath<Subject, Value>
    public let options: Foundation.NSKeyValueObservingOptions
    public init(object: Subject, keyPath: Swift.KeyPath<Subject, Value>, options: Foundation.NSKeyValueObservingOptions)
    public static func == (lhs: ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>, rhs: ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>) -> Swift.Bool
  }
}
@available(iOS, unavailable, introduced: 13)
@available(*, unavailable)
extension ObjectiveC.NSObject.KeyValueObservingPublisher : @unchecked Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ObjectiveC.NSObject.KeyValueObservingPublisher : Combine.Publisher {
  public typealias Output = Value
  public typealias Failure = Swift.Never
  public func receive<S>(subscriber: S) where Value == S.Input, S : Combine.Subscriber, S.Failure == Swift.Never
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct IntegerParseStrategy<Format> : Swift.Codable, Swift.Hashable where Format : Foundation.FormatStyle, Format.FormatInput : Swift.BinaryInteger {
  public var formatStyle: Format
  public var lenient: Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.IntegerParseStrategy<Format>, b: Foundation.IntegerParseStrategy<Format>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy : Swift.Sendable where Format : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Format.FormatInput
  public typealias ParseInput = Swift.String
  public typealias ParseOutput = Format.FormatInput
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.IntegerFormatStyle<Value>, Value : Swift.BinaryInteger
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.IntegerFormatStyle<Value>.Percent, Value : Swift.BinaryInteger
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.IntegerFormatStyle<Value>.Currency, Value : Swift.BinaryInteger
}
@_objcRuntimeName(_TtC10Foundation20_PropertyListEncoder) open class PropertyListEncoder {
  open var outputFormat: Foundation.PropertyListSerialization.PropertyListFormat {
    get
    set
    _modify
  }
  open var userInfo: [Swift.CodingUserInfoKey : Any] {
    get
    set
    _modify
  }
  public init()
  @objc deinit
  open func encode<Value>(_ value: Value) throws -> Foundation.Data where Value : Swift.Encodable
}
@_objcRuntimeName(_TtC10Foundation20_PropertyListDecoder) open class PropertyListDecoder {
  open var userInfo: [Swift.CodingUserInfoKey : Any] {
    get
    set
    _modify
  }
  public init()
  @objc deinit
  open func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
  open func decode<T>(_ type: T.Type, from data: Foundation.Data, format: inout Foundation.PropertyListSerialization.PropertyListFormat) throws -> T where T : Swift.Decodable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.PropertyListEncoder : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.PropertyListDecoder : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Duration {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public struct TimeFormatStyle : Foundation.FormatStyle, Swift.Sendable {
    public struct Pattern : Swift.Hashable, Swift.Codable, Swift.Sendable {
      public static var hourMinute: Swift.Duration.TimeFormatStyle.Pattern {
        get
      }
      public static func hourMinute(padHourToLength: Swift.Int, roundSeconds: Swift.FloatingPointRoundingRule = .toNearestOrEven) -> Swift.Duration.TimeFormatStyle.Pattern
      public static var hourMinuteSecond: Swift.Duration.TimeFormatStyle.Pattern {
        get
      }
      public static func hourMinuteSecond(padHourToLength: Swift.Int, fractionalSecondsLength: Swift.Int = 0, roundFractionalSeconds: Swift.FloatingPointRoundingRule = .toNearestOrEven) -> Swift.Duration.TimeFormatStyle.Pattern
      public static var minuteSecond: Swift.Duration.TimeFormatStyle.Pattern {
        get
      }
      public static func minuteSecond(padMinuteToLength: Swift.Int, fractionalSecondsLength: Swift.Int = 0, roundFractionalSeconds: Swift.FloatingPointRoundingRule = .toNearestOrEven) -> Swift.Duration.TimeFormatStyle.Pattern
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Swift.Duration.TimeFormatStyle.Pattern, b: Swift.Duration.TimeFormatStyle.Pattern) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public var locale: Foundation.Locale {
      get
      set
    }
    public var pattern: Swift.Duration.TimeFormatStyle.Pattern {
      get
      set
    }
    public var attributed: Swift.Duration.TimeFormatStyle.Attributed {
      get
    }
    public init(pattern: Swift.Duration.TimeFormatStyle.Pattern, locale: Foundation.Locale = .autoupdatingCurrent)
    public func format(_ value: Swift.Duration) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Swift.Duration.TimeFormatStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Swift.Duration.TimeFormatStyle, b: Swift.Duration.TimeFormatStyle) -> Swift.Bool
    public typealias FormatInput = Swift.Duration
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FormatStyle where Self == Swift.Duration.TimeFormatStyle {
  public static func time(pattern: Swift.Duration.TimeFormatStyle.Pattern) -> Self
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Duration.TimeFormatStyle {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public struct Attributed : Foundation.FormatStyle, Swift.Sendable {
    public func locale(_ locale: Foundation.Locale) -> Swift.Duration.TimeFormatStyle.Attributed
    public func format(_ value: Swift.Duration) -> Foundation.AttributedString
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Swift.Duration.TimeFormatStyle.Attributed, b: Swift.Duration.TimeFormatStyle.Attributed) -> Swift.Bool
    public typealias FormatInput = Swift.Duration
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public func formatted<F>(_ format: F) -> F.FormatOutput where F : Foundation.FormatStyle, F.FormatInput == Foundation.Date
  public func formatted(date: Foundation.Date.FormatStyle.DateStyle, time: Foundation.Date.FormatStyle.TimeStyle) -> Swift.String
  public func formatted() -> Swift.String
  public init<T>(_ value: T.ParseInput, strategy: T) throws where T : Foundation.ParseStrategy, T.ParseOutput == Foundation.Date
  @_disfavoredOverload public init<T, Value>(_ value: Value, strategy: T) throws where T : Foundation.ParseStrategy, Value : Swift.StringProtocol, T.ParseInput == Swift.String, T.ParseOutput == Foundation.Date
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct FormatStyle : Swift.Sendable {
    public var locale: Foundation.Locale
    public var timeZone: Foundation.TimeZone
    public var calendar: Foundation.Calendar
    public var capitalizationContext: Foundation.FormatStyleCapitalizationContext
    public var attributed: Foundation.Date.AttributedStyle {
      get
    }
    public init(date: Foundation.Date.FormatStyle.DateStyle? = nil, time: Foundation.Date.FormatStyle.TimeStyle? = nil, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, timeZone: Foundation.TimeZone = .autoupdatingCurrent, capitalizationContext: Foundation.FormatStyleCapitalizationContext = .unknown)
  }
  public struct AttributedStyle : Foundation.FormatStyle, Swift.Sendable {
    public func format(_ value: Foundation.Date) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.AttributedStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.AttributedStyle, b: Foundation.Date.AttributedStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.Date
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle {
  public func era(_ format: Foundation.Date.FormatStyle.Symbol.Era = .abbreviated) -> Foundation.Date.FormatStyle
  public func year(_ format: Foundation.Date.FormatStyle.Symbol.Year = .defaultDigits) -> Foundation.Date.FormatStyle
  public func quarter(_ format: Foundation.Date.FormatStyle.Symbol.Quarter = .abbreviated) -> Foundation.Date.FormatStyle
  public func month(_ format: Foundation.Date.FormatStyle.Symbol.Month = .abbreviated) -> Foundation.Date.FormatStyle
  public func week(_ format: Foundation.Date.FormatStyle.Symbol.Week = .defaultDigits) -> Foundation.Date.FormatStyle
  public func day(_ format: Foundation.Date.FormatStyle.Symbol.Day = .defaultDigits) -> Foundation.Date.FormatStyle
  public func dayOfYear(_ format: Foundation.Date.FormatStyle.Symbol.DayOfYear = .defaultDigits) -> Foundation.Date.FormatStyle
  public func weekday(_ format: Foundation.Date.FormatStyle.Symbol.Weekday = .abbreviated) -> Foundation.Date.FormatStyle
  public func hour(_ format: Foundation.Date.FormatStyle.Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Foundation.Date.FormatStyle
  public func minute(_ format: Foundation.Date.FormatStyle.Symbol.Minute = .defaultDigits) -> Foundation.Date.FormatStyle
  public func second(_ format: Foundation.Date.FormatStyle.Symbol.Second = .defaultDigits) -> Foundation.Date.FormatStyle
  public func secondFraction(_ format: Foundation.Date.FormatStyle.Symbol.SecondFraction) -> Foundation.Date.FormatStyle
  public func timeZone(_ format: Foundation.Date.FormatStyle.Symbol.TimeZone = .specificName(.short)) -> Foundation.Date.FormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle : Foundation.FormatStyle {
  public func format(_ value: Foundation.Date) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.Date.FormatStyle
  public typealias FormatInput = Foundation.Date
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Foundation.Date
  public typealias ParseInput = Swift.String
  public typealias ParseOutput = Foundation.Date
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle : Swift.Codable, Swift.Hashable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.Date.FormatStyle, b: Foundation.Date.FormatStyle) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle {
  public struct DateStyle : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static let omitted: Foundation.Date.FormatStyle.DateStyle
    public static let numeric: Foundation.Date.FormatStyle.DateStyle
    public static let abbreviated: Foundation.Date.FormatStyle.DateStyle
    public static let long: Foundation.Date.FormatStyle.DateStyle
    public static let complete: Foundation.Date.FormatStyle.DateStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatStyle.DateStyle, b: Foundation.Date.FormatStyle.DateStyle) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct TimeStyle : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static let omitted: Foundation.Date.FormatStyle.TimeStyle
    public static let shortened: Foundation.Date.FormatStyle.TimeStyle
    public static let standard: Foundation.Date.FormatStyle.TimeStyle
    public static let complete: Foundation.Date.FormatStyle.TimeStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatStyle.TimeStyle, b: Foundation.Date.FormatStyle.TimeStyle) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Date.FormatStyle {
    get
  }
  public typealias Strategy = Foundation.Date.FormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.FormatStyle {
  public static var dateTime: Foundation.Date.FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Date.FormatStyle {
  public static var dateTime: Foundation.Date.FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseStrategy where Self == Foundation.Date.FormatStyle {
  @_disfavoredOverload public static var dateTime: Foundation.Date.FormatStyle {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Date.FormatStyle : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Date
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Date)?
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.NSAttributedString {
  convenience public init(contentsOf url: Foundation.URL, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  convenience public init(markdown: Foundation.Data, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  convenience public init(markdown: Swift.String, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
}
public protocol _KeyValueCodingAndObserving {
}
extension ObjectiveC.NSObject : Foundation._KeyValueCodingAndObserving {
}
public struct NSKeyValueObservedChange<Value> {
  public typealias Kind = Foundation.NSKeyValueChange
  public let kind: Foundation.NSKeyValueObservedChange<Value>.Kind
  public let newValue: Value?
  public let oldValue: Value?
  public let indexes: Foundation.IndexSet?
  public let isPrior: Swift.Bool
}
extension Foundation.NSKeyValueObservedChange : Swift.Sendable where Value : Swift.Sendable {
}
public protocol NSKeyValueObservingCustomization : ObjectiveC.NSObjectProtocol {
  static func keyPathsAffectingValue(for key: Swift.AnyKeyPath) -> Swift.Set<Swift.AnyKeyPath>
  static func automaticallyNotifiesObservers(for key: Swift.AnyKeyPath) -> Swift.Bool
}
@_hasMissingDesignatedInitializers @objc(_NSKeyValueObservation) public class NSKeyValueObservation : ObjectiveC.NSObject {
  @objc public func invalidate()
  @objc deinit
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.NSKeyValueObservation : @unchecked Swift.Sendable {
}
extension Foundation._KeyValueCodingAndObserving {
  #if compiler(>=5.3) && $Sendable
  @preconcurrency public func observe<Value>(_ keyPath: Swift.KeyPath<Self, Value>, options: Foundation.NSKeyValueObservingOptions = [], changeHandler: @escaping @Sendable (Self, Foundation.NSKeyValueObservedChange<Value>) -> Swift.Void) -> Foundation.NSKeyValueObservation
  #endif
  #if compiler(>=5.3) && $UnavailableFromAsync
  @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.") public func willChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>)
  #else
  public func willChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>)
  #endif
  #if compiler(>=5.3) && $UnavailableFromAsync
  @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.") public func willChange<Value>(_ changeKind: Foundation.NSKeyValueChange, valuesAt indexes: Foundation.IndexSet, for keyPath: __owned Swift.KeyPath<Self, Value>)
  #else
  public func willChange<Value>(_ changeKind: Foundation.NSKeyValueChange, valuesAt indexes: Foundation.IndexSet, for keyPath: __owned Swift.KeyPath<Self, Value>)
  #endif
  #if compiler(>=5.3) && $UnavailableFromAsync
  @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.") public func willChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>, withSetMutation mutation: Foundation.NSKeyValueSetMutationKind, using set: Swift.Set<Value>) where Value : Swift.Hashable
  #else
  public func willChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>, withSetMutation mutation: Foundation.NSKeyValueSetMutationKind, using set: Swift.Set<Value>) where Value : Swift.Hashable
  #endif
  #if compiler(>=5.3) && $UnavailableFromAsync
  @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.") public func didChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>)
  #else
  public func didChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>)
  #endif
  #if compiler(>=5.3) && $UnavailableFromAsync
  @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.") public func didChange<Value>(_ changeKind: Foundation.NSKeyValueChange, valuesAt indexes: Foundation.IndexSet, for keyPath: __owned Swift.KeyPath<Self, Value>)
  #else
  public func didChange<Value>(_ changeKind: Foundation.NSKeyValueChange, valuesAt indexes: Foundation.IndexSet, for keyPath: __owned Swift.KeyPath<Self, Value>)
  #endif
  #if compiler(>=5.3) && $UnavailableFromAsync
  @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.") public func didChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>, withSetMutation mutation: Foundation.NSKeyValueSetMutationKind, using set: Swift.Set<Value>) where Value : Swift.Hashable
  #else
  public func didChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>, withSetMutation mutation: Foundation.NSKeyValueSetMutationKind, using set: Swift.Set<Value>) where Value : Swift.Hashable
  #endif
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public typealias Published = Combine.Published
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public typealias ObservableObject = Combine.ObservableObject
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.Date {
  public typealias Stride = Foundation.TimeInterval
  public func distance(to other: Foundation.Date) -> Foundation.TimeInterval
  public func advanced(by n: Foundation.TimeInterval) -> Foundation.Date
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Date : Swift.Strideable {
}
extension Foundation.Dimension {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  convenience public init(forLocale: Foundation.Locale)
}
extension Foundation.UnitTemperature {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_disfavoredOverload convenience public init(forLocale: Foundation.Locale, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitTemperature> = .general)
}
extension Foundation.UnitLength {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_disfavoredOverload convenience public init(forLocale: Foundation.Locale, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> = .general)
}
extension Foundation.UnitEnergy {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_disfavoredOverload convenience public init(forLocale: Foundation.Locale, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitEnergy> = .general)
}
extension Foundation.UnitMass {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_disfavoredOverload convenience public init(forLocale: Foundation.Locale, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitMass> = .general)
}
extension Foundation.UnitVolume {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_disfavoredOverload convenience public init(forLocale: Foundation.Locale, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitVolume> = .general)
}
extension Foundation.Date {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct IntervalFormatStyle : Foundation.FormatStyle, Swift.Codable, Swift.Hashable, Swift.Sendable {
    public typealias DateStyle = Foundation.Date.FormatStyle.DateStyle
    public typealias TimeStyle = Foundation.Date.FormatStyle.TimeStyle
    public var locale: Foundation.Locale
    public var timeZone: Foundation.TimeZone
    public var calendar: Foundation.Calendar
    public init(date: Foundation.Date.IntervalFormatStyle.DateStyle? = nil, time: Foundation.Date.IntervalFormatStyle.TimeStyle? = nil, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, timeZone: Foundation.TimeZone = .autoupdatingCurrent)
    public func format(_ v: Swift.Range<Foundation.Date>) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.IntervalFormatStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.IntervalFormatStyle, b: Foundation.Date.IntervalFormatStyle) -> Swift.Bool
    public typealias FormatInput = Swift.Range<Foundation.Date>
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.IntervalFormatStyle {
  public typealias Symbol = Foundation.Date.FormatStyle.Symbol
  public func year() -> Foundation.Date.IntervalFormatStyle
  public func month(_ format: Foundation.Date.IntervalFormatStyle.Symbol.Month = .abbreviated) -> Foundation.Date.IntervalFormatStyle
  public func day() -> Foundation.Date.IntervalFormatStyle
  public func weekday(_ format: Foundation.Date.IntervalFormatStyle.Symbol.Weekday = .abbreviated) -> Foundation.Date.IntervalFormatStyle
  public func hour(_ format: Foundation.Date.IntervalFormatStyle.Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Foundation.Date.IntervalFormatStyle
  public func minute() -> Foundation.Date.IntervalFormatStyle
  public func second() -> Foundation.Date.IntervalFormatStyle
  public func timeZone(_ format: Foundation.Date.IntervalFormatStyle.Symbol.TimeZone = .genericName(.short)) -> Foundation.Date.IntervalFormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.IntervalFormatStyle {
  public static var interval: Foundation.Date.IntervalFormatStyle {
    get
  }
}
extension Foundation.Locale {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public init(components: Foundation.Locale.Components)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public init(languageComponents: Foundation.Locale.Language.Components)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public init(languageCode: Foundation.Locale.LanguageCode? = nil, script: Foundation.Locale.Script? = nil, languageRegion: Foundation.Locale.Region? = nil)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var language: Foundation.Locale.Language {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public enum IdentifierType : Swift.Sendable {
    case icu
    case bcp47
    case cldr
    public static func == (a: Foundation.Locale.IdentifierType, b: Foundation.Locale.IdentifierType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public func identifier(_ type: Foundation.Locale.IdentifierType) -> Swift.String
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var measurementSystem: Foundation.Locale.MeasurementSystem {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var currency: Foundation.Locale.Currency? {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var numberingSystem: Foundation.Locale.NumberingSystem {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var availableNumberingSystems: [Foundation.Locale.NumberingSystem] {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var firstDayOfWeek: Foundation.Locale.Weekday {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var hourCycle: Foundation.Locale.HourCycle {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var collation: Foundation.Locale.Collation {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var region: Foundation.Locale.Region? {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var timeZone: Foundation.TimeZone? {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var subdivision: Foundation.Locale.Subdivision? {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var variant: Foundation.Locale.Variant? {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public static func identifier(_ type: Foundation.Locale.IdentifierType, from string: Swift.String) -> Swift.String
}
extension Foundation.Locale {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Components : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var languageComponents: Foundation.Locale.Language.Components
    public var calendar: Foundation.Calendar.Identifier?
    public var collation: Foundation.Locale.Collation?
    public var currency: Foundation.Locale.Currency?
    public var numberingSystem: Foundation.Locale.NumberingSystem?
    public var firstDayOfWeek: Foundation.Locale.Weekday?
    public var hourCycle: Foundation.Locale.HourCycle?
    public var measurementSystem: Foundation.Locale.MeasurementSystem?
    public var region: Foundation.Locale.Region?
    public var subdivision: Foundation.Locale.Subdivision?
    public var timeZone: Foundation.TimeZone?
    public var variant: Foundation.Locale.Variant?
    public init(identifier: Swift.String)
    public init(locale: Foundation.Locale)
    public init(languageCode: Foundation.Locale.LanguageCode? = nil, script: Foundation.Locale.Script? = nil, languageRegion: Foundation.Locale.Region? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Locale.Components, b: Foundation.Locale.Components) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension Foundation.Locale {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct LanguageCode : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public init(_ identifier: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    public enum IdentifierType : Swift.Sendable {
      case alpha2
      case alpha3
      public static func == (a: Foundation.Locale.LanguageCode.IdentifierType, b: Foundation.Locale.LanguageCode.IdentifierType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public func identifier(_ type: Foundation.Locale.LanguageCode.IdentifierType) -> Swift.String?
    public var isISOLanguage: Swift.Bool {
      get
    }
    public static var isoLanguageCodes: [Foundation.Locale.LanguageCode] {
      get
    }
    public static let unidentified: Foundation.Locale.LanguageCode
    public static let uncoded: Foundation.Locale.LanguageCode
    public static let multiple: Foundation.Locale.LanguageCode
    public static let unavailable: Foundation.Locale.LanguageCode
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.LanguageCode, rhs: Foundation.Locale.LanguageCode) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Script : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    public init(_ identifier: Swift.String)
    public var isISOScript: Swift.Bool {
      get
    }
    public static let unknown: Foundation.Locale.Script
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.Script, rhs: Foundation.Locale.Script) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Region : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    public init(_ identifier: Swift.String)
    public var isISORegion: Swift.Bool {
      get
    }
    public static let unknown: Foundation.Locale.Region
    public var subRegions: [Foundation.Locale.Region] {
      get
    }
    public var containingRegion: Foundation.Locale.Region? {
      get
    }
    public var continent: Foundation.Locale.Region? {
      get
    }
    public static var isoRegions: [Foundation.Locale.Region] {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.Region, rhs: Foundation.Locale.Region) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Collation : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    public init(_ identifier: Swift.String)
    public static let searchRules: Foundation.Locale.Collation
    public static let standard: Foundation.Locale.Collation
    public static var availableCollations: [Foundation.Locale.Collation] {
      get
    }
    public static func availableCollations(for language: Foundation.Locale.Language) -> [Foundation.Locale.Collation]
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.Collation, rhs: Foundation.Locale.Collation) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Currency : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    public init(_ identifier: Swift.String)
    public var isISOCurrency: Swift.Bool {
      get
    }
    public static let unknown: Foundation.Locale.Currency
    public static var isoCurrencies: [Foundation.Locale.Currency] {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.Currency, rhs: Foundation.Locale.Currency) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct NumberingSystem : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    public init(_ identifier: Swift.String)
    public static var availableNumberingSystems: [Foundation.Locale.NumberingSystem] {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.NumberingSystem, rhs: Foundation.Locale.NumberingSystem) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public enum Weekday : Swift.String, Swift.Codable, Swift.Hashable, Swift.Sendable {
    case sunday
    case monday
    case tuesday
    case wednesday
    case thursday
    case friday
    case saturday
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public enum HourCycle : Swift.String, Swift.Codable, Swift.Hashable, Swift.Sendable {
    case zeroToEleven
    case oneToTwelve
    case zeroToTwentyThree
    case oneToTwentyFour
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct MeasurementSystem : Swift.Codable, Swift.Hashable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    public init(_ identifier: Swift.String)
    public static let metric: Foundation.Locale.MeasurementSystem
    public static let us: Foundation.Locale.MeasurementSystem
    public static let uk: Foundation.Locale.MeasurementSystem
    public static var measurementSystems: [Foundation.Locale.MeasurementSystem] {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.MeasurementSystem, rhs: Foundation.Locale.MeasurementSystem) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Subdivision : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    public init(_ identifier: Swift.String)
    public static func subdivision(for region: Foundation.Locale.Region) -> Foundation.Locale.Subdivision
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.Subdivision, rhs: Foundation.Locale.Subdivision) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Variant : Swift.Codable, Swift.Hashable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    public init(_ identifier: Swift.String)
    public static let posix: Foundation.Locale.Variant
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.Variant, rhs: Foundation.Locale.Variant) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.LanguageCode {
  @_alwaysEmitIntoClient public static var ainu: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ain") }
  }
  @_alwaysEmitIntoClient public static var albanian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sq") }
  }
  @_alwaysEmitIntoClient public static var amharic: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("am") }
  }
  @_alwaysEmitIntoClient public static var apacheWestern: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("apw") }
  }
  @_alwaysEmitIntoClient public static var arabic: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ar") }
  }
  @_alwaysEmitIntoClient public static var armenian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("hy") }
  }
  @_alwaysEmitIntoClient public static var assamese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("as") }
  }
  @_alwaysEmitIntoClient public static var assyrian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("syr") }
  }
  @_alwaysEmitIntoClient public static var azerbaijani: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("az") }
  }
  @_alwaysEmitIntoClient public static var bangla: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("bn") }
  }
  @_alwaysEmitIntoClient public static var belarusian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("be") }
  }
  @_alwaysEmitIntoClient public static var bodo: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("brx") }
  }
  @_alwaysEmitIntoClient public static var bulgarian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("bg") }
  }
  @_alwaysEmitIntoClient public static var burmese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("my") }
  }
  @_alwaysEmitIntoClient public static var cantonese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("yue") }
  }
  @_alwaysEmitIntoClient public static var catalan: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ca") }
  }
  @_alwaysEmitIntoClient public static var cherokee: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("chr") }
  }
  @_alwaysEmitIntoClient public static var chinese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("zh") }
  }
  @_alwaysEmitIntoClient public static var croatian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("hr") }
  }
  @_alwaysEmitIntoClient public static var czech: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("cs") }
  }
  @_alwaysEmitIntoClient public static var danish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("da") }
  }
  @_alwaysEmitIntoClient public static var dhivehi: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("dv") }
  }
  @_alwaysEmitIntoClient public static var dogri: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("doi") }
  }
  @_alwaysEmitIntoClient public static var dutch: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("nl") }
  }
  @_alwaysEmitIntoClient public static var dzongkha: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("dz") }
  }
  @_alwaysEmitIntoClient public static var english: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("en") }
  }
  @_alwaysEmitIntoClient public static var estonian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("et") }
  }
  @_alwaysEmitIntoClient public static var faroese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("fo") }
  }
  @_alwaysEmitIntoClient public static var finnish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("fi") }
  }
  @_alwaysEmitIntoClient public static var french: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("fr") }
  }
  @_alwaysEmitIntoClient public static var fula: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ff") }
  }
  @_alwaysEmitIntoClient public static var georgian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ka") }
  }
  @_alwaysEmitIntoClient public static var german: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("de") }
  }
  @_alwaysEmitIntoClient public static var greek: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("el") }
  }
  @_alwaysEmitIntoClient public static var gujarati: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("gu") }
  }
  @_alwaysEmitIntoClient public static var hawaiian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("haw") }
  }
  @_alwaysEmitIntoClient public static var hebrew: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("he") }
  }
  @_alwaysEmitIntoClient public static var hindi: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("hi") }
  }
  @_alwaysEmitIntoClient public static var hungarian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("hu") }
  }
  @_alwaysEmitIntoClient public static var icelandic: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("is") }
  }
  @_alwaysEmitIntoClient public static var igbo: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ig") }
  }
  @_alwaysEmitIntoClient public static var indonesian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("id") }
  }
  @_alwaysEmitIntoClient public static var irish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ga") }
  }
  @_alwaysEmitIntoClient public static var italian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("it") }
  }
  @_alwaysEmitIntoClient public static var japanese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ja") }
  }
  @_alwaysEmitIntoClient public static var kannada: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("kn") }
  }
  @_alwaysEmitIntoClient public static var kashmiri: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ks") }
  }
  @_alwaysEmitIntoClient public static var kazakh: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("kk") }
  }
  @_alwaysEmitIntoClient public static var khmer: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("km") }
  }
  @_alwaysEmitIntoClient public static var konkani: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("kok") }
  }
  @_alwaysEmitIntoClient public static var korean: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ko") }
  }
  @_alwaysEmitIntoClient public static var kurdish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ku") }
  }
  @_alwaysEmitIntoClient public static var kurdishSorani: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ckb") }
  }
  @_alwaysEmitIntoClient public static var kyrgyz: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ky") }
  }
  @_alwaysEmitIntoClient public static var lao: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("lo") }
  }
  @_alwaysEmitIntoClient public static var latvian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("lv") }
  }
  @_alwaysEmitIntoClient public static var lithuanian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("lt") }
  }
  @_alwaysEmitIntoClient public static var macedonian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mk") }
  }
  @_alwaysEmitIntoClient public static var maithili: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mai") }
  }
  @_alwaysEmitIntoClient public static var malay: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ms") }
  }
  @_alwaysEmitIntoClient public static var malayalam: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ml") }
  }
  @_alwaysEmitIntoClient public static var maltese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mt") }
  }
  @_alwaysEmitIntoClient public static var manipuri: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mni") }
  }
  @_alwaysEmitIntoClient public static var mori: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mi") }
  }
  @_alwaysEmitIntoClient public static var marathi: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mr") }
  }
  @_alwaysEmitIntoClient public static var mongolian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mn") }
  }
  @_alwaysEmitIntoClient public static var navajo: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("nv") }
  }
  @_alwaysEmitIntoClient public static var nepali: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ne") }
  }
  @_alwaysEmitIntoClient public static var norwegian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("no") }
  }
  @_alwaysEmitIntoClient public static var norwegianBokml: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("nb") }
  }
  @_alwaysEmitIntoClient public static var norwegianNynorsk: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("nn") }
  }
  @_alwaysEmitIntoClient public static var odia: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("or") }
  }
  @_alwaysEmitIntoClient public static var pashto: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ps") }
  }
  @_alwaysEmitIntoClient public static var persian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("fa") }
  }
  @_alwaysEmitIntoClient public static var polish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("pl") }
  }
  @_alwaysEmitIntoClient public static var portuguese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("pt") }
  }
  @_alwaysEmitIntoClient public static var punjabi: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("pa") }
  }
  @_alwaysEmitIntoClient public static var rohingya: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("rhg") }
  }
  @_alwaysEmitIntoClient public static var romanian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ro") }
  }
  @_alwaysEmitIntoClient public static var russian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ru") }
  }
  @_alwaysEmitIntoClient public static var samoan: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sm") }
  }
  @_alwaysEmitIntoClient public static var sanskrit: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sa") }
  }
  @_alwaysEmitIntoClient public static var santali: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sat") }
  }
  @_alwaysEmitIntoClient public static var serbian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sr") }
  }
  @_alwaysEmitIntoClient public static var sindhi: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sd") }
  }
  @_alwaysEmitIntoClient public static var sinhala: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("si") }
  }
  @_alwaysEmitIntoClient public static var slovak: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sk") }
  }
  @_alwaysEmitIntoClient public static var slovenian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sl") }
  }
  @_alwaysEmitIntoClient public static var spanish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("es") }
  }
  @_alwaysEmitIntoClient public static var swahili: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sw") }
  }
  @_alwaysEmitIntoClient public static var swedish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sv") }
  }
  @_alwaysEmitIntoClient public static var tagalog: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("tl") }
  }
  @_alwaysEmitIntoClient public static var tajik: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("tg") }
  }
  @_alwaysEmitIntoClient public static var tamil: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ta") }
  }
  @_alwaysEmitIntoClient public static var telugu: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("te") }
  }
  @_alwaysEmitIntoClient public static var thai: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("th") }
  }
  @_alwaysEmitIntoClient public static var tibetan: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("bo") }
  }
  @_alwaysEmitIntoClient public static var tongan: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("to") }
  }
  @_alwaysEmitIntoClient public static var turkish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("tr") }
  }
  @_alwaysEmitIntoClient public static var turkmen: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("tk") }
  }
  @_alwaysEmitIntoClient public static var ukrainian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("uk") }
  }
  @_alwaysEmitIntoClient public static var urdu: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ur") }
  }
  @_alwaysEmitIntoClient public static var uyghur: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ug") }
  }
  @_alwaysEmitIntoClient public static var uzbek: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("uz") }
  }
  @_alwaysEmitIntoClient public static var vietnamese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("vi") }
  }
  @_alwaysEmitIntoClient public static var welsh: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("cy") }
  }
  @_alwaysEmitIntoClient public static var yiddish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("yi") }
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.Region {
  @_alwaysEmitIntoClient public static var afghanistan: Foundation.Locale.Region {
    get { Locale.Region("AF") }
  }
  @_alwaysEmitIntoClient public static var landIslands: Foundation.Locale.Region {
    get { Locale.Region("AX") }
  }
  @_alwaysEmitIntoClient public static var albania: Foundation.Locale.Region {
    get { Locale.Region("AL") }
  }
  @_alwaysEmitIntoClient public static var algeria: Foundation.Locale.Region {
    get { Locale.Region("DZ") }
  }
  @_alwaysEmitIntoClient public static var americanSamoa: Foundation.Locale.Region {
    get { Locale.Region("AS") }
  }
  @_alwaysEmitIntoClient public static var andorra: Foundation.Locale.Region {
    get { Locale.Region("AD") }
  }
  @_alwaysEmitIntoClient public static var angola: Foundation.Locale.Region {
    get { Locale.Region("AO") }
  }
  @_alwaysEmitIntoClient public static var anguilla: Foundation.Locale.Region {
    get { Locale.Region("AI") }
  }
  @_alwaysEmitIntoClient public static var antarctica: Foundation.Locale.Region {
    get { Locale.Region("AQ") }
  }
  @_alwaysEmitIntoClient public static var antiguaBarbuda: Foundation.Locale.Region {
    get { Locale.Region("AG") }
  }
  @_alwaysEmitIntoClient public static var argentina: Foundation.Locale.Region {
    get { Locale.Region("AR") }
  }
  @_alwaysEmitIntoClient public static var armenia: Foundation.Locale.Region {
    get { Locale.Region("AM") }
  }
  @_alwaysEmitIntoClient public static var aruba: Foundation.Locale.Region {
    get { Locale.Region("AW") }
  }
  @_alwaysEmitIntoClient public static var ascensionIsland: Foundation.Locale.Region {
    get { Locale.Region("AC") }
  }
  @_alwaysEmitIntoClient public static var australia: Foundation.Locale.Region {
    get { Locale.Region("AU") }
  }
  @_alwaysEmitIntoClient public static var austria: Foundation.Locale.Region {
    get { Locale.Region("AT") }
  }
  @_alwaysEmitIntoClient public static var azerbaijan: Foundation.Locale.Region {
    get { Locale.Region("AZ") }
  }
  @_alwaysEmitIntoClient public static var bahamas: Foundation.Locale.Region {
    get { Locale.Region("BS") }
  }
  @_alwaysEmitIntoClient public static var bahrain: Foundation.Locale.Region {
    get { Locale.Region("BH") }
  }
  @_alwaysEmitIntoClient public static var bangladesh: Foundation.Locale.Region {
    get { Locale.Region("BD") }
  }
  @_alwaysEmitIntoClient public static var barbados: Foundation.Locale.Region {
    get { Locale.Region("BB") }
  }
  @_alwaysEmitIntoClient public static var belarus: Foundation.Locale.Region {
    get { Locale.Region("BY") }
  }
  @_alwaysEmitIntoClient public static var belgium: Foundation.Locale.Region {
    get { Locale.Region("BE") }
  }
  @_alwaysEmitIntoClient public static var belize: Foundation.Locale.Region {
    get { Locale.Region("BZ") }
  }
  @_alwaysEmitIntoClient public static var benin: Foundation.Locale.Region {
    get { Locale.Region("BJ") }
  }
  @_alwaysEmitIntoClient public static var bermuda: Foundation.Locale.Region {
    get { Locale.Region("BM") }
  }
  @_alwaysEmitIntoClient public static var bhutan: Foundation.Locale.Region {
    get { Locale.Region("BT") }
  }
  @_alwaysEmitIntoClient public static var bolivia: Foundation.Locale.Region {
    get { Locale.Region("BO") }
  }
  @_alwaysEmitIntoClient public static var bosniaHerzegovina: Foundation.Locale.Region {
    get { Locale.Region("BA") }
  }
  @_alwaysEmitIntoClient public static var botswana: Foundation.Locale.Region {
    get { Locale.Region("BW") }
  }
  @_alwaysEmitIntoClient public static var bouvetIsland: Foundation.Locale.Region {
    get { Locale.Region("BV") }
  }
  @_alwaysEmitIntoClient public static var brazil: Foundation.Locale.Region {
    get { Locale.Region("BR") }
  }
  @_alwaysEmitIntoClient public static var britishVirginIslands: Foundation.Locale.Region {
    get { Locale.Region("VG") }
  }
  @_alwaysEmitIntoClient public static var brunei: Foundation.Locale.Region {
    get { Locale.Region("BN") }
  }
  @_alwaysEmitIntoClient public static var bulgaria: Foundation.Locale.Region {
    get { Locale.Region("BG") }
  }
  @_alwaysEmitIntoClient public static var burkinaFaso: Foundation.Locale.Region {
    get { Locale.Region("BF") }
  }
  @_alwaysEmitIntoClient public static var burundi: Foundation.Locale.Region {
    get { Locale.Region("BI") }
  }
  @_alwaysEmitIntoClient public static var cambodia: Foundation.Locale.Region {
    get { Locale.Region("KH") }
  }
  @_alwaysEmitIntoClient public static var cameroon: Foundation.Locale.Region {
    get { Locale.Region("CM") }
  }
  @_alwaysEmitIntoClient public static var canada: Foundation.Locale.Region {
    get { Locale.Region("CA") }
  }
  @_alwaysEmitIntoClient public static var canaryIslands: Foundation.Locale.Region {
    get { Locale.Region("IC") }
  }
  @_alwaysEmitIntoClient public static var capeVerde: Foundation.Locale.Region {
    get { Locale.Region("CV") }
  }
  @_alwaysEmitIntoClient public static var caribbeanNetherlands: Foundation.Locale.Region {
    get { Locale.Region("BQ") }
  }
  @_alwaysEmitIntoClient public static var caymanIslands: Foundation.Locale.Region {
    get { Locale.Region("KY") }
  }
  @_alwaysEmitIntoClient public static var centralAfricanRepublic: Foundation.Locale.Region {
    get { Locale.Region("CF") }
  }
  @_alwaysEmitIntoClient public static var ceutaMelilla: Foundation.Locale.Region {
    get { Locale.Region("EA") }
  }
  @_alwaysEmitIntoClient public static var chad: Foundation.Locale.Region {
    get { Locale.Region("TD") }
  }
  @_alwaysEmitIntoClient public static var chagosArchipelago: Foundation.Locale.Region {
    get { Locale.Region("IO") }
  }
  @_alwaysEmitIntoClient public static var chile: Foundation.Locale.Region {
    get { Locale.Region("CL") }
  }
  @_alwaysEmitIntoClient public static var chinaMainland: Foundation.Locale.Region {
    get { Locale.Region("CN") }
  }
  @_alwaysEmitIntoClient public static var christmasIsland: Foundation.Locale.Region {
    get { Locale.Region("CX") }
  }
  @_alwaysEmitIntoClient public static var clippertonIsland: Foundation.Locale.Region {
    get { Locale.Region("CP") }
  }
  @_alwaysEmitIntoClient public static var cocosIslands: Foundation.Locale.Region {
    get { Locale.Region("CC") }
  }
  @_alwaysEmitIntoClient public static var colombia: Foundation.Locale.Region {
    get { Locale.Region("CO") }
  }
  @_alwaysEmitIntoClient public static var comoros: Foundation.Locale.Region {
    get { Locale.Region("KM") }
  }
  @_alwaysEmitIntoClient public static var congoBrazzaville: Foundation.Locale.Region {
    get { Locale.Region("CG") }
  }
  @_alwaysEmitIntoClient public static var congoKinshasa: Foundation.Locale.Region {
    get { Locale.Region("CD") }
  }
  @_alwaysEmitIntoClient public static var cookIslands: Foundation.Locale.Region {
    get { Locale.Region("CK") }
  }
  @_alwaysEmitIntoClient public static var costaRica: Foundation.Locale.Region {
    get { Locale.Region("CR") }
  }
  @_alwaysEmitIntoClient public static var cteDIvoire: Foundation.Locale.Region {
    get { Locale.Region("CI") }
  }
  @_alwaysEmitIntoClient public static var croatia: Foundation.Locale.Region {
    get { Locale.Region("HR") }
  }
  @_alwaysEmitIntoClient public static var cuba: Foundation.Locale.Region {
    get { Locale.Region("CU") }
  }
  @_alwaysEmitIntoClient public static var curaao: Foundation.Locale.Region {
    get { Locale.Region("CW") }
  }
  @_alwaysEmitIntoClient public static var cyprus: Foundation.Locale.Region {
    get { Locale.Region("CY") }
  }
  @_alwaysEmitIntoClient public static var czechia: Foundation.Locale.Region {
    get { Locale.Region("CZ") }
  }
  @_alwaysEmitIntoClient public static var denmark: Foundation.Locale.Region {
    get { Locale.Region("DK") }
  }
  @_alwaysEmitIntoClient public static var diegoGarcia: Foundation.Locale.Region {
    get { Locale.Region("DG") }
  }
  @_alwaysEmitIntoClient public static var djibouti: Foundation.Locale.Region {
    get { Locale.Region("DJ") }
  }
  @_alwaysEmitIntoClient public static var dominica: Foundation.Locale.Region {
    get { Locale.Region("DM") }
  }
  @_alwaysEmitIntoClient public static var dominicanRepublic: Foundation.Locale.Region {
    get { Locale.Region("DO") }
  }
  @_alwaysEmitIntoClient public static var ecuador: Foundation.Locale.Region {
    get { Locale.Region("EC") }
  }
  @_alwaysEmitIntoClient public static var egypt: Foundation.Locale.Region {
    get { Locale.Region("EG") }
  }
  @_alwaysEmitIntoClient public static var elSalvador: Foundation.Locale.Region {
    get { Locale.Region("SV") }
  }
  @_alwaysEmitIntoClient public static var equatorialGuinea: Foundation.Locale.Region {
    get { Locale.Region("GQ") }
  }
  @_alwaysEmitIntoClient public static var eritrea: Foundation.Locale.Region {
    get { Locale.Region("ER") }
  }
  @_alwaysEmitIntoClient public static var estonia: Foundation.Locale.Region {
    get { Locale.Region("EE") }
  }
  @_alwaysEmitIntoClient public static var eswatini: Foundation.Locale.Region {
    get { Locale.Region("SZ") }
  }
  @_alwaysEmitIntoClient public static var ethiopia: Foundation.Locale.Region {
    get { Locale.Region("ET") }
  }
  @_alwaysEmitIntoClient public static var falklandIslands: Foundation.Locale.Region {
    get { Locale.Region("FK") }
  }
  @_alwaysEmitIntoClient public static var faroeIslands: Foundation.Locale.Region {
    get { Locale.Region("FO") }
  }
  @_alwaysEmitIntoClient public static var fiji: Foundation.Locale.Region {
    get { Locale.Region("FJ") }
  }
  @_alwaysEmitIntoClient public static var finland: Foundation.Locale.Region {
    get { Locale.Region("FI") }
  }
  @_alwaysEmitIntoClient public static var france: Foundation.Locale.Region {
    get { Locale.Region("FR") }
  }
  @_alwaysEmitIntoClient public static var frenchGuiana: Foundation.Locale.Region {
    get { Locale.Region("GF") }
  }
  @_alwaysEmitIntoClient public static var frenchPolynesia: Foundation.Locale.Region {
    get { Locale.Region("PF") }
  }
  @_alwaysEmitIntoClient public static var frenchSouthernTerritories: Foundation.Locale.Region {
    get { Locale.Region("TF") }
  }
  @_alwaysEmitIntoClient public static var gabon: Foundation.Locale.Region {
    get { Locale.Region("GA") }
  }
  @_alwaysEmitIntoClient public static var gambia: Foundation.Locale.Region {
    get { Locale.Region("GM") }
  }
  @_alwaysEmitIntoClient public static var georgia: Foundation.Locale.Region {
    get { Locale.Region("GE") }
  }
  @_alwaysEmitIntoClient public static var germany: Foundation.Locale.Region {
    get { Locale.Region("DE") }
  }
  @_alwaysEmitIntoClient public static var ghana: Foundation.Locale.Region {
    get { Locale.Region("GH") }
  }
  @_alwaysEmitIntoClient public static var gibraltar: Foundation.Locale.Region {
    get { Locale.Region("GI") }
  }
  @_alwaysEmitIntoClient public static var greece: Foundation.Locale.Region {
    get { Locale.Region("GR") }
  }
  @_alwaysEmitIntoClient public static var greenland: Foundation.Locale.Region {
    get { Locale.Region("GL") }
  }
  @_alwaysEmitIntoClient public static var grenada: Foundation.Locale.Region {
    get { Locale.Region("GD") }
  }
  @_alwaysEmitIntoClient public static var guadeloupe: Foundation.Locale.Region {
    get { Locale.Region("GP") }
  }
  @_alwaysEmitIntoClient public static var guam: Foundation.Locale.Region {
    get { Locale.Region("GU") }
  }
  @_alwaysEmitIntoClient public static var guatemala: Foundation.Locale.Region {
    get { Locale.Region("GT") }
  }
  @_alwaysEmitIntoClient public static var guernsey: Foundation.Locale.Region {
    get { Locale.Region("GG") }
  }
  @_alwaysEmitIntoClient public static var guinea: Foundation.Locale.Region {
    get { Locale.Region("GN") }
  }
  @_alwaysEmitIntoClient public static var guineaBissau: Foundation.Locale.Region {
    get { Locale.Region("GW") }
  }
  @_alwaysEmitIntoClient public static var guyana: Foundation.Locale.Region {
    get { Locale.Region("GY") }
  }
  @_alwaysEmitIntoClient public static var haiti: Foundation.Locale.Region {
    get { Locale.Region("HT") }
  }
  @_alwaysEmitIntoClient public static var heardMcdonaldIslands: Foundation.Locale.Region {
    get { Locale.Region("HM") }
  }
  @_alwaysEmitIntoClient public static var honduras: Foundation.Locale.Region {
    get { Locale.Region("HN") }
  }
  @_alwaysEmitIntoClient public static var hongKong: Foundation.Locale.Region {
    get { Locale.Region("HK") }
  }
  @_alwaysEmitIntoClient public static var hungary: Foundation.Locale.Region {
    get { Locale.Region("HU") }
  }
  @_alwaysEmitIntoClient public static var iceland: Foundation.Locale.Region {
    get { Locale.Region("IS") }
  }
  @_alwaysEmitIntoClient public static var india: Foundation.Locale.Region {
    get { Locale.Region("IN") }
  }
  @_alwaysEmitIntoClient public static var indonesia: Foundation.Locale.Region {
    get { Locale.Region("ID") }
  }
  @_alwaysEmitIntoClient public static var iran: Foundation.Locale.Region {
    get { Locale.Region("IR") }
  }
  @_alwaysEmitIntoClient public static var iraq: Foundation.Locale.Region {
    get { Locale.Region("IQ") }
  }
  @_alwaysEmitIntoClient public static var ireland: Foundation.Locale.Region {
    get { Locale.Region("IE") }
  }
  @_alwaysEmitIntoClient public static var isleOfMan: Foundation.Locale.Region {
    get { Locale.Region("IM") }
  }
  @_alwaysEmitIntoClient public static var israel: Foundation.Locale.Region {
    get { Locale.Region("IL") }
  }
  @_alwaysEmitIntoClient public static var italy: Foundation.Locale.Region {
    get { Locale.Region("IT") }
  }
  @_alwaysEmitIntoClient public static var jamaica: Foundation.Locale.Region {
    get { Locale.Region("JM") }
  }
  @_alwaysEmitIntoClient public static var japan: Foundation.Locale.Region {
    get { Locale.Region("JP") }
  }
  @_alwaysEmitIntoClient public static var jersey: Foundation.Locale.Region {
    get { Locale.Region("JE") }
  }
  @_alwaysEmitIntoClient public static var jordan: Foundation.Locale.Region {
    get { Locale.Region("JO") }
  }
  @_alwaysEmitIntoClient public static var kazakhstan: Foundation.Locale.Region {
    get { Locale.Region("KZ") }
  }
  @_alwaysEmitIntoClient public static var kenya: Foundation.Locale.Region {
    get { Locale.Region("KE") }
  }
  @_alwaysEmitIntoClient public static var kiribati: Foundation.Locale.Region {
    get { Locale.Region("KI") }
  }
  @_alwaysEmitIntoClient public static var kosovo: Foundation.Locale.Region {
    get { Locale.Region("XK") }
  }
  @_alwaysEmitIntoClient public static var kuwait: Foundation.Locale.Region {
    get { Locale.Region("KW") }
  }
  @_alwaysEmitIntoClient public static var kyrgyzstan: Foundation.Locale.Region {
    get { Locale.Region("KG") }
  }
  @_alwaysEmitIntoClient public static var laos: Foundation.Locale.Region {
    get { Locale.Region("LA") }
  }
  @_alwaysEmitIntoClient public static var latvia: Foundation.Locale.Region {
    get { Locale.Region("LV") }
  }
  @_alwaysEmitIntoClient public static var lebanon: Foundation.Locale.Region {
    get { Locale.Region("LB") }
  }
  @_alwaysEmitIntoClient public static var lesotho: Foundation.Locale.Region {
    get { Locale.Region("LS") }
  }
  @_alwaysEmitIntoClient public static var liberia: Foundation.Locale.Region {
    get { Locale.Region("LR") }
  }
  @_alwaysEmitIntoClient public static var libya: Foundation.Locale.Region {
    get { Locale.Region("LY") }
  }
  @_alwaysEmitIntoClient public static var liechtenstein: Foundation.Locale.Region {
    get { Locale.Region("LI") }
  }
  @_alwaysEmitIntoClient public static var lithuania: Foundation.Locale.Region {
    get { Locale.Region("LT") }
  }
  @_alwaysEmitIntoClient public static var luxembourg: Foundation.Locale.Region {
    get { Locale.Region("LU") }
  }
  @_alwaysEmitIntoClient public static var macao: Foundation.Locale.Region {
    get { Locale.Region("MO") }
  }
  @_alwaysEmitIntoClient public static var madagascar: Foundation.Locale.Region {
    get { Locale.Region("MG") }
  }
  @_alwaysEmitIntoClient public static var malawi: Foundation.Locale.Region {
    get { Locale.Region("MW") }
  }
  @_alwaysEmitIntoClient public static var malaysia: Foundation.Locale.Region {
    get { Locale.Region("MY") }
  }
  @_alwaysEmitIntoClient public static var maldives: Foundation.Locale.Region {
    get { Locale.Region("MV") }
  }
  @_alwaysEmitIntoClient public static var mali: Foundation.Locale.Region {
    get { Locale.Region("ML") }
  }
  @_alwaysEmitIntoClient public static var malta: Foundation.Locale.Region {
    get { Locale.Region("MT") }
  }
  @_alwaysEmitIntoClient public static var marshallIslands: Foundation.Locale.Region {
    get { Locale.Region("MH") }
  }
  @_alwaysEmitIntoClient public static var martinique: Foundation.Locale.Region {
    get { Locale.Region("MQ") }
  }
  @_alwaysEmitIntoClient public static var mauritania: Foundation.Locale.Region {
    get { Locale.Region("MR") }
  }
  @_alwaysEmitIntoClient public static var mauritius: Foundation.Locale.Region {
    get { Locale.Region("MU") }
  }
  @_alwaysEmitIntoClient public static var mayotte: Foundation.Locale.Region {
    get { Locale.Region("YT") }
  }
  @_alwaysEmitIntoClient public static var mexico: Foundation.Locale.Region {
    get { Locale.Region("MX") }
  }
  @_alwaysEmitIntoClient public static var micronesia: Foundation.Locale.Region {
    get { Locale.Region("FM") }
  }
  @_alwaysEmitIntoClient public static var moldova: Foundation.Locale.Region {
    get { Locale.Region("MD") }
  }
  @_alwaysEmitIntoClient public static var monaco: Foundation.Locale.Region {
    get { Locale.Region("MC") }
  }
  @_alwaysEmitIntoClient public static var mongolia: Foundation.Locale.Region {
    get { Locale.Region("MN") }
  }
  @_alwaysEmitIntoClient public static var montenegro: Foundation.Locale.Region {
    get { Locale.Region("ME") }
  }
  @_alwaysEmitIntoClient public static var montserrat: Foundation.Locale.Region {
    get { Locale.Region("MS") }
  }
  @_alwaysEmitIntoClient public static var morocco: Foundation.Locale.Region {
    get { Locale.Region("MA") }
  }
  @_alwaysEmitIntoClient public static var mozambique: Foundation.Locale.Region {
    get { Locale.Region("MZ") }
  }
  @_alwaysEmitIntoClient public static var myanmar: Foundation.Locale.Region {
    get { Locale.Region("MM") }
  }
  @_alwaysEmitIntoClient public static var namibia: Foundation.Locale.Region {
    get { Locale.Region("NA") }
  }
  @_alwaysEmitIntoClient public static var nauru: Foundation.Locale.Region {
    get { Locale.Region("NR") }
  }
  @_alwaysEmitIntoClient public static var nepal: Foundation.Locale.Region {
    get { Locale.Region("NP") }
  }
  @_alwaysEmitIntoClient public static var netherlands: Foundation.Locale.Region {
    get { Locale.Region("NL") }
  }
  @_alwaysEmitIntoClient public static var newCaledonia: Foundation.Locale.Region {
    get { Locale.Region("NC") }
  }
  @_alwaysEmitIntoClient public static var newZealand: Foundation.Locale.Region {
    get { Locale.Region("NZ") }
  }
  @_alwaysEmitIntoClient public static var nicaragua: Foundation.Locale.Region {
    get { Locale.Region("NI") }
  }
  @_alwaysEmitIntoClient public static var niger: Foundation.Locale.Region {
    get { Locale.Region("NE") }
  }
  @_alwaysEmitIntoClient public static var nigeria: Foundation.Locale.Region {
    get { Locale.Region("NG") }
  }
  @_alwaysEmitIntoClient public static var niue: Foundation.Locale.Region {
    get { Locale.Region("NU") }
  }
  @_alwaysEmitIntoClient public static var norfolkIsland: Foundation.Locale.Region {
    get { Locale.Region("NF") }
  }
  @_alwaysEmitIntoClient public static var northernMarianaIslands: Foundation.Locale.Region {
    get { Locale.Region("MP") }
  }
  @_alwaysEmitIntoClient public static var northMacedonia: Foundation.Locale.Region {
    get { Locale.Region("MK") }
  }
  @_alwaysEmitIntoClient public static var norway: Foundation.Locale.Region {
    get { Locale.Region("NO") }
  }
  @_alwaysEmitIntoClient public static var oman: Foundation.Locale.Region {
    get { Locale.Region("OM") }
  }
  @_alwaysEmitIntoClient public static var pakistan: Foundation.Locale.Region {
    get { Locale.Region("PK") }
  }
  @_alwaysEmitIntoClient public static var palau: Foundation.Locale.Region {
    get { Locale.Region("PW") }
  }
  @_alwaysEmitIntoClient public static var palestinianTerritories: Foundation.Locale.Region {
    get { Locale.Region("PS") }
  }
  @_alwaysEmitIntoClient public static var panama: Foundation.Locale.Region {
    get { Locale.Region("PA") }
  }
  @_alwaysEmitIntoClient public static var papuaNewGuinea: Foundation.Locale.Region {
    get { Locale.Region("PG") }
  }
  @_alwaysEmitIntoClient public static var paraguay: Foundation.Locale.Region {
    get { Locale.Region("PY") }
  }
  @_alwaysEmitIntoClient public static var peru: Foundation.Locale.Region {
    get { Locale.Region("PE") }
  }
  @_alwaysEmitIntoClient public static var philippines: Foundation.Locale.Region {
    get { Locale.Region("PH") }
  }
  @_alwaysEmitIntoClient public static var pitcairnIslands: Foundation.Locale.Region {
    get { Locale.Region("PN") }
  }
  @_alwaysEmitIntoClient public static var poland: Foundation.Locale.Region {
    get { Locale.Region("PL") }
  }
  @_alwaysEmitIntoClient public static var portugal: Foundation.Locale.Region {
    get { Locale.Region("PT") }
  }
  @_alwaysEmitIntoClient public static var puertoRico: Foundation.Locale.Region {
    get { Locale.Region("PR") }
  }
  @_alwaysEmitIntoClient public static var qatar: Foundation.Locale.Region {
    get { Locale.Region("QA") }
  }
  @_alwaysEmitIntoClient public static var runion: Foundation.Locale.Region {
    get { Locale.Region("RE") }
  }
  @_alwaysEmitIntoClient public static var romania: Foundation.Locale.Region {
    get { Locale.Region("RO") }
  }
  @_alwaysEmitIntoClient public static var russia: Foundation.Locale.Region {
    get { Locale.Region("RU") }
  }
  @_alwaysEmitIntoClient public static var rwanda: Foundation.Locale.Region {
    get { Locale.Region("RW") }
  }
  @_alwaysEmitIntoClient public static var saintBarthlemy: Foundation.Locale.Region {
    get { Locale.Region("BL") }
  }
  @_alwaysEmitIntoClient public static var saintHelena: Foundation.Locale.Region {
    get { Locale.Region("SH") }
  }
  @_alwaysEmitIntoClient public static var saintKittsNevis: Foundation.Locale.Region {
    get { Locale.Region("KN") }
  }
  @_alwaysEmitIntoClient public static var saintLucia: Foundation.Locale.Region {
    get { Locale.Region("LC") }
  }
  @_alwaysEmitIntoClient public static var saintMartin: Foundation.Locale.Region {
    get { Locale.Region("MF") }
  }
  @_alwaysEmitIntoClient public static var saintPierreMiquelon: Foundation.Locale.Region {
    get { Locale.Region("PM") }
  }
  @_alwaysEmitIntoClient public static var saintVincentGrenadines: Foundation.Locale.Region {
    get { Locale.Region("VC") }
  }
  @_alwaysEmitIntoClient public static var samoa: Foundation.Locale.Region {
    get { Locale.Region("WS") }
  }
  @_alwaysEmitIntoClient public static var sanMarino: Foundation.Locale.Region {
    get { Locale.Region("SM") }
  }
  @_alwaysEmitIntoClient public static var soTomPrncipe: Foundation.Locale.Region {
    get { Locale.Region("ST") }
  }
  @_alwaysEmitIntoClient public static var saudiArabia: Foundation.Locale.Region {
    get { Locale.Region("SA") }
  }
  @_alwaysEmitIntoClient public static var senegal: Foundation.Locale.Region {
    get { Locale.Region("SN") }
  }
  @_alwaysEmitIntoClient public static var serbia: Foundation.Locale.Region {
    get { Locale.Region("RS") }
  }
  @_alwaysEmitIntoClient public static var seychelles: Foundation.Locale.Region {
    get { Locale.Region("SC") }
  }
  @_alwaysEmitIntoClient public static var sierraLeone: Foundation.Locale.Region {
    get { Locale.Region("SL") }
  }
  @_alwaysEmitIntoClient public static var singapore: Foundation.Locale.Region {
    get { Locale.Region("SG") }
  }
  @_alwaysEmitIntoClient public static var sintMaarten: Foundation.Locale.Region {
    get { Locale.Region("SX") }
  }
  @_alwaysEmitIntoClient public static var slovakia: Foundation.Locale.Region {
    get { Locale.Region("SK") }
  }
  @_alwaysEmitIntoClient public static var slovenia: Foundation.Locale.Region {
    get { Locale.Region("SI") }
  }
  @_alwaysEmitIntoClient public static var solomonIslands: Foundation.Locale.Region {
    get { Locale.Region("SB") }
  }
  @_alwaysEmitIntoClient public static var somalia: Foundation.Locale.Region {
    get { Locale.Region("SO") }
  }
  @_alwaysEmitIntoClient public static var southAfrica: Foundation.Locale.Region {
    get { Locale.Region("ZA") }
  }
  @_alwaysEmitIntoClient public static var southGeorgiaSouthSandwichIslands: Foundation.Locale.Region {
    get { Locale.Region("GS") }
  }
  @_alwaysEmitIntoClient public static var southKorea: Foundation.Locale.Region {
    get { Locale.Region("KR") }
  }
  @_alwaysEmitIntoClient public static var southSudan: Foundation.Locale.Region {
    get { Locale.Region("SS") }
  }
  @_alwaysEmitIntoClient public static var spain: Foundation.Locale.Region {
    get { Locale.Region("ES") }
  }
  @_alwaysEmitIntoClient public static var sriLanka: Foundation.Locale.Region {
    get { Locale.Region("LK") }
  }
  @_alwaysEmitIntoClient public static var suriname: Foundation.Locale.Region {
    get { Locale.Region("SR") }
  }
  @_alwaysEmitIntoClient public static var svalbardJanMayen: Foundation.Locale.Region {
    get { Locale.Region("SJ") }
  }
  @_alwaysEmitIntoClient public static var sweden: Foundation.Locale.Region {
    get { Locale.Region("SE") }
  }
  @_alwaysEmitIntoClient public static var switzerland: Foundation.Locale.Region {
    get { Locale.Region("CH") }
  }
  @_alwaysEmitIntoClient public static var taiwan: Foundation.Locale.Region {
    get { Locale.Region("TW") }
  }
  @_alwaysEmitIntoClient public static var tajikistan: Foundation.Locale.Region {
    get { Locale.Region("TJ") }
  }
  @_alwaysEmitIntoClient public static var tanzania: Foundation.Locale.Region {
    get { Locale.Region("TZ") }
  }
  @_alwaysEmitIntoClient public static var thailand: Foundation.Locale.Region {
    get { Locale.Region("TH") }
  }
  @_alwaysEmitIntoClient public static var timorLeste: Foundation.Locale.Region {
    get { Locale.Region("TL") }
  }
  @_alwaysEmitIntoClient public static var togo: Foundation.Locale.Region {
    get { Locale.Region("TG") }
  }
  @_alwaysEmitIntoClient public static var tokelau: Foundation.Locale.Region {
    get { Locale.Region("TK") }
  }
  @_alwaysEmitIntoClient public static var tonga: Foundation.Locale.Region {
    get { Locale.Region("TO") }
  }
  @_alwaysEmitIntoClient public static var trinidadTobago: Foundation.Locale.Region {
    get { Locale.Region("TT") }
  }
  @_alwaysEmitIntoClient public static var tristanDaCunha: Foundation.Locale.Region {
    get { Locale.Region("TA") }
  }
  @_alwaysEmitIntoClient public static var tunisia: Foundation.Locale.Region {
    get { Locale.Region("TN") }
  }
  @_alwaysEmitIntoClient public static var turkey: Foundation.Locale.Region {
    get { Locale.Region("TR") }
  }
  @_alwaysEmitIntoClient public static var turkmenistan: Foundation.Locale.Region {
    get { Locale.Region("TM") }
  }
  @_alwaysEmitIntoClient public static var turksCaicosIslands: Foundation.Locale.Region {
    get { Locale.Region("TC") }
  }
  @_alwaysEmitIntoClient public static var tuvalu: Foundation.Locale.Region {
    get { Locale.Region("TV") }
  }
  @_alwaysEmitIntoClient public static var uganda: Foundation.Locale.Region {
    get { Locale.Region("UG") }
  }
  @_alwaysEmitIntoClient public static var ukraine: Foundation.Locale.Region {
    get { Locale.Region("UA") }
  }
  @_alwaysEmitIntoClient public static var unitedArabEmirates: Foundation.Locale.Region {
    get { Locale.Region("AE") }
  }
  @_alwaysEmitIntoClient public static var unitedKingdom: Foundation.Locale.Region {
    get { Locale.Region("GB") }
  }
  @_alwaysEmitIntoClient public static var unitedStates: Foundation.Locale.Region {
    get { Locale.Region("US") }
  }
  @_alwaysEmitIntoClient public static var unitedStatesOutlyingIslands: Foundation.Locale.Region {
    get { Locale.Region("UM") }
  }
  @_alwaysEmitIntoClient public static var unitedStatesVirginIslands: Foundation.Locale.Region {
    get { Locale.Region("VI") }
  }
  @_alwaysEmitIntoClient public static var uruguay: Foundation.Locale.Region {
    get { Locale.Region("UY") }
  }
  @_alwaysEmitIntoClient public static var uzbekistan: Foundation.Locale.Region {
    get { Locale.Region("UZ") }
  }
  @_alwaysEmitIntoClient public static var vanuatu: Foundation.Locale.Region {
    get { Locale.Region("VU") }
  }
  @_alwaysEmitIntoClient public static var vaticanCity: Foundation.Locale.Region {
    get { Locale.Region("VA") }
  }
  @_alwaysEmitIntoClient public static var venezuela: Foundation.Locale.Region {
    get { Locale.Region("VE") }
  }
  @_alwaysEmitIntoClient public static var vietnam: Foundation.Locale.Region {
    get { Locale.Region("VN") }
  }
  @_alwaysEmitIntoClient public static var wallisFutuna: Foundation.Locale.Region {
    get { Locale.Region("WF") }
  }
  @_alwaysEmitIntoClient public static var westernSahara: Foundation.Locale.Region {
    get { Locale.Region("EH") }
  }
  @_alwaysEmitIntoClient public static var yemen: Foundation.Locale.Region {
    get { Locale.Region("YE") }
  }
  @_alwaysEmitIntoClient public static var zambia: Foundation.Locale.Region {
    get { Locale.Region("ZM") }
  }
  @_alwaysEmitIntoClient public static var zimbabwe: Foundation.Locale.Region {
    get { Locale.Region("ZW") }
  }
  @_alwaysEmitIntoClient public static var world: Foundation.Locale.Region {
    get { Locale.Region("001") }
  }
  @_alwaysEmitIntoClient public static var latinAmerica: Foundation.Locale.Region {
    get { Locale.Region("419") }
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.Script {
  @_alwaysEmitIntoClient public static var adlam: Foundation.Locale.Script {
    get { Locale.Script("Adlm") }
  }
  @_alwaysEmitIntoClient public static var arabic: Foundation.Locale.Script {
    get { Locale.Script("Arab") }
  }
  @_alwaysEmitIntoClient public static var arabicNastaliq: Foundation.Locale.Script {
    get { Locale.Script("Aran") }
  }
  @_alwaysEmitIntoClient public static var armenian: Foundation.Locale.Script {
    get { Locale.Script("Armn") }
  }
  @_alwaysEmitIntoClient public static var bangla: Foundation.Locale.Script {
    get { Locale.Script("Beng") }
  }
  @_alwaysEmitIntoClient public static var cherokee: Foundation.Locale.Script {
    get { Locale.Script("Cher") }
  }
  @_alwaysEmitIntoClient public static var cyrillic: Foundation.Locale.Script {
    get { Locale.Script("Cyrl") }
  }
  @_alwaysEmitIntoClient public static var devanagari: Foundation.Locale.Script {
    get { Locale.Script("Deva") }
  }
  @_alwaysEmitIntoClient public static var ethiopic: Foundation.Locale.Script {
    get { Locale.Script("Ethi") }
  }
  @_alwaysEmitIntoClient public static var georgian: Foundation.Locale.Script {
    get { Locale.Script("Geor") }
  }
  @_alwaysEmitIntoClient public static var greek: Foundation.Locale.Script {
    get { Locale.Script("Grek") }
  }
  @_alwaysEmitIntoClient public static var gujarati: Foundation.Locale.Script {
    get { Locale.Script("Gujr") }
  }
  @_alwaysEmitIntoClient public static var gurmukhi: Foundation.Locale.Script {
    get { Locale.Script("Guru") }
  }
  @_alwaysEmitIntoClient public static var hanifiRohingya: Foundation.Locale.Script {
    get { Locale.Script("Rohg") }
  }
  @_alwaysEmitIntoClient public static var hanSimplified: Foundation.Locale.Script {
    get { Locale.Script("Hans") }
  }
  @_alwaysEmitIntoClient public static var hanTraditional: Foundation.Locale.Script {
    get { Locale.Script("Hant") }
  }
  @_alwaysEmitIntoClient public static var hebrew: Foundation.Locale.Script {
    get { Locale.Script("Hebr") }
  }
  @_alwaysEmitIntoClient public static var hiragana: Foundation.Locale.Script {
    get { Locale.Script("Hira") }
  }
  @_alwaysEmitIntoClient public static var japanese: Foundation.Locale.Script {
    get { Locale.Script("Jpan") }
  }
  @_alwaysEmitIntoClient public static var kannada: Foundation.Locale.Script {
    get { Locale.Script("Knda") }
  }
  @_alwaysEmitIntoClient public static var katakana: Foundation.Locale.Script {
    get { Locale.Script("Kana") }
  }
  @_alwaysEmitIntoClient public static var khmer: Foundation.Locale.Script {
    get { Locale.Script("Khmr") }
  }
  @_alwaysEmitIntoClient public static var korean: Foundation.Locale.Script {
    get { Locale.Script("Kore") }
  }
  @_alwaysEmitIntoClient public static var lao: Foundation.Locale.Script {
    get { Locale.Script("Laoo") }
  }
  @_alwaysEmitIntoClient public static var latin: Foundation.Locale.Script {
    get { Locale.Script("Latn") }
  }
  @_alwaysEmitIntoClient public static var malayalam: Foundation.Locale.Script {
    get { Locale.Script("Mlym") }
  }
  @_alwaysEmitIntoClient public static var meiteiMayek: Foundation.Locale.Script {
    get { Locale.Script("Mtei") }
  }
  @_alwaysEmitIntoClient public static var myanmar: Foundation.Locale.Script {
    get { Locale.Script("Mymr") }
  }
  @_alwaysEmitIntoClient public static var odia: Foundation.Locale.Script {
    get { Locale.Script("Orya") }
  }
  @_alwaysEmitIntoClient public static var olChiki: Foundation.Locale.Script {
    get { Locale.Script("Olck") }
  }
  @_alwaysEmitIntoClient public static var sinhala: Foundation.Locale.Script {
    get { Locale.Script("Sinh") }
  }
  @_alwaysEmitIntoClient public static var syriac: Foundation.Locale.Script {
    get { Locale.Script("Syrc") }
  }
  @_alwaysEmitIntoClient public static var tamil: Foundation.Locale.Script {
    get { Locale.Script("Taml") }
  }
  @_alwaysEmitIntoClient public static var telugu: Foundation.Locale.Script {
    get { Locale.Script("Telu") }
  }
  @_alwaysEmitIntoClient public static var thaana: Foundation.Locale.Script {
    get { Locale.Script("Thaa") }
  }
  @_alwaysEmitIntoClient public static var thai: Foundation.Locale.Script {
    get { Locale.Script("Thai") }
  }
  @_alwaysEmitIntoClient public static var tibetan: Foundation.Locale.Script {
    get { Locale.Script("Tibt") }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct VerbatimFormatStyle : Foundation.FormatStyle, Swift.Sendable {
    public var timeZone: Foundation.TimeZone
    public var calendar: Foundation.Calendar
    public var locale: Foundation.Locale?
    public init(format: Foundation.Date.FormatString, locale: Foundation.Locale? = nil, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar)
    public var attributed: Foundation.Date.AttributedStyle {
      get
    }
    public func format(_ value: Foundation.Date) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.VerbatimFormatStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.VerbatimFormatStyle, b: Foundation.Date.VerbatimFormatStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.Date
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.VerbatimFormatStyle {
  public static func verbatim(_ format: Foundation.Date.FormatString, locale: Foundation.Locale? = nil, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar) -> Foundation.Date.VerbatimFormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.VerbatimFormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Date.ParseStrategy {
    get
  }
  public typealias Strategy = Foundation.Date.ParseStrategy
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Date.VerbatimFormatStyle : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Date
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Date)?
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol FormatStyle : Swift.Decodable, Swift.Encodable, Swift.Hashable {
  associatedtype FormatInput
  associatedtype FormatOutput
  func format(_ value: Self.FormatInput) -> Self.FormatOutput
  func locale(_ locale: Foundation.Locale) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public func locale(_ locale: Foundation.Locale) -> Self
}
extension Foundation._NSRange : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout Foundation.NSRange?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout Foundation.NSRange?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> Foundation.NSRange
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CoreFoundation.CGRect : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGRect?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGRect?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreFoundation.CGRect
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CoreFoundation.CGPoint : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGPoint?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGPoint?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreFoundation.CGPoint
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CoreFoundation.CGVector : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGVector?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGVector?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreFoundation.CGVector
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CoreFoundation.CGSize : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGSize?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGSize?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreFoundation.CGSize
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CoreFoundation.CGAffineTransform : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGAffineTransform?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGAffineTransform?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreFoundation.CGAffineTransform
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension Foundation.NSValue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func value<StoredType>(of type: StoredType.Type) -> StoredType?
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.RunLoop : Combine.Scheduler {
  public struct SchedulerTimeType : Swift.Strideable, Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var date: Foundation.Date
    public init(_ date: Foundation.Date)
    public func distance(to other: Foundation.RunLoop.SchedulerTimeType) -> Foundation.RunLoop.SchedulerTimeType.Stride
    public func advanced(by n: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType
    public struct Stride : Swift.ExpressibleByFloatLiteral, Swift.Comparable, Swift.SignedNumeric, Swift.Codable, Combine.SchedulerTimeIntervalConvertible, Swift.Sendable {
      public typealias FloatLiteralType = Foundation.TimeInterval
      public typealias IntegerLiteralType = Foundation.TimeInterval
      public typealias Magnitude = Foundation.TimeInterval
      public var magnitude: Foundation.TimeInterval
      public var timeInterval: Foundation.TimeInterval {
        get
      }
      public init(integerLiteral value: Foundation.TimeInterval)
      public init(floatLiteral value: Foundation.TimeInterval)
      public init(_ timeInterval: Foundation.TimeInterval)
      public init?<T>(exactly source: T) where T : Swift.BinaryInteger
      public static func < (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Swift.Bool
      public static func * (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func + (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func - (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func *= (lhs: inout Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride)
      public static func += (lhs: inout Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride)
      public static func -= (lhs: inout Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride)
      public static func seconds(_ s: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func seconds(_ s: Swift.Double) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func milliseconds(_ ms: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func microseconds(_ us: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func nanoseconds(_ ns: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func == (a: Foundation.RunLoop.SchedulerTimeType.Stride, b: Foundation.RunLoop.SchedulerTimeType.Stride) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
    }
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct SchedulerOptions : Swift.Sendable {
  }
  public func schedule(options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.RunLoop.SchedulerTimeType, tolerance: Foundation.RunLoop.SchedulerTimeType.Stride, options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.RunLoop.SchedulerTimeType, interval: Foundation.RunLoop.SchedulerTimeType.Stride, tolerance: Foundation.RunLoop.SchedulerTimeType.Stride, options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void) -> any Combine.Cancellable
  public var now: Foundation.RunLoop.SchedulerTimeType {
    get
  }
  public var minimumTolerance: Foundation.RunLoop.SchedulerTimeType.Stride {
    get
  }
}
extension Foundation.URL {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public struct ParseStrategy : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public init(scheme: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .required, user: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, password: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, host: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .required, port: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.Int> = .optional, path: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, query: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, fragment: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.URL.ParseStrategy, b: Foundation.URL.ParseStrategy) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.ParseStrategy {
  public enum ComponentParseStrategy<Component> : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable where Component : Swift.Decodable, Component : Swift.Encodable, Component : Swift.Hashable, Component : Swift.Sendable {
    case required
    case optional
    case defaultValue(Component)
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.URL.ParseStrategy.ComponentParseStrategy<Component>, b: Foundation.URL.ParseStrategy.ComponentParseStrategy<Component>) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.ParseStrategy {
  public func scheme(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .required) -> Foundation.URL.ParseStrategy
  public func user(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional) -> Foundation.URL.ParseStrategy
  public func password(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional) -> Foundation.URL.ParseStrategy
  public func host(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .required) -> Foundation.URL.ParseStrategy
  public func port(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.Int> = .optional) -> Foundation.URL.ParseStrategy
  public func path(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional) -> Foundation.URL.ParseStrategy
  public func query(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional) -> Foundation.URL.ParseStrategy
  public func fragment(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional) -> Foundation.URL.ParseStrategy
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.ParseStrategy : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Foundation.URL
  public typealias ParseInput = Swift.String
  public typealias ParseOutput = Foundation.URL
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.ParseStrategy where Self == Foundation.URL.ParseStrategy {
  public static var url: Foundation.URL.ParseStrategy {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL {
  public init<T>(_ value: T.ParseInput, strategy: T) throws where T : Foundation.ParseStrategy, T.ParseOutput == Foundation.URL
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.ParseStrategy : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.URL
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.URL)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.URL.ParseStrategy {
  public static func url(scheme: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .required, user: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, password: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, host: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .required, port: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.Int> = .optional, path: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, query: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, fragment: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional) -> Self
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol ObjectiveCConvertibleAttributedStringKey : Foundation.AttributedStringKey {
  associatedtype ObjectiveCValue : ObjectiveC.NSObject
  static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue
  static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.ObjectiveCConvertibleAttributedStringKey where Self.ObjectiveCValue == Foundation.NSNumber, Self.Value : Swift.RawRepresentable, Self.Value.RawValue == Swift.Int {
  public static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue
  public static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.ObjectiveCConvertibleAttributedStringKey where Self.ObjectiveCValue == Foundation.NSString, Self.Value : Swift.RawRepresentable, Self.Value.RawValue == Swift.String {
  public static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue
  public static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeContainer {
  public init(_ dictionary: [Foundation.NSAttributedString.Key : Any])
  public init<S>(_ dictionary: [Foundation.NSAttributedString.Key : Any], including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) throws where S : Foundation.AttributeScope
  public init<S>(_ dictionary: [Foundation.NSAttributedString.Key : Any], including scope: S.Type) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Dictionary where Key == Foundation.NSAttributedString.Key, Value == Any {
  public init(_ container: Foundation.AttributeContainer)
  public init<S>(_ container: Foundation.AttributeContainer, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) throws where S : Foundation.AttributeScope
  public init<S>(_ container: Foundation.AttributeContainer, including scope: S.Type) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.NSAttributedString {
  convenience public init(_ attrStr: Foundation.AttributedString)
  convenience public init<S>(_ attrStr: Foundation.AttributedString, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) throws where S : Foundation.AttributeScope
  convenience public init<S>(_ attrStr: Foundation.AttributedString, including scope: S.Type) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public init(_ nsStr: Foundation.NSAttributedString)
  public init<S>(_ nsStr: Foundation.NSAttributedString, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) throws where S : Foundation.AttributeScope
  public init<S>(_ nsStr: Foundation.NSAttributedString, including scope: S.Type) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.String.Index {
  public init?<S>(_ sourcePosition: Foundation.AttributedString.Index, within target: S) where S : Swift.StringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Index {
  public init?<S>(_ sourcePosition: Swift.String.Index, within target: S) where S : Foundation.AttributedStringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation._NSRange {
  public init<R, S>(_ region: R, in target: S) where R : Swift.RangeExpression, S : Foundation.AttributedStringProtocol, R.Bound == Foundation.AttributedString.Index
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public init?<S>(_ markdownSourcePosition: Foundation.AttributedString.MarkdownSourcePosition, in target: S) where S : Swift.StringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Range where Bound == Foundation.AttributedString.Index {
  public init?<S>(_ range: Foundation.NSRange, in attrStr: S) where S : Foundation.AttributedStringProtocol
  public init?<R, S>(_ region: R, in attrStr: S) where R : Swift.RangeExpression, S : Foundation.AttributedStringProtocol, R.Bound == Swift.String.Index
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Range where Bound == Swift.String.Index {
  public init?<R, S>(_ region: R, in string: S) where R : Swift.RangeExpression, S : Swift.StringProtocol, R.Bound == Foundation.AttributedString.Index
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public init?<S>(_ markdownSourcePosition: Foundation.AttributedString.MarkdownSourcePosition, in target: S) where S : Swift.StringProtocol
}
extension Foundation.FileManager {
  @available(*, deprecated, renamed: "replaceItemAt(_:withItemAt:backupItemName:options:)")
  public func replaceItemAtURL(originalItemURL: Foundation.NSURL, withItemAtURL newItemURL: Foundation.NSURL, backupItemName: Swift.String? = nil, options: Foundation.FileManager.ItemReplacementOptions = []) throws -> Foundation.NSURL?
  @available(macOS 10.6, iOS 4.0, *)
  @available(swift, obsoleted: 4)
  public func replaceItemAt(_ originalItemURL: Foundation.URL, withItemAt newItemURL: Foundation.URL, backupItemName: Swift.String? = nil, options: Foundation.FileManager.ItemReplacementOptions = []) throws -> Foundation.NSURL?
  @available(swift 4)
  @available(macOS 10.6, iOS 4.0, *)
  public func replaceItemAt(_ originalItemURL: Foundation.URL, withItemAt newItemURL: Foundation.URL, backupItemName: Swift.String? = nil, options: Foundation.FileManager.ItemReplacementOptions = []) throws -> Foundation.URL?
  @available(macOS 10.6, iOS 4.0, *)
  @nonobjc public func enumerator(at url: Foundation.URL, includingPropertiesForKeys keys: [Foundation.URLResourceKey]?, options mask: Foundation.FileManager.DirectoryEnumerationOptions = [], errorHandler handler: ((Foundation.URL, any Swift.Error) -> Swift.Bool)? = nil) -> Foundation.FileManager.DirectoryEnumerator?
}
extension Foundation.FileHandle {
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  public func readToEnd() throws -> Foundation.Data?
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  public func read(upToCount count: Swift.Int) throws -> Foundation.Data?
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  public func offset() throws -> Swift.UInt64
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  @discardableResult
  public func seekToEnd() throws -> Swift.UInt64
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  @_specialize(exported: false, kind: full, where T == Foundation.Data)
  @_specialize(exported: false, kind: full, where T == Dispatch.DispatchData)
  public func write<T>(contentsOf data: T) throws where T : Foundation.DataProtocol
}
extension Swift.Array : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.Array<Swift.UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.Array<Swift.UInt8>>
}
extension Swift.ArraySlice : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.ArraySlice<Swift.UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.ArraySlice<Swift.UInt8>>
}
extension Swift.ContiguousArray : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.ContiguousArray<Swift.UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.ContiguousArray<Swift.UInt8>>
}
extension Swift.EmptyCollection : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.EmptyCollection<Foundation.Data> {
    get
  }
  public typealias Regions = Swift.EmptyCollection<Foundation.Data>
}
extension Swift.Repeated : Foundation.DataProtocol where Element == Swift.UInt8 {
  public typealias Regions = Swift.Repeated<Foundation.Data>
  public var regions: Swift.Repeated<Foundation.Data> {
    get
  }
}
extension Swift.Array : Foundation.MutableDataProtocol where Element == Swift.UInt8 {
}
extension Swift.ContiguousArray : Foundation.MutableDataProtocol where Element == Swift.UInt8 {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol EncodableAttributedStringKey : Foundation.AttributedStringKey {
  static func encode(_ value: Self.Value, to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol DecodableAttributedStringKey : Foundation.AttributedStringKey {
  static func decode(from decoder: any Swift.Decoder) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public typealias CodableAttributedStringKey = Foundation.DecodableAttributedStringKey & Foundation.EncodableAttributedStringKey
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.EncodableAttributedStringKey where Self.Value : Swift.Encodable {
  public static func encode(_ value: Self.Value, to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.DecodableAttributedStringKey where Self.Value : Swift.Decodable {
  public static func decode(from decoder: any Swift.Decoder) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol MarkdownDecodableAttributedStringKey : Foundation.AttributedStringKey {
  static func decodeMarkdown(from decoder: any Swift.Decoder) throws -> Self.Value
  static var markdownName: Swift.String { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.MarkdownDecodableAttributedStringKey {
  public static var markdownName: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.MarkdownDecodableAttributedStringKey where Self : Foundation.DecodableAttributedStringKey {
  public static func decodeMarkdown(from decoder: any Swift.Decoder) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.EncodableAttributedStringKey where Self.Value : ObjectiveC.NSObject, Self.Value : Foundation.NSSecureCoding {
  public static func encode(_ value: Self.Value, to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.DecodableAttributedStringKey where Self.Value : ObjectiveC.NSObject, Self.Value : Foundation.NSSecureCoding {
  public static func decode(from decoder: any Swift.Decoder) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol EncodingConfigurationProviding {
  associatedtype EncodingConfiguration
  static var encodingConfiguration: Self.EncodingConfiguration { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol EncodableWithConfiguration {
  associatedtype EncodingConfiguration
  func encode(to encoder: any Swift.Encoder, configuration: Self.EncodingConfiguration) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol DecodingConfigurationProviding {
  associatedtype DecodingConfiguration
  static var decodingConfiguration: Self.DecodingConfiguration { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol DecodableWithConfiguration {
  associatedtype DecodingConfiguration
  init(from decoder: any Swift.Decoder, configuration: Self.DecodingConfiguration) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public typealias CodableWithConfiguration = Foundation.DecodableWithConfiguration & Foundation.EncodableWithConfiguration
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.KeyedEncodingContainer {
  public mutating func encode<T, C>(_ wrapper: Foundation.CodableConfiguration<T?, C>, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws where T : Foundation.DecodableWithConfiguration, T : Foundation.EncodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, C : Foundation.EncodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration, T.EncodingConfiguration == C.EncodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.KeyedDecodingContainer {
  public func decode<T, C>(_: Foundation.CodableConfiguration<T?, C>.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Foundation.CodableConfiguration<T?, C> where T : Foundation.DecodableWithConfiguration, T : Foundation.EncodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, C : Foundation.EncodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration, T.EncodingConfiguration == C.EncodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.KeyedEncodingContainer {
  public mutating func encode<T, C>(_ t: T, forKey key: Swift.KeyedEncodingContainer<K>.Key, configuration: C.Type) throws where T : Foundation.EncodableWithConfiguration, C : Foundation.EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  public mutating func encodeIfPresent<T, C>(_ t: T?, forKey key: Swift.KeyedEncodingContainer<K>.Key, configuration: C.Type) throws where T : Foundation.EncodableWithConfiguration, C : Foundation.EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  public mutating func encode<T>(_ t: T, forKey key: Swift.KeyedEncodingContainer<K>.Key, configuration: T.EncodingConfiguration) throws where T : Foundation.EncodableWithConfiguration
  public mutating func encodeIfPresent<T>(_ t: T?, forKey key: Swift.KeyedEncodingContainer<K>.Key, configuration: T.EncodingConfiguration) throws where T : Foundation.EncodableWithConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.KeyedDecodingContainer {
  public func decode<T, C>(_: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key, configuration: C.Type) throws -> T where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  public func decodeIfPresent<T, C>(_: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key, configuration: C.Type) throws -> T? where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  public func decode<T>(_: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key, configuration: T.DecodingConfiguration) throws -> T where T : Foundation.DecodableWithConfiguration
  public func decodeIfPresent<T>(_: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key, configuration: T.DecodingConfiguration) throws -> T? where T : Foundation.DecodableWithConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UnkeyedEncodingContainer {
  public mutating func encode<T, C>(_ t: T, configuration: C.Type) throws where T : Foundation.EncodableWithConfiguration, C : Foundation.EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  public mutating func encode<T>(_ t: T, configuration: T.EncodingConfiguration) throws where T : Foundation.EncodableWithConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UnkeyedDecodingContainer {
  public mutating func decode<T, C>(_: T.Type, configuration: C.Type) throws -> T where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  public mutating func decodeIfPresent<T, C>(_: T.Type, configuration: C.Type) throws -> T? where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  public mutating func decode<T>(_: T.Type, configuration: T.DecodingConfiguration) throws -> T where T : Foundation.DecodableWithConfiguration
  public mutating func decodeIfPresent<T>(_: T.Type, configuration: T.DecodingConfiguration) throws -> T? where T : Foundation.DecodableWithConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@propertyWrapper public struct CodableConfiguration<T, ConfigurationProvider> : Swift.Codable where T : Foundation.DecodableWithConfiguration, T : Foundation.EncodableWithConfiguration, ConfigurationProvider : Foundation.DecodingConfigurationProviding, ConfigurationProvider : Foundation.EncodingConfigurationProviding, T.DecodingConfiguration == ConfigurationProvider.DecodingConfiguration, T.EncodingConfiguration == ConfigurationProvider.EncodingConfiguration {
  public var wrappedValue: T
  public init(wrappedValue: T)
  public init(wrappedValue: T, from configurationProvider: ConfigurationProvider.Type)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.CodableConfiguration : Swift.Sendable where T : Swift.Sendable {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.CodableConfiguration : Swift.Equatable where T : Swift.Equatable {
  public static func == (a: Foundation.CodableConfiguration<T, ConfigurationProvider>, b: Foundation.CodableConfiguration<T, ConfigurationProvider>) -> Swift.Bool
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.CodableConfiguration : Swift.Hashable where T : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Optional : Foundation.EncodableWithConfiguration where Wrapped : Foundation.EncodableWithConfiguration {
  public func encode(to encoder: any Swift.Encoder, configuration: Wrapped.EncodingConfiguration) throws
  public typealias EncodingConfiguration = Wrapped.EncodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Optional : Foundation.DecodableWithConfiguration where Wrapped : Foundation.DecodableWithConfiguration {
  public init(from decoder: any Swift.Decoder, configuration: Wrapped.DecodingConfiguration) throws
  public typealias DecodingConfiguration = Wrapped.DecodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Array : Foundation.EncodableWithConfiguration where Element : Foundation.EncodableWithConfiguration {
  public func encode(to encoder: any Swift.Encoder, configuration: Element.EncodingConfiguration) throws
  public typealias EncodingConfiguration = Element.EncodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Array : Foundation.DecodableWithConfiguration where Element : Foundation.DecodableWithConfiguration {
  public init(from decoder: any Swift.Decoder, configuration: Element.DecodingConfiguration) throws
  public typealias DecodingConfiguration = Element.DecodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public struct AttributeScopeCodableConfiguration : Swift.Sendable {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScope {
  public static var encodingConfiguration: Foundation.AttributeScopeCodableConfiguration {
    get
  }
  public static var decodingConfiguration: Foundation.AttributeScopeCodableConfiguration {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString : Foundation.CodableWithConfiguration {
  public func encode(to encoder: any Swift.Encoder, configuration: Foundation.AttributeScopeCodableConfiguration) throws
  public init(from decoder: any Swift.Decoder, configuration: Foundation.AttributeScopeCodableConfiguration) throws
  public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeContainer : Foundation.CodableWithConfiguration {
  public func encode(to encoder: any Swift.Encoder, configuration: Foundation.AttributeScopeCodableConfiguration) throws
  public init(from decoder: any Swift.Decoder, configuration: Foundation.AttributeScopeCodableConfiguration) throws
  public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.CodableConfiguration where ConfigurationProvider : Foundation.AttributeScope {
  public init(wrappedValue: T, from keyPath: Swift.KeyPath<Foundation.AttributeScopes, ConfigurationProvider.Type>)
}
public struct CharacterSet : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable, Swift.SetAlgebra {
  public typealias ReferenceType = Foundation.NSCharacterSet
  public init()
  public init(charactersIn range: Swift.Range<Swift.Unicode.Scalar>)
  public init(charactersIn range: Swift.ClosedRange<Swift.Unicode.Scalar>)
  public init(charactersIn string: __shared Swift.String)
  public init(bitmapRepresentation data: __shared Foundation.Data)
  public init?(contentsOfFile file: __shared Swift.String)
  public static var controlCharacters: Foundation.CharacterSet {
    get
  }
  public static var whitespaces: Foundation.CharacterSet {
    get
  }
  public static var whitespacesAndNewlines: Foundation.CharacterSet {
    get
  }
  public static var decimalDigits: Foundation.CharacterSet {
    get
  }
  public static var letters: Foundation.CharacterSet {
    get
  }
  public static var lowercaseLetters: Foundation.CharacterSet {
    get
  }
  public static var uppercaseLetters: Foundation.CharacterSet {
    get
  }
  public static var nonBaseCharacters: Foundation.CharacterSet {
    get
  }
  public static var alphanumerics: Foundation.CharacterSet {
    get
  }
  public static var decomposables: Foundation.CharacterSet {
    get
  }
  public static var illegalCharacters: Foundation.CharacterSet {
    get
  }
  public static var punctuationCharacters: Foundation.CharacterSet {
    get
  }
  public static var capitalizedLetters: Foundation.CharacterSet {
    get
  }
  public static var symbols: Foundation.CharacterSet {
    get
  }
  public static var newlines: Foundation.CharacterSet {
    get
  }
  public static var urlUserAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlPasswordAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlHostAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlPathAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlQueryAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlFragmentAllowed: Foundation.CharacterSet {
    get
  }
  @nonobjc public var bitmapRepresentation: Foundation.Data {
    get
  }
  @nonobjc public var inverted: Foundation.CharacterSet {
    get
  }
  public func hasMember(inPlane plane: Swift.UInt8) -> Swift.Bool
  public mutating func insert(charactersIn range: Swift.Range<Swift.Unicode.Scalar>)
  public mutating func insert(charactersIn range: Swift.ClosedRange<Swift.Unicode.Scalar>)
  public mutating func remove(charactersIn range: Swift.Range<Swift.Unicode.Scalar>)
  public mutating func remove(charactersIn range: Swift.ClosedRange<Swift.Unicode.Scalar>)
  public mutating func insert(charactersIn string: Swift.String)
  public mutating func remove(charactersIn string: Swift.String)
  public mutating func invert()
  @discardableResult
  public mutating func insert(_ character: Swift.Unicode.Scalar) -> (inserted: Swift.Bool, memberAfterInsert: Swift.Unicode.Scalar)
  @discardableResult
  public mutating func update(with character: Swift.Unicode.Scalar) -> Swift.Unicode.Scalar?
  @discardableResult
  public mutating func remove(_ character: Swift.Unicode.Scalar) -> Swift.Unicode.Scalar?
  public func contains(_ member: Swift.Unicode.Scalar) -> Swift.Bool
  public func union(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func formUnion(_ other: Foundation.CharacterSet)
  public func intersection(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func formIntersection(_ other: Foundation.CharacterSet)
  public func subtracting(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func subtract(_ other: Foundation.CharacterSet)
  public func symmetricDifference(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func formSymmetricDifference(_ other: Foundation.CharacterSet)
  public func isSuperset(of other: Foundation.CharacterSet) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.CharacterSet, rhs: Foundation.CharacterSet) -> Swift.Bool
  public typealias ArrayLiteralElement = Swift.Unicode.Scalar
  public typealias Element = Swift.Unicode.Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.CharacterSet : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSCharacterSet
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSCharacterSet, result: inout Foundation.CharacterSet?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSCharacterSet, result: inout Foundation.CharacterSet?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSCharacterSet?) -> Foundation.CharacterSet
  public typealias _ObjectiveCType = Foundation.NSCharacterSet
}
extension Foundation.CharacterSet : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation.NSCharacterSet : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.CharacterSet : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.CharacterSet : Swift.Sendable {
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
public struct Measurement<UnitType> : Foundation.ReferenceConvertible, Swift.Comparable, Swift.Equatable where UnitType : Foundation.Unit {
  public typealias ReferenceType = Foundation.NSMeasurement
  public let unit: UnitType
  public var value: Swift.Double
  public init(value: Swift.Double, unit: UnitType)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Measurement : Swift.Sendable where UnitType : Swift.Sendable {
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement where UnitType : Foundation.Dimension {
  public func converted(to otherUnit: UnitType) -> Foundation.Measurement<UnitType>
  public mutating func convert(to otherUnit: UnitType)
  public static func + (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func - (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement {
  public static func + (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func - (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func * (lhs: Foundation.Measurement<UnitType>, rhs: Swift.Double) -> Foundation.Measurement<UnitType>
  public static func * (lhs: Swift.Double, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func / (lhs: Foundation.Measurement<UnitType>, rhs: Swift.Double) -> Foundation.Measurement<UnitType>
  public static func / (lhs: Swift.Double, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func == <LeftHandSideType, RightHandSideType>(lhs: Foundation.Measurement<LeftHandSideType>, rhs: Foundation.Measurement<RightHandSideType>) -> Swift.Bool where LeftHandSideType : Foundation.Unit, RightHandSideType : Foundation.Unit
  public static func < <LeftHandSideType, RightHandSideType>(lhs: Foundation.Measurement<LeftHandSideType>, rhs: Foundation.Measurement<RightHandSideType>) -> Swift.Bool where LeftHandSideType : Foundation.Unit, RightHandSideType : Foundation.Unit
}
@usableFromInline
internal typealias MeasurementBridgeType = Swift._ObjectiveCBridgeable
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement : Foundation.MeasurementBridgeType {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSMeasurement
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSMeasurement, result: inout Foundation.Measurement<UnitType>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSMeasurement, result: inout Foundation.Measurement<UnitType>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSMeasurement?) -> Foundation.Measurement<UnitType>
  public typealias _ObjectiveCType = Foundation.NSMeasurement
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.NSMeasurement : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.MeasurementFormatter {
  public func string<UnitType>(from measurement: Foundation.Measurement<UnitType>) -> Swift.String where UnitType : Foundation.Unit
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Foundation.NSCoder {
  public func decodeObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: Swift.String) -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @nonobjc public func decodeObject(of classes: [Swift.AnyClass]?, forKey key: Swift.String) -> Any?
  @available(macOS 10.11, iOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc public func decodeTopLevelObject() throws -> Any?
  @available(macOS 10.11, iOS 9.0, *)
  @available(swift, obsoleted: 4)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc public func decodeTopLevelObject(forKey key: Swift.String) throws -> Swift.AnyObject?
  @available(swift 4)
  @available(macOS 10.11, iOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc public func decodeTopLevelObject(forKey key: Swift.String) throws -> Any?
  @available(macOS 10.11, iOS 9.0, *)
  public func decodeTopLevelObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: Swift.String) throws -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc public func decodeTopLevelObject(of classes: [Swift.AnyClass]?, forKey key: Swift.String) throws -> Any?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeArrayOfObjects<DecodedObject>(ofClass cls: DecodedObject.Type, forKey key: Swift.String) -> [DecodedObject]? where DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeArrayOfObjects(ofClasses classes: [Swift.AnyClass], forKey key: Swift.String) -> [Any]?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeDictionary<DecodedKey, DecodedObject>(withKeyClass keyClass: DecodedKey.Type, objectClass: DecodedObject.Type, forKey key: Swift.String) -> [DecodedKey : DecodedObject]? where DecodedKey : ObjectiveC.NSObject, DecodedKey : Foundation.NSCopying, DecodedKey : Foundation.NSSecureCoding, DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeDictionary(withKeysOfClasses keyClasses: [Swift.AnyClass], objectsOfClasses classes: [Swift.AnyClass], forKey key: Swift.String) -> [Swift.AnyHashable : Any]?
}
extension Foundation.NSKeyedArchiver {
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc public func encodeEncodable<T>(_ value: T, forKey key: Swift.String) throws where T : Swift.Encodable
}
extension Foundation.NSKeyedUnarchiver {
  @available(macOS 10.11, iOS 9.0, *)
  @available(swift, obsoleted: 4)
  @available(macOS, introduced: 10.11, deprecated: 10.14, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(iOS, introduced: 9.0, deprecated: 12.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 12.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 5.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @nonobjc public class func unarchiveTopLevelObjectWithData(_ data: Foundation.NSData) throws -> Swift.AnyObject?
  @available(swift 4)
  @available(macOS 10.11, iOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 10.14, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(iOS, introduced: 9.0, deprecated: 12.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 12.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 5.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @nonobjc public class func unarchiveTopLevelObjectWithData(_ data: Foundation.Data) throws -> Any?
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @nonobjc public static func unarchivedObject<DecodedObjectType>(ofClass cls: DecodedObjectType.Type, from data: Foundation.Data) throws -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @nonobjc public static func unarchivedObject(ofClasses classes: [Swift.AnyClass], from data: Foundation.Data) throws -> Any?
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc public func decodeDecodable<T>(_ type: T.Type, forKey key: Swift.String) -> T? where T : Swift.Decodable
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc public func decodeTopLevelDecodable<T>(_ type: T.Type, forKey key: Swift.String) throws -> T? where T : Swift.Decodable
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedArrayOfObjects<DecodedObject>(ofClass cls: DecodedObject.Type, from data: Foundation.Data) throws -> [DecodedObject]? where DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedArrayOfObjects(ofClasses classes: [Swift.AnyClass], from data: Foundation.Data) throws -> [Any]?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedDictionary<DecodedKey, DecodedObject>(ofKeyClass keyClass: DecodedKey.Type, objectClass: DecodedObject.Type, from data: Foundation.Data) throws -> [DecodedKey : DecodedObject]? where DecodedKey : ObjectiveC.NSObject, DecodedKey : Foundation.NSCopying, DecodedKey : Foundation.NSSecureCoding, DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedDictionary(keysOfClasses keyClasses: [Swift.AnyClass], objectsOfClasses objectClasses: [Swift.AnyClass], from data: Foundation.Data) throws -> [Swift.AnyHashable : Any]?
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Duration {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func formatted<S>(_ v: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Swift.Duration
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func formatted() -> Swift.String
}
extension Foundation.NSSortDescriptor {
  convenience public init<Root, Value>(keyPath: Swift.KeyPath<Root, Value>, ascending: Swift.Bool)
  convenience public init<Root, Value>(keyPath: Swift.KeyPath<Root, Value>, ascending: Swift.Bool, comparator cmptr: @escaping Foundation.Comparator)
  public var keyPath: Swift.AnyKeyPath? {
    get
  }
}
public struct Locale : Swift.Hashable, Swift.Equatable, Foundation.ReferenceConvertible, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSLocale
  public typealias LanguageDirection = Foundation.NSLocale.LanguageDirection
  public static var autoupdatingCurrent: Foundation.Locale {
    get
  }
  public static var current: Foundation.Locale {
    get
  }
  public init(identifier: Swift.String)
  public func localizedString(forIdentifier identifier: Swift.String) -> Swift.String?
  public func localizedString(forLanguageCode languageCode: Swift.String) -> Swift.String?
  public func localizedString(forRegionCode regionCode: Swift.String) -> Swift.String?
  public func localizedString(forScriptCode scriptCode: Swift.String) -> Swift.String?
  public func localizedString(forVariantCode variantCode: Swift.String) -> Swift.String?
  public func localizedString(for calendarIdentifier: Foundation.Calendar.Identifier) -> Swift.String?
  public func localizedString(forCurrencyCode currencyCode: Swift.String) -> Swift.String?
  public func localizedString(forCollationIdentifier collationIdentifier: Swift.String) -> Swift.String?
  public func localizedString(forCollatorIdentifier collatorIdentifier: Swift.String) -> Swift.String?
  public var identifier: Swift.String {
    get
  }
  @available(macOS, deprecated: 13, renamed: "language.languageCode.identifier")
  @available(iOS, deprecated: 16, renamed: "language.languageCode.identifier")
  @available(tvOS, deprecated: 16, renamed: "language.languageCode.identifier")
  @available(watchOS, deprecated: 9, renamed: "language.languageCode.identifier")
  public var languageCode: Swift.String? {
    get
  }
  @available(macOS, deprecated: 13, renamed: "language.region.identifier")
  @available(iOS, deprecated: 16, renamed: "language.region.identifier")
  @available(tvOS, deprecated: 16, renamed: "language.region.identifier")
  @available(watchOS, deprecated: 9, renamed: "language.region.identifier")
  public var regionCode: Swift.String? {
    get
  }
  @available(macOS, deprecated: 13, renamed: "language.script.identifier")
  @available(iOS, deprecated: 16, renamed: "language.script.identifier")
  @available(tvOS, deprecated: 16, renamed: "language.script.identifier")
  @available(watchOS, deprecated: 9, renamed: "language.script.identifier")
  public var scriptCode: Swift.String? {
    get
  }
  @available(macOS, deprecated: 13, renamed: "variant.identifier")
  @available(iOS, deprecated: 16, renamed: "variant.identifier")
  @available(tvOS, deprecated: 16, renamed: "variant.identifier")
  @available(watchOS, deprecated: 9, renamed: "variant.identifier")
  public var variantCode: Swift.String? {
    get
  }
  public var exemplarCharacterSet: Foundation.CharacterSet? {
    get
  }
  public var calendar: Foundation.Calendar {
    get
  }
  @available(macOS, deprecated: 13, renamed: "collation.identifier")
  @available(iOS, deprecated: 16, renamed: "collation.identifier")
  @available(tvOS, deprecated: 16, renamed: "collation.identifier")
  @available(watchOS, deprecated: 9, renamed: "collation.identifier")
  public var collationIdentifier: Swift.String? {
    get
  }
  @available(macOS, deprecated: 13, message: "Use `measurementSystem` instead")
  @available(iOS, deprecated: 16, message: "Use `measurementSystem` instead")
  @available(tvOS, deprecated: 16, message: "Use `measurementSystem` instead")
  @available(watchOS, deprecated: 9, message: "Use `measurementSystem` instead")
  public var usesMetricSystem: Swift.Bool {
    get
  }
  public var decimalSeparator: Swift.String? {
    get
  }
  public var groupingSeparator: Swift.String? {
    get
  }
  public var currencySymbol: Swift.String? {
    get
  }
  @available(macOS, deprecated: 13, renamed: "currency.identifier")
  @available(iOS, deprecated: 16, renamed: "currency.identifier")
  @available(tvOS, deprecated: 16, renamed: "currency.identifier")
  @available(watchOS, deprecated: 9, renamed: "currency.identifier")
  public var currencyCode: Swift.String? {
    get
  }
  public var collatorIdentifier: Swift.String? {
    get
  }
  public var quotationBeginDelimiter: Swift.String? {
    get
  }
  public var quotationEndDelimiter: Swift.String? {
    get
  }
  public var alternateQuotationBeginDelimiter: Swift.String? {
    get
  }
  public var alternateQuotationEndDelimiter: Swift.String? {
    get
  }
  public static var availableIdentifiers: [Swift.String] {
    get
  }
  @available(macOS, deprecated: 13, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
  @available(iOS, deprecated: 16, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
  @available(tvOS, deprecated: 16, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
  @available(watchOS, deprecated: 9, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
  public static var isoLanguageCodes: [Swift.String] {
    get
  }
  @available(macOS, deprecated: 13, message: "Use `Locale.Region.isoRegions` instead")
  @available(iOS, deprecated: 16, message: "Use `Locale.Region.isoRegions` instead")
  @available(tvOS, deprecated: 16, message: "Use `Locale.Region.isoRegions` instead")
  @available(watchOS, deprecated: 9, message: "Use `Locale.Region.isoRegions` instead")
  public static var isoRegionCodes: [Swift.String] {
    get
  }
  @available(macOS, deprecated: 13, message: "Use `Locale.Currency.isoCurrencies` instead")
  @available(iOS, deprecated: 16, message: "Use `Locale.Currency.isoCurrencies` instead")
  @available(tvOS, deprecated: 16, message: "Use `Locale.Currency.isoCurrencies` instead")
  @available(watchOS, deprecated: 9, message: "Use `Locale.Currency.isoCurrencies` instead")
  public static var isoCurrencyCodes: [Swift.String] {
    get
  }
  public static var commonISOCurrencyCodes: [Swift.String] {
    get
  }
  public static var preferredLanguages: [Swift.String] {
    get
  }
  @available(macOS, deprecated: 13, message: "Use `Locale.Components(identifier:)` to access components")
  @available(iOS, deprecated: 16, message: "Use `Locale.Components(identifier:)` to access components")
  @available(tvOS, deprecated: 16, message: "Use `Locale.Components(identifier:)` to access components")
  @available(watchOS, deprecated: 9, message: "Use `Locale.Components(identifier:)` to access components")
  public static func components(fromIdentifier string: Swift.String) -> [Swift.String : Swift.String]
  public static func identifier(fromComponents components: [Swift.String : Swift.String]) -> Swift.String
  @available(macOS, deprecated: 13, renamed: "identifier(_:from:)")
  @available(iOS, deprecated: 16, renamed: "identifier(_:from:)")
  @available(tvOS, deprecated: 16, renamed: "identifier(_:from:)")
  @available(watchOS, deprecated: 9, renamed: "identifier(_:from:)")
  public static func canonicalIdentifier(from string: Swift.String) -> Swift.String
  public static func canonicalLanguageIdentifier(from string: Swift.String) -> Swift.String
  public static func identifier(fromWindowsLocaleCode code: Swift.Int) -> Swift.String?
  public static func windowsLocaleCode(fromIdentifier identifier: Swift.String) -> Swift.Int?
  @available(macOS, deprecated: 13, message: "Use `Locale.Language(identifier:).characterDirection`")
  @available(iOS, deprecated: 16, message: "Use `Locale.Language(identifier:).characterDirection`")
  @available(tvOS, deprecated: 16, message: "Use `Locale.Language(identifier:).characterDirection`")
  @available(watchOS, deprecated: 9, message: "Use `Locale.Language(identifier:).characterDirection`")
  public static func characterDirection(forLanguage isoLangCode: Swift.String) -> Foundation.Locale.LanguageDirection
  @available(macOS, deprecated: 13, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
  @available(iOS, deprecated: 16, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
  @available(tvOS, deprecated: 16, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
  @available(watchOS, deprecated: 9, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
  public static func lineDirection(forLanguage isoLangCode: Swift.String) -> Foundation.Locale.LanguageDirection
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.Locale, rhs: Foundation.Locale) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Locale : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation.Locale : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSLocale
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSLocale, result: inout Foundation.Locale?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSLocale, result: inout Foundation.Locale?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSLocale?) -> Foundation.Locale
  public typealias _ObjectiveCType = Foundation.NSLocale
}
extension Foundation.NSLocale : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.Locale : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct AsyncLineSequence<Base> : _Concurrency.AsyncSequence where Base : _Concurrency.AsyncSequence, Base.Element == Swift.UInt8 {
  public typealias Element = Swift.String
  public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = Swift.String
    #if compiler(>=5.3) && $AsyncAwait
    @_specialize(exported: false, kind: full, where Base == Foundation.URL.AsyncBytes)
    @_specialize(exported: false, kind: full, where Base == Foundation.FileHandle.AsyncBytes)
    @_specialize(exported: false, kind: full, where Base == Foundation.URLSession.AsyncBytes)
    public mutating func next() async rethrows -> Swift.String?
    #endif
  }
  public func makeAsyncIterator() -> Foundation.AsyncLineSequence<Base>.AsyncIterator
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.AsyncLineSequence : Swift.Sendable where Base : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.AsyncLineSequence.AsyncIterator : Swift.Sendable where Base.AsyncIterator : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension _Concurrency.AsyncSequence where Self.Element == Swift.UInt8 {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var lines: Foundation.AsyncLineSequence<Self> {
    get
  }
}
#endif
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.URLSession {
  public func dataTaskPublisher(for url: Foundation.URL) -> Foundation.URLSession.DataTaskPublisher
  public func dataTaskPublisher(for request: Foundation.URLRequest) -> Foundation.URLSession.DataTaskPublisher
  public struct DataTaskPublisher : Combine.Publisher, Swift.Sendable {
    public typealias Output = (data: Foundation.Data, response: Foundation.URLResponse)
    public typealias Failure = Foundation.URLError
    public let request: Foundation.URLRequest
    public let session: Foundation.URLSession
    public init(request: Foundation.URLRequest, session: Foundation.URLSession)
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Foundation.URLError, S.Input == (data: Foundation.Data, response: Foundation.URLResponse)
  }
}
public protocol DataProtocol : Swift.RandomAccessCollection where Self.Element == Swift.UInt8, Self.SubSequence : Foundation.DataProtocol {
  associatedtype Regions : Swift.BidirectionalCollection where Self.Regions.Element : Foundation.ContiguousBytes, Self.Regions.Element : Foundation.DataProtocol, Self.Regions.Element.SubSequence : Foundation.ContiguousBytes
  var regions: Self.Regions { get }
  func firstRange<D, R>(of: D, in: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  func lastRange<D, R>(of: D, in: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  func copyBytes(to: Swift.UnsafeMutableRawBufferPointer, count: Swift.Int) -> Swift.Int
  @discardableResult
  func copyBytes<DestinationType>(to: Swift.UnsafeMutableBufferPointer<DestinationType>, count: Swift.Int) -> Swift.Int
  @discardableResult
  func copyBytes<R>(to: Swift.UnsafeMutableRawBufferPointer, from: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  func copyBytes<DestinationType, R>(to: Swift.UnsafeMutableBufferPointer<DestinationType>, from: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
}
public protocol MutableDataProtocol : Foundation.DataProtocol, Swift.MutableCollection, Swift.RangeReplaceableCollection {
  mutating func resetBytes<R>(in range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
extension Foundation.DataProtocol {
  public func firstRange<D>(of data: D) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol
  public func lastRange<D>(of data: D) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol
  @discardableResult
  public func copyBytes(to ptr: Swift.UnsafeMutableRawBufferPointer) -> Swift.Int
  @discardableResult
  public func copyBytes<DestinationType>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>) -> Swift.Int
  @discardableResult
  public func copyBytes(to ptr: Swift.UnsafeMutableRawBufferPointer, count: Swift.Int) -> Swift.Int
  @discardableResult
  public func copyBytes<DestinationType>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>, count: Swift.Int) -> Swift.Int
  @discardableResult
  public func copyBytes<R>(to ptr: Swift.UnsafeMutableRawBufferPointer, from range: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  public func copyBytes<DestinationType, R>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>, from range: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
  public func firstRange<D, R>(of data: D, in range: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  public func lastRange<D, R>(of data: D, in range: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
}
extension Foundation.DataProtocol where Self : Foundation.ContiguousBytes {
  public func copyBytes<DestinationType, R>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>, from range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
extension Foundation.MutableDataProtocol {
  public mutating func resetBytes<R>(in range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
extension Swift.Slice : Foundation.DataProtocol where Base : Foundation.DataProtocol {
  public typealias Regions = [Base.Regions.Element.SubSequence]
  public var regions: [Base.Regions.Element.SubSequence] {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FloatingPointFormatStyle<Value> : Swift.Codable, Swift.Hashable, Swift.Sendable where Value : Swift.BinaryFloatingPoint {
  public var locale: Foundation.Locale
  public init(locale: Foundation.Locale = .autoupdatingCurrent)
  public var attributed: Foundation.FloatingPointFormatStyle<Value>.Attributed {
    get
  }
  public typealias Configuration = Foundation.NumberFormatStyleConfiguration
  public func grouping(_ group: Foundation.FloatingPointFormatStyle<Value>.Configuration.Grouping) -> Foundation.FloatingPointFormatStyle<Value>
  public func precision(_ p: Foundation.FloatingPointFormatStyle<Value>.Configuration.Precision) -> Foundation.FloatingPointFormatStyle<Value>
  public func sign(strategy: Foundation.FloatingPointFormatStyle<Value>.Configuration.SignDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>
  public func decimalSeparator(strategy: Foundation.FloatingPointFormatStyle<Value>.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>
  public func rounded(rule: Foundation.FloatingPointFormatStyle<Value>.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Double? = nil) -> Foundation.FloatingPointFormatStyle<Value>
  public func scale(_ multiplicand: Swift.Double) -> Foundation.FloatingPointFormatStyle<Value>
  public func notation(_ notation: Foundation.FloatingPointFormatStyle<Value>.Configuration.Notation) -> Foundation.FloatingPointFormatStyle<Value>
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.FloatingPointFormatStyle<Value>, b: Foundation.FloatingPointFormatStyle<Value>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle {
  public struct Percent : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var locale: Foundation.Locale
    public init(locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.FloatingPointFormatStyle<Value>.Attributed {
      get
    }
    public typealias Configuration = Foundation.NumberFormatStyleConfiguration
    public func grouping(_ group: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.Grouping) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func precision(_ p: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.Precision) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func sign(strategy: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.SignDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func decimalSeparator(strategy: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func rounded(rule: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Double? = nil) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func scale(_ multiplicand: Swift.Double) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func notation(_ notation: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.Notation) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.FloatingPointFormatStyle<Value>.Percent, b: Foundation.FloatingPointFormatStyle<Value>.Percent) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct Currency : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var locale: Foundation.Locale
    public let currencyCode: Swift.String
    public typealias Configuration = Foundation.CurrencyFormatStyleConfiguration
    public init(code: Swift.String, locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.FloatingPointFormatStyle<Value>.Attributed {
      get
    }
    public func grouping(_ group: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.Grouping) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func precision(_ p: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.Precision) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func sign(strategy: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.SignDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func decimalSeparator(strategy: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func rounded(rule: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Double? = nil) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func scale(_ multiplicand: Swift.Double) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func presentation(_ p: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.Presentation) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.FloatingPointFormatStyle<Value>.Currency, b: Foundation.FloatingPointFormatStyle<Value>.Currency) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle : Foundation.FormatStyle {
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.FloatingPointFormatStyle<Value>
  public typealias FormatInput = Value
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle.Percent : Foundation.FormatStyle {
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.FloatingPointFormatStyle<Value>.Percent
  public typealias FormatInput = Value
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle.Currency : Foundation.FormatStyle {
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.FloatingPointFormatStyle<Value>.Currency
  public typealias FormatInput = Value
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>> {
    get
  }
  public typealias Strategy = Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle.Currency : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>.Currency> {
    get
  }
  public typealias Strategy = Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>.Currency>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle.Percent : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>.Percent> {
    get
  }
  public typealias Strategy = Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>.Percent>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Double> {
  @_alwaysEmitIntoClient public static var number: Foundation.FloatingPointFormatStyle<Swift.Double> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Float> {
  @_alwaysEmitIntoClient public static var number: Foundation.FloatingPointFormatStyle<Swift.Float> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Double>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.FloatingPointFormatStyle<Swift.Double>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Float>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.FloatingPointFormatStyle<Swift.Float>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  @_alwaysEmitIntoClient public static func currency<Value>(code: Swift.String) -> Self where Self == Foundation.FloatingPointFormatStyle<Value>.Currency, Value : Swift.BinaryFloatingPoint {
        return Self(code: code)
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Float16> {
  @_alwaysEmitIntoClient public static var number: Foundation.FloatingPointFormatStyle<Swift.Float16> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Float16>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.FloatingPointFormatStyle<Swift.Float16>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle {
  public struct Attributed : Swift.Codable, Swift.Hashable, Foundation.FormatStyle, Swift.Sendable {
    public func format(_ value: Value) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.FloatingPointFormatStyle<Value>.Attributed
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.FloatingPointFormatStyle<Value>.Attributed, b: Foundation.FloatingPointFormatStyle<Value>.Attributed) -> Swift.Bool
    public typealias FormatInput = Value
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FloatingPointFormatStyle : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Value
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Value)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FloatingPointFormatStyle.Percent : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Value
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Value)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FloatingPointFormatStyle.Currency : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Value
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Value)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.FloatingPointFormatStyle<Swift.Double> {
  public static func localizedDouble(locale: Foundation.Locale) -> Self
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.FloatingPointFormatStyle<Swift.Double>.Percent {
  public static func localizedDoublePercentage(locale: Foundation.Locale) -> Self
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes {
  public var foundation: Foundation.AttributeScopes.FoundationAttributes.Type {
    get
  }
  public struct FoundationAttributes : Foundation.AttributeScope {
    public let link: Foundation.AttributeScopes.FoundationAttributes.LinkAttribute
    public let morphology: Foundation.AttributeScopes.FoundationAttributes.MorphologyAttribute
    public let inflect: Foundation.AttributeScopes.FoundationAttributes.InflectionRuleAttribute
    public let languageIdentifier: Foundation.AttributeScopes.FoundationAttributes.LanguageIdentifierAttribute
    public let personNameComponent: Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute
    public let numberFormat: Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes
    public let dateField: Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute
    public let inlinePresentationIntent: Foundation.AttributeScopes.FoundationAttributes.InlinePresentationIntentAttribute
    public let presentationIntent: Foundation.AttributeScopes.FoundationAttributes.PresentationIntentAttribute
    public let alternateDescription: Foundation.AttributeScopes.FoundationAttributes.AlternateDescriptionAttribute
    public let imageURL: Foundation.AttributeScopes.FoundationAttributes.ImageURLAttribute
    public let replacementIndex: Foundation.AttributeScopes.FoundationAttributes.ReplacementIndexAttribute
    public let measurement: Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute
    public let inflectionAlternative: Foundation.AttributeScopes.FoundationAttributes.InflectionAlternativeAttribute
    public let byteCount: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var durationField: Foundation.AttributeScopes.FoundationAttributes.DurationFieldAttribute {
      get
    }
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var markdownSourcePosition: Foundation.AttributeScopes.FoundationAttributes.MarkdownSourcePositionAttribute {
      get
    }
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var localizedStringArgumentAttributes: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes {
      get
    }
    public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
    public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeDynamicLookup {
  public subscript<T>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes.FoundationAttributes, T>) -> T where T : Foundation.AttributedStringKey {
    get
  }
  public subscript<T>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes, T>) -> T where T : Foundation.AttributedStringKey {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public subscript<T>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes, T>) -> T where T : Foundation.AttributedStringKey {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes {
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum LinkAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = Foundation.URL
    public typealias ObjectiveCValue = ObjectiveC.NSObject
    public static var name: Swift.String
    public static func objectiveCValue(for value: Foundation.URL) throws -> ObjectiveC.NSObject
    public static func value(for object: ObjectiveC.NSObject) throws -> Foundation.URL
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum MorphologyAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey {
    public typealias Value = Foundation.Morphology
    public static let name: Swift.String
    public static let markdownName: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum InflectionRuleAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey {
    public typealias Value = Foundation.InflectionRule
    public static let name: Swift.String
    public static let markdownName: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum LanguageIdentifierAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey {
    public typealias Value = Swift.String
    public static let name: Swift.String
    public static let markdownName: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum PersonNameComponentAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component
    public typealias ObjectiveCValue = Foundation.NSString
    public static let name: Swift.String
    public enum Component : Swift.String, Swift.Codable, Swift.Sendable {
      case givenName, familyName, middleName, namePrefix, nameSuffix, nickname, delimiter
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public struct NumberFormatAttributes : Foundation.AttributeScope {
    public let numberSymbol: Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute
    public let numberPart: Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute
    @frozen public enum NumberPartAttribute : Foundation.CodableAttributedStringKey {
      public enum NumberPart : Swift.Int, Swift.Codable, Swift.Sendable {
        case integer
        case fraction
        public init?(rawValue: Swift.Int)
        public typealias RawValue = Swift.Int
        public var rawValue: Swift.Int {
          get
        }
      }
      public static let name: Swift.String
      public typealias Value = Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart
    }
    @frozen public enum SymbolAttribute : Foundation.CodableAttributedStringKey {
      public enum Symbol : Swift.Int, Swift.Codable, Swift.Sendable {
        case groupingSeparator
        case sign
        case decimalSeparator
        case currency
        case percent
        public init?(rawValue: Swift.Int)
        public typealias RawValue = Swift.Int
        public var rawValue: Swift.Int {
          get
        }
      }
      public static let name: Swift.String
      public typealias Value = Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol
    }
    public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
    public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum DateFieldAttribute : Foundation.CodableAttributedStringKey {
    public enum Field : Swift.Hashable, Swift.Codable, Swift.Sendable {
      case era
      case year
      case relatedGregorianYear
      case quarter
      case month
      case weekOfYear
      case weekOfMonth
      case weekday
      case weekdayOrdinal
      case day
      case dayOfYear
      case amPM
      case hour
      case minute
      case second
      case secondFraction
      case timeZone
      public init(from decoder: any Swift.Decoder) throws
      public func encode(to encoder: any Swift.Encoder) throws
      public static func == (a: Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute.Field, b: Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute.Field) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static let name: Swift.String
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute.Field
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum InflectionAlternativeAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = Foundation.AttributedString
    public typealias ObjectiveCValue = ObjectiveC.NSObject
    public static let name: Swift.String
    public static let markdownName: Swift.String
    public static func decodeMarkdown(from decoder: any Swift.Decoder) throws -> Foundation.AttributedString
    public static func objectiveCValue(for value: Foundation.AttributedString) throws -> ObjectiveC.NSObject
    public static func value(for object: ObjectiveC.NSObject) throws -> Foundation.AttributedString
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum InlinePresentationIntentAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = Foundation.InlinePresentationIntent
    public typealias ObjectiveCValue = Foundation.NSNumber
    public static let name: Swift.String
    public static func objectiveCValue(for value: Foundation.InlinePresentationIntent) throws -> Foundation.NSNumber
    public static func value(for object: Foundation.NSNumber) throws -> Foundation.InlinePresentationIntent
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum PresentationIntentAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.PresentationIntent
    public static let name: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum AlternateDescriptionAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.String
    public static let name: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum ImageURLAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.URL
    public static let name: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum ReplacementIndexAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.Int
    public static let name: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public struct MeasurementAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute.Component
    public static let name: Swift.String
    public enum Component : Swift.Int, Swift.Codable, Swift.Sendable {
      case value
      case unit
      public init?(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum ByteCountAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Component
    public static let name: Swift.String
    public enum Component : Swift.Codable, Swift.Hashable, Swift.Sendable {
      case value
      case spelledOutValue
      case unit(Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit)
      case actualByteCount
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Component, b: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Component) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public enum Unit : Swift.Codable, Swift.Sendable {
      case byte
      case kb
      case mb
      case gb
      case tb
      case pb
      case eb
      case zb
      case yb
      public static func == (a: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit, b: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @frozen public enum MarkdownSourcePositionAttribute : Foundation.CodableAttributedStringKey {
    public static let name: Swift.String
    public typealias Value = Foundation.AttributedString.MarkdownSourcePosition
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  @frozen public enum DurationFieldAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.DurationFieldAttribute.Field
    public static let name: Swift.String
    public enum Field : Swift.Int, Swift.Codable, Swift.Sendable {
      case weeks
      case days
      case hours
      case minutes
      case seconds
      case microseconds
      case milliseconds
      case nanoseconds
      public init?(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct LocalizedStringArgumentAttributes {
    public let localizedNumericArgument: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedNumericArgumentAttribute
    public let localizedDateArgument: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateArgumentAttribute
    public let localizedDateIntervalArgument: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateIntervalArgumentAttribute
    public let localizedURLArgument: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedURLArgumentAttribute
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    @frozen public enum LocalizedNumericArgumentAttribute : Foundation.CodableAttributedStringKey {
      public static let name: Swift.String
      public enum Value : Swift.Hashable, Swift.Codable, Swift.Sendable {
        case uint(Swift.UInt64)
        case int(Swift.Int64)
        case double(Swift.Double)
        case decimal(Foundation.Decimal)
        public func hash(into hasher: inout Swift.Hasher)
        public static func == (a: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedNumericArgumentAttribute.Value, b: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedNumericArgumentAttribute.Value) -> Swift.Bool
        public func encode(to encoder: any Swift.Encoder) throws
        public var hashValue: Swift.Int {
          get
        }
        public init(from decoder: any Swift.Decoder) throws
      }
    }
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    @frozen public enum LocalizedDateArgumentAttribute : Foundation.CodableAttributedStringKey {
      public typealias Value = Foundation.Date
      public static let name: Swift.String
    }
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    @frozen public enum LocalizedDateIntervalArgumentAttribute : Foundation.CodableAttributedStringKey {
      public typealias Value = Swift.Range<Foundation.Date>
      public static let name: Swift.String
    }
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    @frozen public enum LocalizedURLArgumentAttribute : Foundation.CodableAttributedStringKey {
      public typealias Value = Foundation.URL
      public static let name: Swift.String
    }
  }
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LinkAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.MorphologyAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.InflectionRuleAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LanguageIdentifierAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.InlinePresentationIntentAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.PresentationIntentAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.AlternateDescriptionAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.ImageURLAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.ReplacementIndexAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.InflectionAlternativeAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 16)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.DurationFieldAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 16)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.MarkdownSourcePositionAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 16)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 16)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedNumericArgumentAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 16)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateArgumentAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 16)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateIntervalArgumentAttribute : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 16)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedURLArgumentAttribute : @unchecked Swift.Sendable {
}
extension Foundation.NSArray : Swift.ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension Swift.Array : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSArray
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSArray, result: inout Swift.Array<Element>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSArray, result: inout Swift.Array<Element>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSArray?) -> Swift.Array<Element>
  public typealias _ObjectiveCType = Foundation.NSArray
}
extension Foundation.NSArray : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.NSArray : Swift.Sequence {
  final public func makeIterator() -> Foundation.NSFastEnumerationIterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension Foundation.NSArray {
  convenience public init(objects elements: Any...)
}
extension Foundation.NSArray {
  @nonobjc convenience public init(array anArray: __shared Foundation.NSArray)
}
extension Foundation.NSArray : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Array : Swift.CVarArg {
}
public struct URLResourceValues {
  public init()
  public var allValues: [Foundation.URLResourceKey : Any] {
    get
  }
  public var name: Swift.String? {
    get
    set
  }
  public var localizedName: Swift.String? {
    get
  }
  public var isRegularFile: Swift.Bool? {
    get
  }
  public var isDirectory: Swift.Bool? {
    get
  }
  public var isSymbolicLink: Swift.Bool? {
    get
  }
  public var isVolume: Swift.Bool? {
    get
  }
  public var isPackage: Swift.Bool? {
    get
    set
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var isApplication: Swift.Bool? {
    get
  }
  public var isSystemImmutable: Swift.Bool? {
    get
  }
  public var isUserImmutable: Swift.Bool? {
    get
    set
  }
  public var isHidden: Swift.Bool? {
    get
    set
  }
  public var hasHiddenExtension: Swift.Bool? {
    get
    set
  }
  public var creationDate: Foundation.Date? {
    get
    set
  }
  public var contentAccessDate: Foundation.Date? {
    get
    set
  }
  public var contentModificationDate: Foundation.Date? {
    get
    set
  }
  public var attributeModificationDate: Foundation.Date? {
    get
  }
  public var linkCount: Swift.Int? {
    get
  }
  public var parentDirectory: Foundation.URL? {
    get
  }
  public var volume: Foundation.URL? {
    get
  }
  @available(macOS, introduced: 10.6, deprecated: 100000.0, message: "Use .contentType instead")
  @available(iOS, introduced: 4.0, deprecated: 100000.0, message: "Use .contentType instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use .contentType instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use .contentType instead")
  public var typeIdentifier: Swift.String? {
    get
  }
  public var localizedTypeDescription: Swift.String? {
    get
  }
  public var labelNumber: Swift.Int? {
    get
    set
  }
  public var localizedLabel: Swift.String? {
    get
  }
  public var fileResourceIdentifier: (any Foundation.NSCopying & Foundation.NSSecureCoding & ObjectiveC.NSObjectProtocol)? {
    get
  }
  public var volumeIdentifier: (any Foundation.NSCopying & Foundation.NSSecureCoding & ObjectiveC.NSObjectProtocol)? {
    get
  }
  @available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *)
  public var fileIdentifier: Swift.UInt64? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var fileContentIdentifier: Swift.Int64? {
    get
  }
  public var preferredIOBlockSize: Swift.Int? {
    get
  }
  public var isReadable: Swift.Bool? {
    get
  }
  public var isWritable: Swift.Bool? {
    get
  }
  public var isExecutable: Swift.Bool? {
    get
  }
  public var fileSecurity: Foundation.NSFileSecurity? {
    get
    set
  }
  public var isExcludedFromBackup: Swift.Bool? {
    get
    set
  }
  public var path: Swift.String? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var canonicalPath: Swift.String? {
    get
  }
  public var isMountTrigger: Swift.Bool? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var generationIdentifier: (any Foundation.NSCopying & Foundation.NSSecureCoding & ObjectiveC.NSObjectProtocol)? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var documentIdentifier: Swift.Int? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var addedToDirectoryDate: Foundation.Date? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var mayHaveExtendedAttributes: Swift.Bool? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var isPurgeable: Swift.Bool? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var isSparse: Swift.Bool? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var mayShareFileContent: Swift.Bool? {
    get
  }
  public var fileResourceType: Foundation.URLFileResourceType? {
    get
  }
  public var volumeLocalizedFormatDescription: Swift.String? {
    get
  }
  public var volumeTotalCapacity: Swift.Int? {
    get
  }
  public var volumeAvailableCapacity: Swift.Int? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var volumeAvailableCapacityForImportantUsage: Swift.Int64? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var volumeAvailableCapacityForOpportunisticUsage: Swift.Int64? {
    get
  }
  public var volumeResourceCount: Swift.Int? {
    get
  }
  public var volumeSupportsPersistentIDs: Swift.Bool? {
    get
  }
  public var volumeSupportsSymbolicLinks: Swift.Bool? {
    get
  }
  public var volumeSupportsHardLinks: Swift.Bool? {
    get
  }
  public var volumeSupportsJournaling: Swift.Bool? {
    get
  }
  public var volumeIsJournaling: Swift.Bool? {
    get
  }
  public var volumeSupportsSparseFiles: Swift.Bool? {
    get
  }
  public var volumeSupportsZeroRuns: Swift.Bool? {
    get
  }
  public var volumeSupportsCaseSensitiveNames: Swift.Bool? {
    get
  }
  public var volumeSupportsCasePreservedNames: Swift.Bool? {
    get
  }
  public var volumeSupportsRootDirectoryDates: Swift.Bool? {
    get
  }
  public var volumeSupportsVolumeSizes: Swift.Bool? {
    get
  }
  public var volumeSupportsRenaming: Swift.Bool? {
    get
  }
  public var volumeSupportsAdvisoryFileLocking: Swift.Bool? {
    get
  }
  public var volumeSupportsExtendedSecurity: Swift.Bool? {
    get
  }
  public var volumeIsBrowsable: Swift.Bool? {
    get
  }
  public var volumeMaximumFileSize: Swift.Int? {
    get
  }
  public var volumeIsEjectable: Swift.Bool? {
    get
  }
  public var volumeIsRemovable: Swift.Bool? {
    get
  }
  public var volumeIsInternal: Swift.Bool? {
    get
  }
  public var volumeIsAutomounted: Swift.Bool? {
    get
  }
  public var volumeIsLocal: Swift.Bool? {
    get
  }
  public var volumeIsReadOnly: Swift.Bool? {
    get
  }
  public var volumeCreationDate: Foundation.Date? {
    get
  }
  public var volumeURLForRemounting: Foundation.URL? {
    get
  }
  public var volumeUUIDString: Swift.String? {
    get
  }
  public var volumeName: Swift.String? {
    get
    set
  }
  public var volumeLocalizedName: Swift.String? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeIsEncrypted: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeIsRootFileSystem: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsCompression: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsFileCloning: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsSwapRenaming: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsExclusiveRenaming: Swift.Bool? {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var volumeSupportsImmutableFiles: Swift.Bool? {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var volumeSupportsAccessPermissions: Swift.Bool? {
    get
  }
  @available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *)
  public var volumeTypeName: Swift.String? {
    get
  }
  @available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *)
  public var volumeSubtype: Swift.Int? {
    get
  }
  @available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *)
  public var volumeMountFromLocation: Swift.String? {
    get
  }
  public var isUbiquitousItem: Swift.Bool? {
    get
  }
  public var ubiquitousItemHasUnresolvedConflicts: Swift.Bool? {
    get
  }
  public var ubiquitousItemIsDownloading: Swift.Bool? {
    get
  }
  public var ubiquitousItemIsUploaded: Swift.Bool? {
    get
  }
  public var ubiquitousItemIsUploading: Swift.Bool? {
    get
  }
  public var ubiquitousItemDownloadingStatus: Foundation.URLUbiquitousItemDownloadingStatus? {
    get
  }
  public var ubiquitousItemDownloadingError: Foundation.NSError? {
    get
  }
  public var ubiquitousItemUploadingError: Foundation.NSError? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var ubiquitousItemDownloadRequested: Swift.Bool? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var ubiquitousItemContainerDisplayName: Swift.String? {
    get
  }
  @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
  public var ubiquitousItemIsExcludedFromSync: Swift.Bool? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousItemIsShared: Swift.Bool? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemCurrentUserRole: Foundation.URLUbiquitousSharedItemRole? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemCurrentUserPermissions: Foundation.URLUbiquitousSharedItemPermissions? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemOwnerNameComponents: Foundation.PersonNameComponents? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemMostRecentEditorNameComponents: Foundation.PersonNameComponents? {
    get
  }
  @available(macOS 11.0, iOS 9.0, *)
  public var fileProtection: Foundation.URLFileProtection? {
    get
  }
  public var fileSize: Swift.Int? {
    get
  }
  public var fileAllocatedSize: Swift.Int? {
    get
  }
  public var totalFileSize: Swift.Int? {
    get
  }
  public var totalFileAllocatedSize: Swift.Int? {
    get
  }
  public var isAliasFile: Swift.Bool? {
    get
  }
}
public struct URL : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSURL
  public typealias BookmarkResolutionOptions = Foundation.NSURL.BookmarkResolutionOptions
  public typealias BookmarkCreationOptions = Foundation.NSURL.BookmarkCreationOptions
  public init?(string: __shared Swift.String)
  public init?(string: __shared Swift.String, relativeTo url: __shared Foundation.URL?)
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  public init(fileURLWithPath path: __shared Swift.String, isDirectory: Swift.Bool, relativeTo base: __shared Foundation.URL?)
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  public init(fileURLWithPath path: __shared Swift.String, relativeTo base: __shared Foundation.URL?)
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  public init(fileURLWithPath path: __shared Swift.String, isDirectory: Swift.Bool)
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  public init(fileURLWithPath path: __shared Swift.String)
  @available(macOS 10.11, iOS 9.0, *)
  public init?(dataRepresentation: __shared Foundation.Data, relativeTo url: __shared Foundation.URL?, isAbsolute: Swift.Bool = false)
  @available(swift, obsoleted: 4.2)
  public init?(resolvingBookmarkData data: __shared Foundation.Data, options: Foundation.URL.BookmarkResolutionOptions = [], relativeTo url: __shared Foundation.URL? = nil, bookmarkDataIsStale: inout Swift.Bool) throws
  @available(swift 4.2)
  public init(resolvingBookmarkData data: __shared Foundation.Data, options: Foundation.URL.BookmarkResolutionOptions = [], relativeTo url: __shared Foundation.URL? = nil, bookmarkDataIsStale: inout Swift.Bool) throws
  @available(macOS 10.10, iOS 8.0, *)
  public init(resolvingAliasFileAt url: __shared Foundation.URL, options: Foundation.URL.BookmarkResolutionOptions = []) throws
  public init(fileURLWithFileSystemRepresentation path: Swift.UnsafePointer<Swift.Int8>, isDirectory: Swift.Bool, relativeTo baseURL: __shared Foundation.URL?)
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.11, iOS 9.0, *)
  public var dataRepresentation: Foundation.Data {
    get
  }
  public var absoluteString: Swift.String {
    get
  }
  public var relativeString: Swift.String {
    get
  }
  public var baseURL: Foundation.URL? {
    get
  }
  public var absoluteURL: Foundation.URL {
    get
  }
  public var scheme: Swift.String? {
    get
  }
  public var isFileURL: Swift.Bool {
    get
  }
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
  public var host: Swift.String? {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func host(percentEncoded: Swift.Bool = true) -> Swift.String?
  public var port: Swift.Int? {
    get
  }
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
  public var user: Swift.String? {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func user(percentEncoded: Swift.Bool = true) -> Swift.String?
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
  public var password: Swift.String? {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func password(percentEncoded: Swift.Bool = true) -> Swift.String?
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
  public var path: Swift.String {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func path(percentEncoded: Swift.Bool = true) -> Swift.String
  public var relativePath: Swift.String {
    get
  }
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
  public var fragment: Swift.String? {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func fragment(percentEncoded: Swift.Bool = true) -> Swift.String?
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
  public var query: Swift.String? {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func query(percentEncoded: Swift.Bool = true) -> Swift.String?
  @available(macOS 10.11, iOS 9.0, *)
  public var hasDirectoryPath: Swift.Bool {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public func withUnsafeFileSystemRepresentation<ResultType>(_ block: (Swift.UnsafePointer<Swift.Int8>?) throws -> ResultType) rethrows -> ResultType
  public var pathComponents: [Swift.String] {
    get
  }
  public var lastPathComponent: Swift.String {
    get
  }
  public var pathExtension: Swift.String {
    get
  }
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  public func appendingPathComponent(_ pathComponent: Swift.String, isDirectory: Swift.Bool) -> Foundation.URL
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  public func appendingPathComponent(_ pathComponent: Swift.String) -> Foundation.URL
  public func deletingLastPathComponent() -> Foundation.URL
  public func appendingPathExtension(_ pathExtension: Swift.String) -> Foundation.URL
  public func deletingPathExtension() -> Foundation.URL
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  public mutating func appendPathComponent(_ pathComponent: Swift.String, isDirectory: Swift.Bool)
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  public mutating func appendPathComponent(_ pathComponent: Swift.String)
  public mutating func appendPathExtension(_ pathExtension: Swift.String)
  public mutating func deleteLastPathComponent()
  public mutating func deletePathExtension()
  public var standardized: Foundation.URL {
    get
  }
  public mutating func standardize()
  public var standardizedFileURL: Foundation.URL {
    get
  }
  public func resolvingSymlinksInPath() -> Foundation.URL
  public mutating func resolveSymlinksInPath()
  public func checkResourceIsReachable() throws -> Swift.Bool
  @available(macOS 10.10, iOS 8.0, *)
  public func checkPromisedItemIsReachable() throws -> Swift.Bool
  public mutating func setResourceValues(_ values: Foundation.URLResourceValues) throws
  public func resourceValues(forKeys keys: Swift.Set<Foundation.URLResourceKey>) throws -> Foundation.URLResourceValues
  public mutating func setTemporaryResourceValue(_ value: Any, forKey key: Foundation.URLResourceKey)
  public mutating func removeAllCachedResourceValues()
  public mutating func removeCachedResourceValue(forKey key: Foundation.URLResourceKey)
  @available(macOS 10.10, iOS 8.0, *)
  public func promisedItemResourceValues(forKeys keys: Swift.Set<Foundation.URLResourceKey>) throws -> Foundation.URLResourceValues
  public func bookmarkData(options: Foundation.URL.BookmarkCreationOptions = [], includingResourceValuesForKeys keys: Swift.Set<Foundation.URLResourceKey>? = nil, relativeTo url: Foundation.URL? = nil) throws -> Foundation.Data
  public static func resourceValues(forKeys keys: Swift.Set<Foundation.URLResourceKey>, fromBookmarkData data: Foundation.Data) -> Foundation.URLResourceValues?
  public static func writeBookmarkData(_ data: Foundation.Data, to url: Foundation.URL) throws
  public static func bookmarkData(withContentsOf url: Foundation.URL) throws -> Foundation.Data
  @available(macOS 10.7, iOS 8.0, *)
  public func startAccessingSecurityScopedResource() -> Swift.Bool
  @available(macOS 10.7, iOS 8.0, *)
  public func stopAccessingSecurityScopedResource()
  public static func == (lhs: Foundation.URL, rhs: Foundation.URL) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.URL {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public init(filePath path: Swift.String, directoryHint: Foundation.URL.DirectoryHint = .inferFromPath, relativeTo base: Foundation.URL? = nil)
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func appending<S>(path: S, directoryHint: Foundation.URL.DirectoryHint = .inferFromPath) -> Foundation.URL where S : Swift.StringProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public mutating func append<S>(path: S, directoryHint: Foundation.URL.DirectoryHint = .inferFromPath) where S : Swift.StringProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func appending<S>(component: S, directoryHint: Foundation.URL.DirectoryHint = .inferFromPath) -> Foundation.URL where S : Swift.StringProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public mutating func append<S>(component: S, directoryHint: Foundation.URL.DirectoryHint = .inferFromPath) where S : Swift.StringProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func appending(queryItems: [Foundation.URLQueryItem]) -> Foundation.URL
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public mutating func append(queryItems: [Foundation.URLQueryItem])
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func appending<S>(components: S..., directoryHint: Foundation.URL.DirectoryHint = .inferFromPath) -> Foundation.URL where S : Swift.StringProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public mutating func append<S>(components: S..., directoryHint: Foundation.URL.DirectoryHint = .inferFromPath) where S : Swift.StringProtocol
}
extension Foundation.URL {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func currentDirectory() -> Foundation.URL
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var homeDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var temporaryDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var cachesDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var applicationDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var libraryDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var userDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var documentsDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var desktopDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var applicationSupportDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var downloadsDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var moviesDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var musicDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var picturesDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var sharedPublicDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public static var trashDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func homeDirectory(forUser user: Swift.String) -> Foundation.URL?
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public init(for directory: Foundation.FileManager.SearchPathDirectory, in domain: Foundation.FileManager.SearchPathDomainMask, appropriateFor url: Foundation.URL? = nil, create shouldCreate: Swift.Bool = false) throws
}
extension Foundation.URL {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public enum DirectoryHint : Swift.Sendable {
    case isDirectory
    case notDirectory
    case checkFileSystem
    case inferFromPath
    public static func == (a: Foundation.URL.DirectoryHint, b: Foundation.URL.DirectoryHint) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Foundation.URL : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURL
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSURL, result: inout Foundation.URL?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSURL, result: inout Foundation.URL?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURL?) -> Foundation.URL
  public typealias _ObjectiveCType = Foundation.NSURL
}
extension Foundation.URL : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation.NSURL : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.URL : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "URL.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension Foundation.URL : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Foundation.URL : Swift._ExpressibleByFileReferenceLiteral {
  public init(fileReferenceLiteralResourceName name: Swift.String)
}
public typealias _FileReferenceLiteralType = Foundation.URL
@available(iOS, unavailable, introduced: 7)
@available(*, unavailable)
extension Foundation.URLResourceValues : @unchecked Swift.Sendable {
}
extension Foundation.NSSet : Swift.Sequence {
  public func makeIterator() -> Foundation.NSFastEnumerationIterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension Foundation.NSOrderedSet : Swift.Sequence {
  public func makeIterator() -> Foundation.NSFastEnumerationIterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension Swift.Set : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSSet
  public static func _forceBridgeFromObjectiveC(_ s: Foundation.NSSet, result: inout Swift.Set<Element>?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSSet, result: inout Swift.Set<Element>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: Foundation.NSSet?) -> Swift.Set<Element>
  public typealias _ObjectiveCType = Foundation.NSSet
}
extension Foundation.NSSet : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.NSOrderedSet {
  convenience public init(objects elements: Any...)
}
extension Foundation.NSSet {
  convenience public init(objects elements: Any...)
}
extension Foundation.NSSet : Swift.ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension Foundation.NSOrderedSet : Swift.ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension Foundation.NSSet {
  @nonobjc convenience public init(set anSet: __shared Foundation.NSSet)
}
extension Foundation.NSSet : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Set : Swift.CVarArg {
}
extension Foundation.NSData : Foundation.DataProtocol {
  @nonobjc public var startIndex: Swift.Int {
    get
  }
  @nonobjc public var endIndex: Swift.Int {
    get
  }
  @nonobjc public func lastRange<D, R>(of data: D, in r: R) -> Swift.Range<Swift.Int>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, R.Bound == Swift.Int
  @nonobjc public func firstRange<D, R>(of data: D, in r: R) -> Swift.Range<Swift.Int>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, R.Bound == Swift.Int
  @nonobjc public var regions: [Foundation.Data] {
    get
  }
  @nonobjc public subscript(position: Swift.Int) -> Swift.UInt8 {
    get
  }
  public typealias Element = Swift.UInt8
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = Swift.IndexingIterator<Foundation.NSData>
  public typealias Regions = [Foundation.Data]
  public typealias SubSequence = Swift.Slice<Foundation.NSData>
}
@available(macOS 10.11, iOS 9.0, *)
public struct PersonNameComponents : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSPersonNameComponents
  public init()
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public init(namePrefix: Swift.String? = nil, givenName: Swift.String? = nil, middleName: Swift.String? = nil, familyName: Swift.String? = nil, nameSuffix: Swift.String? = nil, nickname: Swift.String? = nil, phoneticRepresentation: Foundation.PersonNameComponents? = nil)
  public var namePrefix: Swift.String? {
    get
    set
  }
  public var givenName: Swift.String? {
    get
    set
  }
  public var middleName: Swift.String? {
    get
    set
  }
  public var familyName: Swift.String? {
    get
    set
  }
  public var nameSuffix: Swift.String? {
    get
    set
  }
  public var nickname: Swift.String? {
    get
    set
  }
  public var phoneticRepresentation: Foundation.PersonNameComponents? {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.11, iOS 9.0, *)
  public static func == (lhs: Foundation.PersonNameComponents, rhs: Foundation.PersonNameComponents) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.11, iOS 9.0, *)
extension Foundation.PersonNameComponents : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.11, iOS 9.0, *)
extension Foundation.PersonNameComponents : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSPersonNameComponents
  public static func _forceBridgeFromObjectiveC(_ personNameComponents: Foundation.NSPersonNameComponents, result: inout Foundation.PersonNameComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ personNameComponents: Foundation.NSPersonNameComponents, result: inout Foundation.PersonNameComponents?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSPersonNameComponents?) -> Foundation.PersonNameComponents
  public typealias _ObjectiveCType = Foundation.NSPersonNameComponents
}
@available(macOS 10.11, iOS 9.0, *)
extension Foundation.NSPersonNameComponents : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.11, iOS 9.0, *)
extension Foundation.PersonNameComponents : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Measurement where UnitType : Foundation.Dimension {
  public struct AttributedStyle : Foundation.FormatStyle, Swift.Sendable {
    public func format(_ measurement: Foundation.Measurement<UnitType>) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.Measurement<UnitType>.AttributedStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Measurement<UnitType>.AttributedStyle, b: Foundation.Measurement<UnitType>.AttributedStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.Measurement<UnitType>
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Measurement.AttributedStyle where UnitType == Foundation.UnitInformationStorage {
  public struct ByteCount : Foundation.FormatStyle, Swift.Sendable {
    public typealias Style = Foundation.ByteCountFormatStyle.Style
    public typealias Units = Foundation.ByteCountFormatStyle.Units
    public var style: Foundation.Measurement<Foundation.UnitInformationStorage>.AttributedStyle.ByteCount.Style {
      get
      set
    }
    public var allowedUnits: Foundation.Measurement<Foundation.UnitInformationStorage>.AttributedStyle.ByteCount.Units {
      get
      set
    }
    public var spellsOutZero: Swift.Bool {
      get
      set
    }
    public var includesActualByteCount: Swift.Bool {
      get
      set
    }
    public var locale: Foundation.Locale {
      get
      set
    }
    public init(style: Foundation.Measurement<UnitType>.AttributedStyle.ByteCount.Style, allowedUnits: Foundation.Measurement<UnitType>.AttributedStyle.ByteCount.Units, spellsOutZero: Swift.Bool, includesActualByteCount: Swift.Bool, locale: Foundation.Locale)
    public func format(_ value: Foundation.Measurement<Foundation.UnitInformationStorage>) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.Measurement<UnitType>.AttributedStyle.ByteCount
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Measurement<UnitType>.AttributedStyle.ByteCount, b: Foundation.Measurement<UnitType>.AttributedStyle.ByteCount) -> Swift.Bool
    public typealias FormatInput = Foundation.Measurement<Foundation.UnitInformationStorage>
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public struct Morphology : Swift.Sendable {
  public init()
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum GrammaticalGender : Swift.Int, Swift.Hashable, Swift.Sendable {
    case feminine
    case masculine
    case neuter
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var grammaticalGender: Foundation.Morphology.GrammaticalGender?
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum PartOfSpeech : Swift.Int, Swift.Hashable, Swift.Sendable {
    case determiner
    case pronoun
    case letter
    case adverb
    case particle
    case adjective
    case adposition
    case verb
    case noun
    case conjunction
    case numeral
    case interjection
    case preposition
    case abbreviation
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var partOfSpeech: Foundation.Morphology.PartOfSpeech?
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum GrammaticalNumber : Swift.Int, Swift.Hashable, Swift.Sendable {
    case singular
    case zero
    case plural
    case pluralTwo
    case pluralFew
    case pluralMany
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var number: Foundation.Morphology.GrammaticalNumber?
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public enum InflectionRule : Swift.Sendable {
  case automatic
  case explicit(Foundation.Morphology)
  public init(morphology: Foundation.Morphology)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.Morphology, b: Foundation.Morphology) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.CustomPronoun : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.Morphology.CustomPronoun, b: Foundation.Morphology.CustomPronoun) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InflectionRule : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.InflectionRule, b: Foundation.InflectionRule) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.CustomPronoun : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.GrammaticalGender : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.GrammaticalNumber : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.PartOfSpeech : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InflectionRule : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InflectionRule {
  public static func canInflect(language: Swift.String) -> Swift.Bool
  public static var canInflectPreferredLocalization: Swift.Bool {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology {
  public func customPronoun(forLanguage language: Swift.String) -> Foundation.Morphology.CustomPronoun?
  public mutating func setCustomPronoun(_ pronoun: Foundation.Morphology.CustomPronoun?, forLanguage language: Swift.String) throws
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public struct CustomPronoun : Swift.Sendable {
    public init()
    public static func isSupported(forLanguage language: Swift.String) -> Swift.Bool
    public static func requiredKeys(forLanguage language: Swift.String) -> [Swift.PartialKeyPath<Foundation.Morphology.CustomPronoun>]
    public var subjectForm: Swift.String?
    public var objectForm: Swift.String?
    public var possessiveForm: Swift.String?
    public var possessiveAdjectiveForm: Swift.String?
    public var reflexiveForm: Swift.String?
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology {
  public var isUnspecified: Swift.Bool {
    get
  }
  public static let user: Foundation.Morphology
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.CustomPronoun : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.__NSMorphologyCustomPronoun
  public static func _forceBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphologyCustomPronoun, result: inout Foundation.Morphology.CustomPronoun?)
  public static func _conditionallyBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphologyCustomPronoun, result: inout Foundation.Morphology.CustomPronoun?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphologyCustomPronoun?) -> Foundation.Morphology.CustomPronoun
  public typealias _ObjectiveCType = Foundation.__NSMorphologyCustomPronoun
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InflectionRule : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.__NSInflectionRule
  public static func _forceBridgeFromObjectiveC(_ rule: Foundation.__NSInflectionRule, result: inout Foundation.InflectionRule?)
  public static func _conditionallyBridgeFromObjectiveC(_ rule: Foundation.__NSInflectionRule, result: inout Foundation.InflectionRule?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ rule: Foundation.__NSInflectionRule?) -> Foundation.InflectionRule
  public typealias _ObjectiveCType = Foundation.__NSInflectionRule
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.__NSMorphology
  public static func _forceBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphology, result: inout Foundation.Morphology?)
  public static func _conditionallyBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphology, result: inout Foundation.Morphology?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphology?) -> Foundation.Morphology
  public typealias _ObjectiveCType = Foundation.__NSMorphology
}
extension Foundation.Decimal {
  public typealias RoundingMode = Foundation.NSDecimalNumber.RoundingMode
  public typealias CalculationError = Foundation.NSDecimalNumber.CalculationError
}
public func pow(_ x: Foundation.Decimal, _ y: Swift.Int) -> Foundation.Decimal
extension Foundation.Decimal : Swift.Hashable, Swift.Comparable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Swift.Bool
  public static func < (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Decimal : Swift.CustomStringConvertible {
  public init?(string: __shared Swift.String, locale: __shared Foundation.Locale? = nil)
  public var description: Swift.String {
    get
  }
}
extension Foundation.Decimal : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Foundation.Decimal : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.Double)
  public typealias FloatLiteralType = Swift.Double
}
extension Foundation.Decimal : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension Foundation.Decimal : Swift.SignedNumeric {
  public var magnitude: Foundation.Decimal {
    get
  }
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public static func += (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func -= (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func *= (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func /= (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func + (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public static func - (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public static func * (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public static func / (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public mutating func negate()
  public typealias Magnitude = Foundation.Decimal
}
extension Foundation.Decimal {
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func add(_ other: Foundation.Decimal) {
        self += other
    }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func subtract(_ other: Foundation.Decimal) {
        self -= other
    }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func multiply(by other: Foundation.Decimal) {
        self *= other
    }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func divide(by other: Foundation.Decimal) {
        self /= other
    }
}
extension Foundation.Decimal : Swift.Strideable {
  public func distance(to other: Foundation.Decimal) -> Foundation.Decimal
  public func advanced(by n: Foundation.Decimal) -> Foundation.Decimal
  public typealias Stride = Foundation.Decimal
}
extension Foundation.Decimal {
  public static let leastFiniteMagnitude: Foundation.Decimal
  public static let greatestFiniteMagnitude: Foundation.Decimal
  public static let leastNormalMagnitude: Foundation.Decimal
  public static let leastNonzeroMagnitude: Foundation.Decimal
  public static let pi: Foundation.Decimal
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public static var infinity: Foundation.Decimal {
    get
  }
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public static var signalingNaN: Foundation.Decimal {
    get
  }
  public static var quietNaN: Foundation.Decimal {
    get
  }
  public static var nan: Foundation.Decimal {
    get
  }
  public static var radix: Swift.Int {
    get
  }
  public init(_ value: Swift.UInt8)
  public init(_ value: Swift.Int8)
  public init(_ value: Swift.UInt16)
  public init(_ value: Swift.Int16)
  public init(_ value: Swift.UInt32)
  public init(_ value: Swift.Int32)
  public init(_ value: Swift.UInt64)
  public init(_ value: Swift.Int64)
  public init(_ value: Swift.UInt)
  public init(_ value: Swift.Int)
  public init(_ value: Swift.Double)
  public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: Foundation.Decimal)
  public init(signOf: Foundation.Decimal, magnitudeOf magnitude: Foundation.Decimal)
  public var exponent: Swift.Int {
    get
  }
  public var significand: Foundation.Decimal {
    get
  }
  public var sign: Swift.FloatingPointSign {
    get
  }
  public var ulp: Foundation.Decimal {
    get
  }
  public var nextUp: Foundation.Decimal {
    get
  }
  public var nextDown: Foundation.Decimal {
    get
  }
  public var floatingPointClass: Swift.FloatingPointClassification {
    get
  }
  public var isCanonical: Swift.Bool {
    get
  }
  public var isSignMinus: Swift.Bool {
    get
  }
  public var isZero: Swift.Bool {
    get
  }
  public var isSubnormal: Swift.Bool {
    get
  }
  public var isNormal: Swift.Bool {
    get
  }
  public var isFinite: Swift.Bool {
    get
  }
  public var isInfinite: Swift.Bool {
    get
  }
  public var isNaN: Swift.Bool {
    get
  }
  public var isSignaling: Swift.Bool {
    get
  }
  public var isSignalingNaN: Swift.Bool {
    get
  }
  public func isEqual(to other: Foundation.Decimal) -> Swift.Bool
  public func isLess(than other: Foundation.Decimal) -> Swift.Bool
  public func isLessThanOrEqualTo(_ other: Foundation.Decimal) -> Swift.Bool
  public func isTotallyOrdered(belowOrEqualTo other: Foundation.Decimal) -> Swift.Bool
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public mutating func formTruncatingRemainder(dividingBy other: Foundation.Decimal)
}
extension Foundation.Decimal : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDecimalNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSDecimalNumber, result: inout Foundation.Decimal?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSDecimalNumber, result: inout Foundation.Decimal?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDecimalNumber?) -> Foundation.Decimal
  public typealias _ObjectiveCType = Foundation.NSDecimalNumber
}
extension Foundation.NSPredicate {
  convenience public init(format predicateFormat: __shared Swift.String, _ args: any Swift.CVarArg...)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle {
  public struct Symbol : Swift.Hashable, Swift.Sendable {
    public struct Era : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Era, b: Foundation.Date.FormatStyle.Symbol.Era) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Year : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Year, b: Foundation.Date.FormatStyle.Symbol.Year) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct YearForWeekOfYear : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear, b: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct CyclicYear : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.CyclicYear, b: Foundation.Date.FormatStyle.Symbol.CyclicYear) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Quarter : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Quarter, b: Foundation.Date.FormatStyle.Symbol.Quarter) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Month : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Month, b: Foundation.Date.FormatStyle.Symbol.Month) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Week : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Week, b: Foundation.Date.FormatStyle.Symbol.Week) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Day : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Day, b: Foundation.Date.FormatStyle.Symbol.Day) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct DayOfYear : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.DayOfYear, b: Foundation.Date.FormatStyle.Symbol.DayOfYear) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Weekday : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Weekday, b: Foundation.Date.FormatStyle.Symbol.Weekday) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct DayPeriod : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.DayPeriod, b: Foundation.Date.FormatStyle.Symbol.DayPeriod) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Hour : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Hour, b: Foundation.Date.FormatStyle.Symbol.Hour) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Minute : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Minute, b: Foundation.Date.FormatStyle.Symbol.Minute) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Second : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Second, b: Foundation.Date.FormatStyle.Symbol.Second) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct SecondFraction : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.SecondFraction, b: Foundation.Date.FormatStyle.Symbol.SecondFraction) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct TimeZone : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.TimeZone, b: Foundation.Date.FormatStyle.Symbol.TimeZone) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct StandaloneQuarter : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter, b: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct StandaloneMonth : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.StandaloneMonth, b: Foundation.Date.FormatStyle.Symbol.StandaloneMonth) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct StandaloneWeekday : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday, b: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct VerbatimHour : Swift.Hashable, Swift.Sendable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.VerbatimHour, b: Foundation.Date.FormatStyle.Symbol.VerbatimHour) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatStyle.Symbol, b: Foundation.Date.FormatStyle.Symbol) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Era {
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.Era {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.Era {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.Era {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Year {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Year {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Year {
    get
  }
  public static func padded(_ length: Swift.Int) -> Foundation.Date.FormatStyle.Symbol.Year
  public static func relatedGregorian(minimumLength: Swift.Int = 1) -> Foundation.Date.FormatStyle.Symbol.Year
  public static func extended(minimumLength: Swift.Int = 1) -> Foundation.Date.FormatStyle.Symbol.Year
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear {
    get
  }
  public static func padded(_ length: Swift.Int) -> Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.CyclicYear {
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.CyclicYear {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.CyclicYear {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.CyclicYear {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Quarter {
  public static var oneDigit: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
  public static var oneDigit: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Month {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Week {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Week {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Week {
    get
  }
  public static var weekOfMonth: Foundation.Date.FormatStyle.Symbol.Week {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Day {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Day {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Day {
    get
  }
  public static var ordinalOfDayInMonth: Foundation.Date.FormatStyle.Symbol.Day {
    get
  }
  public static func julianModified(minimumLength: Swift.Int = 1) -> Foundation.Date.FormatStyle.Symbol.Day
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.DayOfYear {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.DayOfYear {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.DayOfYear {
    get
  }
  public static var threeDigits: Foundation.Date.FormatStyle.Symbol.DayOfYear {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Weekday {
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var short: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var oneDigit: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
  public static var oneDigit: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
  public static var short: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.DayPeriod {
  public enum Width : Swift.Sendable {
    case abbreviated
    case wide
    case narrow
    public static func == (a: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width, b: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func standard(_ width: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width) -> Foundation.Date.FormatStyle.Symbol.DayPeriod
  public static func with12s(_ width: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width) -> Foundation.Date.FormatStyle.Symbol.DayPeriod
  public static func conversational(_ width: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width) -> Foundation.Date.FormatStyle.Symbol.DayPeriod
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Hour {
  public struct AMPMStyle : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static let omitted: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle
    public static let narrow: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle
    public static let abbreviated: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle
    public static let wide: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle, b: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public static func defaultDigits(amPM: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Foundation.Date.FormatStyle.Symbol.Hour
  public static func twoDigits(amPM: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Foundation.Date.FormatStyle.Symbol.Hour
  public static func conversationalDefaultDigits(amPM: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Foundation.Date.FormatStyle.Symbol.Hour
  public static func conversationalTwoDigits(amPM: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Foundation.Date.FormatStyle.Symbol.Hour
  @available(*, deprecated, renamed: "defaultDigits(amPM:)")
  public static var defaultDigitsNoAMPM: Foundation.Date.FormatStyle.Symbol.Hour {
    get
  }
  @available(*, deprecated, renamed: "twoDigits(amPM:)")
  public static var twoDigitsNoAMPM: Foundation.Date.FormatStyle.Symbol.Hour {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.VerbatimHour {
  public struct HourCycle : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static let zeroBased: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle
    public static let oneBased: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle, b: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Clock : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static let twelveHour: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock
    public static let twentyFourHour: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock, b: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public static func defaultDigits(clock: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock, hourCycle: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Foundation.Date.FormatStyle.Symbol.VerbatimHour
  public static func twoDigits(clock: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock, hourCycle: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Foundation.Date.FormatStyle.Symbol.VerbatimHour
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Minute {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Minute {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Minute {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Second {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Second {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Second {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.SecondFraction {
  public static func fractional(_ val: Swift.Int) -> Foundation.Date.FormatStyle.Symbol.SecondFraction
  public static func milliseconds(_ val: Swift.Int) -> Foundation.Date.FormatStyle.Symbol.SecondFraction
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.TimeZone {
  public enum Width : Swift.Sendable {
    case short
    case long
    public static func == (a: Foundation.Date.FormatStyle.Symbol.TimeZone.Width, b: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func specificName(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static func genericName(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static func iso8601(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static func localizedGMT(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static func identifier(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static var exemplarLocation: Foundation.Date.FormatStyle.Symbol.TimeZone {
    get
  }
  public static var genericLocation: Foundation.Date.FormatStyle.Symbol.TimeZone {
    get
  }
}
extension Foundation.IndexSet.Index {
  public static func == (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func < (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func <= (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func > (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func >= (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
}
extension Foundation.IndexSet.RangeView {
  public static func == (lhs: Foundation.IndexSet.RangeView, rhs: Foundation.IndexSet.RangeView) -> Swift.Bool
}
public struct IndexSet : Foundation.ReferenceConvertible, Swift.Equatable, Swift.BidirectionalCollection, Swift.SetAlgebra {
  public struct RangeView : Swift.Equatable, Swift.BidirectionalCollection {
    public typealias Index = Swift.Int
    public let startIndex: Foundation.IndexSet.RangeView.Index
    public let endIndex: Foundation.IndexSet.RangeView.Index
    public func makeIterator() -> Swift.IndexingIterator<Foundation.IndexSet.RangeView>
    public subscript(index: Foundation.IndexSet.RangeView.Index) -> Swift.Range<Foundation.IndexSet.Element> {
      get
    }
    public subscript(bounds: Swift.Range<Foundation.IndexSet.RangeView.Index>) -> Swift.Slice<Foundation.IndexSet.RangeView> {
      get
    }
    public func index(after i: Foundation.IndexSet.RangeView.Index) -> Foundation.IndexSet.RangeView.Index
    public func index(before i: Foundation.IndexSet.RangeView.Index) -> Foundation.IndexSet.RangeView.Index
    public typealias Element = Swift.Range<Foundation.IndexSet.Element>
    public typealias Indices = Swift.DefaultIndices<Foundation.IndexSet.RangeView>
    public typealias Iterator = Swift.IndexingIterator<Foundation.IndexSet.RangeView>
    public typealias SubSequence = Swift.Slice<Foundation.IndexSet.RangeView>
  }
  public struct Index : Swift.CustomStringConvertible, Swift.Comparable, Swift.Sendable {
    public var description: Swift.String {
      get
    }
  }
  public typealias ReferenceType = Foundation.NSIndexSet
  public typealias Element = Swift.Int
  public init(integersIn range: Swift.Range<Foundation.IndexSet.Element>)
  public init<R>(integersIn range: R) where R : Swift.RangeExpression, R.Bound == Swift.Int
  public init(integer: Foundation.IndexSet.Element)
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public var count: Swift.Int {
    get
  }
  public func makeIterator() -> Swift.IndexingIterator<Foundation.IndexSet>
  public var rangeView: Foundation.IndexSet.RangeView {
    get
  }
  public func rangeView(of range: Swift.Range<Foundation.IndexSet.Element>) -> Foundation.IndexSet.RangeView
  public func rangeView<R>(of range: R) -> Foundation.IndexSet.RangeView where R : Swift.RangeExpression, R.Bound == Swift.Int
  public var startIndex: Foundation.IndexSet.Index {
    get
  }
  public var endIndex: Foundation.IndexSet.Index {
    get
  }
  public subscript(index: Foundation.IndexSet.Index) -> Foundation.IndexSet.Element {
    get
  }
  public subscript(bounds: Swift.Range<Foundation.IndexSet.Index>) -> Swift.Slice<Foundation.IndexSet> {
    get
  }
  public var first: Foundation.IndexSet.Element? {
    get
  }
  public var last: Foundation.IndexSet.Element? {
    get
  }
  public func integerGreaterThan(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func integerLessThan(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func integerGreaterThanOrEqualTo(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func integerLessThanOrEqualTo(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func indexRange(in range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Range<Foundation.IndexSet.Index>
  public func indexRange<R>(in range: R) -> Swift.Range<Foundation.IndexSet.Index> where R : Swift.RangeExpression, R.Bound == Swift.Int
  public func count(in range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Int
  public func count<R>(in range: R) -> Swift.Int where R : Swift.RangeExpression, R.Bound == Swift.Int
  public func contains(_ integer: Foundation.IndexSet.Element) -> Swift.Bool
  public func contains(integersIn range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Bool
  public func contains<R>(integersIn range: R) -> Swift.Bool where R : Swift.RangeExpression, R.Bound == Swift.Int
  public func contains(integersIn indexSet: Foundation.IndexSet) -> Swift.Bool
  public func intersects(integersIn range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Bool
  public func intersects<R>(integersIn range: R) -> Swift.Bool where R : Swift.RangeExpression, R.Bound == Swift.Int
  public func index(after i: Foundation.IndexSet.Index) -> Foundation.IndexSet.Index
  public func formIndex(after i: inout Foundation.IndexSet.Index)
  public func index(before i: Foundation.IndexSet.Index) -> Foundation.IndexSet.Index
  public func formIndex(before i: inout Foundation.IndexSet.Index)
  public mutating func formUnion(_ other: Foundation.IndexSet)
  public func union(_ other: Foundation.IndexSet) -> Foundation.IndexSet
  public func symmetricDifference(_ other: Foundation.IndexSet) -> Foundation.IndexSet
  public mutating func formSymmetricDifference(_ other: Foundation.IndexSet)
  public func intersection(_ other: Foundation.IndexSet) -> Foundation.IndexSet
  public mutating func formIntersection(_ other: Foundation.IndexSet)
  @discardableResult
  public mutating func insert(_ integer: Foundation.IndexSet.Element) -> (inserted: Swift.Bool, memberAfterInsert: Foundation.IndexSet.Element)
  @discardableResult
  public mutating func update(with integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  @discardableResult
  public mutating func remove(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public mutating func removeAll()
  public mutating func insert(integersIn range: Swift.Range<Foundation.IndexSet.Element>)
  public mutating func insert<R>(integersIn range: R) where R : Swift.RangeExpression, R.Bound == Swift.Int
  public mutating func remove(integersIn range: Swift.Range<Foundation.IndexSet.Element>)
  public mutating func remove(integersIn range: Swift.ClosedRange<Foundation.IndexSet.Element>)
  public var isEmpty: Swift.Bool {
    get
  }
  public func filteredIndexSet(in range: Swift.Range<Foundation.IndexSet.Element>, includeInteger: (Foundation.IndexSet.Element) throws -> Swift.Bool) rethrows -> Foundation.IndexSet
  public func filteredIndexSet(in range: Swift.ClosedRange<Foundation.IndexSet.Element>, includeInteger: (Foundation.IndexSet.Element) throws -> Swift.Bool) rethrows -> Foundation.IndexSet
  public func filteredIndexSet(includeInteger: (Foundation.IndexSet.Element) throws -> Swift.Bool) rethrows -> Foundation.IndexSet
  public mutating func shift(startingAt integer: Foundation.IndexSet.Element, by delta: Swift.Int)
  public typealias ArrayLiteralElement = Foundation.IndexSet.Element
  public typealias Indices = Swift.DefaultIndices<Foundation.IndexSet>
  public typealias Iterator = Swift.IndexingIterator<Foundation.IndexSet>
  public typealias SubSequence = Swift.Slice<Foundation.IndexSet>
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.IndexSet : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.IndexSet {
  public static func == (lhs: Foundation.IndexSet, rhs: Foundation.IndexSet) -> Swift.Bool
}
extension Foundation.IndexSet : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSIndexSet
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSIndexSet, result: inout Foundation.IndexSet?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSIndexSet, result: inout Foundation.IndexSet?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSIndexSet?) -> Foundation.IndexSet
  public typealias _ObjectiveCType = Foundation.NSIndexSet
}
extension Foundation.NSIndexSet : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.IndexSet : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.IndexSet : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.IndexSet.RangeView : Swift.Sendable {
}
extension Swift.String {
  public init(_ cocoaString: Foundation.NSString)
}
extension Swift.String : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSString
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.String?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.String?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSString?) -> Swift.String
  public typealias _ObjectiveCType = Foundation.NSString
}
extension Swift.Substring : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSString
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.Substring?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.Substring?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSString?) -> Swift.Substring
  public typealias _ObjectiveCType = Foundation.NSString
}
extension Swift.String : Swift.CVarArg {
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Swift.CollectionDifference.Change : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSOrderedCollectionChange
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSOrderedCollectionChange, result: inout Swift.CollectionDifference<ChangeElement>.Change?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSOrderedCollectionChange, result: inout Swift.CollectionDifference<ChangeElement>.Change?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: Foundation.NSOrderedCollectionChange?) -> Swift.CollectionDifference<ChangeElement>.Change
  public typealias _ObjectiveCType = Foundation.NSOrderedCollectionChange
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Swift.CollectionDifference : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSOrderedCollectionDifference
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSOrderedCollectionDifference, result: inout Swift.CollectionDifference<ChangeElement>?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSOrderedCollectionDifference, result: inout Swift.CollectionDifference<ChangeElement>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: Foundation.NSOrderedCollectionDifference?) -> Swift.CollectionDifference<ChangeElement>
  public typealias _ObjectiveCType = Foundation.NSOrderedCollectionDifference
}
extension Foundation.URLCache {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  convenience public init(memoryCapacity: Swift.Int, diskCapacity: Swift.Int, directory: Foundation.URL? = nil)
}
extension Foundation.URL {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public struct FormatStyle : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public init(scheme: Foundation.URL.FormatStyle.ComponentDisplayOption = .always, user: Foundation.URL.FormatStyle.ComponentDisplayOption = .never, password: Foundation.URL.FormatStyle.ComponentDisplayOption = .never, host: Foundation.URL.FormatStyle.HostDisplayOption = .always, port: Foundation.URL.FormatStyle.ComponentDisplayOption = .omitIfHTTPFamily, path: Foundation.URL.FormatStyle.ComponentDisplayOption = .always, query: Foundation.URL.FormatStyle.ComponentDisplayOption = .never, fragment: Foundation.URL.FormatStyle.ComponentDisplayOption = .never)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.URL.FormatStyle, b: Foundation.URL.FormatStyle) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.FormatStyle {
  public enum Component : Swift.Int, Swift.Codable, Swift.Hashable, Swift.Sendable, Swift.CustomStringConvertible {
    case scheme
    case user
    case password
    case host
    case port
    case path
    case query
    case fragment
    public var description: Swift.String {
      get
    }
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.FormatStyle {
  public struct ComponentDisplayOption : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
    public var description: Swift.String {
      get
    }
    public static var always: Foundation.URL.FormatStyle.ComponentDisplayOption {
      get
    }
    public static var never: Foundation.URL.FormatStyle.ComponentDisplayOption {
      get
    }
    public static func displayWhen(_ component: Foundation.URL.FormatStyle.Component, matches requirements: Swift.Set<Swift.String>) -> Foundation.URL.FormatStyle.ComponentDisplayOption
    public static func omitWhen(_ component: Foundation.URL.FormatStyle.Component, matches requirements: Swift.Set<Swift.String>) -> Foundation.URL.FormatStyle.ComponentDisplayOption
    public static var omitIfHTTPFamily: Foundation.URL.FormatStyle.ComponentDisplayOption {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.URL.FormatStyle.ComponentDisplayOption, b: Foundation.URL.FormatStyle.ComponentDisplayOption) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct HostDisplayOption : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
    public var description: Swift.String {
      get
    }
    public static var always: Foundation.URL.FormatStyle.HostDisplayOption {
      get
    }
    public static var never: Foundation.URL.FormatStyle.HostDisplayOption {
      get
    }
    public static func displayWhen(_ component: Foundation.URL.FormatStyle.Component, matches requirements: Swift.Set<Swift.String>) -> Foundation.URL.FormatStyle.HostDisplayOption
    public static func omitWhen(_ component: Foundation.URL.FormatStyle.Component, matches requirements: Swift.Set<Swift.String>) -> Foundation.URL.FormatStyle.HostDisplayOption
    public static var omitIfHTTPFamily: Foundation.URL.FormatStyle.HostDisplayOption {
      get
    }
    public static func omitSpecificSubdomains(_ subdomainsToOmit: Swift.Set<Swift.String> = Set(), includeMultiLevelSubdomains omitMultiLevelSubdomains: Swift.Bool = false) -> Foundation.URL.FormatStyle.HostDisplayOption
    public static func omitSpecificSubdomains(_ subdomainsToOmit: Swift.Set<Swift.String> = Set(), includeMultiLevelSubdomains omitMultiLevelSubdomains: Swift.Bool = false, when component: Foundation.URL.FormatStyle.Component, matches requirements: Swift.Set<Swift.String>) -> Foundation.URL.FormatStyle.HostDisplayOption
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.URL.FormatStyle.HostDisplayOption, b: Foundation.URL.FormatStyle.HostDisplayOption) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.FormatStyle {
  public func scheme(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .always) -> Foundation.URL.FormatStyle
  public func user(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .never) -> Foundation.URL.FormatStyle
  public func password(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .never) -> Foundation.URL.FormatStyle
  public func host(_ strategy: Foundation.URL.FormatStyle.HostDisplayOption = .always) -> Foundation.URL.FormatStyle
  public func port(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .omitIfHTTPFamily) -> Foundation.URL.FormatStyle
  public func path(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .always) -> Foundation.URL.FormatStyle
  public func query(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .never) -> Foundation.URL.FormatStyle
  public func fragment(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .never) -> Foundation.URL.FormatStyle
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.URL.ParseStrategy {
    get
  }
  public typealias Strategy = Foundation.URL.ParseStrategy
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.FormatStyle : Foundation.FormatStyle {
  public func format(_ value: Foundation.URL) -> Swift.String
  public typealias FormatInput = Foundation.URL
  public typealias FormatOutput = Swift.String
}
extension Foundation.URL {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func formatted<F>(_ format: F) -> F.FormatOutput where F : Foundation.FormatStyle, F.FormatInput == Foundation.URL
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func formatted() -> Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FormatStyle where Self == Foundation.URL.FormatStyle {
  public static var url: Foundation.URL.FormatStyle {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.URL.FormatStyle {
  public static var url: Foundation.URL.FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal {
  public struct ParseStrategy<Format> : Foundation.ParseStrategy, Swift.Codable, Swift.Hashable where Format : Foundation.FormatStyle, Format.FormatInput == Foundation.Decimal {
    public var formatStyle: Format
    public var lenient: Swift.Bool
    public func parse(_ value: Swift.String) throws -> Format.FormatInput
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Decimal.ParseStrategy<Format>, b: Foundation.Decimal.ParseStrategy<Format>) -> Swift.Bool
    public typealias ParseInput = Swift.String
    public typealias ParseOutput = Foundation.Decimal
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.ParseStrategy : Swift.Sendable where Format : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal {
  public init<S>(_ value: S.ParseInput, strategy: S) throws where S : Foundation.ParseStrategy, S.ParseOutput == Foundation.Decimal
  public init(_ value: Swift.String, format: Foundation.Decimal.FormatStyle, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.Decimal.FormatStyle.Percent, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.Decimal.FormatStyle.Currency, lenient: Swift.Bool = true) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.ParseStrategy where Format == Foundation.Decimal.FormatStyle {
  public init(format: Format, lenient: Swift.Bool = true)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.ParseStrategy where Format == Foundation.Decimal.FormatStyle.Percent {
  public init(format: Format, lenient: Swift.Bool = true)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.ParseStrategy where Format == Foundation.Decimal.FormatStyle.Currency {
  public init(format: Format, lenient: Swift.Bool = true)
}
public protocol ReferenceConvertible : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.Hashable, Swift._ObjectiveCBridgeable {
  associatedtype ReferenceType : ObjectiveC.NSObject, Foundation.NSCopying
}
extension Foundation.NSTextCheckingResult.CheckingType {
  public static var allSystemTypes: Foundation.NSTextCheckingResult.CheckingType {
    get
  }
  public static var allCustomTypes: Foundation.NSTextCheckingResult.CheckingType {
    get
  }
  public static var allTypes: Foundation.NSTextCheckingResult.CheckingType {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.OperationQueue : Combine.Scheduler {
  public struct SchedulerTimeType : Swift.Strideable, Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var date: Foundation.Date
    public init(_ date: Foundation.Date)
    public func distance(to other: Foundation.OperationQueue.SchedulerTimeType) -> Foundation.OperationQueue.SchedulerTimeType.Stride
    public func advanced(by n: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType
    public struct Stride : Swift.ExpressibleByFloatLiteral, Swift.Comparable, Swift.SignedNumeric, Swift.Codable, Combine.SchedulerTimeIntervalConvertible, Swift.Sendable {
      public typealias FloatLiteralType = Foundation.TimeInterval
      public typealias IntegerLiteralType = Foundation.TimeInterval
      public typealias Magnitude = Foundation.TimeInterval
      public var magnitude: Foundation.TimeInterval
      public var timeInterval: Foundation.TimeInterval {
        get
      }
      public init(integerLiteral value: Foundation.TimeInterval)
      public init(floatLiteral value: Foundation.TimeInterval)
      public init(_ timeInterval: Foundation.TimeInterval)
      public init?<T>(exactly source: T) where T : Swift.BinaryInteger
      public static func < (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Swift.Bool
      public static func * (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func + (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func - (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func *= (lhs: inout Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride)
      public static func += (lhs: inout Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride)
      public static func -= (lhs: inout Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride)
      public static func seconds(_ s: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func seconds(_ s: Swift.Double) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func milliseconds(_ ms: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func microseconds(_ us: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func nanoseconds(_ ns: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func == (a: Foundation.OperationQueue.SchedulerTimeType.Stride, b: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
    }
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct SchedulerOptions : Swift.Sendable {
  }
  public func schedule(options: Foundation.OperationQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.OperationQueue.SchedulerTimeType, tolerance: Foundation.OperationQueue.SchedulerTimeType.Stride, options: Foundation.OperationQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.OperationQueue.SchedulerTimeType, interval: Foundation.OperationQueue.SchedulerTimeType.Stride, tolerance: Foundation.OperationQueue.SchedulerTimeType.Stride, options: Foundation.OperationQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void) -> any Combine.Cancellable
  public var now: Foundation.OperationQueue.SchedulerTimeType {
    get
  }
  public var minimumTolerance: Foundation.OperationQueue.SchedulerTimeType.Stride {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct SortDescriptor<Compared> : Foundation.SortComparator, Swift.Codable, Swift.Sendable {
  public var order: Foundation.SortOrder
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Bool>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Bool?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Double>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Double?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Float>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Float?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int8>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int8?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int16>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int16?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int32>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int32?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int64>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int64?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt8>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt8?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt16>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt16?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt32>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt32?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt64>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt64?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Foundation.Date>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Foundation.Date?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Foundation.UUID>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Foundation.UUID?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.String>, comparator: Swift.String.StandardComparator = .localizedStandard) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.String?>, comparator: Swift.String.StandardComparator = .localizedStandard) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.String>, comparator: Swift.String.StandardComparator = .localizedStandard, order: Foundation.SortOrder) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.String?>, comparator: Swift.String.StandardComparator = .localizedStandard, order: Foundation.SortOrder) where Compared : ObjectiveC.NSObject
  public init?(_ descriptor: Foundation.NSSortDescriptor, comparing comparedType: Compared.Type) where Compared : ObjectiveC.NSObject
  public func compare(_ lhs: Compared, _ rhs: Compared) -> Foundation.ComparisonResult
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.SortDescriptor<Compared>, b: Foundation.SortDescriptor<Compared>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.NSSortDescriptor {
  convenience public init<Compared>(_ sortDescriptor: Foundation.SortDescriptor<Compared>)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Measurement where UnitType : Foundation.Dimension {
  public struct FormatStyle : Foundation.FormatStyle, Swift.Sendable {
    public struct UnitWidth : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var wide: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth {
        get
      }
      public static var abbreviated: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth {
        get
      }
      public static var narrow: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth, b: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public var width: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth
    public var locale: Foundation.Locale
    public var numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>?
    public var usage: Foundation.MeasurementFormatUnitUsage<UnitType>?
    public var attributed: Foundation.Measurement<UnitType>.AttributedStyle {
      get
    }
    public init(width: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth, locale: Foundation.Locale = .autoupdatingCurrent, usage: Foundation.MeasurementFormatUnitUsage<UnitType> = .general, numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>? = nil)
    public func locale(_ locale: Foundation.Locale) -> Foundation.Measurement<UnitType>.FormatStyle
    public func format(_ measurement: Foundation.Measurement<UnitType>) -> Swift.String
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Measurement<UnitType>.FormatStyle, b: Foundation.Measurement<UnitType>.FormatStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.Measurement<UnitType>
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Measurement.FormatStyle where UnitType == Foundation.UnitTemperature {
  public var hidesScaleName: Swift.Bool {
    get
    set
  }
  public init(width: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth = .abbreviated, locale: Foundation.Locale = .autoupdatingCurrent, usage: Foundation.MeasurementFormatUnitUsage<UnitType> = .general, hidesScaleName: Swift.Bool = false, numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>? = nil)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Measurement.FormatStyle where UnitType == Foundation.UnitInformationStorage {
  public struct ByteCount : Foundation.FormatStyle, Swift.Sendable {
    public typealias Style = Foundation.ByteCountFormatStyle.Style
    public typealias Units = Foundation.ByteCountFormatStyle.Units
    public var style: Foundation.Measurement<Foundation.UnitInformationStorage>.FormatStyle.ByteCount.Style
    public var allowedUnits: Foundation.Measurement<Foundation.UnitInformationStorage>.FormatStyle.ByteCount.Units
    public var spellsOutZero: Swift.Bool
    public var includesActualByteCount: Swift.Bool
    public var locale: Foundation.Locale
    public var attributed: Foundation.Measurement<Foundation.UnitInformationStorage>.AttributedStyle.ByteCount {
      get
    }
    public init(style: Foundation.Measurement<UnitType>.FormatStyle.ByteCount.Style, allowedUnits: Foundation.Measurement<UnitType>.FormatStyle.ByteCount.Units, spellsOutZero: Swift.Bool, includesActualByteCount: Swift.Bool, locale: Foundation.Locale)
    public func format(_ value: Foundation.Measurement<Foundation.UnitInformationStorage>) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Measurement<UnitType>.FormatStyle.ByteCount
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Measurement<UnitType>.FormatStyle.ByteCount, b: Foundation.Measurement<UnitType>.FormatStyle.ByteCount) -> Swift.Bool
    public typealias FormatInput = Foundation.Measurement<Foundation.UnitInformationStorage>
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct MeasurementFormatUnitUsage<UnitType> : Swift.Codable, Swift.Hashable, Swift.Sendable where UnitType : Foundation.Dimension {
  public static var general: Foundation.MeasurementFormatUnitUsage<UnitType> {
    get
  }
  public static var asProvided: Foundation.MeasurementFormatUnitUsage<UnitType> {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.MeasurementFormatUnitUsage<UnitType>, b: Foundation.MeasurementFormatUnitUsage<UnitType>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitTemperature {
  public static var weather: Foundation.MeasurementFormatUnitUsage<Foundation.UnitTemperature> {
    get
  }
  public static var person: Foundation.MeasurementFormatUnitUsage<Foundation.UnitTemperature> {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitLength {
  public static var person: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
  public static var road: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
  public static var personHeight: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitLength {
  public static var focalLength: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
  public static var rainfall: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
  public static var snowfall: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitEnergy {
  public static var food: Foundation.MeasurementFormatUnitUsage<Foundation.UnitEnergy> {
    get
  }
  public static var workout: Foundation.MeasurementFormatUnitUsage<Foundation.UnitEnergy> {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitMass {
  public static var personWeight: Foundation.MeasurementFormatUnitUsage<Foundation.UnitMass> {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitVolume {
  public static var liquid: Foundation.MeasurementFormatUnitUsage<Foundation.UnitVolume> {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Measurement where UnitType : Foundation.Dimension {
  public func formatted<S>(_ style: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Foundation.Measurement<UnitType>
  public func formatted() -> Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public static func measurement<UnitType>(width: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth, usage: Foundation.MeasurementFormatUnitUsage<UnitType> = .general, numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>? = nil) -> Self where Self == Foundation.Measurement<UnitType>.FormatStyle, UnitType : Foundation.Dimension
  public static func measurement(width: Foundation.Measurement<Foundation.UnitTemperature>.FormatStyle.UnitWidth = .abbreviated, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitTemperature> = .general, hidesScaleName: Swift.Bool = false, numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>? = nil) -> Self where Self == Foundation.Measurement<Foundation.UnitTemperature>.FormatStyle
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FormatStyle where Self == Foundation.Measurement<Foundation.UnitInformationStorage>.FormatStyle.ByteCount {
  public static func byteCount(style: Foundation.Measurement<Foundation.UnitInformationStorage>.FormatStyle.ByteCount.Style, allowedUnits: Foundation.Measurement<Foundation.UnitInformationStorage>.FormatStyle.ByteCount.Units = .all, spellsOutZero: Swift.Bool = true, includesActualByteCount: Swift.Bool = false) -> Self
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLSessionWebSocketTask {
  public enum Message : Swift.Sendable {
    case data(Foundation.Data)
    case string(Swift.String)
  }
  public func send(_ message: Foundation.URLSessionWebSocketTask.Message, completionHandler: @escaping ((any Swift.Error)?) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @_silgen_name("_$sSo25NSURLSessionWebSocketTaskC10FoundationE4sendyyAbCE7MessageOYaKF")
  @_alwaysEmitIntoClient public func send(_ message: Foundation.URLSessionWebSocketTask.Message) async throws {
        try await withUnsafeThrowingContinuation { continuation in
            send(message) {
                if let error = $0 {
                    continuation.resume(throwing: error)
                } else {
                    continuation.resume(returning: ())
                }
            }
        } as Void
    }
  #endif
  public func receive(completionHandler: @escaping (Swift.Result<Foundation.URLSessionWebSocketTask.Message, any Swift.Error>) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @_silgen_name("_$sSo25NSURLSessionWebSocketTaskC10FoundationE7receiveAbCE7MessageOyYaKF")
  @_alwaysEmitIntoClient public func receive() async throws -> Foundation.URLSessionWebSocketTask.Message {
        try await withUnsafeThrowingContinuation { continuation in
            receive {
                continuation.resume(with: $0)
            }
        }
    }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLSessionTaskTransactionMetrics {
  public var localPort: Swift.Int? {
    get
  }
  public var remotePort: Swift.Int? {
    get
  }
  public var negotiatedTLSProtocolVersion: Security.tls_protocol_version_t? {
    get
  }
  public var negotiatedTLSCipherSuite: Security.tls_ciphersuite_t? {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLSession {
  @_alwaysEmitIntoClient private func makeState() -> Swift.ManagedBuffer<(isCancelled: Swift.Bool, task: Foundation.URLSessionTask?), Darwin.os_unfair_lock> {
        ManagedBuffer<(isCancelled: Bool, task: URLSessionTask?), os_unfair_lock>.create(minimumCapacity: 1) { buffer in
            buffer.withUnsafeMutablePointerToElements { $0.initialize(to: os_unfair_lock()) }
            return (isCancelled: false, task: nil)
        }
    }
  @_alwaysEmitIntoClient private func cancel(state: Swift.ManagedBuffer<(isCancelled: Swift.Bool, task: Foundation.URLSessionTask?), Darwin.os_unfair_lock>) {
        state.withUnsafeMutablePointers { state, lock in
            os_unfair_lock_lock(lock)
            let task = state.pointee.task
            state.pointee = (isCancelled: true, task: nil)
            os_unfair_lock_unlock(lock)
            task?.cancel()
        }
    }
  @_alwaysEmitIntoClient private func activate(state: Swift.ManagedBuffer<(isCancelled: Swift.Bool, task: Foundation.URLSessionTask?), Darwin.os_unfair_lock>, task: Foundation.URLSessionTask) {
        state.withUnsafeMutablePointers { state, lock in
            os_unfair_lock_lock(lock)
            if state.pointee.task != nil {
                fatalError("Cannot activate twice")
            }
            if state.pointee.isCancelled {
                os_unfair_lock_unlock(lock)
                task.cancel()
            } else {
                state.pointee = (isCancelled: false, task: task)
                os_unfair_lock_unlock(lock)
            }
        }
    }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Foundation.URLSession {
  #if compiler(>=5.3) && $AsyncAwait
  public func data(for request: Foundation.URLRequest, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.Data, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func data(from url: Foundation.URL, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.Data, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func upload(for request: Foundation.URLRequest, fromFile fileURL: Foundation.URL, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.Data, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func upload(for request: Foundation.URLRequest, from bodyData: Foundation.Data, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.Data, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func download(for request: Foundation.URLRequest, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.URL, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func download(from url: Foundation.URL, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.URL, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func download(resumeFrom resumeData: Foundation.Data, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.URL, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public struct AsyncBytes : _Concurrency.AsyncSequence, Swift.Sendable {
    public var task: Foundation.URLSessionDataTask {
      get
    }
    public typealias Element = Swift.UInt8
    public typealias AsyncIterator = Foundation.URLSession.AsyncBytes.Iterator
    @frozen public struct Iterator : _Concurrency.AsyncIteratorProtocol, Swift.Sendable {
      public typealias Element = Swift.UInt8
      @usableFromInline
      internal var buffer: Foundation._AsyncBytesBuffer
      #if compiler(>=5.3) && $AsyncAwait
      @inlinable @inline(__always) public mutating func next() async throws -> Swift.UInt8? {
                return try await buffer.next()
            }
      #endif
    }
    public __consuming func makeAsyncIterator() -> Foundation.URLSession.AsyncBytes.Iterator
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  public func bytes(for request: Foundation.URLRequest, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.URLSession.AsyncBytes, Foundation.URLResponse)
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  public func bytes(from url: Foundation.URL, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.URLSession.AsyncBytes, Foundation.URLResponse)
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLSession {
  #if compiler(>=5.3) && $AsyncAwait
  @_alwaysEmitIntoClient @_disfavoredOverload public func data(for request: Foundation.URLRequest) async throws -> (Foundation.Data, Foundation.URLResponse) {
        if #available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *) {
            return try await data(for: request, delegate: nil)
        }
        let cancelState = makeState()
        return try await withTaskCancellationHandler {
            cancel(state: cancelState)
        } operation: {
            try await withCheckedThrowingContinuation { continuation in
                let task = dataTask(with: request) { data, response, error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else {
                        continuation.resume(returning: (data!, response!))
                    }
                }
                task.resume()
                activate(state: cancelState, task: task)
            }
        }
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @_alwaysEmitIntoClient @_disfavoredOverload public func data(from url: Foundation.URL) async throws -> (Foundation.Data, Foundation.URLResponse) {
        if #available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *) {
            return try await data(from: url, delegate: nil)
        }
        let cancelState = makeState()
        return try await withTaskCancellationHandler {
            cancel(state: cancelState)
        } operation: {
            try await withCheckedThrowingContinuation { continuation in
                let task = dataTask(with: url) { data, response, error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else {
                        continuation.resume(returning: (data!, response!))
                    }
                }
                task.resume()
                activate(state: cancelState, task: task)
            }
        }
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @_alwaysEmitIntoClient @_disfavoredOverload public func upload(for request: Foundation.URLRequest, fromFile fileURL: Foundation.URL) async throws -> (Foundation.Data, Foundation.URLResponse) {
        if #available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *) {
            return try await upload(for: request, fromFile: fileURL, delegate: nil)
        }
        let cancelState = makeState()
        return try await withTaskCancellationHandler {
            cancel(state: cancelState)
        } operation: {
            try await withCheckedThrowingContinuation { continuation in
                let task = uploadTask(with: request, fromFile: fileURL) { data, response, error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else {
                        continuation.resume(returning: (data!, response!))
                    }
                }
                task.resume()
                activate(state: cancelState, task: task)
            }
        }
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @_alwaysEmitIntoClient @_disfavoredOverload public func upload(for request: Foundation.URLRequest, from bodyData: Foundation.Data) async throws -> (Foundation.Data, Foundation.URLResponse) {
        if #available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *) {
            return try await upload(for: request, from: bodyData, delegate: nil)
        }
        let cancelState = makeState()
        return try await withTaskCancellationHandler {
            cancel(state: cancelState)
        } operation: {
            try await withCheckedThrowingContinuation { continuation in
                let task = uploadTask(with: request, from: bodyData) { data, response, error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else {
                        continuation.resume(returning: (data!, response!))
                    }
                }
                task.resume()
                activate(state: cancelState, task: task)
            }
        }
    }
  #endif
}
public protocol ContiguousBytes {
  func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
}
extension Swift.Array : Foundation.ContiguousBytes where Element == Swift.UInt8 {
}
extension Swift.ArraySlice : Foundation.ContiguousBytes where Element == Swift.UInt8 {
}
extension Swift.ContiguousArray : Foundation.ContiguousBytes where Element == Swift.UInt8 {
}
extension Swift.UnsafeRawBufferPointer : Foundation.ContiguousBytes {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(self)
    }
}
extension Swift.UnsafeMutableRawBufferPointer : Foundation.ContiguousBytes {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
extension Swift.UnsafeBufferPointer : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
extension Swift.UnsafeMutableBufferPointer : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
extension Swift.EmptyCollection : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(start: nil, count: 0))
    }
}
extension Swift.CollectionOfOne : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        let element = self.first!
        return try Swift.withUnsafeBytes(of: element) {
            return try body($0)
        }
    }
}
extension Swift.Slice : Foundation.ContiguousBytes where Base : Foundation.ContiguousBytes {
  public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FloatingPointParseStrategy<Format> : Swift.Codable, Swift.Hashable where Format : Foundation.FormatStyle, Format.FormatInput : Swift.BinaryFloatingPoint {
  public var formatStyle: Format
  public var lenient: Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.FloatingPointParseStrategy<Format>, b: Foundation.FloatingPointParseStrategy<Format>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy : Swift.Sendable where Format : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy : Foundation.ParseStrategy {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func parse(_ value: Swift.String) throws -> Format.FormatInput
  public typealias ParseInput = Swift.String
  public typealias ParseOutput = Format.FormatInput
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.FloatingPointFormatStyle<Value>, Value : Swift.BinaryFloatingPoint
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.FloatingPointFormatStyle<Value>.Currency, Value : Swift.BinaryFloatingPoint
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.FloatingPointFormatStyle<Value>.Percent, Value : Swift.BinaryFloatingPoint
}
extension Foundation.Locale {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Language : Swift.Hashable, Swift.Codable, Swift.Sendable {
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct Components : Swift.Hashable, Swift.Codable, Swift.Sendable {
      public var languageCode: Foundation.Locale.LanguageCode?
      public var script: Foundation.Locale.Script?
      public var region: Foundation.Locale.Region?
      public init(identifier: Swift.String)
      public init(languageCode: Foundation.Locale.LanguageCode? = nil, script: Foundation.Locale.Script? = nil, region: Foundation.Locale.Region? = nil)
      public init(language: Foundation.Locale.Language)
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Locale.Language.Components, b: Foundation.Locale.Language.Components) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public init(components: Foundation.Locale.Language.Components)
    public init(languageCode: Foundation.Locale.LanguageCode? = nil, script: Foundation.Locale.Script? = nil, region: Foundation.Locale.Region? = nil)
    public init(identifier: Swift.String)
    public var lineLayoutDirection: Foundation.Locale.LanguageDirection {
      get
    }
    public var characterDirection: Foundation.Locale.LanguageDirection {
      get
    }
    public var parent: Foundation.Locale.Language? {
      get
    }
    public func hasCommonParent(with language: Foundation.Locale.Language) -> Swift.Bool
    public func isEquivalent(to language: Foundation.Locale.Language) -> Swift.Bool
    public var minimalIdentifier: Swift.String {
      get
    }
    public var maximalIdentifier: Swift.String {
      get
    }
    public var languageCode: Foundation.Locale.LanguageCode? {
      get
    }
    public var script: Foundation.Locale.Script? {
      get
    }
    public var region: Foundation.Locale.Region? {
      get
    }
    public static var systemLanguages: [Foundation.Locale.Language] {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Locale.Language, b: Foundation.Locale.Language) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension Foundation.NSString : Swift.ExpressibleByStringLiteral {
  required convenience public init(stringLiteral value: Swift.StaticString)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StaticString
  public typealias StringLiteralType = Swift.StaticString
  public typealias UnicodeScalarLiteralType = Swift.StaticString
}
extension Foundation.NSString : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.NSString {
  convenience public init(format: __shared Foundation.NSString, _ args: any Swift.CVarArg...)
  convenience public init(format: __shared Foundation.NSString, locale: Foundation.Locale?, _ args: any Swift.CVarArg...)
  public class func localizedStringWithFormat(_ format: Foundation.NSString, _ args: any Swift.CVarArg...) -> Self
  public func appendingFormat(_ format: Foundation.NSString, _ args: any Swift.CVarArg...) -> Foundation.NSString
}
extension Foundation.NSMutableString {
  public func appendFormat(_ format: Foundation.NSString, _ args: any Swift.CVarArg...)
}
extension Foundation.NSString {
  @nonobjc convenience public init(string aString: __shared Foundation.NSString)
}
extension Foundation.NSString : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSString.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension Foundation.NSExpression {
  convenience public init(format expressionFormat: __shared Swift.String, _ args: any Swift.CVarArg...)
}
extension Foundation.NSExpression {
  convenience public init<Root, Value>(forKeyPath keyPath: Swift.KeyPath<Root, Value>)
}
extension Foundation.NotificationCenter {
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public func notifications(named name: Foundation.Notification.Name, object: Swift.AnyObject? = nil) -> Foundation.NotificationCenter.Notifications
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  @_hasMissingDesignatedInitializers @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  final public class Notifications : _Concurrency.AsyncSequence {
    public typealias Element = Foundation.Notification
    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    public struct Iterator : _Concurrency.AsyncIteratorProtocol {
      #if compiler(>=5.3) && $AsyncAwait
      public func next() async -> Foundation.Notification?
      #endif
      public typealias Element = Foundation.Notification
    }
    @objc deinit
    final public __consuming func makeAsyncIterator() -> Foundation.NotificationCenter.Notifications.Iterator
    public typealias AsyncIterator = Foundation.NotificationCenter.Notifications.Iterator
  }
  #endif
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.NotificationCenter.Notifications : @unchecked Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.NotificationCenter.Notifications.Iterator : @unchecked Swift.Sendable {
}
#endif
@available(macOS 12, iOS 15, watchOS 8, tvOS 15, *)
public struct PresentationIntent : Swift.Hashable, Swift.Codable, Swift.CustomDebugStringConvertible, Swift.Sendable {
  public var components: [Foundation.PresentationIntent.IntentType]
  public var count: Swift.Int {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public enum Kind : Swift.Hashable, Swift.Codable, Swift.CustomDebugStringConvertible, Swift.Sendable {
    case paragraph
    case header(level: Swift.Int)
    case orderedList
    case unorderedList
    case listItem(ordinal: Swift.Int)
    case codeBlock(languageHint: Swift.String?)
    case blockQuote
    case thematicBreak
    case table(columns: [Foundation.PresentationIntent.TableColumn])
    case tableHeaderRow
    case tableRow(rowIndex: Swift.Int)
    case tableCell(columnIndex: Swift.Int)
    public var debugDescription: Swift.String {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.PresentationIntent.Kind, b: Foundation.PresentationIntent.Kind) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct TableColumn : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public enum Alignment : Swift.Int, Swift.Hashable, Swift.Codable, Swift.Sendable {
      case left
      case center
      case right
      public init?(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public var alignment: Foundation.PresentationIntent.TableColumn.Alignment
    public init(alignment: Foundation.PresentationIntent.TableColumn.Alignment)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.PresentationIntent.TableColumn, b: Foundation.PresentationIntent.TableColumn) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct IntentType : Swift.Hashable, Swift.Codable, Swift.CustomDebugStringConvertible, Swift.Sendable {
    public var kind: Foundation.PresentationIntent.Kind
    public var identity: Swift.Int
    public var debugDescription: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.PresentationIntent.IntentType, b: Foundation.PresentationIntent.IntentType) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public init(_ kind: Foundation.PresentationIntent.Kind, identity: Swift.Int, parent: Foundation.PresentationIntent? = nil)
  public init(types: [Foundation.PresentationIntent.IntentType])
  public var isValid: Swift.Bool {
    get
  }
  public var indentationLevel: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.PresentationIntent, b: Foundation.PresentationIntent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.PresentationIntent : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.__NSPresentationIntent
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.__NSPresentationIntent, result: inout Foundation.PresentationIntent?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.__NSPresentationIntent, result: inout Foundation.PresentationIntent?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.__NSPresentationIntent?) -> Foundation.PresentationIntent
  public typealias _ObjectiveCType = Foundation.__NSPresentationIntent
}
extension Foundation.Date {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct RelativeFormatStyle : Foundation.FormatStyle, Swift.Codable, Swift.Hashable, Swift.Sendable {
    public struct UnitsStyle : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var wide: Foundation.Date.RelativeFormatStyle.UnitsStyle {
        get
      }
      public static var spellOut: Foundation.Date.RelativeFormatStyle.UnitsStyle {
        get
      }
      public static var abbreviated: Foundation.Date.RelativeFormatStyle.UnitsStyle {
        get
      }
      public static var narrow: Foundation.Date.RelativeFormatStyle.UnitsStyle {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.RelativeFormatStyle.UnitsStyle, b: Foundation.Date.RelativeFormatStyle.UnitsStyle) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct Presentation : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var numeric: Foundation.Date.RelativeFormatStyle.Presentation {
        get
      }
      public static var named: Foundation.Date.RelativeFormatStyle.Presentation {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.RelativeFormatStyle.Presentation, b: Foundation.Date.RelativeFormatStyle.Presentation) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public var presentation: Foundation.Date.RelativeFormatStyle.Presentation
    public var unitsStyle: Foundation.Date.RelativeFormatStyle.UnitsStyle
    public var capitalizationContext: Foundation.FormatStyleCapitalizationContext
    public var locale: Foundation.Locale
    public var calendar: Foundation.Calendar
    public init(presentation: Foundation.Date.RelativeFormatStyle.Presentation = .numeric, unitsStyle: Foundation.Date.RelativeFormatStyle.UnitsStyle = .wide, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, capitalizationContext: Foundation.FormatStyleCapitalizationContext = .unknown)
    public func format(_ destDate: Foundation.Date) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.RelativeFormatStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.RelativeFormatStyle, b: Foundation.Date.RelativeFormatStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.Date
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.RelativeFormatStyle {
  public static func relative(presentation: Foundation.Date.RelativeFormatStyle.Presentation, unitsStyle: Foundation.Date.RelativeFormatStyle.UnitsStyle = .wide) -> Self
}
public struct Notification : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable {
  public typealias ReferenceType = Foundation.NSNotification
  public var name: Foundation.Notification.Name
  public var object: Any?
  public var userInfo: [Swift.AnyHashable : Any]?
  public init(name: Foundation.Notification.Name, object: Any? = nil, userInfo: [Swift.AnyHashable : Any]? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public typealias Name = Foundation.NSNotification.Name
  public static func == (lhs: Foundation.Notification, rhs: Foundation.Notification) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Notification : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.Notification : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNotification
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNotification, result: inout Foundation.Notification?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNotification, result: inout Foundation.Notification?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNotification?) -> Foundation.Notification
  public typealias _ObjectiveCType = Foundation.NSNotification
}
extension Foundation.NSNotification : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(iOS, unavailable, introduced: 7)
@available(*, unavailable)
extension Foundation.Notification : @unchecked Swift.Sendable {
}
public typealias NSErrorPointer = Swift.AutoreleasingUnsafeMutablePointer<Foundation.NSError?>?
public typealias ErrorPointer = Foundation.NSErrorPointer
public func _convertNSErrorToError(_ error: Foundation.NSError?) -> any Swift.Error
public func _convertErrorToNSError(_ error: any Swift.Error) -> Foundation.NSError
public protocol LocalizedError : Swift.Error {
  var errorDescription: Swift.String? { get }
  var failureReason: Swift.String? { get }
  var recoverySuggestion: Swift.String? { get }
  var helpAnchor: Swift.String? { get }
}
extension Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
  public var recoverySuggestion: Swift.String? {
    get
  }
  public var helpAnchor: Swift.String? {
    get
  }
}
public protocol RecoverableError : Swift.Error {
  var recoveryOptions: [Swift.String] { get }
  func attemptRecovery(optionIndex recoveryOptionIndex: Swift.Int, resultHandler handler: @escaping (_ recovered: Swift.Bool) -> Swift.Void)
  func attemptRecovery(optionIndex recoveryOptionIndex: Swift.Int) -> Swift.Bool
}
extension Foundation.RecoverableError {
  public func attemptRecovery(optionIndex recoveryOptionIndex: Swift.Int, resultHandler handler: @escaping (_ recovered: Swift.Bool) -> Swift.Void)
}
public protocol CustomNSError : Swift.Error {
  static var errorDomain: Swift.String { get }
  var errorCode: Swift.Int { get }
  var errorUserInfo: [Swift.String : Any] { get }
}
extension Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
extension Foundation.CustomNSError where Self : Swift.RawRepresentable, Self.RawValue : Swift.FixedWidthInteger {
  public var errorCode: Swift.Int {
    get
  }
}
extension Swift.Error where Self : Foundation.CustomNSError {
  public var _domain: Swift.String {
    get
  }
  public var _code: Swift.Int {
    get
  }
}
extension Swift.Error where Self : Foundation.CustomNSError, Self : Swift.RawRepresentable, Self.RawValue : Swift.FixedWidthInteger {
  public var _code: Swift.Int {
    get
  }
}
extension Swift.Error {
  public var localizedDescription: Swift.String {
    get
  }
}
public func _getErrorDefaultUserInfo<T>(_ error: T) -> Swift.AnyObject? where T : Swift.Error
extension Foundation.NSError : Swift.Error {
  @nonobjc public var _domain: Swift.String {
    get
  }
  @nonobjc public var _code: Swift.Int {
    get
  }
  @nonobjc public var _userInfo: Swift.AnyObject? {
    get
  }
  @nonobjc public func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CoreFoundation.CFError : Swift.Error {
  public var _domain: Swift.String {
    get
  }
  public var _code: Swift.Int {
    get
  }
  public var _userInfo: Swift.AnyObject? {
    get
  }
  public func _getEmbeddedNSError() -> Swift.AnyObject?
}
public protocol _ObjectiveCBridgeableError : Swift.Error {
  init?(_bridgedNSError: __shared Foundation.NSError)
}
public func _bridgeNSErrorToError<T>(_ error: Foundation.NSError, out: Swift.UnsafeMutablePointer<T>) -> Swift.Bool where T : Foundation._ObjectiveCBridgeableError
public protocol _BridgedNSError : Foundation._ObjectiveCBridgeableError, Swift.Hashable, Swift.RawRepresentable where Self.RawValue : Swift.FixedWidthInteger {
  static var _nsErrorDomain: Swift.String { get }
}
extension Foundation._BridgedNSError {
  public var _domain: Swift.String {
    get
  }
}
extension Foundation._BridgedNSError {
  public var _code: Swift.Int {
    get
  }
  public init?(_bridgedNSError: __shared Foundation.NSError)
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol _BridgedStoredNSError : Foundation.CustomNSError, Foundation._ObjectiveCBridgeableError, Swift.Hashable {
  associatedtype Code : Foundation._ErrorCodeProtocol, Swift.RawRepresentable where Self.Code.RawValue : Swift.FixedWidthInteger
  var _nsError: Foundation.NSError { get }
  init(_nsError error: Foundation.NSError)
}
extension Foundation._BridgedStoredNSError {
  public var code: Self.Code {
    get
  }
  public init(_ code: Self.Code, userInfo: [Swift.String : Any] = [:])
  public var userInfo: [Swift.String : Any] {
    get
  }
}
extension Foundation._BridgedStoredNSError {
  public init?(_bridgedNSError error: Foundation.NSError)
}
extension Foundation._BridgedStoredNSError {
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
extension Foundation._BridgedStoredNSError {
  public func hash(into hasher: inout Swift.Hasher)
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
        return _nsError.hashValue
    }
  }
}
public protocol _ErrorCodeProtocol : Swift.Equatable {
  associatedtype _ErrorType : Foundation._BridgedStoredNSError where Self == Self._ErrorType.Code
}
extension Foundation._ErrorCodeProtocol {
  public static func ~= (match: Self, error: any Swift.Error) -> Swift.Bool
}
extension Foundation._BridgedStoredNSError {
  public func _getEmbeddedNSError() -> Swift.AnyObject?
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
}
extension Swift._SwiftNewtypeWrapper where Self.RawValue == any Swift.Error {
  @inlinable public func _bridgeToObjectiveC() -> Foundation.NSError {
        return rawValue as NSError
    }
  @inlinable public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSError, result: inout Self?) {
        result = Self(rawValue: source)
    }
  @inlinable public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSError, result: inout Self?) -> Swift.Bool {
        result = Self(rawValue: source)
        return result != nil
    }
  @inlinable @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSError?) -> Self {
        return Self(rawValue: _convertNSErrorToError(source))!
    }
}
public struct CocoaError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public struct Code : Swift.RawRepresentable, Swift.Hashable, Foundation._ErrorCodeProtocol, Swift.Sendable {
    public typealias _ErrorType = Foundation.CocoaError
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
  }
}
extension Foundation.CocoaError {
  public var filePath: Swift.String? {
    get
  }
  public var stringEncoding: Swift.String.Encoding? {
    get
  }
  public var underlying: (any Swift.Error)? {
    get
  }
  @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
  public var underlyingErrors: [any Swift.Error] {
    get
  }
  public var url: Foundation.URL? {
    get
  }
}
extension Foundation.CocoaError {
  public static func error(_ code: Foundation.CocoaError.Code, userInfo: [Swift.AnyHashable : Any]? = nil, url: Foundation.URL? = nil) -> any Swift.Error
}
extension Foundation.CocoaError.Code {
  public static var fileNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileLocking: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadCorruptFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var fileReadTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var fileReadUnknownStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.7, iOS 5.0, *)
  public static var fileWriteFileExists: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteOutOfSpace: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var fileWriteVolumeReadOnly: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountUnknown: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountBusy: Foundation.CocoaError.Code {
    get
  }
  public static var keyValueValidation: Foundation.CocoaError.Code {
    get
  }
  public static var formatting: Foundation.CocoaError.Code {
    get
  }
  public static var userCancelled: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var featureUnsupported: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableNotLoadable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableArchitectureMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableRuntimeMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableLoad: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableLink: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadUnknownVersion: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListWriteStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListWriteInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionInterrupted: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionReplyInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileNotUploadedDueToQuota: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileUbiquityServerNotAvailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffFailed: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityConnectionUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityRemoteApplicationTimedOut: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffUserInfoTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderValueNotFound: Foundation.CocoaError.Code {
    get
  }
  public static var coderInvalidValue: Foundation.CocoaError.Code {
    get
  }
}
extension Foundation.CocoaError.Code {
  @available(*, deprecated, renamed: "fileNoSuchFile")
  public static var fileNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileLocking")
  public static var fileLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnknown")
  public static var fileReadUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoPermission")
  public static var fileReadNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInvalidFileName")
  public static var fileReadInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadCorruptFile")
  public static var fileReadCorruptFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoSuchFile")
  public static var fileReadNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
  public static var fileReadInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
  public static var fileReadUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadTooLarge")
  public static var fileReadTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
  public static var fileReadUnknownStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnknown")
  public static var fileWriteUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteNoPermission")
  public static var fileWriteNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInvalidFileName")
  public static var fileWriteInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.7, iOS 5.0, *)
  @available(*, deprecated, renamed: "fileWriteFileExists")
  public static var fileWriteFileExistsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
  public static var fileWriteInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
  public static var fileWriteUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteOutOfSpace")
  public static var fileWriteOutOfSpaceError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
  public static var fileWriteVolumeReadOnlyError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountUnknown")
  public static var fileManagerUnmountUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountBusy")
  public static var fileManagerUnmountBusyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "keyValueValidation")
  public static var keyValueValidationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "formatting")
  public static var formattingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "userCancelled")
  public static var userCancelledError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  @available(*, deprecated, renamed: "featureUnsupported")
  public static var featureUnsupportedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableNotLoadable")
  public static var executableNotLoadableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableArchitectureMismatch")
  public static var executableArchitectureMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableRuntimeMismatch")
  public static var executableRuntimeMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLoad")
  public static var executableLoadError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLink")
  public static var executableLinkError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadCorrupt")
  public static var propertyListReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
  public static var propertyListReadUnknownVersionError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadStream")
  public static var propertyListReadStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListWriteStream")
  public static var propertyListWriteStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteInvalid")
  public static var propertyListWriteInvalidError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
  public static var ubiquitousFileUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
  public static var ubiquitousFileNotUploadedDueToQuotaError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffFailed")
  public static var userActivityHandoffFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
  public static var userActivityConnectionUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
  public static var userActivityRemoteApplicationTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
  public static var userActivityHandoffUserInfoTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderReadCorrupt")
  public static var coderReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderValueNotFound")
  public static var coderValueNotFoundError: Foundation.CocoaError.Code {
    get
  }
}
extension Foundation.CocoaError {
  public static var fileNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileLocking: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadCorruptFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var fileReadTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var fileReadUnknownStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.7, iOS 5.0, *)
  public static var fileWriteFileExists: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteOutOfSpace: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var fileWriteVolumeReadOnly: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountUnknown: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountBusy: Foundation.CocoaError.Code {
    get
  }
  public static var keyValueValidation: Foundation.CocoaError.Code {
    get
  }
  public static var formatting: Foundation.CocoaError.Code {
    get
  }
  public static var userCancelled: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var featureUnsupported: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableNotLoadable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableArchitectureMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableRuntimeMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableLoad: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableLink: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadUnknownVersion: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListWriteStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListWriteInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionInterrupted: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionReplyInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileNotUploadedDueToQuota: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileUbiquityServerNotAvailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffFailed: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityConnectionUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityRemoteApplicationTimedOut: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffUserInfoTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderValueNotFound: Foundation.CocoaError.Code {
    get
  }
  public static var coderInvalidValue: Foundation.CocoaError.Code {
    get
  }
}
extension Foundation.CocoaError {
  @available(*, deprecated, renamed: "fileNoSuchFile")
  public static var fileNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileLocking")
  public static var fileLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnknown")
  public static var fileReadUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoPermission")
  public static var fileReadNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInvalidFileName")
  public static var fileReadInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadCorruptFile")
  public static var fileReadCorruptFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoSuchFile")
  public static var fileReadNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
  public static var fileReadInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
  public static var fileReadUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadTooLarge")
  public static var fileReadTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
  public static var fileReadUnknownStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnknown")
  public static var fileWriteUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteNoPermission")
  public static var fileWriteNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInvalidFileName")
  public static var fileWriteInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.7, iOS 5.0, *)
  @available(*, deprecated, renamed: "fileWriteFileExists")
  public static var fileWriteFileExistsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
  public static var fileWriteInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
  public static var fileWriteUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteOutOfSpace")
  public static var fileWriteOutOfSpaceError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
  public static var fileWriteVolumeReadOnlyError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountUnknown")
  public static var fileManagerUnmountUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountBusy")
  public static var fileManagerUnmountBusyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "keyValueValidation")
  public static var keyValueValidationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "formatting")
  public static var formattingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "userCancelled")
  public static var userCancelledError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  @available(*, deprecated, renamed: "featureUnsupported")
  public static var featureUnsupportedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableNotLoadable")
  public static var executableNotLoadableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableArchitectureMismatch")
  public static var executableArchitectureMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableRuntimeMismatch")
  public static var executableRuntimeMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLoad")
  public static var executableLoadError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLink")
  public static var executableLinkError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadCorrupt")
  public static var propertyListReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
  public static var propertyListReadUnknownVersionError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadStream")
  public static var propertyListReadStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListWriteStream")
  public static var propertyListWriteStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteInvalid")
  public static var propertyListWriteInvalidError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
  public static var ubiquitousFileUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
  public static var ubiquitousFileNotUploadedDueToQuotaError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffFailed")
  public static var userActivityHandoffFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
  public static var userActivityConnectionUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
  public static var userActivityRemoteApplicationTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
  public static var userActivityHandoffUserInfoTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderReadCorrupt")
  public static var coderReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderValueNotFound")
  public static var coderValueNotFoundError: Foundation.CocoaError.Code {
    get
  }
}
extension Foundation.CocoaError {
  @available(macOS 10.11, iOS 9.0, *)
  public var isCoderError: Swift.Bool {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public var isExecutableError: Swift.Bool {
    get
  }
  public var isFileError: Swift.Bool {
    get
  }
  public var isFormattingError: Swift.Bool {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public var isPropertyListError: Swift.Bool {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public var isUbiquitousFileError: Swift.Bool {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var isUserActivityError: Swift.Bool {
    get
  }
  public var isValidationError: Swift.Bool {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public var isXPCConnectionError: Swift.Bool {
    get
  }
}
public struct URLError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public struct Code : Swift.RawRepresentable, Swift.Hashable, Foundation._ErrorCodeProtocol, Swift.Sendable {
    public typealias _ErrorType = Foundation.URLError
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
  }
}
extension Foundation.URLError.Code {
  public static var unknown: Foundation.URLError.Code {
    get
  }
  public static var cancelled: Foundation.URLError.Code {
    get
  }
  public static var badURL: Foundation.URLError.Code {
    get
  }
  public static var timedOut: Foundation.URLError.Code {
    get
  }
  public static var unsupportedURL: Foundation.URLError.Code {
    get
  }
  public static var cannotFindHost: Foundation.URLError.Code {
    get
  }
  public static var cannotConnectToHost: Foundation.URLError.Code {
    get
  }
  public static var networkConnectionLost: Foundation.URLError.Code {
    get
  }
  public static var dnsLookupFailed: Foundation.URLError.Code {
    get
  }
  public static var httpTooManyRedirects: Foundation.URLError.Code {
    get
  }
  public static var resourceUnavailable: Foundation.URLError.Code {
    get
  }
  public static var notConnectedToInternet: Foundation.URLError.Code {
    get
  }
  public static var redirectToNonExistentLocation: Foundation.URLError.Code {
    get
  }
  public static var badServerResponse: Foundation.URLError.Code {
    get
  }
  public static var userCancelledAuthentication: Foundation.URLError.Code {
    get
  }
  public static var userAuthenticationRequired: Foundation.URLError.Code {
    get
  }
  public static var zeroByteResource: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeRawData: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeContentData: Foundation.URLError.Code {
    get
  }
  public static var cannotParseResponse: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var appTransportSecurityRequiresSecureConnection: Foundation.URLError.Code {
    get
  }
  public static var fileDoesNotExist: Foundation.URLError.Code {
    get
  }
  public static var fileIsDirectory: Foundation.URLError.Code {
    get
  }
  public static var noPermissionsToReadFile: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var dataLengthExceedsMaximum: Foundation.URLError.Code {
    get
  }
  public static var secureConnectionFailed: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasBadDate: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateUntrusted: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasUnknownRoot: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateNotYetValid: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRejected: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRequired: Foundation.URLError.Code {
    get
  }
  public static var cannotLoadFromNetwork: Foundation.URLError.Code {
    get
  }
  public static var cannotCreateFile: Foundation.URLError.Code {
    get
  }
  public static var cannotOpenFile: Foundation.URLError.Code {
    get
  }
  public static var cannotCloseFile: Foundation.URLError.Code {
    get
  }
  public static var cannotWriteToFile: Foundation.URLError.Code {
    get
  }
  public static var cannotRemoveFile: Foundation.URLError.Code {
    get
  }
  public static var cannotMoveFile: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedMidStream: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedToComplete: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var internationalRoamingOff: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var callIsActive: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var dataNotAllowed: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var requestBodyStreamExhausted: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionRequiresSharedContainer: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionInUseByAnotherProcess: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionWasDisconnected: Foundation.URLError.Code {
    get
  }
}
extension Foundation.URLError {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public enum BackgroundTaskCancelledReason : Swift.Int, Swift.Sendable {
    case userForceQuitApplication
    case backgroundUpdatesDisabled
    case insufficientSystemResources
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension Foundation.URLError {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public enum NetworkUnavailableReason : Swift.Int, Swift.Sendable {
    case cellular
    case expensive
    case constrained
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension Foundation.URLError {
  public var failingURL: Foundation.URL? {
    get
  }
  public var failureURLString: Swift.String? {
    get
  }
  public var failureURLPeerTrust: Security.SecTrust? {
    get
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var backgroundTaskCancelledReason: Foundation.URLError.BackgroundTaskCancelledReason? {
    get
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var networkUnavailableReason: Foundation.URLError.NetworkUnavailableReason? {
    get
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var downloadTaskResumeData: Foundation.Data? {
    get
  }
}
extension Foundation.URLError {
  public static var unknown: Foundation.URLError.Code {
    get
  }
  public static var cancelled: Foundation.URLError.Code {
    get
  }
  public static var badURL: Foundation.URLError.Code {
    get
  }
  public static var timedOut: Foundation.URLError.Code {
    get
  }
  public static var unsupportedURL: Foundation.URLError.Code {
    get
  }
  public static var cannotFindHost: Foundation.URLError.Code {
    get
  }
  public static var cannotConnectToHost: Foundation.URLError.Code {
    get
  }
  public static var networkConnectionLost: Foundation.URLError.Code {
    get
  }
  public static var dnsLookupFailed: Foundation.URLError.Code {
    get
  }
  public static var httpTooManyRedirects: Foundation.URLError.Code {
    get
  }
  public static var resourceUnavailable: Foundation.URLError.Code {
    get
  }
  public static var notConnectedToInternet: Foundation.URLError.Code {
    get
  }
  public static var redirectToNonExistentLocation: Foundation.URLError.Code {
    get
  }
  public static var badServerResponse: Foundation.URLError.Code {
    get
  }
  public static var userCancelledAuthentication: Foundation.URLError.Code {
    get
  }
  public static var userAuthenticationRequired: Foundation.URLError.Code {
    get
  }
  public static var zeroByteResource: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeRawData: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeContentData: Foundation.URLError.Code {
    get
  }
  public static var cannotParseResponse: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var appTransportSecurityRequiresSecureConnection: Foundation.URLError.Code {
    get
  }
  public static var fileDoesNotExist: Foundation.URLError.Code {
    get
  }
  public static var fileIsDirectory: Foundation.URLError.Code {
    get
  }
  public static var noPermissionsToReadFile: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var dataLengthExceedsMaximum: Foundation.URLError.Code {
    get
  }
  public static var secureConnectionFailed: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasBadDate: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateUntrusted: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasUnknownRoot: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateNotYetValid: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRejected: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRequired: Foundation.URLError.Code {
    get
  }
  public static var cannotLoadFromNetwork: Foundation.URLError.Code {
    get
  }
  public static var cannotCreateFile: Foundation.URLError.Code {
    get
  }
  public static var cannotOpenFile: Foundation.URLError.Code {
    get
  }
  public static var cannotCloseFile: Foundation.URLError.Code {
    get
  }
  public static var cannotWriteToFile: Foundation.URLError.Code {
    get
  }
  public static var cannotRemoveFile: Foundation.URLError.Code {
    get
  }
  public static var cannotMoveFile: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedMidStream: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedToComplete: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var internationalRoamingOff: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var callIsActive: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var dataNotAllowed: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var requestBodyStreamExhausted: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionRequiresSharedContainer: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionInUseByAnotherProcess: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionWasDisconnected: Foundation.URLError.Code {
    get
  }
}
public struct POSIXError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public typealias Code = Darwin.POSIXErrorCode
}
extension Darwin.POSIXErrorCode : Foundation._ErrorCodeProtocol {
  public typealias _ErrorType = Foundation.POSIXError
}
extension Foundation.POSIXError {
  public static var EPERM: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOENT: Darwin.POSIXErrorCode {
    get
  }
  public static var ESRCH: Darwin.POSIXErrorCode {
    get
  }
  public static var EINTR: Darwin.POSIXErrorCode {
    get
  }
  public static var EIO: Darwin.POSIXErrorCode {
    get
  }
  public static var ENXIO: Darwin.POSIXErrorCode {
    get
  }
  public static var E2BIG: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOEXEC: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADF: Darwin.POSIXErrorCode {
    get
  }
  public static var ECHILD: Darwin.POSIXErrorCode {
    get
  }
  public static var EDEADLK: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOMEM: Darwin.POSIXErrorCode {
    get
  }
  public static var EACCES: Darwin.POSIXErrorCode {
    get
  }
  public static var EFAULT: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTBLK: Darwin.POSIXErrorCode {
    get
  }
  public static var EBUSY: Darwin.POSIXErrorCode {
    get
  }
  public static var EEXIST: Darwin.POSIXErrorCode {
    get
  }
  public static var EXDEV: Darwin.POSIXErrorCode {
    get
  }
  public static var ENODEV: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTDIR: Darwin.POSIXErrorCode {
    get
  }
  public static var EISDIR: Darwin.POSIXErrorCode {
    get
  }
  public static var EINVAL: Darwin.POSIXErrorCode {
    get
  }
  public static var ENFILE: Darwin.POSIXErrorCode {
    get
  }
  public static var EMFILE: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTTY: Darwin.POSIXErrorCode {
    get
  }
  public static var ETXTBSY: Darwin.POSIXErrorCode {
    get
  }
  public static var EFBIG: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOSPC: Darwin.POSIXErrorCode {
    get
  }
  public static var ESPIPE: Darwin.POSIXErrorCode {
    get
  }
  public static var EROFS: Darwin.POSIXErrorCode {
    get
  }
  public static var EMLINK: Darwin.POSIXErrorCode {
    get
  }
  public static var EPIPE: Darwin.POSIXErrorCode {
    get
  }
  public static var EDOM: Darwin.POSIXErrorCode {
    get
  }
  public static var ERANGE: Darwin.POSIXErrorCode {
    get
  }
  public static var EAGAIN: Darwin.POSIXErrorCode {
    get
  }
  public static var EWOULDBLOCK: Darwin.POSIXErrorCode {
    get
  }
  public static var EINPROGRESS: Darwin.POSIXErrorCode {
    get
  }
  public static var EALREADY: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTSOCK: Darwin.POSIXErrorCode {
    get
  }
  public static var EDESTADDRREQ: Darwin.POSIXErrorCode {
    get
  }
  public static var EMSGSIZE: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROTOTYPE: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOPROTOOPT: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROTONOSUPPORT: Darwin.POSIXErrorCode {
    get
  }
  public static var ESOCKTNOSUPPORT: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTSUP: Darwin.POSIXErrorCode {
    get
  }
  public static var EPFNOSUPPORT: Darwin.POSIXErrorCode {
    get
  }
  public static var EAFNOSUPPORT: Darwin.POSIXErrorCode {
    get
  }
  public static var EADDRINUSE: Darwin.POSIXErrorCode {
    get
  }
  public static var EADDRNOTAVAIL: Darwin.POSIXErrorCode {
    get
  }
  public static var ENETDOWN: Darwin.POSIXErrorCode {
    get
  }
  public static var ENETUNREACH: Darwin.POSIXErrorCode {
    get
  }
  public static var ENETRESET: Darwin.POSIXErrorCode {
    get
  }
  public static var ECONNABORTED: Darwin.POSIXErrorCode {
    get
  }
  public static var ECONNRESET: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOBUFS: Darwin.POSIXErrorCode {
    get
  }
  public static var EISCONN: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTCONN: Darwin.POSIXErrorCode {
    get
  }
  public static var ESHUTDOWN: Darwin.POSIXErrorCode {
    get
  }
  public static var ETOOMANYREFS: Darwin.POSIXErrorCode {
    get
  }
  public static var ETIMEDOUT: Darwin.POSIXErrorCode {
    get
  }
  public static var ECONNREFUSED: Darwin.POSIXErrorCode {
    get
  }
  public static var ELOOP: Darwin.POSIXErrorCode {
    get
  }
  public static var ENAMETOOLONG: Darwin.POSIXErrorCode {
    get
  }
  public static var EHOSTDOWN: Darwin.POSIXErrorCode {
    get
  }
  public static var EHOSTUNREACH: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTEMPTY: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROCLIM: Darwin.POSIXErrorCode {
    get
  }
  public static var EUSERS: Darwin.POSIXErrorCode {
    get
  }
  public static var EDQUOT: Darwin.POSIXErrorCode {
    get
  }
  public static var ESTALE: Darwin.POSIXErrorCode {
    get
  }
  public static var EREMOTE: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADRPC: Darwin.POSIXErrorCode {
    get
  }
  public static var ERPCMISMATCH: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROGUNAVAIL: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROGMISMATCH: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROCUNAVAIL: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOLCK: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOSYS: Darwin.POSIXErrorCode {
    get
  }
  public static var EFTYPE: Darwin.POSIXErrorCode {
    get
  }
  public static var EAUTH: Darwin.POSIXErrorCode {
    get
  }
  public static var ENEEDAUTH: Darwin.POSIXErrorCode {
    get
  }
  public static var EPWROFF: Darwin.POSIXErrorCode {
    get
  }
  public static var EDEVERR: Darwin.POSIXErrorCode {
    get
  }
  public static var EOVERFLOW: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADEXEC: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADARCH: Darwin.POSIXErrorCode {
    get
  }
  public static var ESHLIBVERS: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADMACHO: Darwin.POSIXErrorCode {
    get
  }
  public static var ECANCELED: Darwin.POSIXErrorCode {
    get
  }
  public static var EIDRM: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOMSG: Darwin.POSIXErrorCode {
    get
  }
  public static var EILSEQ: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOATTR: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADMSG: Darwin.POSIXErrorCode {
    get
  }
  public static var EMULTIHOP: Darwin.POSIXErrorCode {
    get
  }
  public static var ENODATA: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOLINK: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOSR: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOSTR: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROTO: Darwin.POSIXErrorCode {
    get
  }
  public static var ETIME: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOPOLICY: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTRECOVERABLE: Darwin.POSIXErrorCode {
    get
  }
  public static var EOWNERDEAD: Darwin.POSIXErrorCode {
    get
  }
  public static var EQFULL: Darwin.POSIXErrorCode {
    get
  }
}
public struct MachError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public typealias Code = Darwin.MachErrorCode
}
extension Darwin.MachErrorCode : Foundation._ErrorCodeProtocol {
  public typealias _ErrorType = Foundation.MachError
}
extension Foundation.MachError {
  public static var success: Foundation.MachError.Code {
    get
  }
  public static var invalidAddress: Foundation.MachError.Code {
    get
  }
  public static var protectionFailure: Foundation.MachError.Code {
    get
  }
  public static var noSpace: Foundation.MachError.Code {
    get
  }
  public static var invalidArgument: Foundation.MachError.Code {
    get
  }
  public static var failure: Foundation.MachError.Code {
    get
  }
  public static var resourceShortage: Foundation.MachError.Code {
    get
  }
  public static var notReceiver: Foundation.MachError.Code {
    get
  }
  public static var noAccess: Foundation.MachError.Code {
    get
  }
  public static var memoryFailure: Foundation.MachError.Code {
    get
  }
  public static var memoryError: Foundation.MachError.Code {
    get
  }
  public static var alreadyInSet: Foundation.MachError.Code {
    get
  }
  public static var notInSet: Foundation.MachError.Code {
    get
  }
  public static var nameExists: Foundation.MachError.Code {
    get
  }
  public static var aborted: Foundation.MachError.Code {
    get
  }
  public static var invalidName: Foundation.MachError.Code {
    get
  }
  public static var invalidTask: Foundation.MachError.Code {
    get
  }
  public static var invalidRight: Foundation.MachError.Code {
    get
  }
  public static var invalidValue: Foundation.MachError.Code {
    get
  }
  public static var userReferencesOverflow: Foundation.MachError.Code {
    get
  }
  public static var invalidCapability: Foundation.MachError.Code {
    get
  }
  public static var rightExists: Foundation.MachError.Code {
    get
  }
  public static var invalidHost: Foundation.MachError.Code {
    get
  }
  public static var memoryPresent: Foundation.MachError.Code {
    get
  }
  public static var memoryDataMoved: Foundation.MachError.Code {
    get
  }
  public static var memoryRestartCopy: Foundation.MachError.Code {
    get
  }
  public static var invalidProcessorSet: Foundation.MachError.Code {
    get
  }
  public static var policyLimit: Foundation.MachError.Code {
    get
  }
  public static var invalidPolicy: Foundation.MachError.Code {
    get
  }
  public static var invalidObject: Foundation.MachError.Code {
    get
  }
  public static var alreadyWaiting: Foundation.MachError.Code {
    get
  }
  public static var defaultSet: Foundation.MachError.Code {
    get
  }
  public static var exceptionProtected: Foundation.MachError.Code {
    get
  }
  public static var invalidLedger: Foundation.MachError.Code {
    get
  }
  public static var invalidMemoryControl: Foundation.MachError.Code {
    get
  }
  public static var invalidSecurity: Foundation.MachError.Code {
    get
  }
  public static var notDepressed: Foundation.MachError.Code {
    get
  }
  public static var terminated: Foundation.MachError.Code {
    get
  }
  public static var lockSetDestroyed: Foundation.MachError.Code {
    get
  }
  public static var lockUnstable: Foundation.MachError.Code {
    get
  }
  public static var lockOwned: Foundation.MachError.Code {
    get
  }
  public static var lockOwnedSelf: Foundation.MachError.Code {
    get
  }
  public static var semaphoreDestroyed: Foundation.MachError.Code {
    get
  }
  public static var rpcServerTerminated: Foundation.MachError.Code {
    get
  }
  public static var rpcTerminateOrphan: Foundation.MachError.Code {
    get
  }
  public static var rpcContinueOrphan: Foundation.MachError.Code {
    get
  }
  public static var notSupported: Foundation.MachError.Code {
    get
  }
  public static var nodeDown: Foundation.MachError.Code {
    get
  }
  public static var notWaiting: Foundation.MachError.Code {
    get
  }
  public static var operationTimedOut: Foundation.MachError.Code {
    get
  }
  public static var codesignError: Foundation.MachError.Code {
    get
  }
  public static var policyStatic: Foundation.MachError.Code {
    get
  }
}
public struct ErrorUserInfoKey : Swift.RawRepresentable, Swift._SwiftNewtypeWrapper, Swift.Equatable, Swift.Hashable, Swift._ObjectiveCBridgeable, Swift.Sendable {
  public typealias _ObjectiveCType = Foundation.NSString
  public init(rawValue: Swift.String)
  public var rawValue: Swift.String
  public typealias RawValue = Swift.String
}
extension Foundation.ErrorUserInfoKey {
  @available(*, deprecated, renamed: "NSUnderlyingErrorKey")
  public static let underlyingErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedDescriptionKey")
  public static let localizedDescriptionKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedFailureReasonErrorKey")
  public static let localizedFailureReasonErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedRecoverySuggestionErrorKey")
  public static let localizedRecoverySuggestionErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedRecoveryOptionsErrorKey")
  public static let localizedRecoveryOptionsErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSRecoveryAttempterErrorKey")
  public static let recoveryAttempterErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSHelpAnchorErrorKey")
  public static let helpAnchorErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSStringEncodingErrorKey")
  public static let stringEncodingErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSURLErrorKey")
  public static let NSURLErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSFilePathErrorKey")
  public static let filePathErrorKey: Foundation.ErrorUserInfoKey
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.NotificationCenter {
  public func publisher(for name: Foundation.Notification.Name, object: Swift.AnyObject? = nil) -> Foundation.NotificationCenter.Publisher
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.NotificationCenter {
  public struct Publisher : Combine.Publisher {
    public typealias Output = Foundation.Notification
    public typealias Failure = Swift.Never
    public let center: Foundation.NotificationCenter
    public let name: Foundation.Notification.Name
    public let object: Swift.AnyObject?
    public init(center: Foundation.NotificationCenter, name: Foundation.Notification.Name, object: Swift.AnyObject? = nil)
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == Foundation.Notification
  }
}
@available(iOS, unavailable, introduced: 13)
@available(*, unavailable)
extension Foundation.NotificationCenter.Publisher : @unchecked Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.NotificationCenter.Publisher : Swift.Equatable {
  public static func == (lhs: Foundation.NotificationCenter.Publisher, rhs: Foundation.NotificationCenter.Publisher) -> Swift.Bool
}
@available(*, deprecated, message: "Please use the struct type URLRequest")
public typealias MutableURLRequest = Foundation.NSMutableURLRequest
public struct URLRequest : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSURLRequest
  public typealias CachePolicy = Foundation.NSURLRequest.CachePolicy
  public typealias NetworkServiceType = Foundation.NSURLRequest.NetworkServiceType
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public typealias Attribution = Foundation.NSURLRequest.Attribution
  public init(url: Foundation.URL, cachePolicy: Foundation.URLRequest.CachePolicy = .useProtocolCachePolicy, timeoutInterval: Foundation.TimeInterval = 60.0)
  public var url: Foundation.URL? {
    get
    set
  }
  public var cachePolicy: Foundation.URLRequest.CachePolicy {
    get
    set
  }
  public var timeoutInterval: Foundation.TimeInterval {
    get
    set
  }
  public var mainDocumentURL: Foundation.URL? {
    get
    set
  }
  @available(macOS 10.7, iOS 4.0, *)
  public var networkServiceType: Foundation.URLRequest.NetworkServiceType {
    get
    set
  }
  @available(macOS 10.8, iOS 6.0, *)
  public var allowsCellularAccess: Swift.Bool {
    get
    set
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var allowsExpensiveNetworkAccess: Swift.Bool {
    get
    set
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var allowsConstrainedNetworkAccess: Swift.Bool {
    get
    set
  }
  @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
  public var assumesHTTP3Capable: Swift.Bool {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public var attribution: Foundation.URLRequest.Attribution {
    get
    set
  }
  @available(macOS 13.0, iOS 16.1, watchOS 9.1, tvOS 16.1, *)
  public var requiresDNSSECValidation: Swift.Bool {
    get
    set
  }
  public var httpMethod: Swift.String? {
    get
    set
  }
  public var allHTTPHeaderFields: [Swift.String : Swift.String]? {
    get
    set
  }
  public func value(forHTTPHeaderField field: Swift.String) -> Swift.String?
  public mutating func setValue(_ value: Swift.String?, forHTTPHeaderField field: Swift.String)
  public mutating func addValue(_ value: Swift.String, forHTTPHeaderField field: Swift.String)
  public var httpBody: Foundation.Data? {
    get
    set
  }
  public var httpBodyStream: Foundation.InputStream? {
    get
    set
  }
  public var httpShouldHandleCookies: Swift.Bool {
    get
    set
  }
  @available(macOS 10.7, iOS 4.0, *)
  public var httpShouldUsePipelining: Swift.Bool {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.URLRequest, rhs: Foundation.URLRequest) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.URLRequest : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.URLRequest : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURLRequest
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSURLRequest, result: inout Foundation.URLRequest?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSURLRequest, result: inout Foundation.URLRequest?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURLRequest?) -> Foundation.URLRequest
  public typealias _ObjectiveCType = Foundation.NSURLRequest
}
extension Foundation.NSURLRequest : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.BinaryFloatingPoint {
  public func formatted() -> Swift.String
  public func formatted<S>(_ format: S) -> S.FormatOutput where Self == S.FormatInput, S : Foundation.FormatStyle
  public func formatted<S>(_ format: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput : Swift.BinaryFloatingPoint
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.BinaryFloatingPoint {
  public init<S>(_ value: S.ParseInput, strategy: S) throws where S : Foundation.ParseStrategy, S.ParseOutput : Swift.BinaryFloatingPoint
  public init<S>(_ value: S.ParseInput, strategy: S) throws where Self == S.ParseOutput, S : Foundation.ParseStrategy
  public init(_ value: Swift.String, format: Foundation.FloatingPointFormatStyle<Self>, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.FloatingPointFormatStyle<Self>.Percent, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.FloatingPointFormatStyle<Self>.Currency, lenient: Swift.Bool = true) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
@usableFromInline
@frozen internal struct _AsyncBytesBuffer : @unchecked Swift.Sendable {
  internal var storage: Swift.AnyObject? = nil
  @usableFromInline
  internal var nextPointer: Swift.UnsafeMutableRawPointer
  @usableFromInline
  internal var endPointer: Swift.UnsafeMutableRawPointer
  @usableFromInline
  internal init(capacity: Swift.Int)
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  @inline(never) internal mutating func reloadBufferAndNext() async throws -> Swift.UInt8?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable @inline(__always) internal mutating func next() async throws -> Swift.UInt8? {
        if _fastPath(nextPointer != endPointer) {
            let byte = nextPointer.load(fromByteOffset: 0, as: UInt8.self)
            nextPointer = nextPointer + 1
            return byte
        }
        return try await reloadBufferAndNext()
    }
  #endif
}
extension Foundation.FileHandle {
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct AsyncBytes : _Concurrency.AsyncSequence, Swift.Sendable {
    public typealias Element = Swift.UInt8
    public typealias AsyncIterator = Foundation.FileHandle.AsyncBytes.Iterator
    public func makeAsyncIterator() -> Foundation.FileHandle.AsyncBytes.Iterator
    @frozen public struct Iterator : _Concurrency.AsyncIteratorProtocol, Swift.Sendable {
      public typealias Element = Swift.UInt8
      @usableFromInline
      internal var buffer: Foundation._AsyncBytesBuffer
      #if compiler(>=5.3) && $AsyncAwait
      @inlinable @inline(__always) public mutating func next() async throws -> Swift.UInt8? {
                return try await buffer.next()
            }
      #endif
    }
  }
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var bytes: Foundation.FileHandle.AsyncBytes {
    get
  }
  #endif
}
public struct NSFastEnumerationIterator : Swift.IteratorProtocol {
  public init(_ enumerable: any Foundation.NSFastEnumeration)
  public mutating func next() -> Any?
  public typealias Element = Any
}
extension Foundation.NSEnumerator : Swift.Sequence {
  public func makeIterator() -> Foundation.NSFastEnumerationIterator
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
@available(iOS, unavailable, introduced: 7)
@available(*, unavailable)
extension Foundation.NSFastEnumerationIterator : @unchecked Swift.Sendable {
}
public struct URLComponents : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSURLComponents
  public init()
  public init?(url: __shared Foundation.URL, resolvingAgainstBaseURL resolve: Swift.Bool)
  public init?(string: __shared Swift.String)
  public var url: Foundation.URL? {
    get
  }
  public func url(relativeTo base: Foundation.URL?) -> Foundation.URL?
  @available(macOS 10.10, iOS 8.0, *)
  public var string: Swift.String? {
    get
  }
  public var scheme: Swift.String? {
    get
    set
  }
  public var user: Swift.String? {
    get
    set
  }
  public var password: Swift.String? {
    get
    set
  }
  public var host: Swift.String? {
    get
    set
  }
  public var port: Swift.Int? {
    get
    set
  }
  public var path: Swift.String {
    get
    set
  }
  public var query: Swift.String? {
    get
    set
  }
  public var fragment: Swift.String? {
    get
    set
  }
  public var percentEncodedUser: Swift.String? {
    get
    set
  }
  public var percentEncodedPassword: Swift.String? {
    get
    set
  }
  @available(macOS, introduced: 10.9, deprecated: 100000.0, message: "Use encodedHost instead")
  @available(iOS, introduced: 7.0, deprecated: 100000.0, message: "Use encodedHost instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use encodedHost instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use encodedHost instead")
  public var percentEncodedHost: Swift.String? {
    get
    set
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public var encodedHost: Swift.String? {
    get
    set
  }
  public var percentEncodedPath: Swift.String {
    get
    set
  }
  public var percentEncodedQuery: Swift.String? {
    get
    set
  }
  public var percentEncodedFragment: Swift.String? {
    get
    set
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfScheme: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfUser: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfPassword: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfHost: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfPort: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfPath: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfQuery: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfFragment: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var queryItems: [Foundation.URLQueryItem]? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var percentEncodedQueryItems: [Foundation.URLQueryItem]? {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.URLComponents, rhs: Foundation.URLComponents) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.URLComponents : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.URLComponents : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURLComponents
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSURLComponents, result: inout Foundation.URLComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSURLComponents, result: inout Foundation.URLComponents?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURLComponents?) -> Foundation.URLComponents
  public typealias _ObjectiveCType = Foundation.NSURLComponents
}
extension Foundation.NSURLComponents : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, *)
public struct URLQueryItem : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSURLQueryItem
  public init(name: __shared Swift.String, value: __shared Swift.String?)
  public var name: Swift.String {
    get
    set
  }
  public var value: Swift.String? {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.10, iOS 8.0, *)
  public static func == (lhs: Foundation.URLQueryItem, rhs: Foundation.URLQueryItem) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, *)
extension Foundation.URLQueryItem : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, *)
extension Foundation.URLQueryItem : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURLQueryItem
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSURLQueryItem, result: inout Foundation.URLQueryItem?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSURLQueryItem, result: inout Foundation.URLQueryItem?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURLQueryItem?) -> Foundation.URLQueryItem
  public typealias _ObjectiveCType = Foundation.NSURLQueryItem
}
@available(macOS 10.10, iOS 8.0, *)
extension Foundation.NSURLQueryItem : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.URLComponents : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Dispatch.DispatchData : Foundation.DataProtocol {
  public struct Region : Foundation.DataProtocol, Foundation.ContiguousBytes, Swift.Sendable {
    public var regions: Swift.CollectionOfOne<Dispatch.DispatchData.Region> {
      get
    }
    public subscript(position: Dispatch.DispatchData.Index) -> Swift.UInt8 {
      get
    }
    public var startIndex: Dispatch.DispatchData.Index {
      get
    }
    public var endIndex: Dispatch.DispatchData.Index {
      get
    }
    public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
    public typealias Element = Swift.UInt8
    public typealias Index = Dispatch.DispatchData.Index
    public typealias Indices = Swift.Range<Dispatch.DispatchData.Index>
    public typealias Iterator = Swift.IndexingIterator<Dispatch.DispatchData.Region>
    public typealias Regions = Swift.CollectionOfOne<Dispatch.DispatchData.Region>
    public typealias SubSequence = Swift.Slice<Dispatch.DispatchData.Region>
  }
  public var regions: [Dispatch.DispatchData.Region] {
    get
  }
  public typealias Regions = [Dispatch.DispatchData.Region]
}
extension Foundation.UndoManager {
  @available(macOS 10.11, iOS 9.0, *)
  public func registerUndo<TargetType>(withTarget target: TargetType, handler: @escaping (TargetType) -> Swift.Void) where TargetType : AnyObject
}
extension Swift.EncodingError : Foundation.LocalizedError {
}
extension Swift.DecodingError : Foundation.LocalizedError {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.JSONEncoder : Combine.TopLevelEncoder {
  public typealias Output = Foundation.Data
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.PropertyListEncoder : Combine.TopLevelEncoder {
  public typealias Output = Foundation.Data
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.JSONDecoder : Combine.TopLevelDecoder {
  public typealias Input = Foundation.Data
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.PropertyListDecoder : Combine.TopLevelDecoder {
  public typealias Input = Foundation.Data
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct AsyncCharacterSequence<Base> : _Concurrency.AsyncSequence where Base : _Concurrency.AsyncSequence, Base.Element == Swift.UInt8 {
  public typealias Element = Swift.Character
  @frozen public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var remaining: Foundation.AsyncUnicodeScalarSequence<Base>.AsyncIterator
    @usableFromInline
    internal var accumulator: Swift.String = ""
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable @inline(__always) public mutating func next() async rethrows -> Swift.Character? {
            while let scalar = try await remaining.next() {
                accumulator.unicodeScalars.append(scalar)
                if accumulator.count > 1 {
                    return accumulator.removeFirst()
                }
            }
            return accumulator.count > 0 ? accumulator.removeFirst() : nil
        }
    #endif
    public typealias Element = Swift.Character
  }
  public func makeAsyncIterator() -> Foundation.AsyncCharacterSequence<Base>.AsyncIterator
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.AsyncCharacterSequence : Swift.Sendable where Base : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.AsyncCharacterSequence.AsyncIterator : Swift.Sendable where Base.AsyncIterator : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension _Concurrency.AsyncSequence where Self.Element == Swift.UInt8 {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var characters: Foundation.AsyncCharacterSequence<Self> {
    get
  }
}
#endif
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
public struct DateInterval : Foundation.ReferenceConvertible, Swift.Comparable, Swift.Hashable, Swift.Codable, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSDateInterval
  public var start: Foundation.Date
  public var end: Foundation.Date {
    get
    set
  }
  public var duration: Foundation.TimeInterval {
    get
    set
  }
  public init()
  public init(start: Foundation.Date, end: Foundation.Date)
  public init(start: Foundation.Date, duration: Foundation.TimeInterval)
  public func compare(_ dateInterval: Foundation.DateInterval) -> Foundation.ComparisonResult
  public func intersects(_ dateInterval: Foundation.DateInterval) -> Swift.Bool
  public func intersection(with dateInterval: Foundation.DateInterval) -> Foundation.DateInterval?
  public func contains(_ date: Foundation.Date) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func == (lhs: Foundation.DateInterval, rhs: Foundation.DateInterval) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func < (lhs: Foundation.DateInterval, rhs: Foundation.DateInterval) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.DateInterval : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.DateInterval : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDateInterval
  public static func _forceBridgeFromObjectiveC(_ dateInterval: Foundation.NSDateInterval, result: inout Foundation.DateInterval?)
  public static func _conditionallyBridgeFromObjectiveC(_ dateInterval: Foundation.NSDateInterval, result: inout Foundation.DateInterval?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDateInterval?) -> Foundation.DateInterval
  public typealias _ObjectiveCType = Foundation.NSDateInterval
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.NSDateInterval : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol ParseStrategy : Swift.Decodable, Swift.Encodable, Swift.Hashable {
  associatedtype ParseInput
  associatedtype ParseOutput
  func parse(_ value: Self.ParseInput) throws -> Self.ParseOutput
}
extension Foundation.Progress {
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var estimatedTimeRemaining: Foundation.TimeInterval? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var throughput: Swift.Int? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var fileTotalCount: Swift.Int? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var fileCompletedCount: Swift.Int? {
    get
    set
  }
  public func performAsCurrent<ReturnType>(withPendingUnitCount unitCount: Swift.Int64, using work: () throws -> ReturnType) rethrows -> ReturnType
}
extension Foundation.NSDictionary : Swift.ExpressibleByDictionaryLiteral {
  required convenience public init(dictionaryLiteral elements: (Any, Any)...)
  public typealias Key = Any
  public typealias Value = Any
}
extension Swift.Dictionary : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDictionary
  @_specialize(exported: false, kind: full, where Key == Swift.String, Value == Any)
  public static func _forceBridgeFromObjectiveC(_ d: Foundation.NSDictionary, result: inout Swift.Dictionary<Key, Value>?)
  @_specialize(exported: false, kind: full, where Key == Swift.String, Value == Any)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSDictionary, result: inout Swift.Dictionary<Key, Value>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ d: Foundation.NSDictionary?) -> Swift.Dictionary<Key, Value>
  public typealias _ObjectiveCType = Foundation.NSDictionary
}
extension Foundation.NSDictionary : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.NSDictionary : Swift.Sequence {
  @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCE10FoundationCSo12NSDictionary9_Iterator) final public class Iterator : Swift.IteratorProtocol {
    final public func next() -> (key: Any, value: Any)?
    public typealias Element = (key: Any, value: Any)
    @objc deinit
  }
  @objc dynamic public subscript(key: Any) -> Any? {
    @objc(__swift_objectForKeyedSubscript:) get
  }
  public func makeIterator() -> Foundation.NSDictionary.Iterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  public typealias Element = (key: Any, value: Any)
}
@available(iOS, unavailable, introduced: 7)
@available(*, unavailable)
extension Foundation.NSDictionary.Iterator : @unchecked Swift.Sendable {
}
extension Foundation.NSMutableDictionary {
  @objc override dynamic public subscript(key: Any) -> Any? {
    @objc(__swift_objectForKeyedSubscript:) get
    @objc(__swift_setObject:forKeyedSubscript:) set
  }
}
extension Foundation.NSDictionary {
  @objc(__swiftInitWithDictionary_NSDictionary:) convenience dynamic public init(dictionary otherDictionary: __shared Foundation.NSDictionary)
}
extension Foundation.NSDictionary : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Dictionary : Swift.CVarArg {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public func ISO8601Format(_ style: Foundation.Date.ISO8601FormatStyle = .init()) -> Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct ISO8601FormatStyle : Swift.Sendable {
    public enum TimeZoneSeparator : Swift.String, Swift.Codable, Swift.Sendable {
      case colon
      case omitted
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum DateSeparator : Swift.String, Swift.Codable, Swift.Sendable {
      case dash
      case omitted
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum TimeSeparator : Swift.String, Swift.Codable, Swift.Sendable {
      case colon
      case omitted
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum DateTimeSeparator : Swift.String, Swift.Codable, Swift.Sendable {
      case space
      case standard
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public var timeSeparator: Foundation.Date.ISO8601FormatStyle.TimeSeparator {
      get
    }
    public var includingFractionalSeconds: Swift.Bool {
      get
    }
    public var timeZoneSeparator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator {
      get
    }
    public var dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator {
      get
    }
    public var dateTimeSeparator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator {
      get
    }
    public var timeZone: Foundation.TimeZone
    @_disfavoredOverload public init(dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeZone: Foundation.TimeZone = TimeZone(secondsFromGMT: 0)!)
    public init(dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Foundation.Date.ISO8601FormatStyle.TimeSeparator = .colon, timeZoneSeparator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator = .omitted, includingFractionalSeconds: Swift.Bool = false, timeZone: Foundation.TimeZone = TimeZone(secondsFromGMT: 0)!)
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle {
  public func year() -> Foundation.Date.ISO8601FormatStyle
  public func weekOfYear() -> Foundation.Date.ISO8601FormatStyle
  public func month() -> Foundation.Date.ISO8601FormatStyle
  public func day() -> Foundation.Date.ISO8601FormatStyle
  public func time(includingFractionalSeconds: Swift.Bool) -> Foundation.Date.ISO8601FormatStyle
  public func timeZone(separator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator) -> Foundation.Date.ISO8601FormatStyle
  public func dateSeparator(_ separator: Foundation.Date.ISO8601FormatStyle.DateSeparator) -> Foundation.Date.ISO8601FormatStyle
  public func dateTimeSeparator(_ separator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator) -> Foundation.Date.ISO8601FormatStyle
  public func timeSeparator(_ separator: Foundation.Date.ISO8601FormatStyle.TimeSeparator) -> Foundation.Date.ISO8601FormatStyle
  public func timeZoneSeparator(_ separator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator) -> Foundation.Date.ISO8601FormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ISO8601DateFormatter.Options : Swift.Hashable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle : Foundation.FormatStyle {
  public func format(_ value: Foundation.Date) -> Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.Date.ISO8601FormatStyle, b: Foundation.Date.ISO8601FormatStyle) -> Swift.Bool
  public typealias FormatInput = Foundation.Date
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Foundation.Date
  public typealias ParseInput = Swift.String
  public typealias ParseOutput = Foundation.Date
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Date.ISO8601FormatStyle {
    get
  }
  public typealias Strategy = Foundation.Date.ISO8601FormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.ISO8601FormatStyle {
  public static var iso8601: Foundation.Date.ISO8601FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Date.ISO8601FormatStyle {
  public static var iso8601: Foundation.Date.ISO8601FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseStrategy where Self == Foundation.Date.ISO8601FormatStyle {
  @_disfavoredOverload public static var iso8601: Foundation.Date.ISO8601FormatStyle {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Date.ISO8601FormatStyle : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Date
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Date)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.Date.ISO8601FormatStyle {
  @_disfavoredOverload public static var iso8601: Foundation.Date.ISO8601FormatStyle {
    get
  }
  public static func iso8601WithTimeZone(includingFractionalSeconds: Swift.Bool = false, dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Foundation.Date.ISO8601FormatStyle.TimeSeparator = .colon, timeZoneSeparator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator = .omitted) -> Self
  public static func iso8601(timeZone: Foundation.TimeZone, includingFractionalSeconds: Swift.Bool = false, dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Foundation.Date.ISO8601FormatStyle.TimeSeparator = .colon) -> Self
  public static func iso8601Date(timeZone: Foundation.TimeZone, dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator = .dash) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol ParseableFormatStyle : Foundation.FormatStyle {
  associatedtype Strategy : Foundation.ParseStrategy where Self.FormatInput == Self.Strategy.ParseOutput, Self.FormatOutput == Self.Strategy.ParseInput
  var parseStrategy: Self.Strategy { get }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct ParseStrategy : Swift.Hashable, Swift.Sendable {
    public var isLenient: Swift.Bool
    public var twoDigitStartDate: Foundation.Date
    public var locale: Foundation.Locale?
    public var timeZone: Foundation.TimeZone
    public var calendar: Foundation.Calendar
    public var format: Swift.String {
      get
    }
    public init(format: Foundation.Date.FormatString, locale: Foundation.Locale? = nil, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar = Calendar(identifier: .gregorian), isLenient: Swift.Bool = true, twoDigitStartDate: Foundation.Date = Date(timeIntervalSince1970: 0))
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.ParseStrategy, b: Foundation.Date.ParseStrategy) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ParseStrategy : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Foundation.Date
  public typealias ParseInput = Swift.String
  public typealias ParseOutput = Foundation.Date
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseStrategy {
  public static func fixed(format: Foundation.Date.FormatString, timeZone: Foundation.TimeZone, locale: Foundation.Locale? = nil) -> Self where Self == Foundation.Date.ParseStrategy
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Date.ParseStrategy : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Date
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Date)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.Date.ParseStrategy {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func date(format: Foundation.Date.FormatString, locale: Foundation.Locale, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar? = nil, twoDigitStartDate: Foundation.Date = Date(timeIntervalSince1970: 0)) -> Self
  public typealias DateStyle = Foundation.Date.FormatStyle.DateStyle
  public typealias TimeStyle = Foundation.Date.FormatStyle.TimeStyle
  public static func dateTime(date: Self.DateStyle, time: Self.TimeStyle, locale: Foundation.Locale, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar? = nil) -> Foundation.Date.ParseStrategy
  public static func date(_ style: Self.DateStyle, locale: Foundation.Locale, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar? = nil) -> Foundation.Date.ParseStrategy
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.String {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct LocalizationOptions {
    public var replacements: [any Swift.CVarArg]?
    public init()
  }
  public struct LocalizationValue : Swift.Equatable, Swift.ExpressibleByStringInterpolation {
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public enum Placeholder : Swift.Codable, Swift.Hashable, Swift.Sendable {
      case int
      case uint
      case float
      case double
      case object
      public static func == (a: Swift.String.LocalizationValue.Placeholder, b: Swift.String.LocalizationValue.Placeholder) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public init(_ value: Swift.String)
    @_semantics("localization_key.init_literal") public init(stringLiteral value: Swift.String)
    @_semantics("localization_key.init_interpolation") public init(stringInterpolation: Swift.String.LocalizationValue.StringInterpolation)
    public struct StringInterpolation : Swift.StringInterpolationProtocol {
      @_semantics("localization.interpolation_init") public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int)
      @_semantics("localization.interpolation.appendLiteral") public mutating func appendLiteral(_ literal: Swift.String)
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation(_ string: Swift.String)
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation<Subject>(_ subject: Subject) where Subject : ObjectiveC.NSObject
      @_transparent public mutating func appendInterpolation<T>(_ value: T) where T : Foundation._FormatSpecifiable {
                appendInterpolation(value, specifier: formatSpecifier(T.self))
            }
      @_semantics("localization.interpolation.appendInterpolation_param_specifier") public mutating func appendInterpolation<T>(_ value: T, specifier: Swift.String) where T : Foundation._FormatSpecifiable
      @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
      @_transparent public mutating func appendInterpolation(placeholder: Swift.String.LocalizationValue.Placeholder) {
                appendInterpolation(placeholder: placeholder, specifier: placeholderFormatSpecifier(placeholder))
            }
      @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
      @_semantics("localization.interpolation.appendInterpolation_param_specifier") public mutating func appendInterpolation(placeholder: Swift.String.LocalizationValue.Placeholder, specifier: Swift.String)
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation<T, F>(_ value: T, format: F) where T == F.FormatInput, F : Foundation.FormatStyle, F.FormatOutput : Swift.StringProtocol
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation<T, F>(_ value: T, format: F) where T == F.FormatInput, F : Foundation.FormatStyle, F.FormatOutput : Foundation.AttributedStringProtocol
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation(_ attrStr: Foundation.AttributedString, options: Foundation.AttributedString.InterpolationOptions = [])
      @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation<T>(_ value: T) where T : Foundation.CustomLocalizedStringResourceConvertible
      @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation<C>(_ value: C, format: Foundation.ListFormatStyle<Foundation.StringStyle, [Swift.String]>) where C : Swift.Collection, C.Element : Foundation.CustomLocalizedStringResourceConvertible
      public typealias StringLiteralType = Swift.String
    }
    public static func == (a: Swift.String.LocalizationValue, b: Swift.String.LocalizationValue) -> Swift.Bool
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
  }
  @_semantics("string.init_localized") public init(localized keyAndValue: Swift.String.LocalizationValue, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale = .current, comment: Swift.StaticString? = nil)
  @_semantics("string.init_localized") public init(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale = .current, comment: Swift.StaticString? = nil)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("string.init_localized") public init(localized keyAndValue: Swift.String.LocalizationValue, options: Swift.String.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale = .current, comment: Swift.StaticString? = nil)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("string.init_localized") public init(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Swift.String.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale = .current, comment: Swift.StaticString? = nil)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct LocalizationOptions {
    public var replacements: [any Swift.CVarArg]?
    public var applyReplacementIndexAttribute: Swift.Bool
    public init()
  }
  public struct FormattingOptions : Swift.OptionSet, Swift.Sendable {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let applyReplacementIndexAttribute: Foundation.AttributedString.FormattingOptions
    public typealias ArrayLiteralElement = Foundation.AttributedString.FormattingOptions
    public typealias Element = Foundation.AttributedString.FormattingOptions
    public typealias RawValue = Swift.UInt
  }
  public struct InterpolationOptions : Swift.OptionSet, Swift.Sendable {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let insertAttributesWithoutMerging: Foundation.AttributedString.InterpolationOptions
    public typealias ArrayLiteralElement = Foundation.AttributedString.InterpolationOptions
    public typealias Element = Foundation.AttributedString.InterpolationOptions
    public typealias RawValue = Swift.UInt
  }
  @_semantics("attributed_string.init_localized") public init(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil)
  @_semantics("attributed_string.init_localized") public init(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("attributed_string.init_localized") public init(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("attributed_string.init_localized") public init(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Foundation.AttributedString.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil)
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Foundation.AttributedString.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: S.Type) where S : Foundation.AttributeScope
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: S.Type) where S : Foundation.AttributeScope
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: S.Type) where S : Foundation.AttributeScope
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Foundation.AttributedString.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: S.Type) where S : Foundation.AttributeScope
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Swift.String.LocalizationValue : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
@_alwaysEmitIntoClient @_semantics("constant_evaluable") internal func placeholderFormatSpecifier(_ placeholder: Swift.String.LocalizationValue.Placeholder) -> Swift.String {
    switch placeholder {
    case .int: return "%lld"
    case .uint: return "%llu"
    case .float: return "%f"
    case .double: return "%lf"
    case .object: return "%@"
    default: return "%@"
    }
}
@_alwaysEmitIntoClient @_semantics("constant_evaluable") private func formatSpecifier<T>(_ type: T.Type) -> Swift.String {
    switch type {
    case is Int.Type:
        fallthrough
    case is Int64.Type:
        return "%lld"
    case is Int8.Type:
        fallthrough
    case is Int16.Type:
        fallthrough
    case is Int32.Type:
        return "%d"
    case is UInt.Type:
        fallthrough
    case is UInt64.Type:
        return "%llu"
    case is UInt8.Type:
        fallthrough
    case is UInt16.Type:
        fallthrough
    case is UInt32.Type:
        return "%u"
    case is Float.Type:
        return "%f"
    case is CGFloat.Type:
        fallthrough
    case is Double.Type:
        return "%lf"
    default:
        return "%@"
    }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol _FormatSpecifiable : Swift.Equatable {
  associatedtype _Arg : Swift.CVarArg
  var _arg: Self._Arg { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int64 {
    get
  }
  public typealias _Arg = Swift.Int64
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int8 : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int32 {
    get
  }
  public typealias _Arg = Swift.Int32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int16 : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int32 {
    get
  }
  public typealias _Arg = Swift.Int32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int32 : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int32 {
    get
  }
  public typealias _Arg = Swift.Int32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int64 : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int64 {
    get
  }
  public typealias _Arg = Swift.Int64
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt64 {
    get
  }
  public typealias _Arg = Swift.UInt64
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt8 : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt32 {
    get
  }
  public typealias _Arg = Swift.UInt32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt16 : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt32 {
    get
  }
  public typealias _Arg = Swift.UInt32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt32 : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt32 {
    get
  }
  public typealias _Arg = Swift.UInt32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt64 : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt64 {
    get
  }
  public typealias _Arg = Swift.UInt64
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Float : Foundation._FormatSpecifiable {
  public var _arg: Swift.Float {
    get
  }
  public typealias _Arg = Swift.Float
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Double : Foundation._FormatSpecifiable {
  public var _arg: Swift.Double {
    get
  }
  public typealias _Arg = Swift.Double
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension CoreFoundation.CGFloat : Foundation._FormatSpecifiable {
  public var _arg: CoreFoundation.CGFloat {
    get
  }
  public typealias _Arg = CoreFoundation.CGFloat
}
@available(iOS, unavailable, introduced: 16)
@available(*, unavailable)
extension Swift.String.LocalizationOptions : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 16)
@available(*, unavailable)
extension Foundation.AttributedString.LocalizationOptions : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Swift.String.LocalizationValue : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Swift.String.LocalizationValue.StringInterpolation : @unchecked Swift.Sendable {
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public struct LocalizedStringResource : Swift.Equatable, Swift.Codable, Foundation.CustomLocalizedStringResourceConvertible, Swift.ExpressibleByStringInterpolation {
  public let key: Swift.String
  public let defaultValue: Swift.String.LocalizationValue
  public let table: Swift.String?
  public var locale: Foundation.Locale
  public var bundle: Foundation.LocalizedStringResource.BundleDescription {
    get
  }
  public enum BundleDescription : Swift.Sendable {
    case main
    case forClass(Swift.AnyClass)
    case atURL(Foundation.URL)
  }
  @_semantics("string.init_localized") public init(_ keyAndValue: Swift.String.LocalizationValue, table: Swift.String? = nil, locale: Foundation.Locale = .current, bundle: Foundation.LocalizedStringResource.BundleDescription = .main, comment: Swift.StaticString? = nil)
  @_semantics("string.init_localized") public init(_ key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, table: Swift.String? = nil, locale: Foundation.Locale = .current, bundle: Foundation.LocalizedStringResource.BundleDescription = .main, comment: Swift.StaticString? = nil)
  @_semantics("localization_key.init_literal") public init(stringLiteral value: Swift.String)
  @_semantics("localization_key.init_interpolation") public init(stringInterpolation: Swift.String.LocalizationValue.StringInterpolation)
  public var localizedStringResource: Foundation.LocalizedStringResource {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (lhs: Foundation.LocalizedStringResource, rhs: Foundation.LocalizedStringResource) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringInterpolation = Swift.String.LocalizationValue.StringInterpolation
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(iOS, unavailable, introduced: 16)
@available(*, unavailable)
extension Foundation.LocalizedStringResource : @unchecked Swift.Sendable {
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Swift.String {
  @_disfavoredOverload public init(localized resource: Foundation.LocalizedStringResource)
  @_disfavoredOverload public init(localized resource: Foundation.LocalizedStringResource, options: Swift.String.LocalizationOptions)
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributedString {
  @_disfavoredOverload public init(localized resource: Foundation.LocalizedStringResource)
  @_disfavoredOverload public init<S>(localized resource: Foundation.LocalizedStringResource, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope
  @_disfavoredOverload public init<S>(localized resource: Foundation.LocalizedStringResource, including scope: S.Type) where S : Foundation.AttributeScope
  @_disfavoredOverload public init(localized resource: Foundation.LocalizedStringResource, options: Foundation.AttributedString.LocalizationOptions)
  @_disfavoredOverload public init<S>(localized resource: Foundation.LocalizedStringResource, options: Foundation.AttributedString.LocalizationOptions, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope
  @_disfavoredOverload public init<S>(localized resource: Foundation.LocalizedStringResource, options: Foundation.AttributedString.LocalizationOptions, including scope: S.Type) where S : Foundation.AttributeScope
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public protocol CustomLocalizedStringResourceConvertible {
  var localizedStringResource: Foundation.LocalizedStringResource { get }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct IntegerFormatStyle<Value> : Swift.Codable, Swift.Hashable, Swift.Sendable where Value : Swift.BinaryInteger {
  public var locale: Foundation.Locale
  public init(locale: Foundation.Locale = .autoupdatingCurrent)
  public var attributed: Foundation.IntegerFormatStyle<Value>.Attributed {
    get
  }
  public typealias Configuration = Foundation.NumberFormatStyleConfiguration
  public func grouping(_ group: Foundation.IntegerFormatStyle<Value>.Configuration.Grouping) -> Foundation.IntegerFormatStyle<Value>
  public func precision(_ p: Foundation.IntegerFormatStyle<Value>.Configuration.Precision) -> Foundation.IntegerFormatStyle<Value>
  public func sign(strategy: Foundation.IntegerFormatStyle<Value>.Configuration.SignDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>
  public func decimalSeparator(strategy: Foundation.IntegerFormatStyle<Value>.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>
  public func rounded(rule: Foundation.IntegerFormatStyle<Value>.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.IntegerFormatStyle<Value>
  public func scale(_ multiplicand: Swift.Double) -> Foundation.IntegerFormatStyle<Value>
  public func notation(_ notation: Foundation.IntegerFormatStyle<Value>.Configuration.Notation) -> Foundation.IntegerFormatStyle<Value>
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.IntegerFormatStyle<Value>, b: Foundation.IntegerFormatStyle<Value>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle {
  public struct Percent : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var locale: Foundation.Locale
    public init(locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.IntegerFormatStyle<Value>.Attributed {
      get
    }
    public typealias Configuration = Foundation.NumberFormatStyleConfiguration
    public func grouping(_ group: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.Grouping) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func precision(_ p: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.Precision) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func sign(strategy: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.SignDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func decimalSeparator(strategy: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func rounded(rule: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func scale(_ multiplicand: Swift.Double) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func notation(_ notation: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.Notation) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.IntegerFormatStyle<Value>.Percent, b: Foundation.IntegerFormatStyle<Value>.Percent) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct Currency : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public typealias Configuration = Foundation.CurrencyFormatStyleConfiguration
    public var locale: Foundation.Locale
    public let currencyCode: Swift.String
    public init(code: Swift.String, locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.IntegerFormatStyle<Value>.Attributed {
      get
    }
    public func grouping(_ group: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.Grouping) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func precision(_ p: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.Precision) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func sign(strategy: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.SignDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func decimalSeparator(strategy: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func rounded(rule: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func scale(_ multiplicand: Swift.Double) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func presentation(_ p: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.Presentation) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.IntegerFormatStyle<Value>.Currency, b: Foundation.IntegerFormatStyle<Value>.Currency) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle : Foundation.FormatStyle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.IntegerFormatStyle<Value>
  public typealias FormatInput = Value
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle.Percent : Foundation.FormatStyle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.IntegerFormatStyle<Value>.Percent
  public typealias FormatInput = Value
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle.Currency : Foundation.FormatStyle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.IntegerFormatStyle<Value>.Currency
  public typealias FormatInput = Value
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>> {
    get
  }
  public typealias Strategy = Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle.Currency : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>.Currency> {
    get
  }
  public typealias Strategy = Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>.Currency>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle.Percent : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>.Percent> {
    get
  }
  public typealias Strategy = Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>.Percent>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int16> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int16> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int32> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int32> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int64> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int64> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int8> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int8> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt16> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt16> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt32> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt32> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt64> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt64> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt8> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt8> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int16>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int16>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int32>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int32>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int64>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int64>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int8>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int8>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt16>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt16>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt32>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt32>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt64>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt64>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt8>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt8>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public static func currency<V>(code: Swift.String) -> Self where Self == Foundation.IntegerFormatStyle<V>.Currency, V : Swift.BinaryInteger
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle {
  public struct Attributed : Swift.Codable, Swift.Hashable, Foundation.FormatStyle, Swift.Sendable {
    public func format(_ value: Value) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.IntegerFormatStyle<Value>.Attributed
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.IntegerFormatStyle<Value>.Attributed, b: Foundation.IntegerFormatStyle<Value>.Attributed) -> Swift.Bool
    public typealias FormatInput = Value
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.IntegerFormatStyle : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Value
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Value)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.IntegerFormatStyle.Percent : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Value
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Value)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.IntegerFormatStyle.Currency : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Value
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Value)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.IntegerFormatStyle<Swift.Int> {
  public static func localizedInteger(locale: Foundation.Locale) -> Self
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.IntegerFormatStyle<Swift.Int>.Percent {
  public static func localizedIntegerPercentage(locale: Foundation.Locale) -> Self
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.IntegerFormatStyle<Swift.Int>.Currency {
  public static func localizedIntegerCurrency(code: Foundation.Locale.Currency, locale: Foundation.Locale) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct ByteCountFormatStyle : Foundation.FormatStyle, Swift.Sendable {
  public var style: Foundation.ByteCountFormatStyle.Style {
    get
    set
  }
  public var allowedUnits: Foundation.ByteCountFormatStyle.Units {
    get
    set
  }
  public var spellsOutZero: Swift.Bool {
    get
    set
  }
  public var includesActualByteCount: Swift.Bool {
    get
    set
  }
  public var locale: Foundation.Locale {
    get
    set
  }
  public var attributed: Foundation.ByteCountFormatStyle.Attributed
  public func format(_ value: Swift.Int64) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.ByteCountFormatStyle
  public init(style: Foundation.ByteCountFormatStyle.Style = .file, allowedUnits: Foundation.ByteCountFormatStyle.Units = .all, spellsOutZero: Swift.Bool = true, includesActualByteCount: Swift.Bool = false, locale: Foundation.Locale = .autoupdatingCurrent)
  public enum Style : Swift.Int, Swift.Codable, Swift.Hashable, Swift.Sendable {
    case file, memory, decimal, binary
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public struct Units : Swift.OptionSet, Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static var bytes: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var kb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var mb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var gb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var tb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var pb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var eb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var zb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var ybOrHigher: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var all: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var `default`: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public typealias ArrayLiteralElement = Foundation.ByteCountFormatStyle.Units
    public typealias Element = Foundation.ByteCountFormatStyle.Units
    public typealias RawValue = Swift.UInt
  }
  public struct Attributed : Foundation.FormatStyle, Swift.Sendable {
    public var style: Foundation.ByteCountFormatStyle.Style
    public var allowedUnits: Foundation.ByteCountFormatStyle.Units
    public var spellsOutZero: Swift.Bool
    public var includesActualByteCount: Swift.Bool
    public var locale: Foundation.Locale
    public func locale(_ locale: Foundation.Locale) -> Foundation.ByteCountFormatStyle.Attributed
    public func format(_ value: Swift.Int64) -> Foundation.AttributedString
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.ByteCountFormatStyle.Attributed, b: Foundation.ByteCountFormatStyle.Attributed) -> Swift.Bool
    public typealias FormatInput = Swift.Int64
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.ByteCountFormatStyle, b: Foundation.ByteCountFormatStyle) -> Swift.Bool
  public typealias FormatInput = Swift.Int64
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.ByteCountFormatStyle {
  public static func byteCount(style: Foundation.ByteCountFormatStyle.Style, allowedUnits: Foundation.ByteCountFormatStyle.Units = .all, spellsOutZero: Swift.Bool = true, includesActualByteCount: Swift.Bool = false) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Range where Bound == Foundation.Date {
  public func formatted<S>(_ style: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Swift.Range<Foundation.Date>
  public func formatted() -> Swift.String
  public func formatted(date: Foundation.Date.IntervalFormatStyle.DateStyle, time: Foundation.Date.IntervalFormatStyle.TimeStyle) -> Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal {
  public struct FormatStyle : Foundation.FormatStyle, Swift.Sendable {
    public var locale: Foundation.Locale
    public init(locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.Decimal.FormatStyle.Attributed {
      get
    }
    public typealias Configuration = Foundation.NumberFormatStyleConfiguration
    public func grouping(_ group: Foundation.Decimal.FormatStyle.Configuration.Grouping) -> Foundation.Decimal.FormatStyle
    public func precision(_ p: Foundation.Decimal.FormatStyle.Configuration.Precision) -> Foundation.Decimal.FormatStyle
    public func sign(strategy: Foundation.Decimal.FormatStyle.Configuration.SignDisplayStrategy) -> Foundation.Decimal.FormatStyle
    public func decimalSeparator(strategy: Foundation.Decimal.FormatStyle.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.Decimal.FormatStyle
    public func rounded(rule: Foundation.Decimal.FormatStyle.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.Decimal.FormatStyle
    public func scale(_ multiplicand: Swift.Double) -> Foundation.Decimal.FormatStyle
    public func notation(_ notation: Foundation.Decimal.FormatStyle.Configuration.Notation) -> Foundation.Decimal.FormatStyle
    public func format(_ value: Foundation.Decimal) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Decimal.FormatStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Decimal.FormatStyle, b: Foundation.Decimal.FormatStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.Decimal
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle {
  public struct Percent : Foundation.FormatStyle, Swift.Sendable {
    public var locale: Foundation.Locale
    public init(locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.Decimal.FormatStyle.Attributed {
      get
    }
    public typealias Configuration = Foundation.NumberFormatStyleConfiguration
    public func grouping(_ group: Foundation.Decimal.FormatStyle.Percent.Configuration.Grouping) -> Foundation.Decimal.FormatStyle.Percent
    public func precision(_ p: Foundation.Decimal.FormatStyle.Percent.Configuration.Precision) -> Foundation.Decimal.FormatStyle.Percent
    public func sign(strategy: Foundation.Decimal.FormatStyle.Percent.Configuration.SignDisplayStrategy) -> Foundation.Decimal.FormatStyle.Percent
    public func decimalSeparator(strategy: Foundation.Decimal.FormatStyle.Percent.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.Decimal.FormatStyle.Percent
    public func rounded(rule: Foundation.Decimal.FormatStyle.Percent.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.Decimal.FormatStyle.Percent
    public func scale(_ multiplicand: Swift.Double) -> Foundation.Decimal.FormatStyle.Percent
    public func notation(_ notation: Foundation.Decimal.FormatStyle.Percent.Configuration.Notation) -> Foundation.Decimal.FormatStyle.Percent
    public func format(_ value: Foundation.Decimal) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Decimal.FormatStyle.Percent
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Decimal.FormatStyle.Percent, b: Foundation.Decimal.FormatStyle.Percent) -> Swift.Bool
    public typealias FormatInput = Foundation.Decimal
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct Currency : Foundation.FormatStyle, Swift.Sendable {
    public typealias Configuration = Foundation.CurrencyFormatStyleConfiguration
    public var locale: Foundation.Locale
    public var currencyCode: Swift.String
    public init(code: Swift.String, locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.Decimal.FormatStyle.Attributed {
      get
    }
    public func grouping(_ group: Foundation.Decimal.FormatStyle.Currency.Configuration.Grouping) -> Foundation.Decimal.FormatStyle.Currency
    public func precision(_ p: Foundation.Decimal.FormatStyle.Currency.Configuration.Precision) -> Foundation.Decimal.FormatStyle.Currency
    public func sign(strategy: Foundation.Decimal.FormatStyle.Currency.Configuration.SignDisplayStrategy) -> Foundation.Decimal.FormatStyle.Currency
    public func decimalSeparator(strategy: Foundation.Decimal.FormatStyle.Currency.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.Decimal.FormatStyle.Currency
    public func rounded(rule: Foundation.Decimal.FormatStyle.Currency.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.Decimal.FormatStyle.Currency
    public func scale(_ multiplicand: Swift.Double) -> Foundation.Decimal.FormatStyle.Currency
    public func presentation(_ p: Foundation.Decimal.FormatStyle.Currency.Configuration.Presentation) -> Foundation.Decimal.FormatStyle.Currency
    public func format(_ value: Foundation.Decimal) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Decimal.FormatStyle.Currency
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Decimal.FormatStyle.Currency, b: Foundation.Decimal.FormatStyle.Currency) -> Swift.Bool
    public typealias FormatInput = Foundation.Decimal
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Attributed : Foundation.FormatStyle, Swift.Sendable {
    public func format(_ value: Foundation.Decimal) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.Decimal.FormatStyle.Attributed
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Decimal.FormatStyle.Attributed, b: Foundation.Decimal.FormatStyle.Attributed) -> Swift.Bool
    public typealias FormatInput = Foundation.Decimal
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle> {
    get
  }
  public typealias Strategy = Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle.Currency : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle.Currency> {
    get
  }
  public typealias Strategy = Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle.Currency>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle.Percent : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle.Percent> {
    get
  }
  public typealias Strategy = Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle.Percent>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Decimal.FormatStyle {
  public static var number: Foundation.Decimal.FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Decimal.FormatStyle.Percent {
  public static var percent: Foundation.Decimal.FormatStyle.Percent {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Decimal.FormatStyle.Currency {
  public static func currency(code: Swift.String) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Decimal.FormatStyle {
  public static var number: Foundation.Decimal.FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Decimal.FormatStyle.Percent {
  public static var percent: Foundation.Decimal.FormatStyle.Percent {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Decimal.FormatStyle.Currency {
  public static func currency(code: Swift.String) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal {
  public func formatted() -> Swift.String
  public func formatted<S>(_ format: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Foundation.Decimal
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Decimal.FormatStyle : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Decimal
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Decimal)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Decimal.FormatStyle.Percent : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Decimal
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Decimal)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Decimal.FormatStyle.Currency : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Decimal
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Decimal)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.Decimal.FormatStyle {
  public static func localizedDecimal(locale: Foundation.Locale) -> Self
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.Decimal.FormatStyle.Currency {
  public static func localizedCurrency(code: Foundation.Locale.Currency, locale: Foundation.Locale) -> Self
}
@available(macOS 10.8, iOS 6.0, *)
public struct UUID : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable, Swift.CustomStringConvertible, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSUUID
  public var uuid: (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8) {
    get
  }
  public init()
  public init?(uuidString string: __shared Swift.String)
  public init(uuid: Darwin.uuid_t)
  public var uuidString: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: Foundation.UUID, rhs: Foundation.UUID) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.UUID : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.UUID : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSUUID
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSUUID, result: inout Foundation.UUID?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSUUID, result: inout Foundation.UUID?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSUUID?) -> Foundation.UUID
  public typealias _ObjectiveCType = Foundation.NSUUID
}
extension Foundation.NSUUID : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.UUID : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct DateComponents : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSDateComponents
  public init(calendar: Foundation.Calendar? = nil, timeZone: Foundation.TimeZone? = nil, era: Swift.Int? = nil, year: Swift.Int? = nil, month: Swift.Int? = nil, day: Swift.Int? = nil, hour: Swift.Int? = nil, minute: Swift.Int? = nil, second: Swift.Int? = nil, nanosecond: Swift.Int? = nil, weekday: Swift.Int? = nil, weekdayOrdinal: Swift.Int? = nil, quarter: Swift.Int? = nil, weekOfMonth: Swift.Int? = nil, weekOfYear: Swift.Int? = nil, yearForWeekOfYear: Swift.Int? = nil)
  public var calendar: Foundation.Calendar? {
    get
    set
  }
  public var timeZone: Foundation.TimeZone? {
    get
    set
  }
  public var era: Swift.Int? {
    get
    set
  }
  public var year: Swift.Int? {
    get
    set
  }
  public var month: Swift.Int? {
    get
    set
  }
  public var day: Swift.Int? {
    get
    set
  }
  public var hour: Swift.Int? {
    get
    set
  }
  public var minute: Swift.Int? {
    get
    set
  }
  public var second: Swift.Int? {
    get
    set
  }
  public var nanosecond: Swift.Int? {
    get
    set
  }
  public var weekday: Swift.Int? {
    get
    set
  }
  public var weekdayOrdinal: Swift.Int? {
    get
    set
  }
  public var quarter: Swift.Int? {
    get
    set
  }
  public var weekOfMonth: Swift.Int? {
    get
    set
  }
  public var weekOfYear: Swift.Int? {
    get
    set
  }
  public var yearForWeekOfYear: Swift.Int? {
    get
    set
  }
  public var isLeapMonth: Swift.Bool? {
    get
    set
  }
  public var date: Foundation.Date? {
    get
  }
  @available(macOS 10.9, iOS 8.0, *)
  public mutating func setValue(_ value: Swift.Int?, for component: Foundation.Calendar.Component)
  @available(macOS 10.9, iOS 8.0, *)
  public func value(for component: Foundation.Calendar.Component) -> Swift.Int?
  @available(macOS 10.9, iOS 8.0, *)
  public var isValidDate: Swift.Bool {
    get
  }
  @available(macOS 10.9, iOS 8.0, *)
  public func isValidDate(in calendar: Foundation.Calendar) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.DateComponents, rhs: Foundation.DateComponents) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.DateComponents : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.DateComponents : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDateComponents
  public static func _forceBridgeFromObjectiveC(_ dateComponents: Foundation.NSDateComponents, result: inout Foundation.DateComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ dateComponents: Foundation.NSDateComponents, result: inout Foundation.DateComponents?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDateComponents?) -> Foundation.DateComponents
  public typealias _ObjectiveCType = Foundation.NSDateComponents
}
extension Foundation.NSDateComponents : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.DateComponents : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct Calendar : Swift.Hashable, Swift.Equatable, Foundation.ReferenceConvertible, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSCalendar
  public enum Identifier : Swift.Sendable {
    case gregorian
    case buddhist
    case chinese
    case coptic
    case ethiopicAmeteMihret
    case ethiopicAmeteAlem
    case hebrew
    case iso8601
    case indian
    case islamic
    case islamicCivil
    case japanese
    case persian
    case republicOfChina
    @available(macOS 10.10, iOS 8.0, *)
    case islamicTabular
    @available(macOS 10.10, iOS 8.0, *)
    case islamicUmmAlQura
    public static func == (a: Foundation.Calendar.Identifier, b: Foundation.Calendar.Identifier) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Component : Swift.Sendable {
    case era
    case year
    case month
    case day
    case hour
    case minute
    case second
    case weekday
    case weekdayOrdinal
    case quarter
    case weekOfMonth
    case weekOfYear
    case yearForWeekOfYear
    case nanosecond
    case calendar
    case timeZone
    public static func == (a: Foundation.Calendar.Component, b: Foundation.Calendar.Component) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var current: Foundation.Calendar {
    get
  }
  public static var autoupdatingCurrent: Foundation.Calendar {
    get
  }
  public init(identifier: __shared Foundation.Calendar.Identifier)
  public var identifier: Foundation.Calendar.Identifier {
    get
  }
  public var locale: Foundation.Locale? {
    get
    set
  }
  public var timeZone: Foundation.TimeZone {
    get
    set
  }
  public var firstWeekday: Swift.Int {
    get
    set
  }
  public var minimumDaysInFirstWeek: Swift.Int {
    get
    set
  }
  public var eraSymbols: [Swift.String] {
    get
  }
  public var longEraSymbols: [Swift.String] {
    get
  }
  public var monthSymbols: [Swift.String] {
    get
  }
  public var shortMonthSymbols: [Swift.String] {
    get
  }
  public var veryShortMonthSymbols: [Swift.String] {
    get
  }
  public var standaloneMonthSymbols: [Swift.String] {
    get
  }
  public var shortStandaloneMonthSymbols: [Swift.String] {
    get
  }
  public var veryShortStandaloneMonthSymbols: [Swift.String] {
    get
  }
  public var weekdaySymbols: [Swift.String] {
    get
  }
  public var shortWeekdaySymbols: [Swift.String] {
    get
  }
  public var veryShortWeekdaySymbols: [Swift.String] {
    get
  }
  public var standaloneWeekdaySymbols: [Swift.String] {
    get
  }
  public var shortStandaloneWeekdaySymbols: [Swift.String] {
    get
  }
  public var veryShortStandaloneWeekdaySymbols: [Swift.String] {
    get
  }
  public var quarterSymbols: [Swift.String] {
    get
  }
  public var shortQuarterSymbols: [Swift.String] {
    get
  }
  public var standaloneQuarterSymbols: [Swift.String] {
    get
  }
  public var shortStandaloneQuarterSymbols: [Swift.String] {
    get
  }
  public var amSymbol: Swift.String {
    get
  }
  public var pmSymbol: Swift.String {
    get
  }
  public func minimumRange(of component: Foundation.Calendar.Component) -> Swift.Range<Swift.Int>?
  public func maximumRange(of component: Foundation.Calendar.Component) -> Swift.Range<Swift.Int>?
  public func range(of smaller: Foundation.Calendar.Component, in larger: Foundation.Calendar.Component, for date: Foundation.Date) -> Swift.Range<Swift.Int>?
  public func dateInterval(of component: Foundation.Calendar.Component, start: inout Foundation.Date, interval: inout Foundation.TimeInterval, for date: Foundation.Date) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func dateInterval(of component: Foundation.Calendar.Component, for date: Foundation.Date) -> Foundation.DateInterval?
  public func ordinality(of smaller: Foundation.Calendar.Component, in larger: Foundation.Calendar.Component, for date: Foundation.Date) -> Swift.Int?
  public func date(byAdding components: Foundation.DateComponents, to date: Foundation.Date, wrappingComponents: Swift.Bool = false) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(byAdding component: Foundation.Calendar.Component, value: Swift.Int, to date: Foundation.Date, wrappingComponents: Swift.Bool = false) -> Foundation.Date?
  public func date(from components: Foundation.DateComponents) -> Foundation.Date?
  public func dateComponents(_ components: Swift.Set<Foundation.Calendar.Component>, from date: Foundation.Date) -> Foundation.DateComponents
  @available(iOS 8.0, *)
  public func dateComponents(in timeZone: Foundation.TimeZone, from date: Foundation.Date) -> Foundation.DateComponents
  public func dateComponents(_ components: Swift.Set<Foundation.Calendar.Component>, from start: Foundation.Date, to end: Foundation.Date) -> Foundation.DateComponents
  @available(iOS 8.0, *)
  public func dateComponents(_ components: Swift.Set<Foundation.Calendar.Component>, from start: Foundation.DateComponents, to end: Foundation.DateComponents) -> Foundation.DateComponents
  @available(iOS 8.0, *)
  public func component(_ component: Foundation.Calendar.Component, from date: Foundation.Date) -> Swift.Int
  @available(iOS 8.0, *)
  public func startOfDay(for date: Foundation.Date) -> Foundation.Date
  @available(iOS 8.0, *)
  public func compare(_ date1: Foundation.Date, to date2: Foundation.Date, toGranularity component: Foundation.Calendar.Component) -> Foundation.ComparisonResult
  @available(iOS 8.0, *)
  public func isDate(_ date1: Foundation.Date, equalTo date2: Foundation.Date, toGranularity component: Foundation.Calendar.Component) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDate(_ date1: Foundation.Date, inSameDayAs date2: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInToday(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInYesterday(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInTomorrow(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInWeekend(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func dateIntervalOfWeekend(containing date: Foundation.Date, start: inout Foundation.Date, interval: inout Foundation.TimeInterval) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func dateIntervalOfWeekend(containing date: Foundation.Date) -> Foundation.DateInterval?
  @available(iOS 8.0, *)
  public func nextWeekend(startingAfter date: Foundation.Date, start: inout Foundation.Date, interval: inout Foundation.TimeInterval, direction: Foundation.Calendar.SearchDirection = .forward) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func nextWeekend(startingAfter date: Foundation.Date, direction: Foundation.Calendar.SearchDirection = .forward) -> Foundation.DateInterval?
  public enum SearchDirection : Swift.Sendable {
    case forward
    case backward
    public static func == (a: Foundation.Calendar.SearchDirection, b: Foundation.Calendar.SearchDirection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum RepeatedTimePolicy : Swift.Sendable {
    case first
    case last
    public static func == (a: Foundation.Calendar.RepeatedTimePolicy, b: Foundation.Calendar.RepeatedTimePolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum MatchingPolicy : Swift.Sendable {
    case nextTime
    case nextTimePreservingSmallerComponents
    case previousTimePreservingSmallerComponents
    case strict
    public static func == (a: Foundation.Calendar.MatchingPolicy, b: Foundation.Calendar.MatchingPolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(iOS 8.0, *)
  public func enumerateDates(startingAfter start: Foundation.Date, matching components: Foundation.DateComponents, matchingPolicy: Foundation.Calendar.MatchingPolicy, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, direction: Foundation.Calendar.SearchDirection = .forward, using block: (_ result: Foundation.Date?, _ exactMatch: Swift.Bool, _ stop: inout Swift.Bool) -> Swift.Void)
  @available(iOS 8.0, *)
  public func nextDate(after date: Foundation.Date, matching components: Foundation.DateComponents, matchingPolicy: Foundation.Calendar.MatchingPolicy, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, direction: Foundation.Calendar.SearchDirection = .forward) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(bySetting component: Foundation.Calendar.Component, value: Swift.Int, of date: Foundation.Date) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(bySettingHour hour: Swift.Int, minute: Swift.Int, second: Swift.Int, of date: Foundation.Date, matchingPolicy: Foundation.Calendar.MatchingPolicy = .nextTime, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, direction: Foundation.Calendar.SearchDirection = .forward) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(_ date: Foundation.Date, matchesComponents components: Foundation.DateComponents) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.Calendar, rhs: Foundation.Calendar) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Calendar : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.Calendar : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSCalendar
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSCalendar, result: inout Foundation.Calendar?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSCalendar, result: inout Foundation.Calendar?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSCalendar?) -> Foundation.Calendar
  public typealias _ObjectiveCType = Foundation.NSCalendar
}
extension Foundation.NSCalendar : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.Calendar : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Foundation.Calendar.Identifier : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ObjectiveC.NSObject : Swift.CustomStringConvertible {
}
extension ObjectiveC.NSObject : Swift.CustomDebugStringConvertible {
}
public let NSNotFound: Swift.Int
public func NSLocalizedString(_ key: Swift.String, tableName: Swift.String? = nil, bundle: Foundation.Bundle = Bundle.main, value: Swift.String = "", comment: Swift.String) -> Swift.String
public func NSLog(_ format: Swift.String, _ args: any Swift.CVarArg...)
extension Swift.AnyHashable : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> ObjectiveC.NSObject
  public static func _forceBridgeFromObjectiveC(_ x: ObjectiveC.NSObject, result: inout Swift.AnyHashable?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: ObjectiveC.NSObject, result: inout Swift.AnyHashable?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: ObjectiveC.NSObject?) -> Swift.AnyHashable
  public typealias _ObjectiveCType = ObjectiveC.NSObject
}
extension Swift.CVarArg where Self : Swift._ObjectiveCBridgeable {
  public var _cVarArgEncoding: [Swift.Int] {
    get
  }
}
extension Foundation.NSLocking {
  @_alwaysEmitIntoClient @_disfavoredOverload public func withLock<R>(_ body: () throws -> R) rethrows -> R {
        self.lock()
        defer { self.unlock() }
        return try body()
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct ListFormatStyle<Style, Base> : Foundation.FormatStyle where Style : Foundation.FormatStyle, Base : Swift.Sequence, Style.FormatInput == Base.Element, Style.FormatOutput == Swift.String {
  public var width: Foundation.ListFormatStyle<Style, Base>.Width
  public var listType: Foundation.ListFormatStyle<Style, Base>.ListType
  public var locale: Foundation.Locale
  public init(memberStyle: Style)
  public func format(_ value: Base) -> Swift.String
  public enum Width : Swift.Int, Swift.Codable, Swift.Sendable {
    case standard
    case short
    case narrow
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum ListType : Swift.Int, Swift.Codable, Swift.Sendable {
    case and
    case or
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public func locale(_ locale: Foundation.Locale) -> Foundation.ListFormatStyle<Style, Base>
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.ListFormatStyle<Style, Base>, b: Foundation.ListFormatStyle<Style, Base>) -> Swift.Bool
  public typealias FormatInput = Base
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle : Swift.Sendable where Style : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct StringStyle : Foundation.FormatStyle, Swift.Sendable {
  public func format(_ value: Swift.String) -> Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.StringStyle, b: Foundation.StringStyle) -> Swift.Bool
  public typealias FormatInput = Swift.String
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Sequence {
  public func formatted<S>(_ style: S) -> S.FormatOutput where Self == S.FormatInput, S : Foundation.FormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Sequence where Self.Element == Swift.String {
  public func formatted() -> Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public static func list<MemberStyle, Base>(memberStyle: MemberStyle, type: Foundation.ListFormatStyle<MemberStyle, Base>.ListType, width: Foundation.ListFormatStyle<MemberStyle, Base>.Width = .standard) -> Self where Self == Foundation.ListFormatStyle<MemberStyle, Base>, MemberStyle : Foundation.FormatStyle, Base : Swift.Sequence, MemberStyle.FormatInput == Base.Element, MemberStyle.FormatOutput == Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public static func list<Base>(type: Foundation.ListFormatStyle<Foundation.StringStyle, Base>.ListType, width: Foundation.ListFormatStyle<Foundation.StringStyle, Base>.Width = .standard) -> Self where Self == Foundation.ListFormatStyle<Foundation.StringStyle, Base>, Base : Swift.Sequence, Base.Element == Swift.String
}
public var kCFStringEncodingASCII: CoreFoundation.CFStringEncoding {
  get
}
extension Swift.String {
  public struct Encoding : Swift.RawRepresentable, Swift.Sendable {
    public var rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let ascii: Swift.String.Encoding
    public static let nextstep: Swift.String.Encoding
    public static let japaneseEUC: Swift.String.Encoding
    public static let utf8: Swift.String.Encoding
    public static let isoLatin1: Swift.String.Encoding
    public static let symbol: Swift.String.Encoding
    public static let nonLossyASCII: Swift.String.Encoding
    public static let shiftJIS: Swift.String.Encoding
    public static let isoLatin2: Swift.String.Encoding
    public static let unicode: Swift.String.Encoding
    public static let windowsCP1251: Swift.String.Encoding
    public static let windowsCP1252: Swift.String.Encoding
    public static let windowsCP1253: Swift.String.Encoding
    public static let windowsCP1254: Swift.String.Encoding
    public static let windowsCP1250: Swift.String.Encoding
    public static let iso2022JP: Swift.String.Encoding
    public static let macOSRoman: Swift.String.Encoding
    public static let utf16: Swift.String.Encoding
    public static let utf16BigEndian: Swift.String.Encoding
    public static let utf16LittleEndian: Swift.String.Encoding
    public static let utf32: Swift.String.Encoding
    public static let utf32BigEndian: Swift.String.Encoding
    public static let utf32LittleEndian: Swift.String.Encoding
    public typealias RawValue = Swift.UInt
  }
  public typealias EncodingConversionOptions = Foundation.NSString.EncodingConversionOptions
  public typealias EnumerationOptions = Foundation.NSString.EnumerationOptions
  public typealias CompareOptions = Foundation.NSString.CompareOptions
}
extension Swift.String.Encoding : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
        // Note: `hash(only:)` is only defined here because we also define
        // `hashValue`.
        //
        // In 5.0, `hash(into:)` was resolved to RawRepresentable's functionally
        // equivalent definition; we added this definition in 5.1 to make it
        // clear this `hash(into:)` isn't synthesized by the compiler.
        // (Otherwise someone may be tempted to define it, possibly breaking the
        // hash encoding and thus the ABI. RawRepresentable's definition is
        // inlinable.)
        hasher.combine(rawValue)
    }
  public static func == (lhs: Swift.String.Encoding, rhs: Swift.String.Encoding) -> Swift.Bool
}
extension Swift.String.Encoding : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Foundation.NSDate : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSDate.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
extension Foundation.NSItemProvider {
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public func registerObject<T>(ofClass: T.Type, visibility: Foundation.NSItemProviderRepresentationVisibility, loadHandler: @escaping ((T?, (any Swift.Error)?) -> Swift.Void) -> Foundation.Progress?) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderWriting
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public func canLoadObject<T>(ofClass: T.Type) -> Swift.Bool where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public func loadObject<T>(ofClass: T.Type, completionHandler: @escaping (T?, (any Swift.Error)?) -> Swift.Void) -> Foundation.Progress where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
extension Foundation.URL {
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct AsyncBytes : _Concurrency.AsyncSequence, Swift.Sendable {
    public typealias Element = Swift.UInt8
    @frozen public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol, Swift.Sendable {
      @usableFromInline
      internal var buffer: Foundation._AsyncBytesBuffer = _AsyncBytesBuffer(capacity: 0)
      #if compiler(>=5.3) && $AsyncAwait
      @inlinable @inline(__always) public mutating func next() async throws -> Swift.UInt8? {
                return try await buffer.next()
            }
      #endif
      public typealias Element = Swift.UInt8
    }
    public func makeAsyncIterator() -> Foundation.URL.AsyncBytes.AsyncIterator
  }
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var resourceBytes: Foundation.URL.AsyncBytes {
    get
  }
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var lines: Foundation.AsyncLineSequence<Foundation.URL.AsyncBytes> {
    get
  }
  #endif
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol SortComparator : Swift.Hashable {
  associatedtype Compared
  func compare(_ lhs: Self.Compared, _ rhs: Self.Compared) -> Foundation.ComparisonResult
  var order: Foundation.SortOrder { get set }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@frozen public enum SortOrder : Swift.Hashable, Swift.Codable, Swift.Sendable {
  case forward
  case reverse
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: Foundation.SortOrder, b: Foundation.SortOrder) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct ComparableComparator<Compared> : Foundation.SortComparator, Swift.Sendable where Compared : Swift.Comparable {
  public var order: Foundation.SortOrder
  public func compare(_ lhs: Compared, _ rhs: Compared) -> Foundation.ComparisonResult
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.ComparableComparator<Compared>, b: Foundation.ComparableComparator<Compared>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.String {
  public struct StandardComparator : Foundation.SortComparator, Swift.Codable, Swift.Sendable {
    public static let localizedStandard: Swift.String.StandardComparator
    public static let localized: Swift.String.StandardComparator
    public static let lexical: Swift.String.StandardComparator
    public var order: Foundation.SortOrder
    public init(_ base: Swift.String.StandardComparator, order: Foundation.SortOrder = .forward)
    public init(from decoder: any Swift.Decoder) throws
    public func compare(_ lhs: Swift.String, _ rhs: Swift.String) -> Foundation.ComparisonResult
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: Swift.String.StandardComparator, b: Swift.String.StandardComparator) -> Swift.Bool
    public typealias Compared = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Comparator : Foundation.SortComparator, Swift.Codable, Swift.Sendable {
    public let options: Swift.String.CompareOptions
    public let locale: Foundation.Locale?
    public var order: Foundation.SortOrder
    public init(options: Swift.String.CompareOptions, locale: Foundation.Locale? = Locale.current, order: Foundation.SortOrder = .forward)
    public init(_ standardComparison: Swift.String.StandardComparator)
    public init(from decoder: any Swift.Decoder) throws
    public func compare(_ lhs: Swift.String, _ rhs: Swift.String) -> Foundation.ComparisonResult
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: Swift.String.Comparator, b: Swift.String.Comparator) -> Swift.Bool
    public typealias Compared = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.SortComparator where Self == Swift.String.Comparator {
  public static var localizedStandard: Swift.String.Comparator {
    get
  }
  public static var localized: Swift.String.Comparator {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Never : Foundation.SortComparator {
  public typealias Compared = Swift.Never
  public func compare(_ lhs: Swift.Never, _ rhs: Swift.Never) -> Foundation.ComparisonResult
  public var order: Foundation.SortOrder {
    get
    set
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Sequence {
  public func sorted<Comparator>(using comparator: Comparator) -> [Self.Element] where Comparator : Foundation.SortComparator, Self.Element == Comparator.Compared
  public func sorted<S, Comparator>(using comparators: S) -> [Self.Element] where S : Swift.Sequence, Comparator : Foundation.SortComparator, Comparator == S.Element, Self.Element == Comparator.Compared
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Sequence {
  public func compare<Comparator>(_ lhs: Comparator.Compared, _ rhs: Comparator.Compared) -> Foundation.ComparisonResult where Comparator : Foundation.SortComparator, Comparator == Self.Element
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.MutableCollection where Self : Swift.RandomAccessCollection {
  public mutating func sort<Comparator>(using comparator: Comparator) where Comparator : Foundation.SortComparator, Self.Element == Comparator.Compared
  public mutating func sort<S, Comparator>(using comparators: S) where S : Swift.Sequence, Comparator : Foundation.SortComparator, Comparator == S.Element, Self.Element == Comparator.Compared
}
public struct Date : Foundation.ReferenceConvertible, Swift.Comparable, Swift.Equatable, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSDate
  public static let timeIntervalBetween1970AndReferenceDate: Swift.Double
  public static var timeIntervalSinceReferenceDate: Foundation.TimeInterval {
    get
  }
  public init()
  public init(timeIntervalSinceNow: Foundation.TimeInterval)
  public init(timeIntervalSince1970: Foundation.TimeInterval)
  public init(timeInterval: Foundation.TimeInterval, since date: Foundation.Date)
  public init(timeIntervalSinceReferenceDate ti: Foundation.TimeInterval)
  public var timeIntervalSinceReferenceDate: Foundation.TimeInterval {
    get
  }
  public func timeIntervalSince(_ date: Foundation.Date) -> Foundation.TimeInterval
  public var timeIntervalSinceNow: Foundation.TimeInterval {
    get
  }
  public var timeIntervalSince1970: Foundation.TimeInterval {
    get
  }
  public func addingTimeInterval(_ timeInterval: Foundation.TimeInterval) -> Foundation.Date
  public mutating func addTimeInterval(_ timeInterval: Foundation.TimeInterval)
  public static let distantFuture: Foundation.Date
  public static let distantPast: Foundation.Date
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public static var now: Foundation.Date {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public func compare(_ other: Foundation.Date) -> Foundation.ComparisonResult
  public static func == (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
  public static func < (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
  public static func > (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
  public static func + (lhs: Foundation.Date, rhs: Foundation.TimeInterval) -> Foundation.Date
  public static func - (lhs: Foundation.Date, rhs: Foundation.TimeInterval) -> Foundation.Date
  public static func += (lhs: inout Foundation.Date, rhs: Foundation.TimeInterval)
  public static func -= (lhs: inout Foundation.Date, rhs: Foundation.TimeInterval)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Date : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public func description(with locale: Foundation.Locale?) -> Swift.String
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.Date : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDate
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSDate, result: inout Foundation.Date?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSDate, result: inout Foundation.Date?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDate?) -> Foundation.Date
  public typealias _ObjectiveCType = Foundation.NSDate
}
extension Foundation.NSDate : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.Date : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Date.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension Foundation.Date : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.String {
  public static var availableStringEncodings: [Swift.String.Encoding] {
    get
  }
  public static var defaultCStringEncoding: Swift.String.Encoding {
    get
  }
  public static func localizedName(of encoding: Swift.String.Encoding) -> Swift.String
  public static func localizedStringWithFormat(_ format: Swift.String, _ arguments: any Swift.CVarArg...) -> Swift.String
  public init?(utf8String bytes: Swift.UnsafePointer<Swift.CChar>)
  @_alwaysEmitIntoClient public init?(utf8String bytes: [Swift.CChar]) {
        // the stdlib's validatingUTF8 [CChar] overload checks for null termination.
        if let str = String(validatingUTF8: bytes) {
            self = str
            return
        }
        guard let nullPosition = bytes.firstIndex(of: 0) else {
            fatalError(
                "input of String.init(utf8String:) must be null-terminated"
            )
        }
        let ns = bytes.withUnsafeBytes {
            NSString(bytes: $0.baseAddress!,
                     length: nullPosition,
                     encoding: Encoding.utf8.rawValue)
        }
        guard let ns = ns else {
            return nil
        }
        self = String._unconditionallyBridgeFromObjectiveC(ns)
    }
  @available(*, deprecated, message: "Use a copy of the String argument")
  @_alwaysEmitIntoClient public init?(utf8String bytes: Swift.String) {
        var decoded = bytes
        decoded.makeContiguousUTF8()
        if let null = decoded.firstIndex(of: "\0") {
            decoded = String(decoded[..<null])
        }
        self = decoded
    }
  @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
  @_alwaysEmitIntoClient public init?(utf8String bytes: inout Swift.CChar) {
        // a byte interpreted as a buffer is valid only if the value is zero.
        guard bytes == 0 else {
            fatalError(
                "input of String.init(utf8String:) must be null-terminated"
            )
        }
        self = ""
    }
}
extension Swift.String {
  public init?<S>(bytes: __shared S, encoding: Swift.String.Encoding) where S : Swift.Sequence, S.Element == Swift.UInt8
  @available(macOS, deprecated: 13, message: "String does not support no-copy initialization")
  @available(iOS, deprecated: 16, message: "String does not support no-copy initialization")
  @available(tvOS, deprecated: 16, message: "String does not support no-copy initialization")
  @available(watchOS, deprecated: 9, message: "String does not support no-copy initialization")
  public init?(bytesNoCopy bytes: Swift.UnsafeMutableRawPointer, length: Swift.Int, encoding: Swift.String.Encoding, freeWhenDone flag: Swift.Bool)
  public init(utf16CodeUnits: Swift.UnsafePointer<Foundation.unichar>, count: Swift.Int)
  @available(macOS, deprecated: 13, message: "String does not support no-copy initialization")
  @available(iOS, deprecated: 16, message: "String does not support no-copy initialization")
  @available(tvOS, deprecated: 16, message: "String does not support no-copy initialization")
  @available(watchOS, deprecated: 9, message: "String does not support no-copy initialization")
  public init(utf16CodeUnitsNoCopy: Swift.UnsafePointer<Foundation.unichar>, count: Swift.Int, freeWhenDone flag: Swift.Bool)
  public init(contentsOfFile path: __shared Swift.String, encoding enc: Swift.String.Encoding) throws
  public init(contentsOfFile path: __shared Swift.String, usedEncoding: inout Swift.String.Encoding) throws
  public init(contentsOfFile path: __shared Swift.String) throws
  public init(contentsOf url: __shared Foundation.URL, encoding enc: Swift.String.Encoding) throws
  public init(contentsOf url: __shared Foundation.URL, usedEncoding: inout Swift.String.Encoding) throws
  public init(contentsOf url: __shared Foundation.URL) throws
  public init?(cString: Swift.UnsafePointer<Swift.CChar>, encoding enc: Swift.String.Encoding)
  @_alwaysEmitIntoClient public init?(cString: [Swift.CChar], encoding enc: Swift.String.Encoding) {
        if enc == .utf8 || enc == .ascii {
            // the stdlib's validatingUTF8 [CChar] overload checks for null termination.
            if let str = String(validatingUTF8: cString) {
                if enc == .utf8 || str._guts._isContiguousASCII {
                    self = str
                    return
                }
            }
        }
        guard let nullPosition = cString.firstIndex(of: 0) else {
            fatalError(
                "input of String.init(cString:encoding:) must be null-terminated"
            )
        }
        let ns = cString.withUnsafeBytes {
            NSString(bytes: $0.baseAddress!,
                     length: nullPosition,
                     encoding: enc.rawValue)
        }
        guard let ns = ns else {
            return nil
        }
        self = String._unconditionallyBridgeFromObjectiveC(ns)
    }
  @available(*, deprecated, message: "Use a copy of the String argument")
  @_alwaysEmitIntoClient public init?(cString: Swift.String, encoding enc: Swift.String.Encoding) {
        if enc == .utf8 || enc == .ascii {
            var decoded = cString
            decoded.makeContiguousUTF8()
            if let null = decoded.firstIndex(of: "\0") {
                decoded = String(decoded[..<null])
            }
            if enc == .utf8 || decoded.utf8.allSatisfy({ $0 < 128 }) {
                self = decoded
                return
            }
        }
        return nil
    }
  @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
  @_alwaysEmitIntoClient public init?(cString: inout Swift.CChar, encoding enc: Swift.String.Encoding) {
        // a byte interpreted as a buffer is valid only if the value is zero.
        guard cString == 0 else {
            fatalError(
                "input of String.init(cString:encoding:) must be null-terminated"
            )
        }
        self = ""
    }
  public init?(data: __shared Foundation.Data, encoding: Swift.String.Encoding)
  public init(format: __shared Swift.String, _ arguments: any Swift.CVarArg...)
  public init(format: __shared Swift.String, arguments: __shared [any Swift.CVarArg])
  public init(format: __shared Swift.String, locale: __shared Foundation.Locale?, _ args: any Swift.CVarArg...)
  public init(format: __shared Swift.String, locale: __shared Foundation.Locale?, arguments: __shared [any Swift.CVarArg])
}
extension Swift.StringProtocol {
  @inlinable internal func _toRelativeNSRange(_ r: Swift.Range<Swift.String.Index>) -> Foundation.NSRange {
        return NSRange(self._toUTF16Offsets(r))
    }
  public func canBeConverted(to encoding: Swift.String.Encoding) -> Swift.Bool
  public var capitalized: Swift.String {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var localizedCapitalized: Swift.String {
    get
  }
  public func capitalized(with locale: Foundation.Locale?) -> Swift.String
  public func caseInsensitiveCompare<T>(_ aString: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func commonPrefix<T>(with aString: T, options: Swift.String.CompareOptions = []) -> Swift.String where T : Swift.StringProtocol
  public func compare<T>(_ aString: T, options mask: Swift.String.CompareOptions = [], range: Swift.Range<Self.Index>? = nil, locale: Foundation.Locale? = nil) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func completePath(into outputName: Swift.UnsafeMutablePointer<Swift.String>? = nil, caseSensitive: Swift.Bool, matchesInto outputArray: Swift.UnsafeMutablePointer<[Swift.String]>? = nil, filterTypes: [Swift.String]? = nil) -> Swift.Int
  public func components(separatedBy separator: Foundation.CharacterSet) -> [Swift.String]
  public func components<T>(separatedBy separator: T) -> [Swift.String] where T : Swift.StringProtocol
  public func cString(using encoding: Swift.String.Encoding) -> [Swift.CChar]?
  public func data(using encoding: Swift.String.Encoding, allowLossyConversion: Swift.Bool = false) -> Foundation.Data?
  public var decomposedStringWithCanonicalMapping: Swift.String {
    get
  }
  public var decomposedStringWithCompatibilityMapping: Swift.String {
    get
  }
  public func enumerateLines(invoking body: @escaping (_ line: Swift.String, _ stop: inout Swift.Bool) -> Swift.Void)
  public var fastestEncoding: Swift.String.Encoding {
    get
  }
  public func getCString(_ buffer: inout [Swift.CChar], maxLength: Swift.Int, encoding: Swift.String.Encoding) -> Swift.Bool
  public var hash: Swift.Int {
    get
  }
  public func lengthOfBytes(using encoding: Swift.String.Encoding) -> Swift.Int
  public func localizedCaseInsensitiveCompare<T>(_ aString: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func localizedCompare<T>(_ aString: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func localizedStandardCompare<T>(_ string: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  @available(macOS 10.11, iOS 9.0, *)
  public var localizedLowercase: Swift.String {
    get
  }
  public func lowercased(with locale: Foundation.Locale?) -> Swift.String
  public func maximumLengthOfBytes(using encoding: Swift.String.Encoding) -> Swift.Int
  public var precomposedStringWithCanonicalMapping: Swift.String {
    get
  }
  public var precomposedStringWithCompatibilityMapping: Swift.String {
    get
  }
  public func propertyList() -> Any
  public func propertyListFromStringsFileFormat() -> [Swift.String : Swift.String]
  @available(macOS 10.11, iOS 9.0, *)
  public func localizedStandardContains<T>(_ string: T) -> Swift.Bool where T : Swift.StringProtocol
  public var smallestEncoding: Swift.String.Encoding {
    get
  }
  public func addingPercentEncoding(withAllowedCharacters allowedCharacters: Foundation.CharacterSet) -> Swift.String?
  public func appendingFormat<T>(_ format: T, _ arguments: any Swift.CVarArg...) -> Swift.String where T : Swift.StringProtocol
  public func appending<T>(_ aString: T) -> Swift.String where T : Swift.StringProtocol
  public func folding(options: Swift.String.CompareOptions = [], locale: Foundation.Locale?) -> Swift.String
  public func padding<T>(toLength newLength: Swift.Int, withPad padString: T, startingAt padIndex: Swift.Int) -> Swift.String where T : Swift.StringProtocol
  public var removingPercentEncoding: Swift.String? {
    get
  }
  public func replacingCharacters<T, R>(in range: R, with replacement: T) -> Swift.String where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func replacingOccurrences<Target, Replacement>(of target: Target, with replacement: Replacement, options: Swift.String.CompareOptions = [], range searchRange: Swift.Range<Self.Index>? = nil) -> Swift.String where Target : Swift.StringProtocol, Replacement : Swift.StringProtocol
  @available(swift, deprecated: 3.0, obsoleted: 4.0, message: "Use removingPercentEncoding instead, which always uses the recommended UTF-8 encoding.")
  public func replacingPercentEscapes(using encoding: Swift.String.Encoding) -> Swift.String?
  public func trimmingCharacters(in set: Foundation.CharacterSet) -> Swift.String
  @available(macOS 10.11, iOS 9.0, *)
  public var localizedUppercase: Swift.String {
    get
  }
  public func uppercased(with locale: Foundation.Locale?) -> Swift.String
  public func write<T>(toFile path: T, atomically useAuxiliaryFile: Swift.Bool, encoding enc: Swift.String.Encoding) throws where T : Swift.StringProtocol
  public func write(to url: Foundation.URL, atomically useAuxiliaryFile: Swift.Bool, encoding enc: Swift.String.Encoding) throws
  @available(macOS 10.11, iOS 9.0, *)
  public func applyingTransform(_ transform: Foundation.StringTransform, reverse: Swift.Bool) -> Swift.String?
  public func enumerateLinguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: Foundation.NSLinguisticTagger.Options = [], orthography: Foundation.NSOrthography? = nil, invoking body: (Swift.String, Swift.Range<Self.Index>, Swift.Range<Self.Index>, inout Swift.Bool) -> Swift.Void) where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func enumerateSubstrings<R>(in range: R, options opts: Swift.String.EnumerationOptions = [], _ body: @escaping (_ substring: Swift.String?, _ substringRange: Swift.Range<Self.Index>, _ enclosingRange: Swift.Range<Self.Index>, inout Swift.Bool) -> Swift.Void) where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getBytes<R>(_ buffer: inout [Swift.UInt8], maxLength maxBufferCount: Swift.Int, usedLength usedBufferCount: Swift.UnsafeMutablePointer<Swift.Int>, encoding: Swift.String.Encoding, options: Swift.String.EncodingConversionOptions = [], range: R, remaining leftover: Swift.UnsafeMutablePointer<Swift.Range<Self.Index>>) -> Swift.Bool where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getLineStart<R>(_ start: Swift.UnsafeMutablePointer<Self.Index>, end: Swift.UnsafeMutablePointer<Self.Index>, contentsEnd: Swift.UnsafeMutablePointer<Self.Index>, for range: R) where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getParagraphStart<R>(_ start: Swift.UnsafeMutablePointer<Self.Index>, end: Swift.UnsafeMutablePointer<Self.Index>, contentsEnd: Swift.UnsafeMutablePointer<Self.Index>, for range: R) where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func lineRange<R>(for aRange: R) -> Swift.Range<Self.Index> where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func linguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: Foundation.NSLinguisticTagger.Options = [], orthography: Foundation.NSOrthography? = nil, tokenRanges: Swift.UnsafeMutablePointer<[Swift.Range<Self.Index>]>? = nil) -> [Swift.String] where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func paragraphRange<R>(for aRange: R) -> Swift.Range<Self.Index> where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func rangeOfCharacter(from aSet: Foundation.CharacterSet, options mask: Swift.String.CompareOptions = [], range aRange: Swift.Range<Self.Index>? = nil) -> Swift.Range<Self.Index>?
  public func rangeOfComposedCharacterSequence(at anIndex: Self.Index) -> Swift.Range<Self.Index>
  public func rangeOfComposedCharacterSequences<R>(for range: R) -> Swift.Range<Self.Index> where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func range<T>(of aString: T, options mask: Swift.String.CompareOptions = [], range searchRange: Swift.Range<Self.Index>? = nil, locale: Foundation.Locale? = nil) -> Swift.Range<Self.Index>? where T : Swift.StringProtocol
  @available(macOS 10.11, iOS 9.0, *)
  public func localizedStandardRange<T>(of string: T) -> Swift.Range<Self.Index>? where T : Swift.StringProtocol
  @available(swift, deprecated: 3.0, obsoleted: 4.0, message: "Use addingPercentEncoding(withAllowedCharacters:) instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.")
  public func addingPercentEscapes(using encoding: Swift.String.Encoding) -> Swift.String?
  public func contains<T>(_ other: T) -> Swift.Bool where T : Swift.StringProtocol
  public func localizedCaseInsensitiveContains<T>(_ other: T) -> Swift.Bool where T : Swift.StringProtocol
}
extension Swift.StringProtocol {
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range from' operator.")
  public func substring(from index: Self.Index) -> Swift.String
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range upto' operator.")
  public func substring(to index: Self.Index) -> Swift.String
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript.")
  public func substring(with aRange: Swift.Range<Self.Index>) -> Swift.String
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributedString {
  public enum AttributeRunBoundaries : Swift.Hashable, Swift.Sendable {
    case paragraph
    case character(Swift.Character)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.AttributedString.AttributeRunBoundaries, b: Foundation.AttributedString.AttributeRunBoundaries) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct AttributeInvalidationCondition : Swift.Hashable, Swift.Sendable {
    public static let textChanged: Foundation.AttributedString.AttributeInvalidationCondition
    public static func attributeChanged<T>(_ key: T.Type) -> Foundation.AttributedString.AttributeInvalidationCondition where T : Foundation.AttributedStringKey
    public static func attributeChanged<T>(_ key: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>) -> Foundation.AttributedString.AttributeInvalidationCondition where T : Foundation.AttributedStringKey
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.AttributedString.AttributeInvalidationCondition, b: Foundation.AttributedString.AttributeInvalidationCondition) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributedStringKey {
  associatedtype Value : Swift.Hashable
  static var name: Swift.String { get }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  static var runBoundaries: Foundation.AttributedString.AttributeRunBoundaries? { get }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  static var inheritedByAddedText: Swift.Bool { get }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  static var invalidationConditions: Swift.Set<Foundation.AttributedString.AttributeInvalidationCondition>? { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringKey {
  public var description: Swift.String {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public static var runBoundaries: Foundation.AttributedString.AttributeRunBoundaries? {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public static var inheritedByAddedText: Swift.Bool {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public static var invalidationConditions: Swift.Set<Foundation.AttributedString.AttributeInvalidationCondition>? {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributeScope : Foundation.DecodingConfigurationProviding, Foundation.EncodingConfigurationProviding {
  static var decodingConfiguration: Foundation.AttributeScopeCodableConfiguration { get }
  static var encodingConfiguration: Foundation.AttributeScopeCodableConfiguration { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@frozen public enum AttributeScopes {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup @frozen public enum AttributeDynamicLookup {
  public subscript<T>(_: T.Type) -> T where T : Foundation.AttributedStringKey {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
  public subscript<T>(dynamicMember keyPath: Swift.KeyPath<S, T>) -> T.Value? where T : Foundation.AttributedStringKey {
    get
    set
  }
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeScopes : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeDynamicLookup : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.ScopedAttributeContainer : @unchecked Swift.Sendable {
}
public struct NSIndexSetIterator : Swift.IteratorProtocol {
  public typealias Element = Swift.Int
  public mutating func next() -> Swift.Int?
}
extension Foundation.NSIndexSet : Swift.Sequence {
  public func makeIterator() -> Foundation.NSIndexSetIterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  public typealias Element = Foundation.NSIndexSetIterator.Element
  public typealias Iterator = Foundation.NSIndexSetIterator
}
@available(iOS, unavailable, introduced: 7)
@available(*, unavailable)
extension Foundation.NSIndexSetIterator : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Duration {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public struct UnitsFormatStyle : Foundation.FormatStyle, Swift.Sendable {
    public struct UnitWidth : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var wide: Swift.Duration.UnitsFormatStyle.UnitWidth {
        get
      }
      public static var abbreviated: Swift.Duration.UnitsFormatStyle.UnitWidth {
        get
      }
      public static var condensedAbbreviated: Swift.Duration.UnitsFormatStyle.UnitWidth {
        get
      }
      public static var narrow: Swift.Duration.UnitsFormatStyle.UnitWidth {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Swift.Duration.UnitsFormatStyle.UnitWidth, b: Swift.Duration.UnitsFormatStyle.UnitWidth) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct Unit : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var weeks: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var days: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var hours: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var minutes: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var seconds: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var milliseconds: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var microseconds: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var nanoseconds: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Swift.Duration.UnitsFormatStyle.Unit, b: Swift.Duration.UnitsFormatStyle.Unit) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct ZeroValueUnitsDisplayStrategy : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var hide: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy {
        get
      }
      public static func show(length: Swift.Int) -> Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy, b: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct FractionalPartDisplayStrategy : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public var minimumLength: Swift.Int
      public var maximumLength: Swift.Int
      public var roundingRule: Swift.FloatingPointRoundingRule
      public var roundingIncrement: Swift.Double?
      public init<Range>(lengthLimits: Range, roundingRule: Swift.FloatingPointRoundingRule = .toNearestOrEven, roundingIncrement: Swift.Double? = nil) where Range : Swift.RangeExpression, Range.Bound == Swift.Int
      public static func show(length: Swift.Int, rounded rule: Swift.FloatingPointRoundingRule = .toNearestOrEven, increment: Swift.Double? = nil) -> Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy
      public static var hide: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy {
        get
      }
      public static func hide(rounded: Swift.FloatingPointRoundingRule = .toNearestOrEven) -> Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy, b: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public var locale: Foundation.Locale
    public var allowedUnits: Swift.Set<Swift.Duration.UnitsFormatStyle.Unit>
    public var unitWidth: Swift.Duration.UnitsFormatStyle.UnitWidth
    public var maximumUnitCount: Swift.Int?
    public var zeroValueUnitsDisplay: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy
    public var fractionalPartDisplay: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy
    public var valueLengthLimits: Swift.Range<Swift.Int>?
    public init(allowedUnits: Swift.Set<Swift.Duration.UnitsFormatStyle.Unit>, width: Swift.Duration.UnitsFormatStyle.UnitWidth, maximumUnitCount: Swift.Int? = nil, zeroValueUnits: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLength: Swift.Int? = nil, fractionalPart: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide)
    public init<ValueRange>(allowedUnits: Swift.Set<Swift.Duration.UnitsFormatStyle.Unit>, width: Swift.Duration.UnitsFormatStyle.UnitWidth, maximumUnitCount: Swift.Int? = nil, zeroValueUnits: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLengthLimits: ValueRange, fractionalPart: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide) where ValueRange : Swift.RangeExpression, ValueRange.Bound == Swift.Int
    public func format(_ duration: Swift.Duration) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Swift.Duration.UnitsFormatStyle
    public var attributed: Swift.Duration.UnitsFormatStyle.Attributed {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Swift.Duration.UnitsFormatStyle, b: Swift.Duration.UnitsFormatStyle) -> Swift.Bool
    public typealias FormatInput = Swift.Duration
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FormatStyle where Self == Swift.Duration.UnitsFormatStyle {
  public static func units(allowed units: Swift.Set<Swift.Duration.UnitsFormatStyle.Unit> = [.hours, .minutes, .seconds], width: Swift.Duration.UnitsFormatStyle.UnitWidth = .abbreviated, maximumUnitCount: Swift.Int? = nil, zeroValueUnits: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLength: Swift.Int? = nil, fractionalPart: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide) -> Self
  public static func units<ValueRange>(allowed units: Swift.Set<Swift.Duration.UnitsFormatStyle.Unit> = [.hours, .minutes, .seconds], width: Swift.Duration.UnitsFormatStyle.UnitWidth = .abbreviated, maximumUnitCount: Swift.Int? = nil, zeroValueUnits: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLengthLimits: ValueRange, fractionalPart: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide) -> Self where ValueRange : Swift.RangeExpression, ValueRange.Bound == Swift.Int
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Duration.UnitsFormatStyle {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public struct Attributed : Foundation.FormatStyle, Swift.Sendable {
    public func format(_ duration: Swift.Duration) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Swift.Duration.UnitsFormatStyle.Attributed
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Swift.Duration.UnitsFormatStyle.Attributed, b: Swift.Duration.UnitsFormatStyle.Attributed) -> Swift.Bool
    public typealias FormatInput = Swift.Duration
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension Swift.UnsafeRawBufferPointer : Foundation.DataProtocol {
  public var regions: Swift.CollectionOfOne<Swift.UnsafeRawBufferPointer> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.UnsafeRawBufferPointer>
}
extension Swift.UnsafeBufferPointer : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.UnsafeBufferPointer<Swift.UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.UnsafeBufferPointer<Swift.UInt8>>
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public struct MarkdownParsingOptions : Swift.Sendable {
    public enum FailurePolicy : Swift.Int, Swift.Sendable {
      case throwError
      case returnPartiallyParsedIfPossible
      public init?(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public enum InterpretedSyntax : Swift.Int, Swift.Sendable {
      case full
      case inlineOnly
      case inlineOnlyPreservingWhitespace
      public init?(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public var allowsExtendedAttributes: Swift.Bool
    public var interpretedSyntax: Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax
    public var failurePolicy: Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy
    public var languageCode: Swift.String?
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var appliesSourcePositionAttributes: Swift.Bool {
      get
      set
    }
    public init(allowsExtendedAttributes: Swift.Bool = false, interpretedSyntax: Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax = .full, failurePolicy: Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy = .throwError, languageCode: Swift.String? = nil)
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init(allowsExtendedAttributes: Swift.Bool = false, interpretedSyntax: Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax = .full, failurePolicy: Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy = .throwError, languageCode: Swift.String? = nil, appliesSourcePositionAttributes: Swift.Bool = false)
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct MarkdownSourcePosition : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public let startLine: Swift.Int
    public let startColumn: Swift.Int
    public let endLine: Swift.Int
    public let endColumn: Swift.Int
    public init(startLine: Swift.Int, startColumn: Swift.Int, endLine: Swift.Int, endColumn: Swift.Int)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.AttributedString.MarkdownSourcePosition, b: Foundation.AttributedString.MarkdownSourcePosition) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public init<S>(markdown: Swift.String, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init(markdown: Swift.String, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  public init<S>(markdown: Swift.String, including scope: S.Type, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init<S>(markdown: Foundation.Data, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init(markdown: Foundation.Data, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  public init<S>(markdown: Foundation.Data, including scope: S.Type, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init<S>(contentsOf url: Foundation.URL, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init(contentsOf url: Foundation.URL, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  public init<S>(contentsOf url: Foundation.URL, including scope: S.Type, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InlinePresentationIntent : Swift.Hashable, Swift.Codable {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.__NSAttributedStringMarkdownParsingOptions
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.__NSAttributedStringMarkdownParsingOptions, result: inout Foundation.AttributedString.MarkdownParsingOptions?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.__NSAttributedStringMarkdownParsingOptions, result: inout Foundation.AttributedString.MarkdownParsingOptions?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.__NSAttributedStringMarkdownParsingOptions?) -> Foundation.AttributedString.MarkdownParsingOptions
  public typealias _ObjectiveCType = Foundation.__NSAttributedStringMarkdownParsingOptions
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributedString.MarkdownSourcePosition : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.__NSAttributedStringMarkdownSourcePosition
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.__NSAttributedStringMarkdownSourcePosition, result: inout Foundation.AttributedString.MarkdownSourcePosition?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.__NSAttributedStringMarkdownSourcePosition, result: inout Foundation.AttributedString.MarkdownSourcePosition?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.__NSAttributedStringMarkdownSourcePosition?) -> Foundation.AttributedString.MarkdownSourcePosition
  public typealias _ObjectiveCType = Foundation.__NSAttributedStringMarkdownSourcePosition
}
@_alwaysEmitIntoClient internal func _withStackOrHeapBuffer(capacity: Swift.Int, _ body: (Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> Swift.Void) {
    guard capacity > 0 else {
        body(UnsafeMutableBufferPointer(start: nil, count: 0))
        return
    }
    typealias InlineBuffer = ( // 32 bytes
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8
    )
    let inlineCount = MemoryLayout<InlineBuffer>.size
    if capacity <= inlineCount {
        var buffer: InlineBuffer = (
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0
        )
        withUnsafeMutableBytes(of: &buffer) { buffer in
            assert(buffer.count == inlineCount)
            let start = buffer.baseAddress!.assumingMemoryBound(to: UInt8.self)
            body(UnsafeMutableBufferPointer(start: start, count: capacity))
        }
        return
    }

    let buffer = UnsafeMutableBufferPointer<UInt8>.allocate(capacity: capacity)
    defer { buffer.deallocate() }
    body(buffer)
}
@usableFromInline
final internal class __DataStorage : @unchecked Swift.Sendable {
  @usableFromInline
  internal static let maxSize: Swift.Int
  @usableFromInline
  internal static let vmOpsThreshold: Swift.Int
  @inlinable internal static func allocate(_ size: Swift.Int, _ clear: Swift.Bool) -> Swift.UnsafeMutableRawPointer? {
        if clear {
            return calloc(1, size)
        } else {
            return malloc(size)
        }
    }
  @usableFromInline
  internal static func move(_ dest_: Swift.UnsafeMutableRawPointer, _ source_: Swift.UnsafeRawPointer?, _ num_: Swift.Int)
  @inlinable internal static func shouldAllocateCleared(_ size: Swift.Int) -> Swift.Bool {
        return (size > (128 * 1024))
    }
  @usableFromInline
  final internal var _bytes: Swift.UnsafeMutableRawPointer?
  @usableFromInline
  final internal var _length: Swift.Int
  @usableFromInline
  final internal var _capacity: Swift.Int
  @usableFromInline
  final internal var _offset: Swift.Int
  @usableFromInline
  final internal var _deallocator: ((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void)?
  @usableFromInline
  final internal var _needToZero: Swift.Bool
  @inlinable final internal var bytes: Swift.UnsafeRawPointer? {
    get {
        return UnsafeRawPointer(_bytes)?.advanced(by: -_offset)
    }
  }
  @discardableResult
  @inlinable final internal func withUnsafeBytes<Result>(in range: Swift.Range<Swift.Int>, apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
        return try apply(UnsafeRawBufferPointer(start: _bytes?.advanced(by: range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length)))
    }
  @discardableResult
  @inlinable final internal func withUnsafeMutableBytes<Result>(in range: Swift.Range<Swift.Int>, apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
        return try apply(UnsafeMutableRawBufferPointer(start: _bytes!.advanced(by:range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length)))
    }
  @inlinable final internal var mutableBytes: Swift.UnsafeMutableRawPointer? {
    get {
        return _bytes?.advanced(by: -_offset)
    }
  }
  @inlinable final internal var capacity: Swift.Int {
    get {
        return _capacity
    }
  }
  @inlinable final internal var length: Swift.Int {
    get {
            return _length
        }
    set {
            setLength(newValue)
        }
  }
  @inlinable final internal var isExternallyOwned: Swift.Bool {
    get {
        // all __DataStorages will have some sort of capacity, because empty cases hit the .empty enum _Representation
        // anything with 0 capacity means that we have not allocated this pointer and concequently mutation is not ours to make.
        return _capacity == 0
    }
  }
  @usableFromInline
  final internal func ensureUniqueBufferReference(growingTo newLength: Swift.Int = 0, clear: Swift.Bool = false)
  @inlinable final internal func _freeBytes() {
        if let bytes = _bytes {
            if let dealloc = _deallocator {
                dealloc(bytes, length)
            } else {
                free(bytes)
            }
        }
        _deallocator = nil
    }
  @inlinable final internal func enumerateBytes(in range: Swift.Range<Swift.Int>, _ block: (_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>, _ byteIndex: Foundation.Data.Index, _ stop: inout Swift.Bool) -> Swift.Void) {
        var stopv: Bool = false
        block(UnsafeBufferPointer<UInt8>(start: _bytes?.advanced(by: range.lowerBound - _offset).assumingMemoryBound(to: UInt8.self), count: Swift.min(range.upperBound - range.lowerBound, _length)), 0, &stopv)
    }
  @inlinable final internal func setLength(_ length: Swift.Int) {
        let origLength = _length
        let newLength = length
        if _capacity < newLength || _bytes == nil {
            ensureUniqueBufferReference(growingTo: newLength, clear: true)
        } else if origLength < newLength && _needToZero {
            memset(_bytes! + origLength, 0, newLength - origLength)
        } else if newLength < origLength {
            _needToZero = true
        }
        _length = newLength
    }
  @inlinable final internal func append(_ bytes: Swift.UnsafeRawPointer, length: Swift.Int) {
        precondition(length >= 0, "Length of appending bytes must not be negative")
        let origLength = _length
        let newLength = origLength + length
        if _capacity < newLength || _bytes == nil {
            ensureUniqueBufferReference(growingTo: newLength, clear: false)
        }
        _length = newLength
        __DataStorage.move(_bytes!.advanced(by: origLength), bytes, length)
    }
  @inlinable final internal func get(_ index: Swift.Int) -> Swift.UInt8 {
        return _bytes!.advanced(by: index - _offset).assumingMemoryBound(to: UInt8.self).pointee
    }
  @inlinable final internal func set(_ index: Swift.Int, to value: Swift.UInt8) {
        ensureUniqueBufferReference()
        _bytes!.advanced(by: index - _offset).assumingMemoryBound(to: UInt8.self).pointee = value
    }
  @inlinable final internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
        let offsetPointer = UnsafeRawBufferPointer(start: _bytes?.advanced(by: range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length))
        UnsafeMutableRawBufferPointer(start: pointer, count: range.upperBound - range.lowerBound).copyMemory(from: offsetPointer)
    }
  @usableFromInline
  final internal func replaceBytes(in range_: Foundation.NSRange, with replacementBytes: Swift.UnsafeRawPointer?, length replacementLength: Swift.Int)
  @usableFromInline
  final internal func resetBytes(in range_: Swift.Range<Swift.Int>)
  @usableFromInline
  internal init(length: Swift.Int)
  @usableFromInline
  internal init(capacity capacity_: Swift.Int = 0)
  @usableFromInline
  internal init(bytes: Swift.UnsafeRawPointer?, length: Swift.Int)
  @usableFromInline
  internal init(bytes: Swift.UnsafeMutableRawPointer?, length: Swift.Int, copy: Swift.Bool, deallocator: ((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void)?, offset: Swift.Int)
  @usableFromInline
  internal init(immutableReference: Foundation.NSData, offset: Swift.Int)
  @usableFromInline
  internal init(mutableReference: Foundation.NSMutableData, offset: Swift.Int)
  @usableFromInline
  internal init(customReference: Foundation.NSData, offset: Swift.Int)
  @usableFromInline
  internal init(customMutableReference: Foundation.NSMutableData, offset: Swift.Int)
  @objc deinit
  @inlinable final internal func mutableCopy(_ range: Swift.Range<Swift.Int>) -> Foundation.__DataStorage {
        return __DataStorage(bytes: _bytes?.advanced(by: range.lowerBound - _offset), length: range.upperBound - range.lowerBound, copy: true, deallocator: nil, offset: range.lowerBound)
    }
  @inlinable final internal func withInteriorPointerReference<T>(_ range: Swift.Range<Swift.Int>, _ work: (Foundation.NSData) throws -> T) rethrows -> T {
        if range.isEmpty {
            return try work(NSData()) // zero length data can be optimized as a singleton
        }
        return try work(NSData(bytesNoCopy: _bytes!.advanced(by: range.lowerBound - _offset), length: range.upperBound - range.lowerBound, freeWhenDone: false))
    }
  @usableFromInline
  @inline(never) final internal func bridgedReference(_ range: Swift.Range<Swift.Int>) -> Foundation.NSData
}
@frozen public struct Data : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable, Swift.RandomAccessCollection, Swift.MutableCollection, Swift.RangeReplaceableCollection, Foundation.MutableDataProtocol, Foundation.ContiguousBytes, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSData
  public typealias ReadingOptions = Foundation.NSData.ReadingOptions
  public typealias WritingOptions = Foundation.NSData.WritingOptions
  public typealias SearchOptions = Foundation.NSData.SearchOptions
  public typealias Base64EncodingOptions = Foundation.NSData.Base64EncodingOptions
  public typealias Base64DecodingOptions = Foundation.NSData.Base64DecodingOptions
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @usableFromInline
  @frozen internal struct InlineData : Swift.Sendable {
    @usableFromInline
    internal typealias Buffer = (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8)
    @usableFromInline
    internal var bytes: Foundation.Data.InlineData.Buffer
    @usableFromInline
    internal var length: Swift.UInt8
    @inlinable internal static func canStore(count: Swift.Int) -> Swift.Bool {
            return count <= MemoryLayout<Buffer>.size
        }
    @inlinable internal init(_ srcBuffer: Swift.UnsafeRawBufferPointer) {
            self.init(count: srcBuffer.count)
            if !srcBuffer.isEmpty {
                Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                    dstBuffer.baseAddress?.copyMemory(from: srcBuffer.baseAddress!, byteCount: srcBuffer.count)
                }
            }
        }
    @inlinable internal init(count: Swift.Int = 0) {
            assert(count <= MemoryLayout<Buffer>.size)
            bytes = (UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0))
            length = UInt8(count)
        }
    @inlinable internal init(_ slice: Foundation.Data.InlineSlice, count: Swift.Int) {
            self.init(count: count)
            Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                slice.withUnsafeBytes { srcBuffer in
                    dstBuffer.copyMemory(from: UnsafeRawBufferPointer(start: srcBuffer.baseAddress, count: count))
                }
            }
        }
    @inlinable internal init(_ slice: Foundation.Data.LargeSlice, count: Swift.Int) {
            self.init(count: count)
            Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                slice.withUnsafeBytes { srcBuffer in
                    dstBuffer.copyMemory(from: UnsafeRawBufferPointer(start: srcBuffer.baseAddress, count: count))
                }
            }
        }
    @inlinable internal var capacity: Swift.Int {
      get {
            return MemoryLayout<Buffer>.size
        }
    }
    @inlinable internal var count: Swift.Int {
      get {
                return Int(length)
            }
      set(newValue) {
                assert(newValue <= MemoryLayout<Buffer>.size)
                if newValue > length {
                    resetBytes(in: Int(length) ..< newValue) // Also extends length
                } else {
                    length = UInt8(newValue)
                }
            }
    }
    @inlinable internal var startIndex: Swift.Int {
      get {
            return 0
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
            return count
        }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            let count = Int(length)
            return try Swift.withUnsafeBytes(of: bytes) { (rawBuffer) throws -> Result in
                return try apply(UnsafeRawBufferPointer(start: rawBuffer.baseAddress, count: count))
            }
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            let count = Int(length)
            return try Swift.withUnsafeMutableBytes(of: &bytes) { (rawBuffer) throws -> Result in
                return try apply(UnsafeMutableRawBufferPointer(start: rawBuffer.baseAddress, count: count))
            }
        }
    @inlinable internal mutating func append(byte: Swift.UInt8) {
            let count = self.count
            assert(count + 1 <= MemoryLayout<Buffer>.size)
            Swift.withUnsafeMutableBytes(of: &bytes) { $0[count] = byte }
            self.length += 1
        }
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            guard !buffer.isEmpty else { return }
            assert(count + buffer.count <= MemoryLayout<Buffer>.size)
            let cnt = count
            _ = Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
                rawBuffer.baseAddress?.advanced(by: cnt).copyMemory(from: buffer.baseAddress!, byteCount: buffer.count)
            }

            length += UInt8(buffer.count)
        }
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                assert(index <= MemoryLayout<Buffer>.size)
                precondition(index < length, "index \(index) is out of bounds of 0..<\(length)")
                return Swift.withUnsafeBytes(of: bytes) { rawBuffer -> UInt8 in
                    return rawBuffer[index]
                }
            }
      set(newValue) {
                assert(index <= MemoryLayout<Buffer>.size)
                precondition(index < length, "index \(index) is out of bounds of 0..<\(length)")
                Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
                    rawBuffer[index] = newValue
                }
            }
    }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
            assert(range.lowerBound <= MemoryLayout<Buffer>.size)
            assert(range.upperBound <= MemoryLayout<Buffer>.size)
            precondition(range.lowerBound <= length, "index \(range.lowerBound) is out of bounds of 0..<\(length)")
            if length < range.upperBound {
                length = UInt8(range.upperBound)
            }

            let _ = Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
              memset(rawBuffer.baseAddress?.advanced(by: range.lowerBound), 0, range.upperBound - range.lowerBound)
            }
        }
    @usableFromInline
    internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with replacementBytes: Swift.UnsafeRawPointer?, count replacementLength: Swift.Int)
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            Swift.withUnsafeBytes(of: bytes) {
                let cnt = Swift.min($0.count, range.upperBound - range.lowerBound)
                guard cnt > 0 else { return }
                pointer.copyMemory(from: $0.baseAddress!.advanced(by: range.lowerBound), byteCount: cnt)
            }
        }
  }
  @usableFromInline
  internal typealias HalfInt = Swift.Int32
  @usableFromInline
  @frozen internal struct InlineSlice : Swift.Sendable {
    @usableFromInline
    internal var slice: Swift.Range<Foundation.Data.HalfInt>
    @usableFromInline
    internal var storage: Foundation.__DataStorage
    @inlinable internal static func canStore(count: Swift.Int) -> Swift.Bool {
            return count < HalfInt.max
        }
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer) {
            assert(buffer.count < HalfInt.max)
            self.init(__DataStorage(bytes: buffer.baseAddress, length: buffer.count), count: buffer.count)
        }
    @inlinable internal init(capacity: Swift.Int) {
            assert(capacity < HalfInt.max)
            self.init(__DataStorage(capacity: capacity), count: 0)
        }
    @inlinable internal init(count: Swift.Int) {
            assert(count < HalfInt.max)
            self.init(__DataStorage(length: count), count: count)
        }
    @inlinable internal init(_ inline: Foundation.Data.InlineData) {
            assert(inline.count < HalfInt.max)
            self.init(inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }, count: inline.count)
        }
    @inlinable internal init(_ inline: Foundation.Data.InlineData, range: Swift.Range<Swift.Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.init(inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }, range: range)
        }
    @inlinable internal init(_ large: Foundation.Data.LargeSlice) {
            assert(large.range.lowerBound < HalfInt.max)
            assert(large.range.upperBound < HalfInt.max)
            self.init(large.storage, range: large.range)
        }
    @inlinable internal init(_ large: Foundation.Data.LargeSlice, range: Swift.Range<Swift.Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.init(large.storage, range: range)
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, count: Swift.Int) {
            assert(count < HalfInt.max)
            self.storage = storage
            slice = 0..<HalfInt(count)
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, range: Swift.Range<Swift.Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.storage = storage
            slice = HalfInt(range.lowerBound)..<HalfInt(range.upperBound)
        }
    @inlinable internal mutating func ensureUniqueReference() {
            if !isKnownUniquelyReferenced(&storage) {
                storage = storage.mutableCopy(self.range)
            }
        }
    @inlinable internal var startIndex: Swift.Int {
      get {
            return Int(slice.lowerBound)
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
            return Int(slice.upperBound)
        }
    }
    @inlinable internal var capacity: Swift.Int {
      get {
            return storage.capacity
        }
    }
    @inlinable internal mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
            ensureUniqueReference()
            // the current capacity can be zero (representing externally owned buffer), and count can be greater than the capacity
            storage.ensureUniqueBufferReference(growingTo: Swift.max(minimumCapacity, count))
        }
    @inlinable internal var count: Swift.Int {
      get {
                return Int(slice.upperBound - slice.lowerBound)
            }
      set(newValue) {
                assert(newValue < HalfInt.max)
                ensureUniqueReference()
                
                let difference = newValue - count
                if difference > 0 {
                    let additionalRange = Int(slice.upperBound) ..< Int(slice.upperBound) + difference
                    storage.resetBytes(in: additionalRange) // Also extends storage length
                } else {
                    storage.length += difference
                }
                slice = slice.lowerBound..<(slice.lowerBound + HalfInt(newValue))
            }
    }
    @inlinable internal var range: Swift.Range<Swift.Int> {
      get {
                return Int(slice.lowerBound)..<Int(slice.upperBound)
            }
      set(newValue) {
                assert(newValue.lowerBound < HalfInt.max)
                assert(newValue.upperBound < HalfInt.max)
                slice = HalfInt(newValue.lowerBound)..<HalfInt(newValue.upperBound)
            }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            return try storage.withUnsafeBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            ensureUniqueReference()
            return try storage.withUnsafeMutableBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            assert(endIndex + buffer.count < HalfInt.max)
            ensureUniqueReference()
            storage.replaceBytes(in: NSRange(location: range.upperBound, length: storage.length - (range.upperBound - storage._offset)), with: buffer.baseAddress, length: buffer.count)
            slice = slice.lowerBound..<HalfInt(Int(slice.upperBound) + buffer.count)
        }
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                assert(index < HalfInt.max)
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                return storage.get(index)
            }
      set(newValue) {
                assert(index < HalfInt.max)
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                ensureUniqueReference()
                storage.set(index, to: newValue)
            }
    }
    @inlinable internal func bridgedReference() -> Foundation.NSData {
            return storage.bridgedReference(self.range)
        }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            ensureUniqueReference()
            storage.resetBytes(in: range)
            if slice.upperBound < range.upperBound {
                slice = slice.lowerBound..<HalfInt(range.upperBound)
            }
        }
    @inlinable internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer?, count cnt: Swift.Int) {
            precondition(startIndex <= subrange.lowerBound, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.lowerBound <= endIndex, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= subrange.upperBound, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.upperBound <= endIndex, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            let nsRange = NSRange(location: subrange.lowerBound, length: subrange.upperBound - subrange.lowerBound)
            ensureUniqueReference()
            let upper = range.upperBound
            storage.replaceBytes(in: nsRange, with: bytes, length: cnt)
            let resultingUpper = upper - nsRange.length + cnt
            slice = slice.lowerBound..<HalfInt(resultingUpper)
        }
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            storage.copyBytes(to: pointer, from: range)
        }
  }
  @usableFromInline
  @_fixed_layout final internal class RangeReference : @unchecked Swift.Sendable {
    @usableFromInline
    final internal var range: Swift.Range<Swift.Int>
    @inlinable @inline(__always) final internal var lowerBound: Swift.Int {
      get {
            return range.lowerBound
        }
    }
    @inlinable @inline(__always) final internal var upperBound: Swift.Int {
      get {
            return range.upperBound
        }
    }
    @inlinable @inline(__always) final internal var count: Swift.Int {
      get {
            return range.upperBound - range.lowerBound
        }
    }
    @inlinable @inline(__always) internal init(_ range: Swift.Range<Swift.Int>) {
            self.range = range
        }
    @objc @usableFromInline
    deinit
  }
  @usableFromInline
  @frozen internal struct LargeSlice : Swift.Sendable {
    @usableFromInline
    internal var slice: Foundation.Data.RangeReference
    @usableFromInline
    internal var storage: Foundation.__DataStorage
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer) {
            self.init(__DataStorage(bytes: buffer.baseAddress, length: buffer.count), count: buffer.count)
        }
    @inlinable internal init(capacity: Swift.Int) {
            self.init(__DataStorage(capacity: capacity), count: 0)
        }
    @inlinable internal init(count: Swift.Int) {
            self.init(__DataStorage(length: count), count: count)
        }
    @inlinable internal init(_ inline: Foundation.Data.InlineData) {
            let storage = inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }
            self.init(storage, count: inline.count)
        }
    @inlinable internal init(_ slice: Foundation.Data.InlineSlice) {
            self.storage = slice.storage
            self.slice = RangeReference(slice.range)
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, count: Swift.Int) {
            self.storage = storage
            self.slice = RangeReference(0..<count)
        }
    @inlinable internal mutating func ensureUniqueReference() {
            if !isKnownUniquelyReferenced(&storage) {
                storage = storage.mutableCopy(range)
            }
            if !isKnownUniquelyReferenced(&slice) {
                slice = RangeReference(range)
            }
        }
    @inlinable internal var startIndex: Swift.Int {
      get {
            return slice.range.lowerBound
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
          return slice.range.upperBound
        }
    }
    @inlinable internal var capacity: Swift.Int {
      get {
            return storage.capacity
        }
    }
    @inlinable internal mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
            ensureUniqueReference()
            // the current capacity can be zero (representing externally owned buffer), and count can be greater than the capacity
            storage.ensureUniqueBufferReference(growingTo: Swift.max(minimumCapacity, count))
        }
    @inlinable internal var count: Swift.Int {
      get {
                return slice.count
            }
      set(newValue) {
                ensureUniqueReference()
                let difference = newValue - count
                if difference > 0 {
                    let additionalRange = Int(slice.upperBound) ..< Int(slice.upperBound) + difference
                    storage.resetBytes(in: additionalRange) // Already sets the length
                } else {
                    storage.length += difference
                }
                slice.range = slice.range.lowerBound..<(slice.range.lowerBound + newValue)
            }
    }
    @inlinable internal var range: Swift.Range<Swift.Int> {
      get {
            return slice.range
        }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            return try storage.withUnsafeBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            ensureUniqueReference()
            return try storage.withUnsafeMutableBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            ensureUniqueReference()
            storage.replaceBytes(in: NSRange(location: range.upperBound, length: storage.length - (range.upperBound - storage._offset)), with: buffer.baseAddress, length: buffer.count)
            slice.range = slice.range.lowerBound..<slice.range.upperBound + buffer.count
        }
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                return storage.get(index)
            }
      set(newValue) {
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                ensureUniqueReference()
                storage.set(index, to: newValue)
            }
    }
    @inlinable internal func bridgedReference() -> Foundation.NSData {
            return storage.bridgedReference(self.range)
        }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Swift.Int>) {
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            ensureUniqueReference()
            storage.resetBytes(in: range)
            if slice.range.upperBound < range.upperBound {
                slice.range = slice.range.lowerBound..<range.upperBound
            }
        }
    @inlinable internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer?, count cnt: Swift.Int) {
            precondition(startIndex <= subrange.lowerBound, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.lowerBound <= endIndex, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= subrange.upperBound, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.upperBound <= endIndex, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            let nsRange = NSRange(location: subrange.lowerBound, length: subrange.upperBound - subrange.lowerBound)
            ensureUniqueReference()
            let upper = range.upperBound
            storage.replaceBytes(in: nsRange, with: bytes, length: cnt)
            let resultingUpper = upper - nsRange.length + cnt
            slice.range = slice.range.lowerBound..<resultingUpper
        }
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            storage.copyBytes(to: pointer, from: range)
        }
  }
  @usableFromInline
  @frozen internal enum _Representation : Swift.Sendable {
    case empty
    case inline(Foundation.Data.InlineData)
    case slice(Foundation.Data.InlineSlice)
    case large(Foundation.Data.LargeSlice)
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer) {
            if buffer.isEmpty {
                self = .empty
            } else if InlineData.canStore(count: buffer.count) {
                self = .inline(InlineData(buffer))
            } else if InlineSlice.canStore(count: buffer.count) {
                self = .slice(InlineSlice(buffer))
            } else {
                self = .large(LargeSlice(buffer))
            }
        }
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer, owner: Swift.AnyObject) {
            if buffer.isEmpty {
                self = .empty
            } else if InlineData.canStore(count: buffer.count) {
                self = .inline(InlineData(buffer))
            } else {
                let count = buffer.count
                let storage = __DataStorage(bytes: UnsafeMutableRawPointer(mutating: buffer.baseAddress), length: count, copy: false, deallocator: { _, _ in
                    _fixLifetime(owner)
                }, offset: 0)
                if InlineSlice.canStore(count: count) {
                    self = .slice(InlineSlice(storage, count: count))
                } else {
                    self = .large(LargeSlice(storage, count: count))
                }
            }
        }
    @inlinable internal init(capacity: Swift.Int) {
            if capacity == 0 {
                self = .empty
            } else if InlineData.canStore(count: capacity) {
                self = .inline(InlineData())
            } else if InlineSlice.canStore(count: capacity) {
                self = .slice(InlineSlice(capacity: capacity))
            } else {
                self = .large(LargeSlice(capacity: capacity))
            }
        }
    @inlinable internal init(count: Swift.Int) {
            if count == 0 {
                self = .empty
            } else if InlineData.canStore(count: count) {
                self = .inline(InlineData(count: count))
            } else if InlineSlice.canStore(count: count) {
                self = .slice(InlineSlice(count: count))
            } else {
                self = .large(LargeSlice(count: count))
            }
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, count: Swift.Int) {
            if count == 0 {
                self = .empty
            } else if InlineData.canStore(count: count) {
                self = .inline(storage.withUnsafeBytes(in: 0..<count) { InlineData($0) })
            } else if InlineSlice.canStore(count: count) {
                self = .slice(InlineSlice(storage, count: count))
            } else {
                self = .large(LargeSlice(storage, count: count))
            }
        }
    @usableFromInline
    internal mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
    @inlinable internal var count: Swift.Int {
      get {
                switch self {
                case .empty: return 0
                case .inline(let inline): return inline.count
                case .slice(let slice): return slice.count
                case .large(let slice): return slice.count
                }
            }
      set(newValue) {
                // HACK: The definition of this inline function takes an inout reference to self, giving the optimizer a unique referencing guarantee.
                //       This allows us to avoid excessive retain-release traffic around modifying enum values, and inlining the function then avoids the additional frame.
                @inline(__always)
                func apply(_ representation: inout _Representation, _ newValue: Int) -> _Representation? {
                    switch representation {
                    case .empty:
                        if newValue == 0 {
                            return nil
                        } else if InlineData.canStore(count: newValue) {
                            return .inline(InlineData(count: newValue))
                        } else if InlineSlice.canStore(count: newValue) {
                            return .slice(InlineSlice(count: newValue))
                        } else {
                            return .large(LargeSlice(count: newValue))
                        }
                    case .inline(var inline):
                        if newValue == 0 {
                            return .empty
                        } else if InlineData.canStore(count: newValue) {
                            guard inline.count != newValue else { return nil }
                            inline.count = newValue
                            return .inline(inline)
                        } else if InlineSlice.canStore(count: newValue) {
                            var slice = InlineSlice(inline)
                            slice.count = newValue
                            return .slice(slice)
                        } else {
                            var slice = LargeSlice(inline)
                            slice.count = newValue
                            return .large(slice)
                        }
                    case .slice(var slice):
                        if newValue == 0 && slice.startIndex == 0 {
                            return .empty
                        } else if slice.startIndex == 0 && InlineData.canStore(count: newValue) {
                            return .inline(InlineData(slice, count: newValue))
                        } else if InlineSlice.canStore(count: newValue + slice.startIndex) {
                            guard slice.count != newValue else { return nil }
                            representation = .empty // TODO: remove this when mgottesman lands optimizations
                            slice.count = newValue
                            return .slice(slice)
                        } else {
                            var newSlice = LargeSlice(slice)
                            newSlice.count = newValue
                            return .large(newSlice)
                        }
                    case .large(var slice):
                        if newValue == 0 && slice.startIndex == 0 {
                            return .empty
                        } else if slice.startIndex == 0 && InlineData.canStore(count: newValue) {
                            return .inline(InlineData(slice, count: newValue))
                        } else {
                            guard slice.count != newValue else { return nil}
                            representation = .empty // TODO: remove this when mgottesman lands optimizations
                            slice.count = newValue
                            return .large(slice)
                        }
                    }
                }

                if let rep = apply(&self, newValue) {
                    self = rep
                }
            }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            switch self {
            case .empty:
                let empty = InlineData()
                return try empty.withUnsafeBytes(apply)
            case .inline(let inline):
                return try inline.withUnsafeBytes(apply)
            case .slice(let slice):
                return try slice.withUnsafeBytes(apply)
            case .large(let slice):
                return try slice.withUnsafeBytes(apply)
            }
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            switch self {
            case .empty:
                var empty = InlineData()
                return try empty.withUnsafeMutableBytes(apply)
            case .inline(var inline):
                defer { self = .inline(inline) }
                return try inline.withUnsafeMutableBytes(apply)
            case .slice(var slice):
                self = .empty
                defer { self = .slice(slice) }
                return try slice.withUnsafeMutableBytes(apply)
            case .large(var slice):
                self = .empty
                defer { self = .large(slice) }
                return try slice.withUnsafeMutableBytes(apply)
            }
        }
    @inlinable internal func withInteriorPointerReference<T>(_ work: (Foundation.NSData) throws -> T) rethrows -> T {
            switch self {
            case .empty:
                return try work(NSData())
            case .inline(let inline):
                return try inline.withUnsafeBytes {
                    return try work(NSData(bytesNoCopy: UnsafeMutableRawPointer(mutating: $0.baseAddress ?? UnsafeRawPointer(bitPattern: 0xBAD0)!), length: $0.count, freeWhenDone: false))
                }
            case .slice(let slice):
                return try slice.storage.withInteriorPointerReference(slice.range, work)
            case .large(let slice):
                return try slice.storage.withInteriorPointerReference(slice.range, work)
            }
        }
    @usableFromInline
    internal func enumerateBytes(_ block: (_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>, _ byteIndex: Foundation.Data.Index, _ stop: inout Swift.Bool) -> Swift.Void)
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            switch self {
            case .empty:
                self = _Representation(buffer)
            case .inline(var inline):
                if InlineData.canStore(count: inline.count + buffer.count) {
                    inline.append(contentsOf: buffer)
                    self = .inline(inline)
                } else if InlineSlice.canStore(count: inline.count + buffer.count) {
                    var newSlice = InlineSlice(inline)
                    newSlice.append(contentsOf: buffer)
                    self = .slice(newSlice)
                } else {
                    var newSlice = LargeSlice(inline)
                    newSlice.append(contentsOf: buffer)
                    self = .large(newSlice)
                }
            case .slice(var slice):
                if InlineSlice.canStore(count: slice.range.upperBound + buffer.count) {
                    self = .empty
                    defer { self = .slice(slice) }
                    slice.append(contentsOf: buffer)
                } else {
                    self = .empty
                    var newSlice = LargeSlice(slice)
                    newSlice.append(contentsOf: buffer)
                    self = .large(newSlice)
                }
            case .large(var slice):
                self = .empty
                defer { self = .large(slice) }
                slice.append(contentsOf: buffer)
            }
        }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
            switch self {
            case .empty:
                if range.upperBound == 0 {
                    self = .empty
                } else if InlineData.canStore(count: range.upperBound) {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .inline(InlineData(count: range.upperBound))
                } else if InlineSlice.canStore(count: range.upperBound) {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .slice(InlineSlice(count: range.upperBound))
                } else {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .large(LargeSlice(count: range.upperBound))
                }
            case .inline(var inline):
                if inline.count < range.upperBound {
                    if InlineSlice.canStore(count: range.upperBound) {
                        var slice = InlineSlice(inline)
                        slice.resetBytes(in: range)
                        self = .slice(slice)
                    } else {
                        var slice = LargeSlice(inline)
                        slice.resetBytes(in: range)
                        self = .large(slice)
                    }
                } else {
                    inline.resetBytes(in: range)
                    self = .inline(inline)
                }
            case .slice(var slice):
                if InlineSlice.canStore(count: range.upperBound) {
                    self = .empty
                    slice.resetBytes(in: range)
                    self = .slice(slice)
                } else {
                    self = .empty
                    var newSlice = LargeSlice(slice)
                    newSlice.resetBytes(in: range)
                    self = .large(newSlice)
                }
            case .large(var slice):
                self = .empty
                slice.resetBytes(in: range)
                self = .large(slice)
            }
        }
    @usableFromInline
    internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer?, count cnt: Swift.Int)
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                switch self {
                case .empty: preconditionFailure("index \(index) out of range of 0")
                case .inline(let inline): return inline[index]
                case .slice(let slice): return slice[index]
                case .large(let slice): return slice[index]
                }
            }
      set(newValue) {
                switch self {
                case .empty: preconditionFailure("index \(index) out of range of 0")
                case .inline(var inline):
                    inline[index] = newValue
                    self = .inline(inline)
                case .slice(var slice):
                    self = .empty
                    slice[index] = newValue
                    self = .slice(slice)
                case .large(var slice):
                    self = .empty
                    slice[index] = newValue
                    self = .large(slice)
                }
            }
    }
    @inlinable internal subscript(bounds: Swift.Range<Foundation.Data.Index>) -> Foundation.Data {
      get {
                switch self {
                case .empty:
                    precondition(bounds.lowerBound == 0 && (bounds.upperBound - bounds.lowerBound) == 0, "Range \(bounds) out of bounds 0..<0")
                    return Data()
                case .inline(let inline):
                    precondition(bounds.upperBound <= inline.count, "Range \(bounds) out of bounds 0..<\(inline.count)")
                    if bounds.lowerBound == 0 {
                        var newInline = inline
                        newInline.count = bounds.upperBound
                        return Data(representation: .inline(newInline))
                    } else {
                        return Data(representation: .slice(InlineSlice(inline, range: bounds)))
                    }
                case .slice(let slice):
                    precondition(slice.startIndex <= bounds.lowerBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.lowerBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(slice.startIndex <= bounds.upperBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.upperBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    if bounds.lowerBound == 0 && bounds.upperBound == 0 {
                        return Data()
                    } else if bounds.lowerBound == 0 && InlineData.canStore(count: bounds.count) {
                        return Data(representation: .inline(InlineData(slice, count: bounds.count)))
                    } else {
                        var newSlice = slice
                        newSlice.range = bounds
                        return Data(representation: .slice(newSlice))
                    }
                case .large(let slice):
                    precondition(slice.startIndex <= bounds.lowerBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.lowerBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(slice.startIndex <= bounds.upperBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.upperBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    if bounds.lowerBound == 0 && bounds.upperBound == 0 {
                        return Data()
                    } else if bounds.lowerBound == 0 && InlineData.canStore(count: bounds.upperBound) {
                        return Data(representation: .inline(InlineData(slice, count: bounds.upperBound)))
                    } else if InlineSlice.canStore(count: bounds.lowerBound) && InlineSlice.canStore(count: bounds.upperBound) {
                        return Data(representation: .slice(InlineSlice(slice, range: bounds)))
                    } else {
                        var newSlice = slice
                        newSlice.slice = RangeReference(bounds)
                        return Data(representation: .large(newSlice))
                    }
                }
            }
    }
    @inlinable internal var startIndex: Swift.Int {
      get {
            switch self {
            case .empty: return 0
            case .inline: return 0
            case .slice(let slice): return slice.startIndex
            case .large(let slice): return slice.startIndex
            }
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
            switch self {
            case .empty: return 0
            case .inline(let inline): return inline.count
            case .slice(let slice): return slice.endIndex
            case .large(let slice): return slice.endIndex
            }
        }
    }
    @inlinable internal func bridgedReference() -> Foundation.NSData {
            switch self {
            case .empty: return NSData()
            case .inline(let inline):
                return inline.withUnsafeBytes {
                    return NSData(bytes: $0.baseAddress, length: $0.count)
                }
            case .slice(let slice):
                return slice.bridgedReference()
            case .large(let slice):
                return slice.bridgedReference()
            }
        }
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            switch self {
            case .empty:
                precondition(range.lowerBound == 0 && range.upperBound == 0, "Range \(range) out of bounds 0..<0")
                return
            case .inline(let inline):
                inline.copyBytes(to: pointer, from: range)
            case .slice(let slice):
                slice.copyBytes(to: pointer, from: range)
            case .large(let slice):
                slice.copyBytes(to: pointer, from: range)
            }
        }
  }
  @usableFromInline
  internal var _representation: Foundation.Data._Representation
  public enum Deallocator {
    case virtualMemory
    case unmap
    case free
    case none
    case custom((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void)
    @usableFromInline
    internal var _deallocator: ((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void) {
      get
    }
  }
  @inlinable public init(bytes: Swift.UnsafeRawPointer, count: Swift.Int) {
        _representation = _Representation(UnsafeRawBufferPointer(start: bytes, count: count))
    }
  @inlinable public init<SourceType>(buffer: Swift.UnsafeBufferPointer<SourceType>) {
        _representation = _Representation(UnsafeRawBufferPointer(buffer))
    }
  @inlinable public init<SourceType>(buffer: Swift.UnsafeMutableBufferPointer<SourceType>) {
        _representation = _Representation(UnsafeRawBufferPointer(buffer))
    }
  @inlinable public init(repeating repeatedValue: Swift.UInt8, count: Swift.Int) {
        self.init(count: count)
        withUnsafeMutableBytes { (buffer: UnsafeMutableRawBufferPointer) -> Void in
            memset(buffer.baseAddress, Int32(repeatedValue), buffer.count)
        }
    }
  @inlinable public init(capacity: Swift.Int) {
        _representation = _Representation(capacity: capacity)
    }
  @inlinable public init(count: Swift.Int) {
        _representation = _Representation(count: count)
    }
  @inlinable public init() {
        _representation = .empty
    }
  @inlinable public init(bytesNoCopy bytes: Swift.UnsafeMutableRawPointer, count: Swift.Int, deallocator: Foundation.Data.Deallocator) {
        let whichDeallocator = deallocator._deallocator
        if count == 0 {
            deallocator._deallocator(bytes, count)
            _representation = .empty
        } else {
            _representation = _Representation(__DataStorage(bytes: bytes, length: count, copy: false, deallocator: whichDeallocator, offset: 0), count: count)
        }
    }
  @inlinable public init(contentsOf url: __shared Foundation.URL, options: Foundation.Data.ReadingOptions = []) throws {
        let d = try NSData(contentsOf: url, options: ReadingOptions(rawValue: options.rawValue))
        self.init(referencing: d)
    }
  @inlinable public init?(base64Encoded base64String: __shared Swift.String, options: Foundation.Data.Base64DecodingOptions = []) {
        if let d = NSData(base64Encoded: base64String, options: Base64DecodingOptions(rawValue: options.rawValue)) {
            self.init(referencing: d)
        } else {
            return nil
        }
    }
  @inlinable public init?(base64Encoded base64Data: __shared Foundation.Data, options: Foundation.Data.Base64DecodingOptions = []) {
        if let d = NSData(base64Encoded: base64Data, options: Base64DecodingOptions(rawValue: options.rawValue)) {
            self.init(referencing: d)
        } else {
            return nil
        }
    }
  public init(referencing reference: __shared Foundation.NSData)
  @inlinable public init<S>(_ elements: S) where S : Swift.Sequence, S.Element == Swift.UInt8 {
        // If the sequence is already contiguous, access the underlying raw memory directly.
        if let contiguous = elements as? ContiguousBytes {
            _representation = contiguous.withUnsafeBytes { return _Representation($0) }
            return
        }

        // The sequence might still be able to provide direct access to typed memory.
        // NOTE: It's safe to do this because we're already guarding on S's element as `UInt8`. This would not be safe on arbitrary sequences.
        let representation = elements.withContiguousStorageIfAvailable {
            _Representation(UnsafeRawBufferPointer($0))
        }
        if let representation = representation {
            _representation = representation
            return
        }

        // Copy as much as we can in one shot from the sequence.
        let underestimatedCount = elements.underestimatedCount
        _representation = _Representation(count: underestimatedCount)
        var (iter, endIndex): (S.Iterator, Int) = _representation.withUnsafeMutableBytes { buffer in
            let start = buffer.baseAddress!.assumingMemoryBound(to: UInt8.self)
            let b = UnsafeMutableBufferPointer(start: start, count: buffer.count)
            return elements._copyContents(initializing: b)
        }
        guard endIndex == _representation.count else {
            // We can't trap here. We have to allow an underfilled buffer
            // to emulate the previous implementation.
            _representation.replaceSubrange(endIndex ..< _representation.endIndex, with: nil, count: 0)
            return
        }

        // Append the rest byte-wise, buffering through an InlineData.
        var buffer = InlineData()
        while let element = iter.next() {
            buffer.append(byte: element)
            if buffer.count == buffer.capacity {
                buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
                buffer.count = 0
            }
        }

        // If we've still got bytes left in the buffer (i.e. the loop ended before we filled up the buffer and cleared it out), append them.
        if buffer.count > 0 {
            buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
            buffer.count = 0
        }
    }
  @available(swift 4.2)
  @available(swift, deprecated: 5, message: "use `init(_:)` instead")
  public init<S>(bytes elements: S) where S : Swift.Sequence, S.Element == Swift.UInt8
  @available(swift, obsoleted: 4.2)
  public init(bytes: Swift.Array<Swift.UInt8>)
  @available(swift, obsoleted: 4.2)
  public init(bytes: Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init(representation: Foundation.Data._Representation) {
        _representation = representation
    }
  @inlinable public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
        _representation.reserveCapacity(minimumCapacity)
    }
  @inlinable public var count: Swift.Int {
    get {
            return _representation.count
        }
    set(newValue) {
            precondition(newValue >= 0, "count must not be negative")
            _representation.count = newValue
        }
  }
  @inlinable public var regions: Swift.CollectionOfOne<Foundation.Data> {
    get {
        return CollectionOfOne(self)
    }
  }
  @available(swift, deprecated: 5, message: "use `withUnsafeBytes<R>(_: (UnsafeRawBufferPointer) throws -> R) rethrows -> R` instead")
  public func withUnsafeBytes<ResultType, ContentType>(_ body: (Swift.UnsafePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
  @inlinable public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType {
        return try _representation.withUnsafeBytes(body)
    }
  @available(swift, deprecated: 5, message: "use `withUnsafeMutableBytes<R>(_: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R` instead")
  public mutating func withUnsafeMutableBytes<ResultType, ContentType>(_ body: (Swift.UnsafeMutablePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
  @inlinable public mutating func withUnsafeMutableBytes<ResultType>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> ResultType) rethrows -> ResultType {
        return try _representation.withUnsafeMutableBytes(body)
    }
  @inlinable public func copyBytes(to pointer: Swift.UnsafeMutablePointer<Swift.UInt8>, count: Swift.Int) {
        precondition(count >= 0, "count of bytes to copy must not be negative")
        if count == 0 { return }
        _copyBytesHelper(to: UnsafeMutableRawPointer(pointer), from: startIndex..<(startIndex + count))
    }
  @inlinable internal func _copyBytesHelper(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
        if range.isEmpty { return }
        _representation.copyBytes(to: pointer, from: range)
    }
  @inlinable public func copyBytes(to pointer: Swift.UnsafeMutablePointer<Swift.UInt8>, from range: Swift.Range<Foundation.Data.Index>) {
        _copyBytesHelper(to: pointer, from: range)
    }
  @inlinable public func copyBytes<DestinationType>(to buffer: Swift.UnsafeMutableBufferPointer<DestinationType>, from range: Swift.Range<Foundation.Data.Index>? = nil) -> Swift.Int {
        let cnt = count
        guard cnt > 0 else { return 0 }
        
        let copyRange : Range<Index>
        if let r = range {
            guard !r.isEmpty else { return 0 }
            copyRange = r.lowerBound..<(r.lowerBound + Swift.min(buffer.count * MemoryLayout<DestinationType>.stride, r.upperBound - r.lowerBound))
        } else {
            copyRange = 0..<Swift.min(buffer.count * MemoryLayout<DestinationType>.stride, cnt)
        }
        
        guard !copyRange.isEmpty else { return 0 }
        
        _copyBytesHelper(to: buffer.baseAddress!, from: copyRange)
        return copyRange.upperBound - copyRange.lowerBound
    }
  public func write(to url: Foundation.URL, options: Foundation.Data.WritingOptions = []) throws
  public func range(of dataToFind: Foundation.Data, options: Foundation.Data.SearchOptions = [], in range: Swift.Range<Foundation.Data.Index>? = nil) -> Swift.Range<Foundation.Data.Index>?
  @available(swift, deprecated: 5, message: "use `regions` or `for-in` instead")
  public func enumerateBytes(_ block: (_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>, _ byteIndex: Foundation.Data.Index, _ stop: inout Swift.Bool) -> Swift.Void)
  @inlinable internal mutating func _append<SourceType>(_ buffer: Swift.UnsafeBufferPointer<SourceType>) {
        if buffer.isEmpty { return }
        _representation.append(contentsOf: UnsafeRawBufferPointer(buffer))
    }
  @inlinable public mutating func append(_ bytes: Swift.UnsafePointer<Swift.UInt8>, count: Swift.Int) {
        if count == 0 { return }
        _append(UnsafeBufferPointer(start: bytes, count: count))
    }
  public mutating func append(_ other: Foundation.Data)
  @inlinable public mutating func append<SourceType>(_ buffer: Swift.UnsafeBufferPointer<SourceType>) {
        _append(buffer)
    }
  @inlinable public mutating func append(contentsOf bytes: [Swift.UInt8]) {
        bytes.withUnsafeBufferPointer { (buffer: UnsafeBufferPointer<UInt8>) -> Void in
            _append(buffer)
        }
    }
  @inlinable public mutating func append<S>(contentsOf elements: S) where S : Swift.Sequence, S.Element == Swift.UInt8 {
        // If the sequence is already contiguous, access the underlying raw memory directly.
        if let contiguous = elements as? ContiguousBytes {
            contiguous.withUnsafeBytes {
                _representation.append(contentsOf: $0)
            }

            return
        }

        // The sequence might still be able to provide direct access to typed memory.
        // NOTE: It's safe to do this because we're already guarding on S's element as `UInt8`. This would not be safe on arbitrary sequences.
        let appended: Void? = elements.withContiguousStorageIfAvailable {
            _representation.append(contentsOf: UnsafeRawBufferPointer($0))
        }
        guard appended == nil else { return }

        // The sequence is really not contiguous.
        // Copy as much as we can in one shot.
        let underestimatedCount = elements.underestimatedCount
        let originalCount = _representation.count
        resetBytes(in: self.endIndex ..< self.endIndex + underestimatedCount)
        var (iter, copiedCount): (S.Iterator, Int) = _representation.withUnsafeMutableBytes { buffer in
            assert(buffer.count == originalCount + underestimatedCount)
            let start = buffer.baseAddress!.assumingMemoryBound(to: UInt8.self) + originalCount
            let b = UnsafeMutableBufferPointer(start: start, count: buffer.count - originalCount)
            return elements._copyContents(initializing: b)
        }
        guard copiedCount == underestimatedCount else {
            // We can't trap here. We have to allow an underfilled buffer
            // to emulate the previous implementation.
            _representation.replaceSubrange(startIndex + originalCount + copiedCount ..< endIndex, with: nil, count: 0)
            return
        }

        // Append the rest byte-wise, buffering through an InlineData.
        var buffer = InlineData()
        while let element = iter.next() {
            buffer.append(byte: element)
            if buffer.count == buffer.capacity {
                buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
                buffer.count = 0
            }
        }

        // If we've still got bytes left in the buffer (i.e. the loop ended before we filled up the buffer and cleared it out), append them.
        if buffer.count > 0 {
            buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
            buffer.count = 0
        }
    }
  @inlinable public mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
        // it is worth noting that the range here may be out of bounds of the Data itself (which triggers a growth)
        precondition(range.lowerBound >= 0, "Ranges must not be negative bounds")
        precondition(range.upperBound >= 0, "Ranges must not be negative bounds")
        _representation.resetBytes(in: range)
    }
  @inlinable public mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with data: Foundation.Data) {
        data.withUnsafeBytes { (buffer: UnsafeRawBufferPointer) in
            _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: buffer.count)
        }
    }
  @inlinable public mutating func replaceSubrange<SourceType>(_ subrange: Swift.Range<Foundation.Data.Index>, with buffer: Swift.UnsafeBufferPointer<SourceType>) {
        guard !buffer.isEmpty  else { return }
        replaceSubrange(subrange, with: buffer.baseAddress!, count: buffer.count * MemoryLayout<SourceType>.stride)
    }
  @inlinable public mutating func replaceSubrange<ByteCollection>(_ subrange: Swift.Range<Foundation.Data.Index>, with newElements: ByteCollection) where ByteCollection : Swift.Collection, ByteCollection.Element == Swift.UInt8 {
        // If the collection is already contiguous, access the underlying raw memory directly.
        if let contiguous = newElements as? ContiguousBytes {
            contiguous.withUnsafeBytes { buffer in
                _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: buffer.count)
            }
            return
        }
        // The collection might still be able to provide direct access to typed memory.
        // NOTE: It's safe to do this because we're already guarding on ByteCollection's element as `UInt8`. This would not be safe on arbitrary collections.
        let replaced: Void? = newElements.withContiguousStorageIfAvailable { buffer in
            _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: buffer.count)
        }
        guard replaced == nil else { return }

        let totalCount = Int(newElements.count)
        _withStackOrHeapBuffer(capacity: totalCount) { buffer in
            var (iterator, index) = newElements._copyContents(initializing: buffer)
            precondition(index == buffer.endIndex, "Collection has less elements than its count")
            precondition(iterator.next() == nil, "Collection has more elements than its count")
            _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: totalCount)
        }
    }
  @inlinable public mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer, count cnt: Swift.Int) {
        _representation.replaceSubrange(subrange, with: bytes, count: cnt)
    }
  public func subdata(in range: Swift.Range<Foundation.Data.Index>) -> Foundation.Data
  @inlinable public func base64EncodedString(options: Foundation.Data.Base64EncodingOptions = []) -> Swift.String {
        return _representation.withInteriorPointerReference {
            return $0.base64EncodedString(options: options)
        }
    }
  @inlinable public func base64EncodedData(options: Foundation.Data.Base64EncodingOptions = []) -> Foundation.Data {
        return _representation.withInteriorPointerReference {
            return $0.base64EncodedData(options: options)
        }
    }
  @inline(never) public func hash(into hasher: inout Swift.Hasher)
  public func advanced(by amount: Swift.Int) -> Foundation.Data
  @inlinable public subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
    get {
            return _representation[index]
        }
    set(newValue) {
            _representation[index] = newValue
        }
  }
  @inlinable public subscript(bounds: Swift.Range<Foundation.Data.Index>) -> Foundation.Data {
    get {
            return _representation[bounds]
        }
    set {
            replaceSubrange(bounds, with: newValue)
        }
  }
  @inlinable public subscript<R>(rangeExpression: R) -> Foundation.Data where R : Swift.RangeExpression, R.Bound : Swift.FixedWidthInteger {
    get {
            let lower = R.Bound(startIndex)
            let upper = R.Bound(endIndex)
            let range = rangeExpression.relative(to: lower..<upper)
            let start = Int(range.lowerBound)
            let end = Int(range.upperBound)
            let r: Range<Int> = start..<end
            return _representation[r]
        }
    set {
            let lower = R.Bound(startIndex)
            let upper = R.Bound(endIndex)
            let range = rangeExpression.relative(to: lower..<upper)
            let start = Int(range.lowerBound)
            let end = Int(range.upperBound)
            let r: Range<Int> = start..<end
            replaceSubrange(r, with: newValue)
        }
  }
  @inlinable public var startIndex: Foundation.Data.Index {
    get {
            return _representation.startIndex
        }
  }
  @inlinable public var endIndex: Foundation.Data.Index {
    get {
            return _representation.endIndex
        }
  }
  @inlinable public func index(before i: Foundation.Data.Index) -> Foundation.Data.Index {
        return i - 1
    }
  @inlinable public func index(after i: Foundation.Data.Index) -> Foundation.Data.Index {
        return i + 1
    }
  @inlinable public var indices: Swift.Range<Swift.Int> {
    get {
            return startIndex..<endIndex
        }
  }
  @inlinable public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> (Foundation.Data.Iterator, Swift.UnsafeMutableBufferPointer<Swift.UInt8>.Index) {
        guard !isEmpty else { return (makeIterator(), buffer.startIndex) }
        let cnt = Swift.min(count, buffer.count)
        
        withUnsafeBytes { (bytes: UnsafeRawBufferPointer) in
            _ = memcpy(UnsafeMutableRawPointer(buffer.baseAddress), bytes.baseAddress, cnt)
        }
        
        return (Iterator(self, at: startIndex + cnt), buffer.index(buffer.startIndex, offsetBy: cnt))
    }
  @inlinable public func makeIterator() -> Foundation.Data.Iterator {
        return Iterator(self, at: startIndex)
    }
  public struct Iterator : Swift.IteratorProtocol, Swift.Sendable {
    @usableFromInline
    internal typealias Buffer = (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8)
    @usableFromInline
    internal let _data: Foundation.Data
    @usableFromInline
    internal var _buffer: Foundation.Data.Iterator.Buffer
    @usableFromInline
    internal var _idx: Foundation.Data.Index
    @usableFromInline
    internal let _endIdx: Foundation.Data.Index
    @usableFromInline
    internal init(_ data: Foundation.Data, at loc: Foundation.Data.Index)
    public mutating func next() -> Swift.UInt8?
    public typealias Element = Swift.UInt8
  }
  @inlinable public static func == (d1: Foundation.Data, d2: Foundation.Data) -> Swift.Bool {
        let length1 = d1.count
        if length1 != d2.count {
            return false
        }
        if length1 > 0 {
            return d1.withUnsafeBytes { (b1: UnsafeRawBufferPointer) in
                return d2.withUnsafeBytes { (b2: UnsafeRawBufferPointer) in
                    return memcmp(b1.baseAddress!, b2.baseAddress!, b2.count) == 0
                }
            }
        }
        return true
    }
  public typealias Element = Swift.UInt8
  public typealias Regions = Swift.CollectionOfOne<Foundation.Data>
  public typealias SubSequence = Foundation.Data
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Data : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.Data : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSData
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSData, result: inout Foundation.Data?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSData, result: inout Foundation.Data?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSData?) -> Foundation.Data
  public typealias _ObjectiveCType = Foundation.NSData
}
extension Foundation.NSData : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.Data : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS, unavailable, introduced: 7)
@available(*, unavailable)
extension Foundation.Data.Deallocator : @unchecked Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct FormatString : Swift.Hashable, Swift.Sendable {
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatString, b: Foundation.Date.FormatString) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatString : Swift.ExpressibleByStringInterpolation {
  public init(stringInterpolation: Foundation.Date.FormatString.StringInterpolation)
  public init(stringLiteral value: Swift.String)
  public struct StringInterpolation : Swift.StringInterpolationProtocol, Swift.Sendable {
    public typealias StringLiteralType = Swift.String
    public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int)
    public mutating func appendLiteral(_ literal: Swift.String)
    public mutating func appendInterpolation(era: Foundation.Date.FormatStyle.Symbol.Era)
    public mutating func appendInterpolation(year: Foundation.Date.FormatStyle.Symbol.Year)
    public mutating func appendInterpolation(yearForWeekOfYear: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear)
    public mutating func appendInterpolation(cyclicYear: Foundation.Date.FormatStyle.Symbol.CyclicYear)
    public mutating func appendInterpolation(quarter: Foundation.Date.FormatStyle.Symbol.Quarter)
    public mutating func appendInterpolation(standaloneQuarter: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter)
    public mutating func appendInterpolation(month: Foundation.Date.FormatStyle.Symbol.Month)
    public mutating func appendInterpolation(standaloneMonth: Foundation.Date.FormatStyle.Symbol.StandaloneMonth)
    public mutating func appendInterpolation(week: Foundation.Date.FormatStyle.Symbol.Week)
    public mutating func appendInterpolation(day: Foundation.Date.FormatStyle.Symbol.Day)
    public mutating func appendInterpolation(dayOfYear: Foundation.Date.FormatStyle.Symbol.DayOfYear)
    public mutating func appendInterpolation(weekday: Foundation.Date.FormatStyle.Symbol.Weekday)
    public mutating func appendInterpolation(standaloneWeekday: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday)
    public mutating func appendInterpolation(dayPeriod: Foundation.Date.FormatStyle.Symbol.DayPeriod)
    public mutating func appendInterpolation(hour: Foundation.Date.FormatStyle.Symbol.VerbatimHour)
    public mutating func appendInterpolation(minute: Foundation.Date.FormatStyle.Symbol.Minute)
    public mutating func appendInterpolation(second: Foundation.Date.FormatStyle.Symbol.Second)
    public mutating func appendInterpolation(secondFraction: Foundation.Date.FormatStyle.Symbol.SecondFraction)
    public mutating func appendInterpolation(timeZone: Foundation.Date.FormatStyle.Symbol.TimeZone)
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.Timer {
  public static func publish(every interval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval? = nil, on runLoop: Foundation.RunLoop, in mode: Foundation.RunLoop.Mode, options: Foundation.RunLoop.SchedulerOptions? = nil) -> Foundation.Timer.TimerPublisher
  final public class TimerPublisher : Combine.ConnectablePublisher {
    public typealias Output = Foundation.Date
    public typealias Failure = Swift.Never
    final public let interval: Foundation.TimeInterval
    final public let tolerance: Foundation.TimeInterval?
    final public let runLoop: Foundation.RunLoop
    final public let mode: Foundation.RunLoop.Mode
    final public let options: Foundation.RunLoop.SchedulerOptions?
    public init(interval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval? = nil, runLoop: Foundation.RunLoop, mode: Foundation.RunLoop.Mode, options: Foundation.RunLoop.SchedulerOptions? = nil)
    @objc deinit
    final public func connect() -> any Combine.Cancellable
    final public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == Foundation.Date
  }
}
@available(iOS, unavailable, introduced: 13)
@available(*, unavailable)
extension Foundation.Timer.TimerPublisher : @unchecked Swift.Sendable {
}
extension Foundation.NSURL : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSURL.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct AttributeContainer : Swift.Equatable, Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public subscript<T>(_: T.Type) -> T.Value? where T : Foundation.AttributedStringKey {
    get
    set
  }
  public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey {
    get
    set
  }
  public subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
    get
    _modify
  }
  public static subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> Foundation.AttributeContainer.Builder<K> where K : Foundation.AttributedStringKey {
    get
  }
  @_disfavoredOverload public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> Foundation.AttributeContainer.Builder<K> where K : Foundation.AttributedStringKey {
    get
  }
  public struct Builder<T> where T : Foundation.AttributedStringKey {
    public func callAsFunction(_ value: T.Value) -> Foundation.AttributeContainer
  }
  public init()
  public mutating func merge(_ other: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew)
  public func merging(_ other: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew) -> Foundation.AttributeContainer
  public static func == (a: Foundation.AttributeContainer, b: Foundation.AttributeContainer) -> Swift.Bool
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributeContainer : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributedStringAttributeMutation {
  mutating func setAttributes(_ attributes: Foundation.AttributeContainer)
  mutating func mergeAttributes(_ attributes: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy)
  mutating func replaceAttributes(_ attributes: Foundation.AttributeContainer, with others: Foundation.AttributeContainer)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public protocol AttributedStringProtocol : Foundation.AttributedStringAttributeMutation, Swift.CustomStringConvertible, Swift.Hashable {
  var startIndex: Foundation.AttributedString.Index { get }
  var endIndex: Foundation.AttributedString.Index { get }
  var runs: Foundation.AttributedString.Runs { get }
  var characters: Foundation.AttributedString.CharacterView { get }
  var unicodeScalars: Foundation.AttributedString.UnicodeScalarView { get }
  subscript<K>(_: K.Type) -> K.Value? where K : Foundation.AttributedStringKey { get set }
  subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey { get set }
  subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope { get set }
  subscript<R>(bounds: R) -> Foundation.AttributedSubstring where R : Swift.RangeExpression, R.Bound == Foundation.AttributedString.Index { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringProtocol {
  public func settingAttributes(_ attributes: Foundation.AttributeContainer) -> Foundation.AttributedString
  public func mergingAttributes(_ attributes: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew) -> Foundation.AttributedString
  public func replacingAttributes(_ attributes: Foundation.AttributeContainer, with others: Foundation.AttributeContainer) -> Foundation.AttributedString
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringProtocol {
  public var description: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  @_specialize(exported: false, kind: full, where Self == Foundation.AttributedString, RHS == Foundation.AttributedString)
  @_specialize(exported: false, kind: full, where Self == Foundation.AttributedString, RHS == Foundation.AttributedSubstring)
  @_specialize(exported: false, kind: full, where Self == Foundation.AttributedSubstring, RHS == Foundation.AttributedString)
  @_specialize(exported: false, kind: full, where Self == Foundation.AttributedSubstring, RHS == Foundation.AttributedSubstring)
  public static func == <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Foundation.AttributedStringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringProtocol {
  public func index(afterCharacter i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(beforeCharacter i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(_ i: Foundation.AttributedString.Index, offsetByCharacters distance: Swift.Int) -> Foundation.AttributedString.Index
  public func index(afterUnicodeScalar i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(beforeUnicodeScalar i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(_ i: Foundation.AttributedString.Index, offsetByUnicodeScalars distance: Swift.Int) -> Foundation.AttributedString.Index
  public func index(afterRun i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(beforeRun i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(_ i: Foundation.AttributedString.Index, offsetByRuns distance: Swift.Int) -> Foundation.AttributedString.Index
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringProtocol {
  public func range<T>(of stringToFind: T, options: Swift.String.CompareOptions = [], locale: Foundation.Locale? = nil) -> Swift.Range<Foundation.AttributedString.Index>? where T : Swift.StringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct AttributedString : Foundation.AttributedStringProtocol {
  public enum AttributeMergePolicy : Swift.Sendable {
    case keepNew
    case keepCurrent
    public static func == (a: Foundation.AttributedString.AttributeMergePolicy, b: Foundation.AttributedString.AttributeMergePolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public subscript<K>(_: K.Type) -> K.Value? where K : Foundation.AttributedStringKey {
    get
    set
  }
  public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey {
    get
    set
  }
  public subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
    get
    _modify
  }
  public mutating func setAttributes(_ attributes: Foundation.AttributeContainer)
  public mutating func mergeAttributes(_ attributes: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew)
  public mutating func replaceAttributes(_ attributes: Foundation.AttributeContainer, with others: Foundation.AttributeContainer)
  public func transformingAttributes<K>(_ k: K.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K>) -> Swift.Void) -> Foundation.AttributedString where K : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2>(_ k: K1.Type, _ k2: K2.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2, K3>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2, K3, K4>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ k4: K4.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>, inout Foundation.AttributedString.SingleAttributeTransformer<K4>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K4 : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2, K3, K4, K5>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ k4: K4.Type, _ k5: K5.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>, inout Foundation.AttributedString.SingleAttributeTransformer<K4>, inout Foundation.AttributedString.SingleAttributeTransformer<K5>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K4 : Foundation.AttributedStringKey, K5 : Foundation.AttributedStringKey
  public func transformingAttributes<K>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K>) -> Swift.Void) -> Foundation.AttributedString where K : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K1>, _ k2: Swift.KeyPath<Foundation.AttributeDynamicLookup, K2>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2, K3>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K1>, _ k2: Swift.KeyPath<Foundation.AttributeDynamicLookup, K2>, _ k3: Swift.KeyPath<Foundation.AttributeDynamicLookup, K3>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2, K3, K4>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K1>, _ k2: Swift.KeyPath<Foundation.AttributeDynamicLookup, K2>, _ k3: Swift.KeyPath<Foundation.AttributeDynamicLookup, K3>, _ k4: Swift.KeyPath<Foundation.AttributeDynamicLookup, K4>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>, inout Foundation.AttributedString.SingleAttributeTransformer<K4>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K4 : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2, K3, K4, K5>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K1>, _ k2: Swift.KeyPath<Foundation.AttributeDynamicLookup, K2>, _ k3: Swift.KeyPath<Foundation.AttributeDynamicLookup, K3>, _ k4: Swift.KeyPath<Foundation.AttributeDynamicLookup, K4>, _ k5: Swift.KeyPath<Foundation.AttributeDynamicLookup, K5>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>, inout Foundation.AttributedString.SingleAttributeTransformer<K4>, inout Foundation.AttributedString.SingleAttributeTransformer<K5>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K4 : Foundation.AttributedStringKey, K5 : Foundation.AttributedStringKey
  public struct SingleAttributeTransformer<T> where T : Foundation.AttributedStringKey {
    public var range: Swift.Range<Foundation.AttributedString.Index>
    public var value: T.Value? {
      get
      set
    }
    public mutating func replace<U>(with key: U.Type, value: U.Value) where U : Foundation.AttributedStringKey
    public mutating func replace<U>(with keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>, value: U.Value) where U : Foundation.AttributedStringKey
  }
  public struct Index : Swift.Comparable, Swift.Sendable {
    public static func < (lhs: Foundation.AttributedString.Index, rhs: Foundation.AttributedString.Index) -> Swift.Bool
    public static func == (a: Foundation.AttributedString.Index, b: Foundation.AttributedString.Index) -> Swift.Bool
  }
  public struct Runs : Swift.BidirectionalCollection, Swift.Equatable, Swift.CustomStringConvertible {
    public struct Index : Swift.Comparable, Swift.Strideable, Swift.Sendable {
      public static func < (lhs: Foundation.AttributedString.Runs.Index, rhs: Foundation.AttributedString.Runs.Index) -> Swift.Bool
      public func distance(to other: Foundation.AttributedString.Runs.Index) -> Swift.Int
      public func advanced(by n: Swift.Int) -> Foundation.AttributedString.Runs.Index
      public typealias Stride = Swift.Int
    }
    @dynamicMemberLookup public struct Run : Swift.Equatable, Swift.CustomStringConvertible {
      public var range: Swift.Range<Foundation.AttributedString.Index> {
        get
      }
      public static func == (lhs: Foundation.AttributedString.Runs.Run, rhs: Foundation.AttributedString.Runs.Run) -> Swift.Bool
      public var description: Swift.String {
        get
      }
      public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey {
        get
      }
      public subscript<K>(_: K.Type) -> K.Value? where K : Foundation.AttributedStringKey {
        get
      }
      public subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
        get
      }
      public var attributes: Foundation.AttributeContainer {
        get
      }
    }
    public typealias Element = Foundation.AttributedString.Runs.Run
    public static func == (lhs: Foundation.AttributedString.Runs, rhs: Foundation.AttributedString.Runs) -> Swift.Bool
    public var description: Swift.String {
      get
    }
    public func index(before i: Foundation.AttributedString.Runs.Index) -> Foundation.AttributedString.Runs.Index
    public func index(after i: Foundation.AttributedString.Runs.Index) -> Foundation.AttributedString.Runs.Index
    public var startIndex: Foundation.AttributedString.Runs.Index {
      get
    }
    public var endIndex: Foundation.AttributedString.Runs.Index {
      get
    }
    public subscript(position: Foundation.AttributedString.Runs.Index) -> Foundation.AttributedString.Runs.Run {
      get
    }
    public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.Run {
      get
    }
    public struct AttributesSlice1<T> : Swift.BidirectionalCollection where T : Foundation.AttributedStringKey {
      public typealias Index = Foundation.AttributedString.Index
      public typealias Element = (T.Value?, Swift.Range<Foundation.AttributedString.Index>)
      public struct Iterator : Swift.IteratorProtocol {
        public typealias Element = Foundation.AttributedString.Runs.AttributesSlice1<T>.Element
        public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Iterator.Element?
      }
      public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Iterator
      public var startIndex: Foundation.AttributedString.Runs.AttributesSlice1<T>.Index {
        get
      }
      public var endIndex: Foundation.AttributedString.Runs.AttributesSlice1<T>.Index {
        get
      }
      public func index(before i: Foundation.AttributedString.Runs.AttributesSlice1<T>.Index) -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Index
      public func index(after i: Foundation.AttributedString.Runs.AttributesSlice1<T>.Index) -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Index
      public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Element {
        get
      }
      public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice1<T>>
      public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice1<T>>
    }
    public struct AttributesSlice2<T, U> : Swift.BidirectionalCollection where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey {
      public typealias Index = Foundation.AttributedString.Index
      public typealias Element = (T.Value?, U.Value?, Swift.Range<Foundation.AttributedString.Index>)
      public struct Iterator : Swift.IteratorProtocol {
        public typealias Element = Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Element
        public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Iterator.Element?
      }
      public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Iterator
      public var startIndex: Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index {
        get
      }
      public var endIndex: Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index {
        get
      }
      public func index(before i: Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index
      public func index(after i: Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index
      public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Element {
        get
      }
      public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice2<T, U>>
      public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice2<T, U>>
    }
    public struct AttributesSlice3<T, U, V> : Swift.BidirectionalCollection where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey {
      public typealias Index = Foundation.AttributedString.Index
      public typealias Element = (T.Value?, U.Value?, V.Value?, Swift.Range<Foundation.AttributedString.Index>)
      public struct Iterator : Swift.IteratorProtocol {
        public typealias Element = Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Element
        public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Iterator.Element?
      }
      public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Iterator
      public var startIndex: Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index {
        get
      }
      public var endIndex: Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index {
        get
      }
      public func index(before i: Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index
      public func index(after i: Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index
      public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Element {
        get
      }
      public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>>
      public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>>
    }
    public struct AttributesSlice4<T, U, V, W> : Swift.BidirectionalCollection where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey {
      public typealias Index = Foundation.AttributedString.Index
      public typealias Element = (T.Value?, U.Value?, V.Value?, W.Value?, Swift.Range<Foundation.AttributedString.Index>)
      public struct Iterator : Swift.IteratorProtocol {
        public typealias Element = Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Element
        public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Iterator.Element?
      }
      public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Iterator
      public var startIndex: Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index {
        get
      }
      public var endIndex: Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index {
        get
      }
      public func index(before i: Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index
      public func index(after i: Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index
      public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Element {
        get
      }
      public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>>
      public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>>
    }
    public struct AttributesSlice5<T, U, V, W, X> : Swift.BidirectionalCollection where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey, X : Foundation.AttributedStringKey {
      public typealias Index = Foundation.AttributedString.Index
      public typealias Element = (T.Value?, U.Value?, V.Value?, W.Value?, X.Value?, Swift.Range<Foundation.AttributedString.Index>)
      public struct Iterator : Swift.IteratorProtocol {
        public typealias Element = Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Element
        public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Iterator.Element?
      }
      public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Iterator
      public var startIndex: Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index {
        get
      }
      public var endIndex: Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index {
        get
      }
      public func index(before i: Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index
      public func index(after i: Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index
      public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Element {
        get
      }
      public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>>
      public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>>
    }
    public subscript<T, U, V, W, X>(t: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>, u: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>, v: Swift.KeyPath<Foundation.AttributeDynamicLookup, V>, w: Swift.KeyPath<Foundation.AttributeDynamicLookup, W>, x: Swift.KeyPath<Foundation.AttributeDynamicLookup, X>) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey, X : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U, V, W>(t: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>, u: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>, v: Swift.KeyPath<Foundation.AttributeDynamicLookup, V>, w: Swift.KeyPath<Foundation.AttributeDynamicLookup, W>) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U, V>(t: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>, u: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>, v: Swift.KeyPath<Foundation.AttributeDynamicLookup, V>) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U>(t: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>, u: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey {
      get
    }
    public subscript<T>(keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>) -> Foundation.AttributedString.Runs.AttributesSlice1<T> where T : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U, V, W, X>(t: T.Type, u: U.Type, v: V.Type, w: W.Type, x: X.Type) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey, X : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U, V, W>(t: T.Type, u: U.Type, v: V.Type, w: W.Type) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U, V>(t: T.Type, u: U.Type, v: V.Type) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U>(t: T.Type, u: U.Type) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey {
      get
    }
    public subscript<T>(t: T.Type) -> Foundation.AttributedString.Runs.AttributesSlice1<T> where T : Foundation.AttributedStringKey {
      get
    }
    public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs>
    public typealias Iterator = Swift.IndexingIterator<Foundation.AttributedString.Runs>
    public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs>
  }
  public var runs: Foundation.AttributedString.Runs {
    get
  }
  public struct CharacterView : Swift.BidirectionalCollection, Swift.RangeReplaceableCollection {
    public typealias Element = Swift.Character
    public typealias Index = Foundation.AttributedString.Index
    public init()
    public var startIndex: Foundation.AttributedString.Index {
      get
    }
    public var endIndex: Foundation.AttributedString.Index {
      get
    }
    public func index(before i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
    public func index(after i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
    public subscript(index: Foundation.AttributedString.Index) -> Swift.Character {
      get
      set
    }
    public subscript(bounds: Swift.Range<Foundation.AttributedString.Index>) -> Swift.Slice<Foundation.AttributedString.CharacterView> {
      get
      set
    }
    public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Foundation.AttributedString.CharacterView.Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.Character
    public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.CharacterView>
    public typealias Iterator = Swift.IndexingIterator<Foundation.AttributedString.CharacterView>
    public typealias SubSequence = Swift.Slice<Foundation.AttributedString.CharacterView>
  }
  public struct UnicodeScalarView : Swift.RangeReplaceableCollection, Swift.BidirectionalCollection {
    public typealias Element = Swift.UnicodeScalar
    public typealias Index = Foundation.AttributedString.Index
    public init()
    public var startIndex: Foundation.AttributedString.Index {
      get
    }
    public var endIndex: Foundation.AttributedString.Index {
      get
    }
    public func index(before i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
    public func index(after i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
    public func index(_ i: Foundation.AttributedString.Index, offsetBy distance: Swift.Int) -> Foundation.AttributedString.Index
    public subscript(index: Foundation.AttributedString.Index) -> Swift.UnicodeScalar {
      get
    }
    public subscript(bounds: Swift.Range<Foundation.AttributedString.Index>) -> Swift.Slice<Foundation.AttributedString.UnicodeScalarView> {
      get
    }
    public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Foundation.AttributedString.UnicodeScalarView.Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.Unicode.Scalar
    public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.UnicodeScalarView>
    public typealias Iterator = Swift.IndexingIterator<Foundation.AttributedString.UnicodeScalarView>
    public typealias SubSequence = Swift.Slice<Foundation.AttributedString.UnicodeScalarView>
  }
  public var characters: Foundation.AttributedString.CharacterView {
    get
    set
    _modify
  }
  public var unicodeScalars: Foundation.AttributedString.UnicodeScalarView {
    get
    set
    _modify
  }
  public static func == (lhs: Foundation.AttributedString, rhs: Foundation.AttributedString) -> Swift.Bool
  public init()
  public init(_ string: Swift.String, attributes: Foundation.AttributeContainer = .init())
  public init(_ substring: Swift.Substring, attributes: Foundation.AttributeContainer = .init())
  public init<S>(_ elements: S, attributes: Foundation.AttributeContainer = .init()) where S : Swift.Sequence, S.Element == Swift.Character
  public init(_ substring: Foundation.AttributedSubstring)
  public init<S, T>(_ other: T, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope, T : Foundation.AttributedStringProtocol
  public init<S, T>(_ other: T, including scope: S.Type) where S : Foundation.AttributeScope, T : Foundation.AttributedStringProtocol
  public static func + <T>(lhs: Foundation.AttributedString, rhs: T) -> Foundation.AttributedString where T : Foundation.AttributedStringProtocol
  public static func += <T>(lhs: inout Foundation.AttributedString, rhs: T) where T : Foundation.AttributedStringProtocol
  public static func + (lhs: Foundation.AttributedString, rhs: Foundation.AttributedString) -> Foundation.AttributedString
  public static func += (lhs: inout Foundation.AttributedString, rhs: Foundation.AttributedString)
  public subscript<R>(bounds: R) -> Foundation.AttributedSubstring where R : Swift.RangeExpression, R.Bound == Foundation.AttributedString.Index {
    get
    set
    _modify
  }
  public mutating func append<S>(_ s: S) where S : Foundation.AttributedStringProtocol
  public mutating func insert<S>(_ s: S, at index: Foundation.AttributedString.Index) where S : Foundation.AttributedStringProtocol
  public mutating func removeSubrange<R>(_ range: R) where R : Swift.RangeExpression, R.Bound == Foundation.AttributedString.Index
  public mutating func replaceSubrange<R, S>(_ range: R, with s: S) where R : Swift.RangeExpression, S : Foundation.AttributedStringProtocol, R.Bound == Foundation.AttributedString.Index
  public var startIndex: Foundation.AttributedString.Index {
    get
  }
  public var endIndex: Foundation.AttributedString.Index {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct AttributedSubstring {
  public init()
  public var base: Foundation.AttributedString {
    get
  }
  public var description: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedSubstring : Foundation.AttributedStringProtocol {
  public var startIndex: Foundation.AttributedString.Index {
    get
  }
  public var endIndex: Foundation.AttributedString.Index {
    get
  }
  public static func == (lhs: Foundation.AttributedSubstring, rhs: Foundation.AttributedSubstring) -> Swift.Bool
  public mutating func setAttributes(_ attributes: Foundation.AttributeContainer)
  public mutating func mergeAttributes(_ attributes: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew)
  public mutating func replaceAttributes(_ attributes: Foundation.AttributeContainer, with others: Foundation.AttributeContainer)
  public var runs: Foundation.AttributedString.Runs {
    get
  }
  public var characters: Foundation.AttributedString.CharacterView {
    get
  }
  public var unicodeScalars: Foundation.AttributedString.UnicodeScalarView {
    get
  }
  public subscript<R>(bounds: R) -> Foundation.AttributedSubstring where R : Swift.RangeExpression, R.Bound == Foundation.AttributedString.Index {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedSubstring {
  public subscript<K>(_: K.Type) -> K.Value? where K : Foundation.AttributedStringKey {
    get
    set
  }
  public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey {
    get
    set
  }
  public subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
    get
    _modify
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.String {
  public init(_ attrStrSlice: Swift.Slice<Foundation.AttributedString.CharacterView>)
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeContainer : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributeContainer.Builder : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.SingleAttributeTransformer : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.Runs : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.Runs.Run : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.Runs.AttributesSlice1 : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.Runs.AttributesSlice1.Iterator : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.Runs.AttributesSlice2 : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.Runs.AttributesSlice2.Iterator : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.Runs.AttributesSlice3 : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.Runs.AttributesSlice3.Iterator : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.Runs.AttributesSlice4 : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.Runs.AttributesSlice4.Iterator : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.Runs.AttributesSlice5 : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.Runs.AttributesSlice5.Iterator : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.CharacterView : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedString.UnicodeScalarView : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.AttributedSubstring : @unchecked Swift.Sendable {
}
@_objcRuntimeName(_TtC10Foundation13__JSONEncoder) open class JSONEncoder {
  public struct OutputFormatting : Swift.OptionSet, Swift.Sendable {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let prettyPrinted: Foundation.JSONEncoder.OutputFormatting
    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    public static let sortedKeys: Foundation.JSONEncoder.OutputFormatting
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public static let withoutEscapingSlashes: Foundation.JSONEncoder.OutputFormatting
    public typealias ArrayLiteralElement = Foundation.JSONEncoder.OutputFormatting
    public typealias Element = Foundation.JSONEncoder.OutputFormatting
    public typealias RawValue = Swift.UInt
  }
  public enum DateEncodingStrategy : Swift.Sendable {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
    case iso8601
    case formatted(Foundation.DateFormatter)
    @preconcurrency case custom(@Sendable (Foundation.Date, any Swift.Encoder) throws -> Swift.Void)
  }
  public enum DataEncodingStrategy : Swift.Sendable {
    case deferredToData
    case base64
    @preconcurrency case custom(@Sendable (Foundation.Data, any Swift.Encoder) throws -> Swift.Void)
  }
  public enum NonConformingFloatEncodingStrategy : Swift.Sendable {
    case `throw`
    case convertToString(positiveInfinity: Swift.String, negativeInfinity: Swift.String, nan: Swift.String)
  }
  public enum KeyEncodingStrategy : Swift.Sendable {
    case useDefaultKeys
    case convertToSnakeCase
    @preconcurrency case custom(@Sendable (_ codingPath: [any Swift.CodingKey]) -> any Swift.CodingKey)
  }
  open var outputFormatting: Foundation.JSONEncoder.OutputFormatting {
    get
    set
    _modify
  }
  open var dateEncodingStrategy: Foundation.JSONEncoder.DateEncodingStrategy {
    get
    set
    _modify
  }
  open var dataEncodingStrategy: Foundation.JSONEncoder.DataEncodingStrategy {
    get
    set
    _modify
  }
  open var nonConformingFloatEncodingStrategy: Foundation.JSONEncoder.NonConformingFloatEncodingStrategy {
    get
    set
    _modify
  }
  open var keyEncodingStrategy: Foundation.JSONEncoder.KeyEncodingStrategy {
    get
    set
    _modify
  }
  open var userInfo: [Swift.CodingUserInfoKey : Any] {
    get
    set
    _modify
  }
  public init()
  @objc deinit
  open func encode<T>(_ value: T) throws -> Foundation.Data where T : Swift.Encodable
}
@_objcRuntimeName(_TtC10Foundation13__JSONDecoder) open class JSONDecoder {
  public enum DateDecodingStrategy : Swift.Sendable {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
    case iso8601
    case formatted(Foundation.DateFormatter)
    @preconcurrency case custom(@Sendable (_ decoder: any Swift.Decoder) throws -> Foundation.Date)
  }
  public enum DataDecodingStrategy : Swift.Sendable {
    case deferredToData
    case base64
    @preconcurrency case custom(@Sendable (_ decoder: any Swift.Decoder) throws -> Foundation.Data)
  }
  public enum NonConformingFloatDecodingStrategy : Swift.Sendable {
    case `throw`
    case convertFromString(positiveInfinity: Swift.String, negativeInfinity: Swift.String, nan: Swift.String)
  }
  public enum KeyDecodingStrategy : Swift.Sendable {
    case useDefaultKeys
    case convertFromSnakeCase
    @preconcurrency case custom(@Sendable (_ codingPath: [any Swift.CodingKey]) -> any Swift.CodingKey)
  }
  open var dateDecodingStrategy: Foundation.JSONDecoder.DateDecodingStrategy {
    get
    set
    _modify
  }
  open var dataDecodingStrategy: Foundation.JSONDecoder.DataDecodingStrategy {
    get
    set
    _modify
  }
  open var nonConformingFloatDecodingStrategy: Foundation.JSONDecoder.NonConformingFloatDecodingStrategy {
    get
    set
    _modify
  }
  open var keyDecodingStrategy: Foundation.JSONDecoder.KeyDecodingStrategy {
    get
    set
    _modify
  }
  open var userInfo: [Swift.CodingUserInfoKey : Any] {
    get
    set
    _modify
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  open var allowsJSON5: Swift.Bool {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  open var assumesTopLevelDictionary: Swift.Bool {
    get
    set
  }
  public init()
  @objc deinit
  open func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.JSONDecoder : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.JSONEncoder : @unchecked Swift.Sendable {
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct AsyncUnicodeScalarSequence<Base> : _Concurrency.AsyncSequence where Base : _Concurrency.AsyncSequence, Base.Element == Swift.UInt8 {
  public typealias Element = Swift.UnicodeScalar
  @frozen public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var _base: Base.AsyncIterator
    @usableFromInline
    internal var _leftover: Swift.UInt8? = nil
    @inlinable @inline(__always) internal func _expectedContinuationCountForByte(_ byte: Swift.UInt8) -> Swift.Int? {
            if byte & 0b11100000 == 0b11000000 {
                return 1
            }
            if byte & 0b11110000 == 0b11100000 {
                return 2
            }
            if byte & 0b11111000 == 0b11110000 {
                return 3
            }
            if byte & 0b10000000 == 0b00000000 {
                return 0
            }
            if byte & 0b11000000 == 0b10000000 {
                //is a continuation itself
                return nil
            }
            //is an invalid value
            return nil
        }
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable internal mutating func _nextComplexScalar(_ first: Swift.UInt8) async rethrows -> Swift.UnicodeScalar? {
            guard let expectedContinuationCount = _expectedContinuationCountForByte(first) else {
                //We only reach here for invalid UTF8, so just return a replacement character directly
                return "\u{FFFD}"
            }
            var bytes: (UInt8, UInt8, UInt8, UInt8) = (first, 0, 0, 0)
            var numContinuations = 0
            while numContinuations < expectedContinuationCount, let next = try await _base.next() {
                guard UTF8.isContinuation(next) else {
                    //We read one more byte than we needed due to an invalid missing continuation byte. Store it in `leftover` for next time
                    _leftover = next
                    break
                }
                
                numContinuations += 1
                withUnsafeMutableBytes(of: &bytes) {
                    $0[numContinuations] = next
                }
            }
            return withUnsafeBytes(of: &bytes) {
                return String(decoding: $0, as: UTF8.self).unicodeScalars.first
            }
        }
    #endif
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable @inline(__always) public mutating func next() async rethrows -> Swift.UnicodeScalar? {
            if let leftover = _leftover {
                self._leftover = nil
                return try await _nextComplexScalar(leftover)
            }
            if let byte = try await _base.next() {
                if UTF8.isASCII(byte) {
                    _onFastPath()
                    return UnicodeScalar(byte)
                }
                return try await _nextComplexScalar(byte)
            }
            
            return nil
        }
    #endif
    public typealias Element = Swift.UnicodeScalar
  }
  public func makeAsyncIterator() -> Foundation.AsyncUnicodeScalarSequence<Base>.AsyncIterator
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.AsyncUnicodeScalarSequence : Swift.Sendable where Base : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.AsyncUnicodeScalarSequence.AsyncIterator : Swift.Sendable where Base.AsyncIterator : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension _Concurrency.AsyncSequence where Self.Element == Swift.UInt8 {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var unicodeScalars: Foundation.AsyncUnicodeScalarSequence<Self> {
    get
  }
}
#endif
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct KeyPathComparator<Compared> : Foundation.SortComparator {
  public let keyPath: Swift.PartialKeyPath<Compared>
  public var order: Foundation.SortOrder {
    get
    set
  }
  public init<Value>(_ keyPath: Swift.KeyPath<Compared, Value>, order: Foundation.SortOrder = .forward) where Value : Swift.Comparable
  public init<Value>(_ keyPath: Swift.KeyPath<Compared, Value?>, order: Foundation.SortOrder = .forward) where Value : Swift.Comparable
  public init<Value, Comparator>(_ keyPath: Swift.KeyPath<Compared, Value>, comparator: Comparator) where Value == Comparator.Compared, Comparator : Foundation.SortComparator
  public init<Value, Comparator>(_ keyPath: Swift.KeyPath<Compared, Value?>, comparator: Comparator) where Value == Comparator.Compared, Comparator : Foundation.SortComparator
  public init<Value, Comparator>(_ keyPath: Swift.KeyPath<Compared, Value>, comparator: Comparator, order: Foundation.SortOrder) where Value == Comparator.Compared, Comparator : Foundation.SortComparator
  public init<Value, Comparator>(_ keyPath: Swift.KeyPath<Compared, Value?>, comparator: Comparator, order: Foundation.SortOrder) where Value == Comparator.Compared, Comparator : Foundation.SortComparator
  public func compare(_ lhs: Compared, _ rhs: Compared) -> Foundation.ComparisonResult
  public static func == (lhs: Foundation.KeyPathComparator<Compared>, rhs: Foundation.KeyPathComparator<Compared>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.KeyPathComparator : @unchecked Swift.Sendable {
}
extension Foundation._NSRange : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(location)
        hasher.combine(length)
    }
  @inlinable public static func == (lhs: Foundation.NSRange, rhs: Foundation.NSRange) -> Swift.Bool {
        return lhs.location == rhs.location && lhs.length == rhs.length
    }
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation._NSRange : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation._NSRange {
  public init?(_ string: __shared Swift.String)
}
extension Foundation._NSRange {
  @inlinable public var lowerBound: Swift.Int {
    get { location }
  }
  @inlinable public var upperBound: Swift.Int {
    get { location + length }
  }
  @inlinable public func contains(_ index: Swift.Int) -> Swift.Bool {
        !(index < location) && (index - location) < length
    }
  @inlinable public mutating func formUnion(_ other: Foundation.NSRange) {
        self = union(other)
    }
  @inlinable public func union(_ other: Foundation.NSRange) -> Foundation.NSRange {
        let max1 = location + length
        let max2 = other.location + other.length
        let maxend = (max1 < max2) ? max2 : max1
        let minloc = location < other.location ? location : other.location
        return NSRange(location: minloc, length: maxend - minloc)
    }
  @inlinable public func intersection(_ other: Foundation.NSRange) -> Foundation.NSRange? {
        let max1 = location + length
        let max2 = other.location + other.length
        let minend = (max1 < max2) ? max1 : max2
        if other.location <= location && location < max2 {
            return NSRange(location: location, length: minend - location)
        } else if location <= other.location && other.location < max1 {
            return NSRange(location: other.location, length: minend - other.location);
        }
        return nil
    }
}
extension Foundation._NSRange {
  @inlinable public init<R>(_ region: R) where R : Swift.RangeExpression, R.Bound : Swift.FixedWidthInteger {
        let r = region.relative(to: 0..<R.Bound.max)
        self.init(location: numericCast(r.lowerBound), length: numericCast(r.count))
    }
  public init<R, S>(_ region: R, in target: S) where R : Swift.RangeExpression, S : Swift.StringProtocol, R.Bound == Swift.String.Index
  @available(swift, deprecated: 4, message: "Use Range.init(_:) instead")
  public func toRange() -> Swift.Range<Swift.Int>?
}
extension Swift.Range where Bound : Swift.BinaryInteger {
  @inlinable public init?(_ range: Foundation.NSRange) {
        guard range.location != NSNotFound else { return nil }
        self.init(uncheckedBounds: (numericCast(range.lowerBound), numericCast(range.upperBound)))
    }
}
extension Swift.Range where Bound == Swift.Int {
  @inlinable public init?(_ range: Foundation.NSRange) {
        guard range.location != NSNotFound else { return nil }
        self.init(uncheckedBounds: (range.lowerBound, range.upperBound))
    }
}
extension Swift.Range where Bound == Swift.String.Index {
  public init?(_ range: Foundation.NSRange, in string: __shared Swift.String)
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public init?<S>(_ range: Foundation.NSRange, in string: __shared S) where S : Swift.StringProtocol
}
extension Foundation._NSRange : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation._NSRange : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSRange.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension Foundation._NSRange : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.BinaryInteger {
  public func formatted() -> Swift.String
  public func formatted<S>(_ format: S) -> S.FormatOutput where Self == S.FormatInput, S : Foundation.FormatStyle
  public func formatted<S>(_ format: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput : Swift.BinaryInteger
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.BinaryInteger {
  public init<S>(_ value: S.ParseInput, strategy: S) throws where S : Foundation.ParseStrategy, S.ParseOutput : Swift.BinaryInteger
  public init<S>(_ value: S.ParseInput, strategy: S) throws where Self == S.ParseOutput, S : Foundation.ParseStrategy
  public init(_ value: Swift.String, format: Foundation.IntegerFormatStyle<Self>, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.IntegerFormatStyle<Self>.Percent, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.IntegerFormatStyle<Self>.Currency, lenient: Swift.Bool = true) throws
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public struct URLResource : Swift.Hashable, Swift.Codable {
  public let bundle: Foundation.Bundle
  public let name: Swift.String
  public let subdirectory: Swift.String?
  public var locale: Foundation.Locale
  public init(name: Swift.String, subdirectory: Swift.String? = nil, locale: Foundation.Locale = .current, bundle: Foundation.Bundle = .main)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.URLResource, b: Foundation.URLResource) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS, unavailable, introduced: 16)
@available(*, unavailable)
extension Foundation.URLResource : @unchecked Swift.Sendable {
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.URL {
  public init?(resource: Foundation.URLResource)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.Scanner {
  public enum NumberRepresentation : Swift.Sendable {
    case decimal
    case hexadecimal
    public static func == (a: Foundation.Scanner.NumberRepresentation, b: Foundation.Scanner.NumberRepresentation) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var currentIndex: Swift.String.Index {
    get
    set
  }
  public func scanInt(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Int?
  public func scanInt32(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Int32?
  public func scanInt64(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Int64?
  public func scanUInt64(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.UInt64?
  public func scanFloat(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Float?
  public func scanDouble(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Double?
  public func scanDecimal() -> Foundation.Decimal?
  public func scanString(_ searchString: Swift.String) -> Swift.String?
  public func scanCharacters(from set: Foundation.CharacterSet) -> Swift.String?
  public func scanUpToString(_ substring: Swift.String) -> Swift.String?
  public func scanUpToCharacters(from set: Foundation.CharacterSet) -> Swift.String?
  public func scanCharacter() -> Swift.Character?
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FormatStyleCapitalizationContext : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public static var unknown: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static var standalone: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static var listItem: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static var beginningOfSentence: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static var middleOfSentence: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.FormatStyleCapitalizationContext, b: Foundation.FormatStyleCapitalizationContext) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum NumberFormatStyleConfiguration {
  public typealias RoundingRule = Swift.FloatingPointRoundingRule
  public struct Grouping : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
    public static var automatic: Foundation.NumberFormatStyleConfiguration.Grouping {
      get
    }
    public static var never: Foundation.NumberFormatStyleConfiguration.Grouping {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.NumberFormatStyleConfiguration.Grouping, b: Foundation.NumberFormatStyleConfiguration.Grouping) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Precision : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static func significantDigits<R>(_ limits: R) -> Foundation.NumberFormatStyleConfiguration.Precision where R : Swift.RangeExpression, R.Bound == Swift.Int
    public static func significantDigits(_ digits: Swift.Int) -> Foundation.NumberFormatStyleConfiguration.Precision
    public static func integerAndFractionLength<R1, R2>(integerLimits: R1, fractionLimits: R2) -> Foundation.NumberFormatStyleConfiguration.Precision where R1 : Swift.RangeExpression, R2 : Swift.RangeExpression, R1.Bound == Swift.Int, R2.Bound == Swift.Int
    public static func integerAndFractionLength(integer: Swift.Int, fraction: Swift.Int) -> Foundation.NumberFormatStyleConfiguration.Precision
    public static func integerLength<R>(_ limits: R) -> Foundation.NumberFormatStyleConfiguration.Precision where R : Swift.RangeExpression
    public static func integerLength(_ length: Swift.Int) -> Foundation.NumberFormatStyleConfiguration.Precision
    public static func fractionLength<R>(_ limits: R) -> Foundation.NumberFormatStyleConfiguration.Precision where R : Swift.RangeExpression, R.Bound == Swift.Int
    public static func fractionLength(_ length: Swift.Int) -> Foundation.NumberFormatStyleConfiguration.Precision
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.NumberFormatStyleConfiguration.Precision, b: Foundation.NumberFormatStyleConfiguration.Precision) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct DecimalSeparatorDisplayStrategy : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
    public static var automatic: Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy {
      get
    }
    public static var always: Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy, b: Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct SignDisplayStrategy : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
    public static var automatic: Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static var never: Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static func always(includingZero: Swift.Bool = true) -> Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy, b: Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Notation : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
    public static var scientific: Foundation.NumberFormatStyleConfiguration.Notation {
      get
    }
    public static var automatic: Foundation.NumberFormatStyleConfiguration.Notation {
      get
    }
    public static var compactName: Foundation.NumberFormatStyleConfiguration.Notation {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.NumberFormatStyleConfiguration.Notation, b: Foundation.NumberFormatStyleConfiguration.Notation) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum CurrencyFormatStyleConfiguration {
  public typealias Grouping = Foundation.NumberFormatStyleConfiguration.Grouping
  public typealias Precision = Foundation.NumberFormatStyleConfiguration.Precision
  public typealias DecimalSeparatorDisplayStrategy = Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy
  public typealias RoundingRule = Foundation.NumberFormatStyleConfiguration.RoundingRule
  public struct SignDisplayStrategy : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static var automatic: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static var never: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static func always(showZero: Swift.Bool = true) -> Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy
    public static var accounting: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static func accountingAlways(showZero: Swift.Bool = false) -> Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy, b: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Presentation : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static var narrow: Foundation.CurrencyFormatStyleConfiguration.Presentation {
      get
    }
    public static var standard: Foundation.CurrencyFormatStyleConfiguration.Presentation {
      get
    }
    public static var isoCode: Foundation.CurrencyFormatStyleConfiguration.Presentation {
      get
    }
    public static var fullName: Foundation.CurrencyFormatStyleConfiguration.Presentation {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.CurrencyFormatStyleConfiguration.Presentation, b: Foundation.CurrencyFormatStyleConfiguration.Presentation) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum DescriptiveNumberFormatConfiguration {
  public typealias CapitalizationContext = Foundation.FormatStyleCapitalizationContext
  public struct Presentation : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static var spellOut: Foundation.DescriptiveNumberFormatConfiguration.Presentation {
      get
    }
    public static var ordinal: Foundation.DescriptiveNumberFormatConfiguration.Presentation {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.DescriptiveNumberFormatConfiguration.Presentation, b: Foundation.DescriptiveNumberFormatConfiguration.Presentation) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.FloatingPointRoundingRule : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.NumberFormatStyleConfiguration : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.CurrencyFormatStyleConfiguration : @unchecked Swift.Sendable {
}
@available(iOS, unavailable, introduced: 15)
@available(*, unavailable)
extension Foundation.DescriptiveNumberFormatConfiguration : @unchecked Swift.Sendable {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public func inflected() -> Foundation.AttributedString
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents {
  public struct FormatStyle : Foundation.FormatStyle, Swift.Sendable {
    public var style: Foundation.PersonNameComponents.FormatStyle.Style
    public var locale: Foundation.Locale
    public var attributed: Foundation.PersonNameComponents.AttributedStyle {
      get
    }
    public init(style: Foundation.PersonNameComponents.FormatStyle.Style = .medium, locale: Foundation.Locale = .autoupdatingCurrent)
    public func locale(_ locale: Foundation.Locale) -> Foundation.PersonNameComponents.FormatStyle
    public func format(_ value: Foundation.PersonNameComponents) -> Swift.String
    public enum Style : Swift.Int, Swift.Codable, Swift.Hashable, Swift.Sendable {
      case short
      case medium
      case long
      case abbreviated
      public init?(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.PersonNameComponents.FormatStyle, b: Foundation.PersonNameComponents.FormatStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.PersonNameComponents
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct AttributedStyle : Foundation.FormatStyle, Swift.Sendable {
    public var style: Foundation.PersonNameComponents.FormatStyle.Style
    public var locale: Foundation.Locale
    public init(style: Foundation.PersonNameComponents.FormatStyle.Style = .medium, locale: Foundation.Locale = .autoupdatingCurrent)
    public func format(_ value: Foundation.PersonNameComponents) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.PersonNameComponents.AttributedStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.PersonNameComponents.AttributedStyle, b: Foundation.PersonNameComponents.AttributedStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.PersonNameComponents
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents {
  public struct ParseStrategy : Foundation.ParseStrategy, Swift.Sendable {
    public init()
    public func parse(_ value: Swift.String) throws -> Foundation.PersonNameComponents
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.PersonNameComponents.ParseStrategy, b: Foundation.PersonNameComponents.ParseStrategy) -> Swift.Bool
    public typealias ParseInput = Swift.String
    public typealias ParseOutput = Foundation.PersonNameComponents
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents {
  public func formatted<S>(_ style: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Foundation.PersonNameComponents
  public func formatted() -> Swift.String
  public init<S>(_ value: S.ParseInput, strategy: S) throws where S : Foundation.ParseStrategy, S.ParseOutput == Foundation.PersonNameComponents
  public init(_ value: Swift.String) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents.FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.PersonNameComponents.ParseStrategy {
    get
  }
  public typealias Strategy = Foundation.PersonNameComponents.ParseStrategy
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.PersonNameComponents.FormatStyle {
  public static func name(style: Foundation.PersonNameComponents.FormatStyle.Style) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.PersonNameComponents.FormatStyle {
  public static func name(style: Foundation.PersonNameComponents.FormatStyle.Style) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseStrategy where Self == Foundation.PersonNameComponents.ParseStrategy {
  public static var name: Foundation.PersonNameComponents.ParseStrategy {
    get
  }
}
public struct TimeZone : Swift.Hashable, Swift.Equatable, Foundation.ReferenceConvertible, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSTimeZone
  public static var current: Foundation.TimeZone {
    get
  }
  public static var autoupdatingCurrent: Foundation.TimeZone {
    get
  }
  public init?(identifier: __shared Swift.String)
  public init?(secondsFromGMT seconds: Swift.Int)
  public init?(abbreviation: __shared Swift.String)
  public var identifier: Swift.String {
    get
  }
  public func secondsFromGMT(for date: Foundation.Date = Date()) -> Swift.Int
  public func abbreviation(for date: Foundation.Date = Date()) -> Swift.String?
  public func isDaylightSavingTime(for date: Foundation.Date = Date()) -> Swift.Bool
  public func daylightSavingTimeOffset(for date: Foundation.Date = Date()) -> Foundation.TimeInterval
  public func nextDaylightSavingTimeTransition(after date: Foundation.Date) -> Foundation.Date?
  public static var knownTimeZoneIdentifiers: [Swift.String] {
    get
  }
  public static var abbreviationDictionary: [Swift.String : Swift.String] {
    get
    set
  }
  public static var timeZoneDataVersion: Swift.String {
    get
  }
  public var nextDaylightSavingTimeTransition: Foundation.Date? {
    get
  }
  public func localizedName(for style: Foundation.NSTimeZone.NameStyle, locale: Foundation.Locale?) -> Swift.String?
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_alwaysEmitIntoClient @_disfavoredOverload public static var gmt: Foundation.TimeZone {
    get { TimeZone(secondsFromGMT: 0)! }
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.TimeZone, rhs: Foundation.TimeZone) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.TimeZone : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation.TimeZone : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSTimeZone
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSTimeZone, result: inout Foundation.TimeZone?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSTimeZone, result: inout Foundation.TimeZone?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSTimeZone?) -> Foundation.TimeZone
  public typealias _ObjectiveCType = Foundation.NSTimeZone
}
extension Foundation.NSTimeZone : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.TimeZone : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct IndexPath : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable, Swift.MutableCollection, Swift.RandomAccessCollection, Swift.Comparable, Swift.ExpressibleByArrayLiteral, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSIndexPath
  public typealias Element = Swift.Int
  public typealias Index = Swift.Array<Swift.Int>.Index
  public typealias Indices = Swift.DefaultIndices<Foundation.IndexPath>
  public init()
  public init<ElementSequence>(indexes: ElementSequence) where ElementSequence : Swift.Sequence, ElementSequence.Element == Swift.Int
  public init(arrayLiteral indexes: Foundation.IndexPath.Element...)
  public init(indexes: Swift.Array<Foundation.IndexPath.Element>)
  public init(index: Foundation.IndexPath.Element)
  public func dropLast() -> Foundation.IndexPath
  public mutating func append(_ other: Foundation.IndexPath)
  public mutating func append(_ other: Foundation.IndexPath.Element)
  public mutating func append(_ other: Swift.Array<Foundation.IndexPath.Element>)
  public func appending(_ other: Foundation.IndexPath.Element) -> Foundation.IndexPath
  public func appending(_ other: Foundation.IndexPath) -> Foundation.IndexPath
  public func appending(_ other: Swift.Array<Foundation.IndexPath.Element>) -> Foundation.IndexPath
  public subscript(index: Foundation.IndexPath.Index) -> Foundation.IndexPath.Element {
    get
    set
  }
  public subscript(range: Swift.Range<Foundation.IndexPath.Index>) -> Foundation.IndexPath {
    get
    set
  }
  public func makeIterator() -> Swift.IndexingIterator<Foundation.IndexPath>
  public var count: Swift.Int {
    get
  }
  public var startIndex: Foundation.IndexPath.Index {
    get
  }
  public var endIndex: Foundation.IndexPath.Index {
    get
  }
  public func index(before i: Foundation.IndexPath.Index) -> Foundation.IndexPath.Index
  public func index(after i: Foundation.IndexPath.Index) -> Foundation.IndexPath.Index
  public func compare(_ other: Foundation.IndexPath) -> Foundation.ComparisonResult
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func + (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Foundation.IndexPath
  public static func += (lhs: inout Foundation.IndexPath, rhs: Foundation.IndexPath)
  public static func < (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func <= (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func > (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func >= (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public typealias ArrayLiteralElement = Foundation.IndexPath.Element
  public typealias Iterator = Swift.IndexingIterator<Foundation.IndexPath>
  public typealias SubSequence = Foundation.IndexPath
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.IndexPath : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.IndexPath : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSIndexPath
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSIndexPath, result: inout Foundation.IndexPath?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSIndexPath, result: inout Foundation.IndexPath?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSIndexPath?) -> Foundation.IndexPath
  public typealias _ObjectiveCType = Foundation.NSIndexPath
}
extension Foundation.NSIndexPath : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.IndexPath : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.Int8 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int8?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int8?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int8
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.UInt8 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt8?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt8?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt8
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Int16 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int16?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int16?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int16
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.UInt16 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt16?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt16?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt16
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Int32 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int32?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int32?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int32
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.UInt32 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt32?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt32?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt32
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Int64 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int64?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int64?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int64
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.UInt64 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt64?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt64?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt64
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Int : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.UInt : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Float : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Float?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Float?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Float
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Double : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Double?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Double?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Double
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Bool : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Bool?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Bool?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Bool
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension CoreFoundation.CGFloat : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout CoreFoundation.CGFloat?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout CoreFoundation.CGFloat?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> CoreFoundation.CGFloat
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Foundation.NSNumber : Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByIntegerLiteral, Swift.ExpressibleByBooleanLiteral {
  @nonobjc required convenience public init(integerLiteral value: Swift.Int)
  @nonobjc required convenience public init(floatLiteral value: Swift.Double)
  @nonobjc required convenience public init(booleanLiteral value: Swift.Bool)
  public typealias BooleanLiteralType = Swift.Bool
  public typealias FloatLiteralType = Swift.Double
  public typealias IntegerLiteralType = Swift.Int
}
extension Foundation.NSNumber : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.Date {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct ComponentsFormatStyle : Foundation.FormatStyle, Swift.Codable, Swift.Hashable, Swift.Sendable {
    public struct Field : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var year: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var month: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var week: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var day: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var hour: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var minute: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var second: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.ComponentsFormatStyle.Field, b: Foundation.Date.ComponentsFormatStyle.Field) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct Style : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var wide: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public static var abbreviated: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public static var condensedAbbreviated: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public static var narrow: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public static var spellOut: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.ComponentsFormatStyle.Style, b: Foundation.Date.ComponentsFormatStyle.Style) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public var style: Foundation.Date.ComponentsFormatStyle.Style
    public var fields: Swift.Set<Foundation.Date.ComponentsFormatStyle.Field>?
    public var calendar: Foundation.Calendar
    public var locale: Foundation.Locale
    public init(style: Foundation.Date.ComponentsFormatStyle.Style, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, fields: Swift.Set<Foundation.Date.ComponentsFormatStyle.Field>? = nil)
    public func format(_ v: Swift.Range<Foundation.Date>) -> Swift.String
    public func calendar(_ calendar: Foundation.Calendar) -> Foundation.Date.ComponentsFormatStyle
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.ComponentsFormatStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.ComponentsFormatStyle, b: Foundation.Date.ComponentsFormatStyle) -> Swift.Bool
    public typealias FormatInput = Swift.Range<Foundation.Date>
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.ComponentsFormatStyle {
  public static func components(style: Foundation.Date.ComponentsFormatStyle.Style, fields: Swift.Set<Foundation.Date.ComponentsFormatStyle.Field>? = nil) -> Self
  public static var timeDuration: Foundation.Date.ComponentsFormatStyle {
    get
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.IdentifierType : Swift.Equatable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.IdentifierType : Swift.Hashable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.LanguageCode.IdentifierType : Swift.Equatable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.LanguageCode.IdentifierType : Swift.Hashable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.Weekday : Swift.RawRepresentable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.HourCycle : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.AttributeScopes.FoundationAttributes.DurationFieldAttribute.Field : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.AttributeScopes.FoundationAttributes.DurationFieldAttribute.Field : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.AttributeScopes.FoundationAttributes.DurationFieldAttribute.Field : Swift.RawRepresentable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.DirectoryHint : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.DirectoryHint : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Foundation.Morphology.GrammaticalGender : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Foundation.Morphology.PartOfSpeech : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Foundation.Morphology.GrammaticalNumber : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.DayPeriod.Width : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.DayPeriod.Width : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.TimeZone.Width : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.TimeZone.Width : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.FormatStyle.Component : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, watchOS 8, tvOS 15, *)
extension Foundation.PresentationIntent.TableColumn.Alignment : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.BackgroundTaskCancelledReason : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.BackgroundTaskCancelledReason : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.BackgroundTaskCancelledReason : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.NetworkUnavailableReason : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.NetworkUnavailableReason : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.NetworkUnavailableReason : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateSeparator : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateSeparator : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateSeparator : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeSeparator : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeSeparator : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeSeparator : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateTimeSeparator : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateTimeSeparator : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateTimeSeparator : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ByteCountFormatStyle.Style : Swift.RawRepresentable {}
extension Foundation.Calendar.Identifier : Swift.Equatable {}
extension Foundation.Calendar.Identifier : Swift.Hashable {}
extension Foundation.Calendar.Component : Swift.Equatable {}
extension Foundation.Calendar.Component : Swift.Hashable {}
extension Foundation.Calendar.SearchDirection : Swift.Equatable {}
extension Foundation.Calendar.SearchDirection : Swift.Hashable {}
extension Foundation.Calendar.RepeatedTimePolicy : Swift.Equatable {}
extension Foundation.Calendar.RepeatedTimePolicy : Swift.Hashable {}
extension Foundation.Calendar.MatchingPolicy : Swift.Equatable {}
extension Foundation.Calendar.MatchingPolicy : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.Width : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.Width : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.Width : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.ListType : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.ListType : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.ListType : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.AttributeMergePolicy : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.AttributeMergePolicy : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.Scanner.NumberRepresentation : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.Scanner.NumberRepresentation : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents.FormatStyle.Style : Swift.RawRepresentable {}
