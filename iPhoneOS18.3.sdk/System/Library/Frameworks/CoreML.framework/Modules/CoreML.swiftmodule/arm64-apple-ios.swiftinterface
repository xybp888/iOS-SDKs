// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.6 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios18.2 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-bare-slash-regex -user-module-version 3402.5.1 -module-name CoreML
@_exported import CoreML
import CoreVideo
import Foundation
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public struct MLShapedArraySlice<Scalar> : CoreML.MLShapedArrayProtocol, @unchecked Swift.Sendable where Scalar : CoreML.MLShapedArrayScalar {
  public typealias ArrayLiteralElement = Scalar
  public typealias SubSequence = CoreML.MLShapedArraySlice<Scalar>
  public let shape: [Swift.Int]
  public init(bytesNoCopy bytes: Swift.UnsafeRawPointer, shape: [Swift.Int], strides: [Swift.Int], deallocator: Foundation.Data.Deallocator)
  public init(unsafeUninitializedShape shape: [Swift.Int], initializingWith initializer: (_ ptr: inout Swift.UnsafeMutableBufferPointer<Scalar>, _ strides: [Swift.Int]) throws -> Swift.Void) rethrows
  public init(scalar: Scalar)
  public init(data: Foundation.Data, shape: [Swift.Int], strides: [Swift.Int])
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
  public init<S>(scalars: S, shape: [Swift.Int]) where Scalar == S.Element, S : Swift.Sequence
  public init<S>(concatenating shapedArrays: S, alongAxis: Swift.Int) where Scalar == S.Element.Scalar, S : Swift.Sequence, S.Element : CoreML.MLShapedArrayProtocol
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
  public init(mutating pixelBuffer: CoreVideo.CVPixelBuffer, shape: [Swift.Int])
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
  public init(_ multiArray: CoreML.MLMultiArray)
  public var strides: [Swift.Int] {
    get
  }
  public subscript<C>(sliceRanges: C) -> CoreML.MLShapedArraySlice<Scalar> where C : Swift.Collection, C.Element == Swift.Range<Swift.Int> {
    get
    set
  }
  public func withUnsafeShapedBufferPointer<R>(_ body: (_ ptr: Swift.UnsafeBufferPointer<Scalar>, _ shape: [Swift.Int], _ strides: [Swift.Int]) throws -> R) rethrows -> R
  public mutating func withUnsafeMutableShapedBufferPointer<R>(_ body: (_ ptr: inout Swift.UnsafeMutableBufferPointer<Scalar>, _ shape: [Swift.Int], _ strides: [Swift.Int]) throws -> R) rethrows -> R
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Index = Swift.Int
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Indices = Swift.Range<Swift.Int>
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Iterator = Swift.IndexingIterator<CoreML.MLShapedArraySlice<Scalar>>
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArraySlice {
  public typealias Element = CoreML.MLShapedArraySlice<Scalar>
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript<C>(indices: C) -> CoreML.MLShapedArraySlice<Scalar> where C : Swift.Collection, C.Element == Swift.Int {
    get
    set
  }
  public subscript<C>(scalarAt indices: C) -> Scalar where C : Swift.Collection, C.Element == Swift.Int {
    get
    set
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArraySlice {
  public init(data: Foundation.Data, shape: [Swift.Int])
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
extension CoreML.MLShapedArraySlice {
  public func reshaped(to newShape: [Swift.Int]) -> CoreML.MLShapedArraySlice<Scalar>
  public func squeezingShape() -> CoreML.MLShapedArraySlice<Scalar>
  public func expandingShape(at axis: Swift.Int) -> CoreML.MLShapedArraySlice<Scalar>
  public func transposed() -> CoreML.MLShapedArraySlice<Scalar>
  public func transposed(permutation axes: [Swift.Int]) -> CoreML.MLShapedArraySlice<Scalar>
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
extension CoreML.MLShapedArraySlice {
  public func changingLayout(to bufferLayout: CoreML.MLShapedArrayBufferLayout) -> CoreML.MLShapedArraySlice<Scalar>
  public mutating func withUnsafeMutableShapedBufferPointer<R>(using bufferLayout: CoreML.MLShapedArrayBufferLayout, _ body: (_ ptr: inout Swift.UnsafeMutableBufferPointer<Scalar>, _ shape: [Swift.Int], _ strides: [Swift.Int]) throws -> R) rethrows -> R
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLFeatureValue {
  convenience public init<Scalar>(shapedArray: CoreML.MLShapedArray<Scalar>) where Scalar : CoreML.MLShapedArrayScalar
  public func shapedArrayValue<Scalar>(of type: Scalar.Type) -> CoreML.MLShapedArray<Scalar>? where Scalar : CoreML.MLShapedArrayScalar
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension CoreML.MLShapedArray : Swift.Encodable where Scalar : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension CoreML.MLShapedArray : Swift.Decodable where Scalar : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension CoreML.MLShapedArraySlice : Swift.Encodable where Scalar : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension CoreML.MLShapedArraySlice : Swift.Decodable where Scalar : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct MLSendableFeatureValue : Swift.Equatable, Swift.Sendable {
  public var type: CoreML.MLFeatureType {
    get
  }
  public var isUndefined: Swift.Bool {
    get
  }
  public var isScalar: Swift.Bool {
    get
  }
  public var isShapedArray: Swift.Bool {
    get
  }
  public var integerValue: Swift.Int? {
    get
  }
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var float16Value: Swift.Float16? {
    get
  }
  public var floatValue: Swift.Float? {
    get
  }
  public var doubleValue: Swift.Double? {
    get
  }
  public var stringValue: Swift.String? {
    get
  }
  public var stringArrayValue: [Swift.String]? {
    get
  }
  public var stringDictionaryValue: [Swift.String : Swift.Double]? {
    get
  }
  public var integerDictionaryValue: [Swift.Int : Swift.Double]? {
    get
  }
  public func shapedArrayValue<Scalar>(of type: Scalar.Type) -> CoreML.MLShapedArray<Scalar>? where Scalar : CoreML.MLShapedArrayScalar
  public init(undefined type: CoreML.MLFeatureType)
  public init(_ value: Swift.Int)
  public init(_ value: Swift.Int32)
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public init(_ value: Swift.Float16)
  public init(_ value: Swift.Float)
  public init(_ value: Swift.Double)
  public init(_ value: Swift.String)
  public init(_ value: [Swift.String])
  public init(_ value: [Swift.String : Swift.Double])
  public init(_ value: [Swift.String : Swift.Int])
  public init(_ value: [Swift.Int : Swift.Double])
  public init(_ value: [Swift.Int : Swift.Int])
  public init<Scalar>(_ value: CoreML.MLShapedArray<Scalar>) where Scalar : CoreML.MLShapedArrayScalar
  public init?(_ value: CoreML.MLFeatureValue)
  public static func == (a: CoreML.MLSendableFeatureValue, b: CoreML.MLSendableFeatureValue) -> Swift.Bool
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLSendableFeatureValue : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension CoreML.MLFeatureValue {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  convenience public init(_ value: CoreML.MLSendableFeatureValue)
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public protocol MLShapedArrayProtocol<Scalar> : Swift.ExpressibleByArrayLiteral, Swift.MutableCollection, Swift.RandomAccessCollection where Self.Index == Swift.Int {
  associatedtype Scalar : CoreML.MLShapedArrayScalar
  init(bytesNoCopy bytes: Swift.UnsafeRawPointer, shape: [Swift.Int], strides: [Swift.Int], deallocator: Foundation.Data.Deallocator)
  init(unsafeUninitializedShape shape: [Swift.Int], initializingWith initializer: (_ ptr: inout Swift.UnsafeMutableBufferPointer<Self.Scalar>, _ strides: [Swift.Int]) throws -> Swift.Void) rethrows
  var shape: [Swift.Int] { get }
  var strides: [Swift.Int] { get }
  subscript<C>(sliceRanges: C) -> CoreML.MLShapedArraySlice<Self.Scalar> where C : Swift.Collection, C.Element == Swift.Range<Swift.Int> { get set }
  subscript<C>(indices: C) -> CoreML.MLShapedArraySlice<Self.Scalar> where C : Swift.Collection, C.Element == Swift.Int { get set }
  subscript<C>(scalarAt indices: C) -> Self.Scalar where C : Swift.Collection, C.Element == Swift.Int { get set }
  func withUnsafeShapedBufferPointer<R>(_ body: (_ ptr: Swift.UnsafeBufferPointer<Self.Scalar>, _ shape: [Swift.Int], _ strides: [Swift.Int]) throws -> R) rethrows -> R
  mutating func withUnsafeMutableShapedBufferPointer<R>(_ body: (_ ptr: inout Swift.UnsafeMutableBufferPointer<Self.Scalar>, _ shape: [Swift.Int], _ strides: [Swift.Int]) throws -> R) rethrows -> R
}
#else
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public protocol MLShapedArrayProtocol : Swift.ExpressibleByArrayLiteral, Swift.MutableCollection, Swift.RandomAccessCollection where Self.Index == Swift.Int {
  associatedtype Scalar : CoreML.MLShapedArrayScalar
  init(bytesNoCopy bytes: Swift.UnsafeRawPointer, shape: [Swift.Int], strides: [Swift.Int], deallocator: Foundation.Data.Deallocator)
  init(unsafeUninitializedShape shape: [Swift.Int], initializingWith initializer: (_ ptr: inout Swift.UnsafeMutableBufferPointer<Self.Scalar>, _ strides: [Swift.Int]) throws -> Swift.Void) rethrows
  var shape: [Swift.Int] { get }
  var strides: [Swift.Int] { get }
  subscript<C>(sliceRanges: C) -> CoreML.MLShapedArraySlice<Self.Scalar> where C : Swift.Collection, C.Element == Swift.Range<Swift.Int> { get set }
  subscript<C>(indices: C) -> CoreML.MLShapedArraySlice<Self.Scalar> where C : Swift.Collection, C.Element == Swift.Int { get set }
  subscript<C>(scalarAt indices: C) -> Self.Scalar where C : Swift.Collection, C.Element == Swift.Int { get set }
  func withUnsafeShapedBufferPointer<R>(_ body: (_ ptr: Swift.UnsafeBufferPointer<Self.Scalar>, _ shape: [Swift.Int], _ strides: [Swift.Int]) throws -> R) rethrows -> R
  mutating func withUnsafeMutableShapedBufferPointer<R>(_ body: (_ ptr: inout Swift.UnsafeMutableBufferPointer<Self.Scalar>, _ shape: [Swift.Int], _ strides: [Swift.Int]) throws -> R) rethrows -> R
}
#endif
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArrayProtocol {
  public subscript<C>(partialSliceRanges: C) -> CoreML.MLShapedArraySlice<Self.Scalar> where C : Swift.Collection, C.Element == any CoreML.MLShapedArrayRangeExpression {
    get
    set
  }
  public subscript(sliceRange: Swift.Range<Swift.Int>) -> CoreML.MLShapedArraySlice<Self.Scalar> {
    get
    set
  }
  public subscript(sliceRanges: any CoreML.MLShapedArrayRangeExpression...) -> CoreML.MLShapedArraySlice<Self.Scalar> {
    get
    set
  }
  public subscript(sliceRange: any CoreML.MLShapedArrayRangeExpression) -> CoreML.MLShapedArraySlice<Self.Scalar> {
    get
    set
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArrayProtocol {
  public subscript(indices: Swift.Int...) -> CoreML.MLShapedArraySlice<Self.Scalar> {
    get
    set
  }
  public subscript(scalarAt indices: Swift.Int...) -> Self.Scalar {
    get
    set
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArrayProtocol {
  public subscript(_: (Swift.UnboundedRange_) -> Swift.Void) -> CoreML.MLShapedArraySlice<Self.Scalar> {
    get
    set
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArrayProtocol {
  public var isScalar: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var scalarCount: Swift.Int {
    get
  }
  public var scalars: [Self.Scalar] {
    get
    set
  }
  public var scalar: Self.Scalar? {
    get
    set
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArrayProtocol {
  public mutating func fill(with value: Self.Scalar)
  public mutating func fill<C>(with collection: C) where C : Swift.Collection, Self.Scalar == C.Element
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArrayProtocol {
  public func index(after: Self.Index) -> Self.Index
  public func index(_ index: Self.Index, offsetBy distance: Swift.Int) -> Self.Index
  public subscript(index: Swift.Int) -> CoreML.MLShapedArraySlice<Self.Scalar> {
    get
    set
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArrayProtocol where Self.Scalar : Swift.BinaryFloatingPoint, Self.Scalar.RawSignificand : Swift.FixedWidthInteger {
  public init(identityMatrixOfSize size: Swift.Int)
  public init(randomScalarsIn range: Swift.Range<Self.Scalar>, shape: [Swift.Int])
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArrayProtocol where Self.Scalar : Swift.FixedWidthInteger {
  public init(identityMatrixOfSize size: Swift.Int)
  public init(randomScalarsIn range: Swift.Range<Self.Scalar>, shape: [Swift.Int])
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArrayProtocol {
  public init(arrayLiteral elements: Self.Scalar...)
  public init(repeating value: Self.Scalar, shape: [Swift.Int])
  public init<S>(scalars: S, shape: [Swift.Int]) where S : Swift.Sequence, Self.Scalar == S.Element
  public init(bytesNoCopy bytes: Swift.UnsafeRawPointer, shape: [Swift.Int], deallocator: Foundation.Data.Deallocator)
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArrayProtocol {
  public init<T>(converting source: T) where T : CoreML.MLShapedArrayProtocol
  public init(_ multiArray: CoreML.MLMultiArray)
  public init(converting multiArray: CoreML.MLMultiArray)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  prefix public static func .! (rhs: CoreML.MLTensor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public static func .& (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
  public static func .| (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
  public static func .^ (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func all(keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func all(alongAxes axes: Swift.Int..., keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func all(alongAxes axes: [Swift.Int], keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func any(keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func any(alongAxes axes: Swift.Int..., keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func any(alongAxes axes: [Swift.Int], keepRank: Swift.Bool = false) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func cast(like other: CoreML.MLTensor) -> CoreML.MLTensor
  public func cast<Scalar>(to scalarType: Scalar.Type) -> CoreML.MLTensor where Scalar : CoreML.MLTensorScalar
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func squeezingShape() -> CoreML.MLTensor
  public func squeezingShape(at axes: Swift.Int...) -> CoreML.MLTensor
  public func squeezingShape(at axes: [Swift.Int]) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func expandingShape(at axes: Swift.Int...) -> CoreML.MLTensor
  public func expandingShape(at axes: [Swift.Int]) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func reshaped(to newShape: [Swift.Int]) -> CoreML.MLTensor
  public func flattened() -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func transposed() -> CoreML.MLTensor
  public func transposed(permutation: Swift.Int...) -> CoreML.MLTensor
  public func transposed(permutation: [Swift.Int]) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func replacing(with replacement: CoreML.MLTensor, where mask: CoreML.MLTensor) -> CoreML.MLTensor
  public func replacing(with replacement: some MLTensorScalar, where mask: CoreML.MLTensor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public init(concatenating tensors: some Collection<MLTensor>, alongAxis axis: Swift.Int = 0)
  public init(stacking tensors: some Collection<MLTensor>, alongAxis axis: Swift.Int = 0)
  public func concatenated(with other: CoreML.MLTensor, alongAxis axis: Swift.Int = 0) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: CoreML.MLTensor...)
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias ArrayLiteralElement = CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public init(_ elements: some Collection<MLTensor>, alongAxis axis: Swift.Int = 0)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func unstacked(alongAxis axis: Swift.Int = 0) -> [CoreML.MLTensor]
  public func split(count: Swift.Int, alongAxis axis: Swift.Int = 0) -> [CoreML.MLTensor]
  public func split(sizes: [Swift.Int], alongAxis axis: Swift.Int = 0) -> [CoreML.MLTensor]
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func reversed(alongAxes axes: Swift.Int...) -> CoreML.MLTensor
  public func reversed(alongAxes axes: [Swift.Int]) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public enum ResizeMethod : Swift.Sendable, Swift.Hashable {
    case bilinear(alignCorners: Swift.Bool = false)
    case nearestNeighbor
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CoreML.MLTensor.ResizeMethod, b: CoreML.MLTensor.ResizeMethod) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor.ResizeMethod : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func resized(to size: (newHeight: Swift.Int, newWidth: Swift.Int), method: CoreML.MLTensor.ResizeMethod = .nearestNeighbor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func clamped(to bounds: Swift.ClosedRange<Swift.Float>) -> CoreML.MLTensor
  public func clamped(to bounds: Swift.PartialRangeFrom<Swift.Float>) -> CoreML.MLTensor
  public func clamped(to bounds: Swift.PartialRangeThrough<Swift.Float>) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func softmax(alongAxis axis: Swift.Int = -1) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public static func + (lhs: CoreML.MLTensor, rhs: some MLTensorScalar & Numeric) -> CoreML.MLTensor
  public static func + (lhs: some MLTensorScalar & Numeric, rhs: CoreML.MLTensor) -> CoreML.MLTensor
  public static func + (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
  public static func += (lhs: inout CoreML.MLTensor, rhs: CoreML.MLTensor)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public static func - (lhs: CoreML.MLTensor, rhs: some MLTensorScalar & Numeric) -> CoreML.MLTensor
  public static func - (lhs: some MLTensorScalar & Numeric, rhs: CoreML.MLTensor) -> CoreML.MLTensor
  public static func - (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
  public static func -= (lhs: inout CoreML.MLTensor, rhs: CoreML.MLTensor)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public static func * (lhs: CoreML.MLTensor, rhs: some MLTensorScalar & Numeric) -> CoreML.MLTensor
  public static func * (lhs: some MLTensorScalar & Numeric, rhs: CoreML.MLTensor) -> CoreML.MLTensor
  public static func * (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
  public static func *= (lhs: inout CoreML.MLTensor, rhs: CoreML.MLTensor)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public static func / (lhs: CoreML.MLTensor, rhs: some MLTensorScalar & Numeric) -> CoreML.MLTensor
  public static func / (lhs: some MLTensorScalar & Numeric, rhs: CoreML.MLTensor) -> CoreML.MLTensor
  public static func / (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
  public static func /= (lhs: inout CoreML.MLTensor, rhs: CoreML.MLTensor)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public static func % (lhs: CoreML.MLTensor, rhs: some MLTensorScalar & Numeric) -> CoreML.MLTensor
  public static func % (lhs: some MLTensorScalar & Numeric, rhs: CoreML.MLTensor) -> CoreML.MLTensor
  @_disfavoredOverload public static func % (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
  public static func %= (lhs: inout CoreML.MLTensor, rhs: CoreML.MLTensor)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func pow(_ exponent: some MLTensorScalar & Numeric) -> CoreML.MLTensor
  @_disfavoredOverload public func pow(_ exponent: CoreML.MLTensor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public func pointwiseMin(_ lhs: CoreML.MLTensor, _ rhs: CoreML.MLTensor) -> CoreML.MLTensor
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public func pointwiseMax(_ lhs: CoreML.MLTensor, _ rhs: CoreML.MLTensor) -> CoreML.MLTensor
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func tiled(multiples: [Swift.Int]) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func bandPart(lowerBandCount: Swift.Int, upperBandCount: Swift.Int) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func cumulativeProduct(alongAxis axis: Swift.Int = 0) -> CoreML.MLTensor
  public func cumulativeSum(alongAxis axis: Swift.Int = 0) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func topK(_ k: Swift.Int) -> (values: CoreML.MLTensor, indices: CoreML.MLTensor)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public enum PaddingMode : Swift.Hashable, Swift.Sendable {
    case constant(Swift.Float)
    case reflection
    case symmetric
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CoreML.MLTensor.PaddingMode, b: CoreML.MLTensor.PaddingMode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor.PaddingMode : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func padded(forSizes sizes: [(before: Swift.Int, after: Swift.Int)], with value: Swift.Float) -> CoreML.MLTensor
  public func padded(forSizes sizes: [(before: Swift.Int, after: Swift.Int)], mode: CoreML.MLTensor.PaddingMode) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func argsort(alongAxis axis: Swift.Int = -1, descendingOrder: Swift.Bool = false) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public static func .== (lhs: CoreML.MLTensor, rhs: some MLTensorScalar & Numeric) -> CoreML.MLTensor
  public static func .== (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public static func .!= (lhs: CoreML.MLTensor, rhs: some MLTensorScalar & Numeric) -> CoreML.MLTensor
  public static func .!= (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public static func .> (lhs: CoreML.MLTensor, rhs: some MLTensorScalar & Numeric) -> CoreML.MLTensor
  public static func .> (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public static func .>= (lhs: CoreML.MLTensor, rhs: some MLTensorScalar & Numeric) -> CoreML.MLTensor
  public static func .>= (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public static func .< (lhs: CoreML.MLTensor, rhs: some MLTensorScalar & Numeric) -> CoreML.MLTensor
  public static func .< (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public static func .<= (lhs: CoreML.MLTensor, rhs: some MLTensorScalar & Numeric) -> CoreML.MLTensor
  public static func .<= (lhs: CoreML.MLTensor, rhs: CoreML.MLTensor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func gathering(atIndices indices: CoreML.MLTensor, alongAxis axis: Swift.Int) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func gathering(atIndices indices: CoreML.MLTensor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func replacing(atIndices indices: CoreML.MLTensor, with replacement: some MLTensorScalar, alongAxis axis: Swift.Int) -> CoreML.MLTensor
  public func replacing(with replacement: CoreML.MLTensor, atIndices indices: CoreML.MLTensor, alongAxis axis: Swift.Int) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct _MLTensorRange : CoreML.MLTensorRangeExpression {
  public var _mlTensorRange: CoreML._MLTensorRange {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public protocol MLTensorRangeExpression : Swift.Sendable {
  var _mlTensorRange: CoreML._MLTensorRange { get }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.Int : CoreML.MLTensorRangeExpression {
  public var _mlTensorRange: CoreML._MLTensorRange {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.Range : CoreML.MLTensorRangeExpression where Bound == Swift.Int {
  public var _mlTensorRange: CoreML._MLTensorRange {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.ClosedRange : CoreML.MLTensorRangeExpression where Bound == Swift.Int {
  public var _mlTensorRange: CoreML._MLTensorRange {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.PartialRangeFrom : CoreML.MLTensorRangeExpression where Bound == Swift.Int {
  public var _mlTensorRange: CoreML._MLTensorRange {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.PartialRangeUpTo : CoreML.MLTensorRangeExpression where Bound == Swift.Int {
  public var _mlTensorRange: CoreML._MLTensorRange {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.PartialRangeThrough : CoreML.MLTensorRangeExpression where Bound == Swift.Int {
  public var _mlTensorRange: CoreML._MLTensorRange {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensorRangeExpression where Self == CoreML._MLTensorRange {
  public static var fillAll: any CoreML.MLTensorRangeExpression {
    get
  }
  public static var newAxis: any CoreML.MLTensorRangeExpression {
    get
  }
  public static var squeezeAxis: any CoreML.MLTensorRangeExpression {
    get
  }
  public static func index(_ index: Swift.Int) -> any CoreML.MLTensorRangeExpression
  public static func range(_ range: Swift.Range<Swift.Int>, stride: Swift.Int = 1) -> any CoreML.MLTensorRangeExpression
  public static func closedRange(_ range: Swift.ClosedRange<Swift.Int>, stride: Swift.Int = 1) -> any CoreML.MLTensorRangeExpression
  public static func partialRangeFrom(_ range: Swift.PartialRangeFrom<Swift.Int>, stride: Swift.Int = 1) -> any CoreML.MLTensorRangeExpression
  public static func partialRangeUpTo(_ range: Swift.PartialRangeUpTo<Swift.Int>, stride: Swift.Int = 1) -> any CoreML.MLTensorRangeExpression
  public static func partialRangeUpTo(_ range: Swift.PartialRangeThrough<Swift.Int>, stride: Swift.Int = 1) -> any CoreML.MLTensorRangeExpression
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  @usableFromInline
  @frozen internal struct IndexPath {
    @usableFromInline
    internal let start: [Swift.Int], end: [Swift.Int], strides: [Swift.Int]
    @usableFromInline
    internal let beginMask: Swift.Int, endMask: Swift.Int, ellipsisMask: Swift.Int, newAxisMask: Swift.Int, squeezeAxisMask: Swift.Int
    public init(begin: [Swift.Int], end: [Swift.Int], strides: [Swift.Int], beginMask: Swift.Int, endMask: Swift.Int, ellipsisMask: Swift.Int, newAxisMask: Swift.Int, squeezeAxisMask: Swift.Int)
  }
  public subscript(firstRange: (Swift.UnboundedRange_) -> (), trailingRanges: (any CoreML.MLTensorRangeExpression)?...) -> CoreML.MLTensor {
    get
  }
  public subscript(firstRange: (any CoreML.MLTensorRangeExpression)?, secondRange: (Swift.UnboundedRange_) -> (), trailingRanges: (any CoreML.MLTensorRangeExpression)?...) -> CoreML.MLTensor {
    get
  }
  public subscript(firstRange: (any CoreML.MLTensorRangeExpression)?, secondRange: (any CoreML.MLTensorRangeExpression)?, thirdRange: (Swift.UnboundedRange_) -> (), trailingRanges: (any CoreML.MLTensorRangeExpression)?...) -> CoreML.MLTensor {
    get
  }
  public subscript(firstRange: (any CoreML.MLTensorRangeExpression)?, secondRange: (any CoreML.MLTensorRangeExpression)?, thirdRange: (any CoreML.MLTensorRangeExpression)?, fourthRange: (Swift.UnboundedRange_) -> (), trailingRanges: (any CoreML.MLTensorRangeExpression)?...) -> CoreML.MLTensor {
    get
  }
  public subscript(ranges: (any CoreML.MLTensorRangeExpression)?...) -> CoreML.MLTensor {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func sum(keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func sum(alongAxes axes: Swift.Int..., keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func sum(alongAxes axes: [Swift.Int], keepRank: Swift.Bool = false) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func mean(keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func mean(alongAxes axes: Swift.Int..., keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func mean(alongAxes axes: [Swift.Int], keepRank: Swift.Bool = false) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func min(keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func min(alongAxes axes: Swift.Int..., keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func min(alongAxes axes: [Swift.Int], keepRank: Swift.Bool = false) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func max(keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func max(alongAxes axes: Swift.Int..., keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func max(alongAxes axes: [Swift.Int], keepRank: Swift.Bool = false) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func product(keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func product(alongAxes axes: Swift.Int..., keepRank: Swift.Bool = false) -> CoreML.MLTensor
  public func product(alongAxes axes: [Swift.Int], keepRank: Swift.Bool = false) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func argmax() -> CoreML.MLTensor
  public func argmax(alongAxis axis: Swift.Int, keepRank: Swift.Bool = false) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func argmin() -> CoreML.MLTensor
  public func argmin(alongAxis axis: Swift.Int, keepRank: Swift.Bool = false) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  prefix public static func - (rhs: CoreML.MLTensor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func abs() -> CoreML.MLTensor
  public func acos() -> CoreML.MLTensor
  public func acosh() -> CoreML.MLTensor
  public func asin() -> CoreML.MLTensor
  public func asinh() -> CoreML.MLTensor
  public func atan() -> CoreML.MLTensor
  public func atanh() -> CoreML.MLTensor
  public func ceil() -> CoreML.MLTensor
  public func cos() -> CoreML.MLTensor
  public func cosh() -> CoreML.MLTensor
  public func exp() -> CoreML.MLTensor
  public func exp2() -> CoreML.MLTensor
  public func floor() -> CoreML.MLTensor
  public func log() -> CoreML.MLTensor
  public func reciprocal() -> CoreML.MLTensor
  public func round() -> CoreML.MLTensor
  public func rsqrt() -> CoreML.MLTensor
  public func sign() -> CoreML.MLTensor
  public func sin() -> CoreML.MLTensor
  public func sinh() -> CoreML.MLTensor
  public func squareRoot() -> CoreML.MLTensor
  public func squared() -> CoreML.MLTensor
  public func tan() -> CoreML.MLTensor
  public func tanh() -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public init<Scalar>(randomNormal shape: [Swift.Int], mean: Scalar = Scalar.init(0.0), standardDeviation: Scalar = Scalar.init(1.0), seed: Swift.UInt64? = nil, scalarType: Scalar.Type = Scalar.self) where Scalar : CoreML.MLTensorScalar, Scalar : Swift.BinaryFloatingPoint
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public init<Scalar>(randomUniform shape: [Swift.Int], in bounds: Swift.Range<Scalar> = 0..<1, seed: Swift.UInt64? = nil, scalarType: Scalar.Type = Scalar.self) where Scalar : CoreML.MLTensorScalar, Scalar : Swift.BinaryFloatingPoint
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public init<Scalar>(randomUniform shape: [Swift.Int], in bounds: Swift.ClosedRange<Scalar> = 0...1, seed: Swift.UInt64? = nil, scalarType: Scalar.Type = Scalar.self) where Scalar : CoreML.MLTensorScalar, Scalar : Swift.BinaryInteger
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func matmul(_ other: CoreML.MLTensor) -> CoreML.MLTensor
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public func withMLTensorComputePolicy<Result>(_ computePolicy: CoreML.MLComputePolicy, _ body: () throws -> Result) rethrows -> Result
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public func withMLTensorComputePolicy<R>(_ computePolicy: CoreML.MLComputePolicy, _ body: () async throws -> R) async rethrows -> R
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CoreML.MLMultiArray {
  convenience public init<C>(_ data: C) throws where C : Swift.Collection, C.Element : Swift.FixedWidthInteger
  convenience public init<C>(_ data: C) throws where C : Swift.Collection, C.Element == Swift.Float
  convenience public init<C>(_ data: C) throws where C : Swift.Collection, C.Element == Swift.Double
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  convenience public init(shape: [Swift.Int], dataType: CoreML.MLMultiArrayDataType, strides: [Swift.Int])
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  convenience public init<ShapedArray>(_ shapedArray: ShapedArray) where ShapedArray : CoreML.MLShapedArrayProtocol
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  public func withUnsafeBytes<R>(_ body: (_ ptr: Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  public func withUnsafeMutableBytes<R>(_ body: (_ ptr: Swift.UnsafeMutableRawBufferPointer, _ strides: [Swift.Int]) throws -> R) rethrows -> R
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  public func withUnsafeBufferPointer<S, R>(ofType type: S.Type, _ body: (_ ptr: Swift.UnsafeBufferPointer<S>) throws -> R) rethrows -> R where S : CoreML.MLShapedArrayScalar
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  public func withUnsafeMutableBufferPointer<S, R>(ofType type: S.Type, _ body: (_ ptr: Swift.UnsafeMutableBufferPointer<S>, _ strides: [Swift.Int]) throws -> R) rethrows -> R where S : CoreML.MLShapedArrayScalar
}
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(macOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
@available(iOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
@available(watchOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
@available(tvOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
extension Swift.UnsafeBufferPointer {
  public init(_ multiArray: CoreML.MLMultiArray) throws
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(macOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
@available(iOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
@available(watchOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
@available(tvOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
extension Swift.UnsafeBufferPointer {
  public init(_ multiArray: CoreML.MLMultiArray) throws
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(macOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
@available(iOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
@available(watchOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
@available(tvOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
extension Swift.UnsafeMutableBufferPointer {
  public init(_ multiArray: CoreML.MLMultiArray) throws
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(macOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
@available(iOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
@available(watchOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
@available(tvOS, deprecated: 100000.0, message: "Use .dataPointer and withExtendedLifetime instead")
extension Swift.UnsafeMutableBufferPointer {
  public init(_ multiArray: CoreML.MLMultiArray) throws
}
#endif
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
public enum MLComputeDevice : Swift.Equatable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
  case cpu(CoreML.MLCPUComputeDevice)
  case gpu(CoreML.MLGPUComputeDevice)
  case neuralEngine(CoreML.MLNeuralEngineComputeDevice)
  public var description: Swift.String {
    get
  }
  public static var allComputeDevices: [CoreML.MLComputeDevice] {
    get
  }
  public static func == (a: CoreML.MLComputeDevice, b: CoreML.MLComputeDevice) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension CoreML.MLModelConfiguration {
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  public var optimizationHints: CoreML.MLOptimizationHints {
    get
    set
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension CoreML.MLStateConstraint {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public var bufferShape: [Swift.Int] {
    get
  }
}
@_hasMissingDesignatedInitializers @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
public class MLComputePlan {
  public struct DeviceUsage : Swift.Sendable {
    public let supported: [CoreML.MLComputeDevice]
    public let preferred: CoreML.MLComputeDevice
  }
  public struct Cost : Swift.Sendable {
    public let weight: Swift.Double
  }
  final public let modelStructure: CoreML.MLModelStructure
  public static func load(asset: CoreML.MLModelAsset, configuration: CoreML.MLModelConfiguration) async throws -> CoreML.MLComputePlan
  public static func load(contentsOf url: Foundation.URL, configuration: CoreML.MLModelConfiguration) async throws -> CoreML.MLComputePlan
  public func estimatedCost(of operation: CoreML.MLModelStructure.Program.Operation) -> CoreML.MLComputePlan.Cost?
  public func deviceUsage(for layer: CoreML.MLModelStructure.NeuralNetwork.Layer) -> CoreML.MLComputePlan.DeviceUsage?
  public func deviceUsage(for operation: CoreML.MLModelStructure.Program.Operation) -> CoreML.MLComputePlan.DeviceUsage?
  @objc deinit
}
@available(*, unavailable)
extension CoreML.MLComputePlan : Swift.Sendable {
}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
public struct MLOptimizationHints : Swift.Equatable, Swift.Sendable {
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  public enum ReshapeFrequency : Swift.Int, Swift.Sendable {
    case frequent
    case infrequent
    public init?(rawValue: Swift.Int)
    @available(iOS 17.4, tvOS 17.4, watchOS 10.4, macOS 14.4, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public enum SpecializationStrategy : Swift.Int, Swift.Sendable {
    case `default`
    case fastPrediction
    public init?(rawValue: Swift.Int)
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var reshapeFrequency: CoreML.MLOptimizationHints.ReshapeFrequency
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public var specializationStrategy: CoreML.MLOptimizationHints.SpecializationStrategy
  public init()
  public static func == (a: CoreML.MLOptimizationHints, b: CoreML.MLOptimizationHints) -> Swift.Bool
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public struct MLShapedArray<Scalar> : CoreML.MLShapedArrayProtocol, @unchecked Swift.Sendable where Scalar : CoreML.MLShapedArrayScalar {
  public typealias ArrayLiteralElement = Scalar
  public typealias SubSequence = CoreML.MLShapedArraySlice<Scalar>
  public init(bytesNoCopy bytes: Swift.UnsafeRawPointer, shape: [Swift.Int], strides: [Swift.Int], deallocator: Foundation.Data.Deallocator)
  public init(data: Foundation.Data, shape: [Swift.Int], strides: [Swift.Int])
  public init(unsafeUninitializedShape shape: [Swift.Int], initializingWith initializer: (_ ptr: inout Swift.UnsafeMutableBufferPointer<Scalar>, _ strides: [Swift.Int]) throws -> Swift.Void) rethrows
  public init(scalar: Scalar)
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
  public init<S>(scalars: S, shape: [Swift.Int]) where Scalar == S.Element, S : Swift.Sequence
  public init<S>(concatenating shapedArrays: S, alongAxis: Swift.Int) where Scalar == S.Element.Scalar, S : Swift.Sequence, S.Element : CoreML.MLShapedArrayProtocol
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
  public init(mutating pixelBuffer: CoreVideo.CVPixelBuffer, shape: [Swift.Int])
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
  public init(_ multiArray: CoreML.MLMultiArray)
  public var shape: [Swift.Int] {
    get
  }
  public var strides: [Swift.Int] {
    get
  }
  public func withUnsafeShapedBufferPointer<R>(_ body: (_ ptr: Swift.UnsafeBufferPointer<Scalar>, _ shape: [Swift.Int], _ strides: [Swift.Int]) throws -> R) rethrows -> R
  public mutating func withUnsafeMutableShapedBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Scalar>, _ shape: [Swift.Int], _ strides: [Swift.Int]) throws -> R) rethrows -> R
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
  public func withPixelBufferIfAvailable<R>(_ body: (_ pixelBuffer: CoreVideo.CVPixelBuffer) throws -> R) rethrows -> R?
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
  public mutating func withMutablePixelBufferIfAvailable<R>(_ body: (_ pixelBuffer: CoreVideo.CVPixelBuffer) throws -> R) rethrows -> R?
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Element = CoreML.MLShapedArraySlice<Scalar>
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Index = Swift.Int
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Indices = Swift.Range<Swift.Int>
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Iterator = Swift.IndexingIterator<CoreML.MLShapedArray<Scalar>>
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArray : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArray {
  public var indices: Swift.Range<Swift.Int> {
    get
  }
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(index: Swift.Int) -> CoreML.MLShapedArraySlice<Scalar> {
    get
    set
  }
  public subscript<C>(indices: C) -> CoreML.MLShapedArraySlice<Scalar> where C : Swift.Collection, C.Element == Swift.Int {
    get
    set
  }
  public subscript<C>(scalarAt indices: C) -> Scalar where C : Swift.Collection, C.Element == Swift.Int {
    get
    set
  }
  public subscript<C>(sliceRanges: C) -> CoreML.MLShapedArraySlice<Scalar> where C : Swift.Collection, C.Element == Swift.Range<Swift.Int> {
    get
    set
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension CoreML.MLShapedArray {
  public init(data: Foundation.Data, shape: [Swift.Int])
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
extension CoreML.MLShapedArray {
  public func reshaped(to newShape: [Swift.Int]) -> CoreML.MLShapedArray<Scalar>
  public func squeezingShape() -> CoreML.MLShapedArray<Scalar>
  public func expandingShape(at axis: Swift.Int) -> CoreML.MLShapedArray<Scalar>
  public func transposed() -> CoreML.MLShapedArray<Scalar>
  public func transposed(permutation axes: [Swift.Int]) -> CoreML.MLShapedArray<Scalar>
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public enum MLShapedArrayBufferLayout : Swift.Sendable {
  case firstMajorContiguous
  case lastMajorContiguous
  case strides(_: [Swift.Int])
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension CoreML.MLShapedArray {
  public func changingLayout(to bufferLayout: CoreML.MLShapedArrayBufferLayout) -> CoreML.MLShapedArray<Scalar>
  public mutating func withUnsafeMutableShapedBufferPointer<R>(using bufferLayout: CoreML.MLShapedArrayBufferLayout, _ body: (_ ptr: inout Swift.UnsafeMutableBufferPointer<Scalar>, _ shape: [Swift.Int], _ strides: [Swift.Int]) throws -> R) rethrows -> R
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public protocol MLShapedArrayScalar {
  static var multiArrayDataType: CoreML.MLMultiArrayDataType { get }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.Int32 : CoreML.MLShapedArrayScalar {
  public static var multiArrayDataType: CoreML.MLMultiArrayDataType {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.Double : CoreML.MLShapedArrayScalar {
  public static var multiArrayDataType: CoreML.MLMultiArrayDataType {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.Float : CoreML.MLShapedArrayScalar {
  public static var multiArrayDataType: CoreML.MLMultiArrayDataType {
    get
  }
}
@available(macOS 15.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Float16 : CoreML.MLShapedArrayScalar {
  public static var multiArrayDataType: CoreML.MLMultiArrayDataType {
    get
  }
}
@available(macOS, unavailable)
@available(iOS, unavailable)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension CoreML.MLModelCollection {
  public class func beginAccessing(identifier: Swift.String, completionHandler handler: @escaping (Swift.Result<CoreML.MLModelCollection, any Swift.Error>) -> Swift.Void) -> Foundation.Progress
  public class func endAccessing(identifier: Swift.String, completionHandler handler: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension CoreML.MLShapedArray : Swift.Equatable where Scalar : Swift.Equatable {
  public static func == (lhs: CoreML.MLShapedArray<Scalar>, rhs: CoreML.MLShapedArray<Scalar>) -> Swift.Bool
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension CoreML.MLShapedArraySlice : Swift.Equatable where Scalar : Swift.Equatable {
  public static func == (lhs: CoreML.MLShapedArraySlice<Scalar>, rhs: CoreML.MLShapedArraySlice<Scalar>) -> Swift.Bool
}
extension CoreML.MLModel {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public func prediction(from inputs: [Swift.String : CoreML.MLTensor]) async throws -> [Swift.String : CoreML.MLTensor]
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public func prediction(from inputs: [Swift.String : CoreML.MLTensor], using state: CoreML.MLState) async throws -> [Swift.String : CoreML.MLTensor]
}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
public enum MLModelStructure : Swift.Sendable {
  public struct Program : Swift.Sendable {
    public struct ValueType : Swift.Sendable {
    }
    public struct Value : Swift.Sendable {
    }
    public struct NamedValueType : Swift.Sendable {
      public let name: Swift.String
      public let type: CoreML.MLModelStructure.Program.ValueType
    }
    public enum Binding : Swift.Sendable {
      case value(CoreML.MLModelStructure.Program.Value)
      case name(Swift.String)
    }
    public struct Argument : Swift.Sendable {
      public let bindings: [CoreML.MLModelStructure.Program.Binding]
    }
    public struct Function : Swift.Sendable {
      public let inputs: [CoreML.MLModelStructure.Program.NamedValueType]
      public let block: CoreML.MLModelStructure.Program.Block
    }
    public struct Block : Swift.Sendable {
      public let inputs: [CoreML.MLModelStructure.Program.NamedValueType]
      public let outputNames: [Swift.String]
      public let operations: [CoreML.MLModelStructure.Program.Operation]
    }
    public struct Operation : Swift.Sendable {
      public let operatorName: Swift.String
      public let inputs: [Swift.String : CoreML.MLModelStructure.Program.Argument]
      public let outputs: [CoreML.MLModelStructure.Program.NamedValueType]
      public let blocks: [CoreML.MLModelStructure.Program.Block]
    }
    public let functions: [Swift.String : CoreML.MLModelStructure.Program.Function]
  }
  public struct NeuralNetwork : Swift.Sendable {
    public struct Layer : Swift.Sendable {
      public let name: Swift.String
      public let type: Swift.String
      public let inputNames: [Swift.String]
      public let outputNames: [Swift.String]
    }
    public let layers: [CoreML.MLModelStructure.NeuralNetwork.Layer]
  }
  public struct Pipeline : Swift.Sendable {
    public let subModelNames: [Swift.String]
    public let subModels: [CoreML.MLModelStructure]
  }
  case neuralNetwork(CoreML.MLModelStructure.NeuralNetwork)
  case program(CoreML.MLModelStructure.Program)
  case pipeline(CoreML.MLModelStructure.Pipeline)
  case unsupported
  public static func load(contentsOf url: Foundation.URL) async throws -> CoreML.MLModelStructure
  public static func load(asset: CoreML.MLModelAsset) async throws -> CoreML.MLModelStructure
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct MLComputePolicy : Swift.Sendable, Swift.Hashable, Swift.CustomStringConvertible {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CoreML.MLComputePolicy, b: CoreML.MLComputePolicy) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLComputePolicy {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLComputePolicy : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLComputePolicy {
  public static var cpuAndGPU: CoreML.MLComputePolicy {
    get
  }
  public static var cpuOnly: CoreML.MLComputePolicy {
    get
  }
  public init(_ computeUnits: CoreML.MLComputeUnits)
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public protocol MLShapedArrayRangeExpression {
  func relative(toShapedArrayAxis range: Swift.Range<Swift.Int>) -> Swift.Range<Swift.Int>
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.Range : CoreML.MLShapedArrayRangeExpression where Bound == Swift.Int {
  public func relative(toShapedArrayAxis range: Swift.Range<Swift.Int>) -> Swift.Range<Swift.Int>
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.PartialRangeFrom : CoreML.MLShapedArrayRangeExpression where Bound == Swift.Int {
  public func relative(toShapedArrayAxis range: Swift.Range<Swift.Int>) -> Swift.Range<Swift.Int>
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.PartialRangeUpTo : CoreML.MLShapedArrayRangeExpression where Bound == Swift.Int {
  public func relative(toShapedArrayAxis range: Swift.Range<Swift.Int>) -> Swift.Range<Swift.Int>
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.ClosedRange : CoreML.MLShapedArrayRangeExpression where Bound == Swift.Int {
  public func relative(toShapedArrayAxis range: Swift.Range<Swift.Int>) -> Swift.Range<Swift.Int>
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.PartialRangeThrough : CoreML.MLShapedArrayRangeExpression where Bound == Swift.Int {
  public func relative(toShapedArrayAxis range: Swift.Range<Swift.Int>) -> Swift.Range<Swift.Int>
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public protocol MLTensorScalar : Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.Int8 : CoreML.MLTensorScalar {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.Int16 : CoreML.MLTensorScalar {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.Int32 : CoreML.MLTensorScalar {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.UInt8 : CoreML.MLTensorScalar {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.UInt16 : CoreML.MLTensorScalar {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.UInt32 : CoreML.MLTensorScalar {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.Float16 : CoreML.MLTensorScalar {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.Float : CoreML.MLTensorScalar {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Swift.Bool : CoreML.MLTensorScalar {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public init(unsafeUninitializedShape shape: [Swift.Int], scalarType: any CoreML.MLTensorScalar.Type, initializingWith initializer: (Swift.UnsafeMutableRawBufferPointer) throws -> Swift.Void) rethrows
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public init(shape: [Swift.Int], scalars: some Collection<Float>)
  public init<Scalar>(shape: [Swift.Int], scalars: some Collection<Scalar>, scalarType: Scalar.Type = Scalar.self) where Scalar : CoreML.MLTensorScalar
  public init<Scalar>(_ value: Scalar, scalarType: Scalar.Type = Scalar.self) where Scalar : CoreML.MLTensorScalar
  public init<Scalar>(_ scalars: some Collection<Scalar>, scalarType: Scalar.Type = Scalar.self) where Scalar : CoreML.MLTensorScalar
  public init(_ scalars: some Collection<Float>)
  public init(_ scalars: some Collection<Int32>)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public init(repeating repeatedValue: Swift.Float, shape: [Swift.Int])
  public init<Scalar>(repeating repeatedValue: Scalar, shape: [Swift.Int], scalarType: Scalar.Type = Scalar.self) where Scalar : CoreML.MLTensorScalar
  public init<Scalar>(zeros shape: [Swift.Int], scalarType: Scalar.Type = Scalar.self) where Scalar : CoreML.MLTensorScalar, Scalar : Swift.FixedWidthInteger
  public init<Scalar>(zeros shape: [Swift.Int], scalarType: Scalar.Type = Scalar.self) where Scalar : CoreML.MLTensorScalar, Scalar : Swift.BinaryFloatingPoint, Scalar.RawSignificand : Swift.FixedWidthInteger
  public init<Scalar>(ones shape: [Swift.Int], scalarType: Scalar.Type = Scalar.self) where Scalar : CoreML.MLTensorScalar, Scalar : Swift.FixedWidthInteger
  public init<Scalar>(ones shape: [Swift.Int], scalarType: Scalar.Type = Scalar.self) where Scalar : CoreML.MLTensorScalar, Scalar : Swift.BinaryFloatingPoint, Scalar.RawSignificand : Swift.FixedWidthInteger
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  @inlinable public init(rangeFrom start: Swift.Float, to end: Swift.Float, by stride: Swift.Float.Stride) {
        self.init(rangeFrom: start, to: end, by: stride, scalarType: Float.self)
    }
  @inlinable public init<Scalar>(rangeFrom start: Scalar, to end: Scalar, by stride: Scalar.Stride, scalarType: Scalar.Type = Scalar.self) where Scalar : CoreML.MLTensorScalar, Scalar : Swift.Strideable {
        self.init(
            Array<Scalar>(Swift.stride(from: start, to: end, by: stride)),
            scalarType: scalarType
        )
    }
  public init(linearSpaceFrom start: Swift.Float, through end: Swift.Float, count: Swift.Int)
  public init<Scalar>(linearSpaceFrom start: Scalar, through end: Scalar, count: Swift.Int, scalarType: Scalar.Type = Scalar.self) where Scalar : CoreML.MLTensorScalar, Scalar : Swift.BinaryFloatingPoint
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral: Swift.Float)
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias FloatLiteralType = Swift.Float
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral: Swift.Int32)
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias IntegerLiteralType = Swift.Int32
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral: Swift.Bool)
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias BooleanLiteralType = Swift.Bool
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public init<ShapedArray>(_ shapedArray: ShapedArray) where ShapedArray : CoreML.MLShapedArrayProtocol, ShapedArray.Scalar : CoreML.MLTensorScalar
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public init(shape: [Swift.Int], data: Foundation.Data, scalarType: any CoreML.MLTensorScalar.Type)
  public init(bytesNoCopy bytes: Swift.UnsafeRawBufferPointer, shape: [Swift.Int], scalarType: any CoreML.MLTensorScalar.Type, deallocator: Foundation.Data.Deallocator)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct MLTensor : Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public var rank: Swift.Int {
    get
  }
  public var shape: [Swift.Int] {
    get
  }
  public var scalarCount: Swift.Int {
    get
  }
  public var isScalar: Swift.Bool {
    get
  }
  public var scalarType: any CoreML.MLTensorScalar.Type {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor {
  public func shapedArray<Scalar>(of scalarType: Scalar.Type) async -> CoreML.MLShapedArray<Scalar> where Scalar : CoreML.MLShapedArrayScalar, Scalar : CoreML.MLTensorScalar
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension CoreML.MLModel {
  public class func load(contentsOf url: Foundation.URL, configuration: CoreML.MLModelConfiguration = MLModelConfiguration(), completionHandler handler: @escaping (Swift.Result<CoreML.MLModel, any Swift.Error>) -> Swift.Void)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public class func load(contentsOf url: Foundation.URL, configuration: CoreML.MLModelConfiguration = MLModelConfiguration()) async throws -> CoreML.MLModel
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @available(watchOS, unavailable)
  public class func compileModel(at url: Foundation.URL, completionHandler handler: @escaping (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void)
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @available(watchOS, unavailable)
  public class func compileModel(at url: Foundation.URL) async throws -> Foundation.URL
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func makeState() -> CoreML.MLState
  @available(macOS, unavailable)
  @available(iOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @available(visionOS, unavailable)
  public func newState() -> CoreML.MLState
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public func prediction(from input: any CoreML.MLFeatureProvider, options: CoreML.MLPredictionOptions = MLPredictionOptions()) async throws -> any CoreML.MLFeatureProvider
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func prediction(from input: any CoreML.MLFeatureProvider, using state: CoreML.MLState, options: CoreML.MLPredictionOptions = MLPredictionOptions()) async throws -> any CoreML.MLFeatureProvider
  @available(macOS, unavailable)
  @available(iOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @available(visionOS, unavailable)
  public func prediction(fromFeatures input: any CoreML.MLFeatureProvider, options: CoreML.MLPredictionOptions = MLPredictionOptions()) throws -> any CoreML.MLFeatureProvider
  @available(macOS, unavailable)
  @available(iOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @available(visionOS, unavailable)
  public func predictions(fromBatch input: any CoreML.MLBatchProvider, options: CoreML.MLPredictionOptions = MLPredictionOptions()) throws -> any CoreML.MLBatchProvider
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public static var availableComputeDevices: [CoreML.MLComputeDevice] {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
extension CoreML.MLState {
  @available(*, deprecated, message: "Use withMultiArray(for:) instead.")
  public func withMultiArray<R>(_ body: (CoreML.MLMultiArray) -> R) throws -> R
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
  public func withMultiArray<R>(for stateName: Swift.String, _ body: (CoreML.MLMultiArray) throws -> R) rethrows -> R
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreML.MLTensor.IndexPath : Swift.Sendable {}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension CoreML.MLOptimizationHints.ReshapeFrequency : Swift.Equatable {}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension CoreML.MLOptimizationHints.ReshapeFrequency : Swift.Hashable {}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension CoreML.MLOptimizationHints.ReshapeFrequency : Swift.RawRepresentable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension CoreML.MLOptimizationHints.SpecializationStrategy : Swift.Equatable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension CoreML.MLOptimizationHints.SpecializationStrategy : Swift.Hashable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension CoreML.MLOptimizationHints.SpecializationStrategy : Swift.RawRepresentable {}
