// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0 effective-5.10 (swiftlang-6.0.0.7.43 clang-1600.0.25.3)
// swift-module-flags: -disable-objc-attr-requires-foundation-module -target arm64e-apple-ios18.1 -enable-objc-interop -enable-library-evolution -module-link-name swiftCore -parse-stdlib -swift-version 5 -O -library-level api -enforce-exclusivity=unchecked -enable-experimental-concise-pound-file -target-min-inlining-version min -enable-experimental-feature NoncopyableGenerics2 -enable-experimental-feature SuppressedAssociatedTypes -enable-experimental-feature ExtensionImportVisiblity -enable-experimental-feature Macros -enable-experimental-feature FreestandingMacros -enable-experimental-feature Extern -enable-experimental-feature BitwiseCopyable -user-module-version 6.0.0.7.43 -module-name Swift
// swift-module-flags-ignorable: -enable-ossa-modules -enable-lexical-lifetimes=false
import SwiftShims
@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Swift.Comparable {
   
   
   
   
  return y < x ? y : x
}
@inlinable public func min<T>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T where T : Swift.Comparable {
  var minValue = min(min(x, y), z)
   
  for value in rest where value < minValue {
    minValue = value
  }
  return minValue
}
@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Swift.Comparable {
   
  return y >= x ? y : x
}
@inlinable public func max<T>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T where T : Swift.Comparable {
  var maxValue = max(max(x, y), z)
   
  for value in rest where value >= maxValue {
    maxValue = value
  }
  return maxValue
}
@frozen public struct EnumeratedSequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @inlinable internal init(_base: Base) {
    self._base = _base
  }
}
extension Swift.EnumeratedSequence : Swift.Sendable where Base : Swift.Sendable {
}
extension Swift.EnumeratedSequence {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal var _count: Swift.Int
    @inlinable internal init(_base: Base.Iterator) {
      self._base = _base
      self._count = 0
    }
  }
}
extension Swift.EnumeratedSequence.Iterator : Swift.Sendable where Base.Iterator : Swift.Sendable {
}
extension Swift.EnumeratedSequence.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  public typealias Element = (offset: Swift.Int, element: Base.Element)
  @inlinable public mutating func next() -> Swift.EnumeratedSequence<Base>.Iterator.Element? {
    guard let b = _base.next() else { return nil }
    let result = (offset: _count, element: b)
    _count += 1 
    return result
  }
  public typealias Iterator = Swift.EnumeratedSequence<Base>.Iterator
}
extension Swift.EnumeratedSequence : Swift.Sequence {
  @inlinable public __consuming func makeIterator() -> Swift.EnumeratedSequence<Base>.Iterator {
    return Iterator(_base: _base.makeIterator())
  }
  public typealias Element = Swift.EnumeratedSequence<Base>.Iterator.Element
}
@usableFromInline
@frozen internal struct _ArrayBody {
  @usableFromInline
  internal var _storage: SwiftShims._SwiftArrayBodyStorage
  @inlinable internal init(count: Swift.Int, capacity: Swift.Int, elementTypeIsBridgedVerbatim: Swift.Bool = false) {
    _internalInvariant(count >= 0)
    _internalInvariant(capacity >= 0)
    
    _storage = _SwiftArrayBodyStorage(
      count: count,
      _capacityAndFlags:
        (UInt(truncatingIfNeeded: capacity) &<< 1) |
        (elementTypeIsBridgedVerbatim ? 1 : 0))
  }
  @inlinable internal init() {
    _storage = _SwiftArrayBodyStorage(count: 0, _capacityAndFlags: 0)
  }
  @inlinable internal var count: Swift.Int {
    get {
      return _assumeNonNegative(_storage.count)
    }
    set(newCount) {
      _storage.count = newCount
    }
  }
  @inlinable internal var capacity: Swift.Int {
    get {
    return Int(_capacityAndFlags &>> 1)
  }
  }
  @inlinable internal var elementTypeIsBridgedVerbatim: Swift.Bool {
    get {
      return (_capacityAndFlags & 0x1) != 0
    }
    set {
      _capacityAndFlags
        = newValue ? _capacityAndFlags | 1 : _capacityAndFlags & ~1
    }
  }
  @inlinable internal var _capacityAndFlags: Swift.UInt {
    get {
      return _storage._capacityAndFlags
    }
    set {
      _storage._capacityAndFlags = newValue
    }
  }
}
@usableFromInline
internal typealias _ArrayBridgeStorage = Swift._BridgeStorage<Swift.__ContiguousArrayStorageBase>
@usableFromInline
@frozen internal struct _ArrayBuffer<Element> : Swift._ArrayBufferProtocol {
  @usableFromInline
  internal var _storage: Swift._ArrayBridgeStorage
  @inlinable internal init(storage: Swift._ArrayBridgeStorage) {
    _storage = storage
  }
  @inlinable internal init() {
    _storage = _ArrayBridgeStorage(native: _emptyArrayStorage)
  }
  @inlinable internal init(nsArray: Swift.AnyObject) {
    _internalInvariant(_isClassOrObjCExistential(Element.self))
    _storage = _ArrayBridgeStorage(objC: nsArray)
  }
  @inlinable internal __consuming func cast<U>(toBufferOf _: U.Type) -> Swift._ArrayBuffer<U> {
    _internalInvariant(_isClassOrObjCExistential(Element.self))
    _internalInvariant(_isClassOrObjCExistential(U.self))
    return _ArrayBuffer<U>(storage: _storage)
  }
  @inlinable internal __consuming func downcast<U>(toBufferWithDeferredTypeCheckOf _: U.Type) -> Swift._ArrayBuffer<U> {
    _internalInvariant(_isClassOrObjCExistential(Element.self))
    _internalInvariant(_isClassOrObjCExistential(U.self))
    
     
     
     

    return _ArrayBuffer<U>(
      storage: _ArrayBridgeStorage(native: _native._storage, isFlagged: true))
  }
  @inlinable internal var needsElementTypeCheck: Swift.Bool {
    get {
     
    return !_isNativeTypeChecked && !(AnyObject.self is Element.Type)
  }
  }
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._ArrayBuffer<Element>>
  @usableFromInline
  internal typealias SubSequence = Swift._SliceBuffer<Element>
}
extension Swift._ArrayBuffer {
  @inlinable internal init(_buffer source: Swift._ArrayBuffer<Element>.NativeBuffer, shiftedToStartIndex: Swift.Int) {
    _internalInvariant(shiftedToStartIndex == 0, "shiftedToStartIndex must be 0")
    _storage = _ArrayBridgeStorage(native: source._storage)
  }
  @inlinable internal var arrayPropertyIsNativeTypeChecked: Swift.Bool {
    get {
    return _isNativeTypeChecked
  }
  }
  @inlinable internal mutating func isUniquelyReferenced() -> Swift.Bool {
    if !_isClassOrObjCExistential(Element.self) {
      return _storage.isUniquelyReferencedUnflaggedNative()
    }
    return _storage.isUniquelyReferencedNative()
   }
  @_alwaysEmitIntoClient internal mutating func beginCOWMutation() -> Swift.Bool {
    let isUnique: Bool
    if !_isClassOrObjCExistential(Element.self) {
      isUnique = _storage.beginCOWMutationUnflaggedNative()
    } else if !_storage.beginCOWMutationNative() {
      return false
    } else {
      isUnique = _isNative
    }
    return isUnique
  }
  @_alwaysEmitIntoClient @inline(__always) internal mutating func endCOWMutation() {
    _storage.endCOWMutation()
  }
  @inlinable internal func _asCocoaArray() -> Swift.AnyObject {
    return _fastPath(_isNative) ? _native._asCocoaArray() : _nonNative.buffer
  }
  @_alwaysEmitIntoClient @inline(never) @_semantics("optimize.sil.specialize.owned2guarantee.never") internal __consuming func _consumeAndCreateNew() -> Swift._ArrayBuffer<Element> {
    return _consumeAndCreateNew(bufferIsUnique: false,
                                minimumCapacity: count,
                                growForAppend: false)
  }
  @_alwaysEmitIntoClient @inline(never) @_semantics("optimize.sil.specialize.owned2guarantee.never") internal __consuming func _consumeAndCreateNew(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) -> Swift._ArrayBuffer<Element> {
    let newCapacity = _growArrayCapacity(oldCapacity: capacity,
                                         minimumCapacity: minimumCapacity,
                                         growForAppend: growForAppend)
    let c = count
    _internalInvariant(newCapacity >= c)
    
    let newBuffer = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: c, minimumCapacity: newCapacity)

    if bufferIsUnique {
       
       
      let dest = newBuffer.firstElementAddress
      dest.moveInitialize(from: mutableFirstElementAddress,
                          count: c)
      _native.mutableCount = 0
    } else {
      _copyContents(
        subRange: 0..<c,
        initializing: newBuffer.mutableFirstElementAddress)
    }
    return _ArrayBuffer(_buffer: newBuffer, shiftedToStartIndex: 0)
  }
  @inlinable internal mutating func requestUniqueMutableBackingBuffer(minimumCapacity: Swift.Int) -> Swift._ArrayBuffer<Element>.NativeBuffer? {
    if _fastPath(isUniquelyReferenced()) {
      let b = _native
      if _fastPath(b.mutableCapacity >= minimumCapacity) {
        return b
      }
    }
    return nil
  }
  @inlinable internal mutating func isMutableAndUniquelyReferenced() -> Swift.Bool {
    return isUniquelyReferenced()
  }
  @inlinable internal func requestNativeBuffer() -> Swift._ArrayBuffer<Element>.NativeBuffer? {
    if !_isClassOrObjCExistential(Element.self) {
      return _native
    }
    return _fastPath(_storage.isNative) ? _native : nil
  }
  @usableFromInline
  @inline(never) internal func _typeCheckSlowPath(_ index: Swift.Int)
  @inlinable internal func _typeCheck(_ subRange: Swift.Range<Swift.Int>) {
    if !_isClassOrObjCExistential(Element.self) {
      return
    }

    if _slowPath(needsElementTypeCheck) {
       
       
       
      for i in subRange.lowerBound ..< subRange.upperBound {
        _typeCheckSlowPath(i)
      }
    }
  }
  @discardableResult
  @inlinable internal __consuming func _copyContents(subRange bounds: Swift.Range<Swift.Int>, initializing target: Swift.UnsafeMutablePointer<Element>) -> Swift.UnsafeMutablePointer<Element> {
    _typeCheck(bounds)
    if _fastPath(_isNative) {
      return _native._copyContents(subRange: bounds, initializing: target)
    }
    let buffer = UnsafeMutableRawPointer(target)
      .assumingMemoryBound(to: AnyObject.self)
    let result = _nonNative._copyContents(
      subRange: bounds,
      initializing: buffer)
    return UnsafeMutableRawPointer(result).assumingMemoryBound(to: Element.self)
  }
  @inlinable internal __consuming func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift._ArrayBuffer<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    if _fastPath(_isNative) {
      let (_, c) = _native._copyContents(initializing: buffer)
      return (IndexingIterator(_elements: self, _position: c), c)
    }
    guard buffer.count > 0 else { return (makeIterator(), 0) }
    let ptr = UnsafeMutableRawPointer(buffer.baseAddress)?
      .assumingMemoryBound(to: AnyObject.self)
    let (_, c) = _nonNative._copyContents(
      initializing: UnsafeMutableBufferPointer(start: ptr, count: buffer.count))
    return (IndexingIterator(_elements: self, _position: c), c)
  }
  @inlinable internal subscript(bounds: Swift.Range<Swift.Int>) -> Swift._SliceBuffer<Element> {
    get {
      _typeCheck(bounds)
      if _fastPath(_isNative) {
        return _native[bounds]
      }
      return _nonNative[bounds].unsafeCastElements(to: Element.self)
    }
    set {
      fatalError("not implemented")
    }
  }
  @inlinable internal var firstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    _internalInvariant(_isNative, "must be a native buffer")
    return _native.firstElementAddress
  }
  }
  @_alwaysEmitIntoClient internal var mutableFirstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    _internalInvariant(_isNative, "must be a native buffer")
    return _native.mutableFirstElementAddress
  }
  }
  @inlinable internal var firstElementAddressIfContiguous: Swift.UnsafeMutablePointer<Element>? {
    get {
    return _fastPath(_isNative) ? firstElementAddress : nil
  }
  }
  @inlinable internal var count: Swift.Int {
    @inline(__always) get {
      return _fastPath(_isNative) ? _native.count : _nonNative.endIndex
    }
    set {
      _internalInvariant(_isNative, "attempting to update count of Cocoa array")
      _native.count = newValue
    }
  }
  @_alwaysEmitIntoClient internal var immutableCount: Swift.Int {
    get {
    return _fastPath(_isNative) ? _native.immutableCount : _nonNative.endIndex
  }
  }
  @_alwaysEmitIntoClient internal var mutableCount: Swift.Int {
    @inline(__always) get {
      _internalInvariant(
        _isNative,
        "attempting to get mutating-count of non-native buffer")
      return _native.mutableCount
    }
    @inline(__always) set {
      _internalInvariant(_isNative, "attempting to update count of Cocoa array")
      _native.mutableCount = newValue
    }
  }
  @inlinable internal func _checkInoutAndNativeBounds(_ index: Swift.Int, wasNative: Swift.Bool) {
    _precondition(
      _isNative == wasNative,
      "inout rules were violated: the array was overwritten")

    if _fastPath(wasNative) {
      _native._checkValidSubscript(index)
    }
  }
  @inlinable internal func _checkInoutAndNativeTypeCheckedBounds(_ index: Swift.Int, wasNativeTypeChecked: Swift.Bool) {
    _precondition(
      _isNativeTypeChecked == wasNativeTypeChecked,
      "inout rules were violated: the array was overwritten")

    if _fastPath(wasNativeTypeChecked) {
      _native._checkValidSubscript(index)
    }
  }
  @_alwaysEmitIntoClient internal func _checkValidSubscriptMutating(_ index: Swift.Int) {
    _native._checkValidSubscriptMutating(index)
  }
  @inlinable internal var capacity: Swift.Int {
    get {
    return _fastPath(_isNative) ? _native.capacity : _nonNative.endIndex
  }
  }
  @_alwaysEmitIntoClient internal var immutableCapacity: Swift.Int {
    get {
    return _fastPath(_isNative) ? _native.immutableCapacity : _nonNative.count
  }
  }
  @_alwaysEmitIntoClient internal var mutableCapacity: Swift.Int {
    get {
    _internalInvariant(_isNative, "attempting to get mutating-capacity of non-native buffer")
    return _native.mutableCapacity
  }
  }
  @inlinable @inline(__always) internal func getElement(_ i: Swift.Int, wasNativeTypeChecked: Swift.Bool) -> Element {
    if _fastPath(wasNativeTypeChecked) {
      return _nativeTypeChecked[i]
    }
    return unsafeBitCast(_getElementSlowPath(i), to: Element.self)
  }
  @inline(never) @inlinable @_effects(notEscaping self.value**) @_effects(escaping self.value**.class*.value** => return.value**) internal func _getElementSlowPath(_ i: Swift.Int) -> Swift.AnyObject {
    _internalInvariant(
      _isClassOrObjCExistential(Element.self),
      "Only single reference elements can be indexed here.")
    let element: AnyObject
    if _isNative {
       
       
       
      _native._checkValidSubscript(i)
      
      element = cast(toBufferOf: AnyObject.self)._native[i]
      guard element is Element else {
        _assertionFailure(
          "Fatal error",
          """
          Down-casted Array element failed to match the target type
          Expected \(Element.self) but found \(type(of: element))
          """,
          flags: _fatalErrorFlags()
        )
      }
    } else {
       
      element = _nonNative[i]
      guard element is Element else {
        _assertionFailure(
          "Fatal error",
          """
          NSArray element failed to match the Swift Array Element type
          Expected \(Element.self) but found \(type(of: element))
          """,
          flags: _fatalErrorFlags()
        )
      }
    }
    return element
  }
  @inlinable internal subscript(i: Swift.Int) -> Element {
    get {
      return getElement(i, wasNativeTypeChecked: _isNativeTypeChecked)
    }
    nonmutating set {
      if _fastPath(_isNative) {
        _native[i] = newValue
      }
      else {
        var refCopy = self
        refCopy.replaceSubrange(
          i..<(i + 1),
          with: 1,
          elementsOf: CollectionOfOne(newValue))
      }
    }
  }
  @inlinable internal func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    if _fastPath(_isNative) {
      defer { _fixLifetime(self) }
      return try body(
        UnsafeBufferPointer(start: firstElementAddress, count: count))
    }
    return try ContiguousArray(self).withUnsafeBufferPointer(body)
  }
  @inlinable internal mutating func withUnsafeMutableBufferPointer<R>(_ body: (Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    _internalInvariant(
      _isNative || count == 0,
      "Array is bridging an opaque NSArray; can't get a pointer to the elements"
    )
    defer { _fixLifetime(self) }
    return try body(UnsafeMutableBufferPointer(
      start: firstElementAddressIfContiguous, count: count))
  }
  @inlinable internal var owner: Swift.AnyObject {
    get {
    return _fastPath(_isNative) ? _native._storage : _nonNative.buffer
  }
  }
  @inlinable internal var nativeOwner: Swift.AnyObject {
    get {
    _internalInvariant(_isNative, "Expect a native array")
    return _native._storage
  }
  }
  @inlinable internal var identity: Swift.UnsafeRawPointer {
    get {
    if _isNative {
      return _native.identity
    }
    else {
      return UnsafeRawPointer(
        Unmanaged.passUnretained(_nonNative.buffer).toOpaque())
    }
  }
  }
  @inlinable internal var startIndex: Swift.Int {
    get {
    return 0
  }
  }
  @inlinable internal var endIndex: Swift.Int {
    get {
    return count
  }
  }
  @usableFromInline
  internal typealias Indices = Swift.Range<Swift.Int>
  @usableFromInline
  internal typealias NativeBuffer = Swift._ContiguousArrayBuffer<Element>
  @inlinable internal var _isNative: Swift.Bool {
    get {
    if !_isClassOrObjCExistential(Element.self) {
      return true
    } else {
      return _storage.isNative
    }
  }
  }
  @inlinable internal var _isNativeTypeChecked: Swift.Bool {
    get {
    if !_isClassOrObjCExistential(Element.self) {
      return true
    } else {
      return _storage.isUnflaggedNative
    }
  }
  }
  @inlinable internal var _native: Swift._ArrayBuffer<Element>.NativeBuffer {
    get {
    return NativeBuffer(
      _isClassOrObjCExistential(Element.self)
      ? _storage.nativeInstance : _storage.unflaggedNativeInstance)
  }
  }
  @inlinable internal var _nativeTypeChecked: Swift._ArrayBuffer<Element>.NativeBuffer {
    get {
    return NativeBuffer(_storage.unflaggedNativeInstance)
  }
  }
  @inlinable internal var _nonNative: Swift._CocoaArrayWrapper {
    get {
      _internalInvariant(_isClassOrObjCExistential(Element.self))
      return _CocoaArrayWrapper(_storage.objCInstance)
    }
  }
}
extension Swift._ArrayBuffer : @unchecked Swift.Sendable where Element : Swift.Sendable {
}
@usableFromInline
internal protocol _ArrayBufferProtocol : Swift.MutableCollection, Swift.RandomAccessCollection where Self.Indices == Swift.Range<Swift.Int> {
  init()
  init(_buffer: Swift._ContiguousArrayBuffer<Self.Element>, shiftedToStartIndex: Swift.Int)
  init(copying buffer: Self)
  @discardableResult
  __consuming func _copyContents(subRange bounds: Swift.Range<Swift.Int>, initializing target: Swift.UnsafeMutablePointer<Self.Element>) -> Swift.UnsafeMutablePointer<Self.Element>
  mutating func requestUniqueMutableBackingBuffer(minimumCapacity: Swift.Int) -> Swift._ContiguousArrayBuffer<Self.Element>?
  mutating func isMutableAndUniquelyReferenced() -> Swift.Bool
  func requestNativeBuffer() -> Swift._ContiguousArrayBuffer<Self.Element>?
  mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Int>, with newCount: Swift.Int, elementsOf newValues: __owned C) where C : Swift.Collection, Self.Element == C.Element
  subscript(bounds: Swift.Range<Swift.Int>) -> Swift._SliceBuffer<Self.Element> { get }
  func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R
  mutating func withUnsafeMutableBufferPointer<R>(_ body: (Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R
  override var count: Swift.Int { get set }
  var capacity: Swift.Int { get }
  var owner: Swift.AnyObject { get }
  var firstElementAddress: Swift.UnsafeMutablePointer<Self.Element> { get }
  var firstElementAddressIfContiguous: Swift.UnsafeMutablePointer<Self.Element>? { get }
  var subscriptBaseAddress: Swift.UnsafeMutablePointer<Self.Element> { get }
  var identity: Swift.UnsafeRawPointer { get }
}
extension Swift._ArrayBufferProtocol {
  @inlinable internal var subscriptBaseAddress: Swift.UnsafeMutablePointer<Self.Element> {
    get {
    return firstElementAddress
  }
  }
  @inline(never) @inlinable internal init(copying buffer: Self) {
    let newBuffer = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: buffer.count, minimumCapacity: buffer.count)
    buffer._copyContents(
      subRange: buffer.indices,
      initializing: newBuffer.firstElementAddress)
    self = Self( _buffer: newBuffer, shiftedToStartIndex: buffer.startIndex)
  }
  @inlinable internal mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Int>, with newCount: Swift.Int, elementsOf newValues: __owned C) where C : Swift.Collection, Self.Element == C.Element {
    _internalInvariant(startIndex == 0, "_SliceBuffer should override this function.")
    let elements = self.firstElementAddress

     
    let holeStart = elements + subrange.lowerBound
    let holeEnd = holeStart + newCount
    let eraseCount = subrange.count
    holeStart.deinitialize(count: eraseCount)

    let growth = newCount - eraseCount

    if growth != 0 {
      let tailStart = elements + subrange.upperBound
      let tailCount = self.count - subrange.upperBound
      holeEnd.moveInitialize(from: tailStart, count: tailCount)
      self.count += growth
    }

     
     
     
     
    if newCount > 0 {
      let done: Void? = newValues.withContiguousStorageIfAvailable {
        _precondition(
          $0.count == newCount,
          "invalid Collection: count differed in successive traversals"
        )
        holeStart.initialize(from: $0.baseAddress!, count: newCount)
      }
      if done == nil {
        var place = holeStart
        var i = newValues.startIndex
        while place < holeEnd {
          place.initialize(to: newValues[i])
          place += 1
          newValues.formIndex(after: &i)
        }
        _expectEnd(of: newValues, is: i)
      }
    }
  }
}
@inlinable public func _arrayForceCast<SourceElement, TargetElement>(_ source: Swift.Array<SourceElement>) -> Swift.Array<TargetElement> {
  if _isClassOrObjCExistential(SourceElement.self)
  && _isClassOrObjCExistential(TargetElement.self) {
    let src = source._buffer
    if let native = src.requestNativeBuffer() {
      if native.storesOnlyElementsOfType(TargetElement.self) {
         
         
        return Array(_buffer: src.cast(toBufferOf: TargetElement.self))
      }
       
      return Array(_buffer:
        src.downcast(toBufferWithDeferredTypeCheckOf: TargetElement.self))
    }
    return Array(_immutableCocoaArray: source._buffer._asCocoaArray())
  }
#if $TypedThrows
  return source.map { $0 as! TargetElement }
#else
  return try! source.__rethrows_map { $0 as! TargetElement }
#endif
}
@inlinable public func _arrayConditionalCast<SourceElement, TargetElement>(_ source: [SourceElement]) -> [TargetElement]? {
  var successfulCasts = ContiguousArray<TargetElement>()
  successfulCasts.reserveCapacity(source.count)
  for element in source {
    if let casted = element as? TargetElement {
      successfulCasts.append(casted)
    } else {
      return nil
    }
  }
  return Array(successfulCasts)
}
#if compiler(>=5.3) && $LexicalLifetimes
@frozen @_eagerMove public struct Array<Element> : Swift._DestructorSafeContainer {
  @usableFromInline
  internal typealias _Buffer = Swift._ArrayBuffer<Element>
  @usableFromInline
  internal var _buffer: Swift.Array<Element>._Buffer
  @inlinable internal init(_buffer: Swift.Array<Element>._Buffer) {
    self._buffer = _buffer
  }
}
#else
@frozen public struct Array<Element> : Swift._DestructorSafeContainer {
  @usableFromInline
  internal typealias _Buffer = Swift._ArrayBuffer<Element>
  @usableFromInline
  internal var _buffer: Swift.Array<Element>._Buffer
  @inlinable internal init(_buffer: Swift.Array<Element>._Buffer) {
    self._buffer = _buffer
  }
}
#endif
extension Swift.Array {
  @inlinable @_semantics("array.props.isNativeTypeChecked") @_effects(notEscaping self.**) public func _hoistableIsNativeTypeChecked() -> Swift.Bool {
   return _buffer.arrayPropertyIsNativeTypeChecked
  }
  @inlinable @_semantics("array.get_count") @_effects(notEscaping self.**) internal func _getCount() -> Swift.Int {
    return _buffer.immutableCount
  }
  @inlinable @_semantics("array.get_capacity") @_effects(notEscaping self.**) internal func _getCapacity() -> Swift.Int {
    return _buffer.immutableCapacity
  }
  @inlinable @_semantics("array.make_mutable") @_effects(notEscaping self.**) internal mutating func _makeMutableAndUnique() {
    if _slowPath(!_buffer.beginCOWMutation()) {
      _buffer = _buffer._consumeAndCreateNew()
    }
  }
  @_alwaysEmitIntoClient @_semantics("array.end_mutation") @_effects(notEscaping self.**) internal mutating func _endMutation() {
    _buffer.endCOWMutation()
  }
  @inlinable @inline(__always) internal func _checkSubscript_native(_ index: Swift.Int) {
    _ = _checkSubscript(index, wasNativeTypeChecked: true)
  }
  @inlinable @_semantics("array.check_subscript") @_effects(notEscaping self.**) public func _checkSubscript(_ index: Swift.Int, wasNativeTypeChecked: Swift.Bool) -> Swift._DependenceToken {
     
     
     
     
    if _fastPath(wasNativeTypeChecked) {
      _buffer._native._checkValidSubscript(index)
    }
    return _DependenceToken()
  }
  @_alwaysEmitIntoClient @_semantics("array.check_subscript") @_effects(notEscaping self.**) internal func _checkSubscript_mutating(_ index: Swift.Int) {
    _buffer._checkValidSubscriptMutating(index)
  }
  @inlinable @_semantics("array.check_index") @_effects(notEscaping self.**) internal func _checkIndex(_ index: Swift.Int) {
    _precondition(index <= endIndex, "Array index is out of range")
    _precondition(index >= startIndex, "Negative Array index is out of range")
  }
  @_semantics("array.get_element") @_effects(notEscaping self.value**) @_effects(escaping self.value**.class*.value** -> return.value**) @inlinable @inline(__always) public func _getElement(_ index: Swift.Int, wasNativeTypeChecked: Swift.Bool, matchingSubscriptCheck: Swift._DependenceToken) -> Element {
    return _buffer.getElement(index, wasNativeTypeChecked: wasNativeTypeChecked)
  }
  @inlinable @_semantics("array.get_element_address") internal func _getElementAddress(_ index: Swift.Int) -> Swift.UnsafeMutablePointer<Element> {
    return _buffer.firstElementAddress + index
  }
}
extension Swift.Array : Swift._ArrayProtocol {
  @inlinable public var capacity: Swift.Int {
    get {
    return _getCapacity()
  }
  }
  @inlinable public var _owner: Swift.AnyObject? {
    @inlinable @inline(__always) get {
      return _buffer.owner      
    }
  }
  @inlinable public var _baseAddressIfContiguous: Swift.UnsafeMutablePointer<Element>? {
    @inline(__always) get { return _buffer.firstElementAddressIfContiguous }
  }
}
extension Swift.Array : Swift.RandomAccessCollection, Swift.MutableCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = Swift.IndexingIterator<Swift.Array<Element>>
  @inlinable public var startIndex: Swift.Int {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.Int {
    @inlinable get {
      return _getCount()
    }
  }
  @inlinable public func index(after i: Swift.Int) -> Swift.Int {
     
     
     
     
     
    return i + 1
  }
  @inlinable public func formIndex(after i: inout Swift.Int) {
     
     
     
     
     
    i += 1
  }
  @inlinable public func index(before i: Swift.Int) -> Swift.Int {
     
     
     
     
     
    return i - 1
  }
  @inlinable public func formIndex(before i: inout Swift.Int) {
     
     
     
     
     
    i -= 1
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
     
     
     
     
     
    return i + distance
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
     
     
     
     
     
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
  @inlinable public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
     
     
     
     
     
    return end - start
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
     
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
     
  }
  @inlinable public subscript(index: Swift.Int) -> Element {
    get {
       
       
       
      let wasNativeTypeChecked = _hoistableIsNativeTypeChecked()

       
       
      let token = _checkSubscript(
        index, wasNativeTypeChecked: wasNativeTypeChecked)

      return _getElement(
        index, wasNativeTypeChecked: wasNativeTypeChecked,
        matchingSubscriptCheck: token)
    }
    _modify {
      _makeMutableAndUnique()  
      _checkSubscript_mutating(index)
      let address = _buffer.mutableFirstElementAddress + index
      defer { _endMutation() }
      yield &address.pointee
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
       
       
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
  @inlinable @_semantics("array.get_count") public var count: Swift.Int {
    get {
    return _getCount()
  }
  }
  public typealias SubSequence = Swift.ArraySlice<Element>
}
extension Swift.Array : Swift.ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
    self = elements
  }
  public typealias ArrayLiteralElement = Element
}
extension Swift.Array : Swift.RangeReplaceableCollection {
  @inlinable @_semantics("array.init.empty") public init() {
    _buffer = _Buffer()
  }
  @inlinable public init<S>(_ s: S) where Element == S.Element, S : Swift.Sequence {
    self = Array(
      _buffer: _Buffer(
        _buffer: s._copyToContiguousArray()._buffer,
        shiftedToStartIndex: 0))
  }
  @inlinable @_semantics("array.init") public init(repeating repeatedValue: Element, count: Swift.Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = Array._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
    _endMutation()
  }
  @usableFromInline
  @inline(never) internal static func _allocateBufferUninitialized(minimumCapacity: Swift.Int) -> Swift.Array<Element>._Buffer
  @inlinable internal init(_uninitializedCount count: Swift.Int) {
    _precondition(count >= 0, "Can't construct Array with count < 0")
     
     
    _buffer = _Buffer()
    if count > 0 {
       
       
       
      _buffer = Array._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.mutableCount = count
    }
     
     
  }
  @inlinable @_semantics("array.uninitialized") internal static func _allocateUninitialized(_ count: Swift.Int) -> (Swift.Array<Element>, Swift.UnsafeMutablePointer<Element>) {
    let result = Array(_uninitializedCount: count)
    return (result, result._buffer.firstElementAddress)
  }
  @inlinable @_semantics("array.uninitialized") @_effects(escaping storage => return.0.value**) @_effects(escaping storage.class*.value** => return.0.value**.class*.value**) @_effects(escaping storage.class*.value** => return.1.value**) internal static func _adoptStorage(_ storage: __owned Swift._ContiguousArrayStorage<Element>, count: Swift.Int) -> (Swift.Array<Element>, Swift.UnsafeMutablePointer<Element>) {

    let innerBuffer = _ContiguousArrayBuffer<Element>(
      count: count,
      storage: storage)

    return (
      Array(
        _buffer: _Buffer(_buffer: innerBuffer, shiftedToStartIndex: 0)),
        innerBuffer.firstElementAddress)
  }
  @inlinable internal mutating func _deallocateUninitialized() {
     
     
    _buffer.mutableCount = 0
  }
  @inlinable @_semantics("array.mutate_unknown") @_effects(notEscaping self.**) public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
    _reserveCapacityImpl(minimumCapacity: minimumCapacity,
                         growForAppend: false)
    _endMutation()
  }
  @_alwaysEmitIntoClient internal mutating func _reserveCapacityImpl(minimumCapacity: Swift.Int, growForAppend: Swift.Bool) {
    let isUnique = _buffer.beginCOWMutation()
    if _slowPath(!isUnique || _buffer.mutableCapacity < minimumCapacity) {
      _createNewBuffer(bufferIsUnique: isUnique,
                       minimumCapacity: Swift.max(minimumCapacity, _buffer.count),
                       growForAppend: growForAppend)
    }
    _internalInvariant(_buffer.mutableCapacity >= minimumCapacity)
    _internalInvariant(_buffer.mutableCapacity == 0 ||
                       _buffer.isUniquelyReferenced())
  }
  @_alwaysEmitIntoClient internal mutating func _createNewBuffer(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) {
    _internalInvariant(!bufferIsUnique || _buffer.isUniquelyReferenced())
    _buffer = _buffer._consumeAndCreateNew(bufferIsUnique: bufferIsUnique,
                                           minimumCapacity: minimumCapacity,
                                           growForAppend: growForAppend)
  }
  @inline(never) @inlinable internal mutating func _copyToNewBuffer(oldCount: Swift.Int) {
    let newCount = oldCount &+ 1
    var newBuffer = _buffer._forceCreateUniqueMutableBuffer(
      countForNewBuffer: oldCount, minNewCapacity: newCount)
    _buffer._arrayOutOfPlaceUpdate(&newBuffer, oldCount, 0)
  }
  @inlinable @_semantics("array.make_mutable") @_effects(notEscaping self.**) internal mutating func _makeUniqueAndReserveCapacityIfNotUnique() {
    if _slowPath(!_buffer.beginCOWMutation()) {
      _createNewBuffer(bufferIsUnique: false,
                       minimumCapacity: count &+ 1,
                       growForAppend: true)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") @_effects(notEscaping self.**) internal mutating func _reserveCapacityAssumingUniqueBuffer(oldCount: Swift.Int) {
     
     
     
     
     
     
     
     
     
    let capacity = _buffer.mutableCapacity
    _internalInvariant(capacity == 0 || _buffer.isMutableAndUniquelyReferenced())

    if _slowPath(oldCount &+ 1 > capacity) {
      _createNewBuffer(bufferIsUnique: capacity > 0,
                       minimumCapacity: oldCount &+ 1,
                       growForAppend: true)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") @_effects(notEscaping self.**) internal mutating func _appendElementAssumeUniqueAndCapacity(_ oldCount: Swift.Int, newElement: __owned Element) {
    _internalInvariant(_buffer.isMutableAndUniquelyReferenced())
    _internalInvariant(_buffer.mutableCapacity >= _buffer.mutableCount &+ 1)

    _buffer.mutableCount = oldCount &+ 1
    (_buffer.mutableFirstElementAddress + oldCount).initialize(to: newElement)
  }
  @inlinable @_semantics("array.append_element") @_effects(notEscaping self.value**) public mutating func append(_ newElement: __owned Element) {
     
     
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _buffer.mutableCount
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
    _endMutation()
  }
  @inlinable @_semantics("array.append_contentsOf") @_effects(notEscaping self.value**) public mutating func append<S>(contentsOf newElements: __owned S) where Element == S.Element, S : Swift.Sequence {

    defer {
      _endMutation()
    }

    let newElementsCount = newElements.underestimatedCount
    _reserveCapacityImpl(minimumCapacity: self.count + newElementsCount,
                         growForAppend: true)

    let oldCount = _buffer.mutableCount
    let startNewElements = _buffer.mutableFirstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: _buffer.mutableCapacity - oldCount)

    var (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
     
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    _precondition(newElementsCount <= writtenCount, 
      "newElements.underestimatedCount was an overestimate")
     

     
    if writtenCount > 0 {
      _buffer.mutableCount = _buffer.mutableCount + writtenCount
    }

    if _slowPath(writtenUpTo == buf.endIndex) {

#if !$Embedded
       
       
       
       
       
      if S.self == [Element].self {
        _internalInvariant(remainder.next() == nil)
        return
      }
#endif

       
       
      var newCount = _buffer.mutableCount
      var nextItem = remainder.next()
      while nextItem != nil {
        _reserveCapacityAssumingUniqueBuffer(oldCount: newCount)

        let currentCapacity = _buffer.mutableCapacity
        let base = _buffer.mutableFirstElementAddress

         
        while let next = nextItem, newCount < currentCapacity {
          (base + newCount).initialize(to: next)
          newCount += 1
          nextItem = remainder.next()
        }
        _buffer.mutableCount = newCount
      }
    }
  }
  @inlinable @_semantics("array.reserve_capacity_for_append") @_effects(notEscaping self.**) internal mutating func reserveCapacityForAppend(newElementsCount: Swift.Int) {
     
     
    _reserveCapacityImpl(minimumCapacity: self.count + newElementsCount,
                         growForAppend: true)
    _endMutation()
  }
  @inlinable @_semantics("array.mutate_unknown") @_effects(notEscaping self.value**) @_effects(escaping self.value**.class*.value** -> return.value**) public mutating func _customRemoveLast() -> Element? {
    _makeMutableAndUnique()
    let newCount = _buffer.mutableCount - 1
    _precondition(newCount >= 0, "Can't removeLast from an empty Array")
    let pointer = (_buffer.mutableFirstElementAddress + newCount)
    let element = pointer.move()
    _buffer.mutableCount = newCount
    _endMutation()
    return element
  }
  @discardableResult
  @inlinable @_semantics("array.mutate_unknown") @_effects(notEscaping self.value**) @_effects(escaping self.value**.class*.value** -> return.value**) public mutating func remove(at index: Swift.Int) -> Element {
    _makeMutableAndUnique()
    let currentCount = _buffer.mutableCount
    _precondition(index < currentCount, "Index out of range")
    _precondition(index >= 0, "Index out of range")
    let newCount = currentCount - 1
    let pointer = (_buffer.mutableFirstElementAddress + index)
    let result = pointer.move()
    pointer.moveInitialize(from: pointer + 1, count: newCount - index)
    _buffer.mutableCount = newCount
    _endMutation()
    return result
  }
  @inlinable public mutating func insert(_ newElement: __owned Element, at i: Swift.Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else if _buffer.isMutableAndUniquelyReferenced() {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
    else {
      let buffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: 0,
        minimumCapacity: capacity
      )
      _buffer = _Buffer(_buffer: buffer, shiftedToStartIndex: startIndex)
    }
  }
  @available(*, deprecated, renamed: "withContiguousMutableStorageIfAvailable")
  @inlinable public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    if let n = _buffer.requestNativeBuffer() {
      return ContiguousArray(_buffer: n)
    }
    return _copyCollectionToContiguousArray(self)
  }
}
extension Swift.Array {
  @inlinable public static func + (lhs: Swift.Array<Element>, rhs: Swift.Array<Element>) -> Swift.Array<Element> {
    var lhs = lhs
    lhs.append(contentsOf: rhs)
    return lhs
  }
  @inlinable public static func += (lhs: inout Swift.Array<Element>, rhs: Swift.Array<Element>) {
    lhs.append(contentsOf: rhs)
  }
}
extension Swift.Array : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Array : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.Array {
  @usableFromInline
  @_transparent internal func _cPointerArgs() -> (Swift.AnyObject?, Swift.UnsafeRawPointer?) {
    let p = _baseAddressIfContiguous
    if _fastPath(p != nil || isEmpty) {
      return (_owner, UnsafeRawPointer(p))
    }
    let n = ContiguousArray(self._buffer)._buffer
    return (n.owner, UnsafeRawPointer(n.firstElementAddress))
  }
}
extension Swift.Array {
  @inlinable internal init(_unsafeUninitializedCapacity: Swift.Int, initializingWith initializer: (_ buffer: inout Swift.UnsafeMutableBufferPointer<Element>, _ initializedCount: inout Swift.Int) throws -> Swift.Void) rethrows {
    var firstElementAddress: UnsafeMutablePointer<Element>
    (self, firstElementAddress) =
      Array._allocateUninitialized(_unsafeUninitializedCapacity)

    var initializedCount = 0
    var buffer = UnsafeMutableBufferPointer<Element>(
      start: firstElementAddress, count: _unsafeUninitializedCapacity)
    defer {
       
      _precondition(
        initializedCount <= _unsafeUninitializedCapacity,
        "Initialized count set to greater than specified capacity."
      )
      _precondition(
        buffer.baseAddress == firstElementAddress,
        "Can't reassign buffer in Array(unsafeUninitializedCapacity:initializingWith:)"
      )
      self._buffer.mutableCount = initializedCount
      _endMutation()
    }
    try initializer(&buffer, &initializedCount)
  }
  @_alwaysEmitIntoClient @inlinable public init(unsafeUninitializedCapacity: Swift.Int, initializingWith initializer: (_ buffer: inout Swift.UnsafeMutableBufferPointer<Element>, _ initializedCount: inout Swift.Int) throws -> Swift.Void) rethrows {
    self = try Array(
      _unsafeUninitializedCapacity: unsafeUninitializedCapacity,
      initializingWith: initializer)
  }
  @inlinable public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
  @_semantics("array.withUnsafeMutableBufferPointer") @_effects(notEscaping self.value**) @inlinable @inline(__always) public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    _makeMutableAndUnique()
    let count = _buffer.mutableCount

     
    let pointer = _buffer.mutableFirstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    defer {
      _precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "Array withUnsafeMutableBufferPointer: replacing the buffer is not allowed")
      _endMutation()
      _fixLifetime(self)
    }

     
    return try body(&inoutBufferPointer)
  }
  @inlinable public __consuming func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.Array<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {

    guard !self.isEmpty else { return (makeIterator(),buffer.startIndex) }

     
     
    guard var p = buffer.baseAddress
      else { _preconditionFailure("Attempt to copy contents into nil buffer pointer") }
    _precondition(self.count <= buffer.count, 
      "Insufficient space allocated to copy array contents")

    if let s = _baseAddressIfContiguous {
      p.initialize(from: s, count: self.count)
       
       
      _fixLifetime(self._owner)
    } else {
      for x in self {
        p.initialize(to: x)
        p += 1
      }
    }

    var it = IndexingIterator(_elements: self)
    it._position = endIndex
    return (it,buffer.index(buffer.startIndex, offsetBy: self.count))
  }
}
extension Swift.Array {
  @inlinable @_semantics("array.mutate_unknown") @_effects(notEscaping self.value**) @_effects(notEscaping self.value**.class*.value**) public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Int>, with newElements: __owned C) where Element == C.Element, C : Swift.Collection {
    _precondition(subrange.lowerBound >= self._buffer.startIndex,
      "Array replace: subrange start is negative")

    _precondition(subrange.upperBound <= _buffer.endIndex,
      "Array replace: subrange extends past the end")

    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    _reserveCapacityImpl(minimumCapacity: self.count + growth,
                         growForAppend: true)
    _buffer.replaceSubrange(subrange, with: insertCount, elementsOf: newElements)
    _endMutation()
  }
}
extension Swift.Array : Swift.Equatable where Element : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.Array<Element>, rhs: Swift.Array<Element>) -> Swift.Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

     
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    _internalInvariant(lhs.startIndex == 0 && rhs.startIndex == 0)
    _internalInvariant(lhs.endIndex == lhsCount && rhs.endIndex == lhsCount)

     
    for idx in 0..<lhsCount {
      if lhs[idx] != rhs[idx] {
        return false
      }
    }

    return true
  }
}
extension Swift.Array : Swift.Hashable where Element : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(count)  
    for element in self {
      hasher.combine(element)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Array {
  @inlinable public mutating func withUnsafeMutableBytes<R>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}
@usableFromInline
internal func _bridgeCocoaArray<T>(_ _immutableCocoaArray: Swift.AnyObject) -> Swift.Array<T>
extension Swift.Array {
  @inlinable public func _bridgeToObjectiveCImpl() -> Swift.AnyObject {
    return _buffer._asCocoaArray()
  }
  @inlinable public static func _bridgeFromObjectiveCAdoptingNativeStorageOf(_ source: Swift.AnyObject) -> Swift.Array<Element>? {
     
    let maybeNative = (source as? __SwiftDeferredNSArray)?._nativeStorage ?? source

    return (maybeNative as? _ContiguousArrayStorage<Element>).map {
      Array(_ContiguousArrayBuffer($0))
    }
  }
  @inlinable public init(_immutableCocoaArray: Swift.AnyObject) {
    self = _bridgeCocoaArray(_immutableCocoaArray)
  }
}
extension Swift.Array : Swift._HasCustomAnyHashableRepresentation where Element : Swift.Hashable {
  public __consuming func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.Array : @unchecked Swift.Sendable where Element : Swift.Sendable {
}
@frozen public struct _DependenceToken {
  @inlinable public init() {
  }
}
@inlinable @inline(__always) @_semantics("array.uninitialized_intrinsic") public func _allocateUninitializedArray<Element>(_ builtinCount: Builtin.Word) -> (Swift.Array<Element>, Builtin.RawPointer) {
  let count = Int(builtinCount)
  if count > 0 {
     
     
    let storageType: _ContiguousArrayStorage<Element>.Type
    #if !$Embedded
    storageType = getContiguousArrayStorageType(for: Element.self)
    #else
    storageType = _ContiguousArrayStorage<Element>.self
    #endif
    let bufferObject = Builtin.allocWithTailElems_1(
       storageType, builtinCount, Element.self)

    let (array, ptr) = Array<Element>._adoptStorage(bufferObject, count: count)
    return (array, ptr._rawValue)
  }
   
  let (array, ptr) = Array<Element>._allocateUninitialized(count)
  return (array, ptr._rawValue)
}
@inlinable @_semantics("array.dealloc_uninitialized") public func _deallocateUninitializedArray<Element>(_ array: __owned Swift.Array<Element>) {
  var array = array
  array._deallocateUninitialized()
}
@_alwaysEmitIntoClient @_semantics("array.finalize_intrinsic") @_effects(readnone) @_effects(escaping array.value** => return.value**) @_effects(escaping array.value**.class*.value** => return.value**.class*.value**) public func _finalizeUninitializedArray<Element>(_ array: __owned Swift.Array<Element>) -> Swift.Array<Element> {
  var mutableArray = array
  mutableArray._endMutation()
  return mutableArray
}
extension Swift._ArrayBufferProtocol {
  @inlinable @inline(never) internal mutating func _arrayOutOfPlaceReplace<C>(_ bounds: Swift.Range<Swift.Int>, with newValues: __owned C, count insertCount: Swift.Int) where C : Swift.Collection, Self.Element == C.Element {

    let growth = insertCount - bounds.count
    let newCount = self.count + growth
    var newBuffer = _forceCreateUniqueMutableBuffer(
      newCount: newCount, requiredCapacity: newCount)

    _arrayOutOfPlaceUpdate(
      &newBuffer, bounds.lowerBound - startIndex, insertCount,
      { rawMemory, count in
        var p = rawMemory
        var q = newValues.startIndex
        for _ in 0..<count {
          p.initialize(to: newValues[q])
          newValues.formIndex(after: &q)
          p += 1
        }
        _expectEnd(of: newValues, is: q)
      }
    )
  }
}
@inlinable internal func _expectEnd<C>(of s: C, is i: C.Index) where C : Swift.Collection {
  _debugPrecondition(
    i == s.endIndex,
    "invalid Collection: count differed in successive traversals")
}
@inlinable internal func _growArrayCapacity(_ capacity: Swift.Int) -> Swift.Int {
  return capacity * 2
}
@_alwaysEmitIntoClient internal func _growArrayCapacity(oldCapacity: Swift.Int, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) -> Swift.Int {
  if growForAppend {
    if oldCapacity < minimumCapacity {
       
      return Swift.max(minimumCapacity, _growArrayCapacity(oldCapacity))
    }
    return oldCapacity
  }
   
   
   
  return minimumCapacity
}
extension Swift._ArrayBufferProtocol {
  @inline(never) @inlinable internal func _forceCreateUniqueMutableBuffer(newCount: Swift.Int, requiredCapacity: Swift.Int) -> Swift._ContiguousArrayBuffer<Self.Element> {
    return _forceCreateUniqueMutableBufferImpl(
      countForBuffer: newCount, minNewCapacity: newCount,
      requiredCapacity: requiredCapacity)
  }
  @inline(never) @inlinable internal func _forceCreateUniqueMutableBuffer(countForNewBuffer: Swift.Int, minNewCapacity: Swift.Int) -> Swift._ContiguousArrayBuffer<Self.Element> {
    return _forceCreateUniqueMutableBufferImpl(
      countForBuffer: countForNewBuffer, minNewCapacity: minNewCapacity,
      requiredCapacity: minNewCapacity)
  }
  @inlinable internal func _forceCreateUniqueMutableBufferImpl(countForBuffer: Swift.Int, minNewCapacity: Swift.Int, requiredCapacity: Swift.Int) -> Swift._ContiguousArrayBuffer<Self.Element> {
    _internalInvariant(countForBuffer >= 0)
    _internalInvariant(requiredCapacity >= countForBuffer)
    _internalInvariant(minNewCapacity >= countForBuffer)

    let minimumCapacity = Swift.max(requiredCapacity,
      minNewCapacity > capacity
         ? _growArrayCapacity(capacity) : capacity)

    return _ContiguousArrayBuffer(
      _uninitializedCount: countForBuffer, minimumCapacity: minimumCapacity)
  }
}
extension Swift._ArrayBufferProtocol {
  @inline(never) @inlinable internal mutating func _arrayOutOfPlaceUpdate(_ dest: inout Swift._ContiguousArrayBuffer<Self.Element>, _ headCount: Swift.Int, _ newCount: Swift.Int, _ initializeNewElements: ((Swift.UnsafeMutablePointer<Self.Element>, _ count: Swift.Int) -> ()) = { ptr, count in
      _internalInvariant(count == 0)
    }) {

    _internalInvariant(headCount >= 0)
    _internalInvariant(newCount >= 0)

     
    let sourceCount = self.count
    let tailCount = dest.count - headCount - newCount
    _internalInvariant(headCount + tailCount <= sourceCount)

    let oldCount = sourceCount - headCount - tailCount
    let destStart = dest.firstElementAddress
    let newStart = destStart + headCount
    let newEnd = newStart + newCount

     
    if let backing = requestUniqueMutableBackingBuffer(
      minimumCapacity: sourceCount) {

      let sourceStart = firstElementAddress
      let oldStart = sourceStart + headCount

       
       
      let backingStart = backing.firstElementAddress
      let sourceOffset = sourceStart - backingStart
      backingStart.deinitialize(count: sourceOffset)

       
      destStart.moveInitialize(from: sourceStart, count: headCount)

       
      oldStart.deinitialize(count: oldCount)

      initializeNewElements(newStart, newCount)

       
      newEnd.moveInitialize(from: oldStart + oldCount, count: tailCount)

       
       
      let backingEnd = backingStart + backing.count
      let sourceEnd = sourceStart + sourceCount
      sourceEnd.deinitialize(count: backingEnd - sourceEnd)
      backing.count = 0
    }
    else {
      let headStart = startIndex
      let headEnd = headStart + headCount
      let newStart = _copyContents(
        subRange: headStart..<headEnd,
        initializing: destStart)
      initializeNewElements(newStart, newCount)
      let tailStart = headEnd + oldCount
      let tailEnd = endIndex
      _copyContents(subRange: tailStart..<tailEnd, initializing: newEnd)
    }
    self = Self(_buffer: dest, shiftedToStartIndex: startIndex)
  }
}
extension Swift._ArrayBufferProtocol {
  @usableFromInline
  @inline(never) internal mutating func _outlinedMakeUniqueBuffer(bufferCount: Swift.Int)
  @inlinable internal mutating func _arrayAppendSequence<S>(_ newItems: __owned S) where S : Swift.Sequence, Self.Element == S.Element {
    
     
     
    _internalInvariant(count == capacity)
    var newCount = self.count

     
     
     
    var stream = newItems.makeIterator()
    var nextItem = stream.next()
    while nextItem != nil {

       
      var newBuffer = _forceCreateUniqueMutableBuffer(
        countForNewBuffer: newCount, 
         
         
        minNewCapacity: newCount + 1)

      _arrayOutOfPlaceUpdate(&newBuffer, newCount, 0)

      let currentCapacity = self.capacity
      let base = self.firstElementAddress

       
      while let next = nextItem, newCount < currentCapacity {
        (base + newCount).initialize(to: next)
        newCount += 1
        nextItem = stream.next()
      }
      self.count = newCount
    }
  }
}
@frozen public struct ArraySlice<Element> : Swift._DestructorSafeContainer {
  @usableFromInline
  internal typealias _Buffer = Swift._SliceBuffer<Element>
  @usableFromInline
  internal var _buffer: Swift.ArraySlice<Element>._Buffer
  @inlinable internal init(_buffer: Swift.ArraySlice<Element>._Buffer) {
    self._buffer = _buffer
  }
  @inlinable internal init(_buffer buffer: Swift._ContiguousArrayBuffer<Element>) {
    self.init(_buffer: _Buffer(_buffer: buffer, shiftedToStartIndex: 0))
  }
}
extension Swift.ArraySlice {
  @inlinable @_semantics("array.props.isNativeTypeChecked") public func _hoistableIsNativeTypeChecked() -> Swift.Bool {
   return _buffer.arrayPropertyIsNativeTypeChecked
  }
  @inlinable @_semantics("array.get_count") internal func _getCount() -> Swift.Int {
    return _buffer.count
  }
  @inlinable @_semantics("array.get_capacity") internal func _getCapacity() -> Swift.Int {
    return _buffer.capacity
  }
  @inlinable @_semantics("array.make_mutable") internal mutating func _makeMutableAndUnique() {
    if _slowPath(!_buffer.beginCOWMutation()) {
      _buffer = _Buffer(copying: _buffer)
    }
  }
  @_alwaysEmitIntoClient @_semantics("array.end_mutation") internal mutating func _endMutation() {
    _buffer.endCOWMutation()
  }
  @inlinable @inline(__always) internal func _checkSubscript_native(_ index: Swift.Int) {
    _buffer._checkValidSubscript(index)
  }
  @inlinable @_semantics("array.check_subscript") public func _checkSubscript(_ index: Swift.Int, wasNativeTypeChecked: Swift.Bool) -> Swift._DependenceToken {
    _buffer._checkValidSubscript(index)
    return _DependenceToken()
  }
  @inlinable @_semantics("array.check_index") internal func _checkIndex(_ index: Swift.Int) {
    _precondition(index <= endIndex, "ArraySlice index is out of range")
    _precondition(index >= startIndex, "ArraySlice index is out of range (before startIndex)")
  }
  @_semantics("array.get_element") @inlinable @inline(__always) public func _getElement(_ index: Swift.Int, wasNativeTypeChecked: Swift.Bool, matchingSubscriptCheck: Swift._DependenceToken) -> Element {
    return _buffer.getElement(index)
  }
  @inlinable @_semantics("array.get_element_address") internal func _getElementAddress(_ index: Swift.Int) -> Swift.UnsafeMutablePointer<Element> {
    return _buffer.subscriptBaseAddress + index
  }
}
extension Swift.ArraySlice : Swift._ArrayProtocol {
  @inlinable public var capacity: Swift.Int {
    get {
    return _getCapacity()
  }
  }
  @inlinable public var _owner: Swift.AnyObject? {
    get {
    return _buffer.owner
  }
  }
  @inlinable public var _baseAddressIfContiguous: Swift.UnsafeMutablePointer<Element>? {
    @inline(__always) get { return _buffer.firstElementAddressIfContiguous }
  }
  @inlinable internal var _baseAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    return _buffer.firstElementAddress
  }
  }
}
extension Swift.ArraySlice : Swift.RandomAccessCollection, Swift.MutableCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = Swift.IndexingIterator<Swift.ArraySlice<Element>>
  @inlinable public var startIndex: Swift.Int {
    get {
    return _buffer.startIndex
  }
  }
  @inlinable public var endIndex: Swift.Int {
    get {
    return _buffer.endIndex
  }
  }
  @inlinable public func index(after i: Swift.Int) -> Swift.Int {
     
     
     
     
     
    return i + 1
  }
  @inlinable public func formIndex(after i: inout Swift.Int) {
     
     
     
     
     
    i += 1
  }
  @inlinable public func index(before i: Swift.Int) -> Swift.Int {
     
     
     
     
     
    return i - 1
  }
  @inlinable public func formIndex(before i: inout Swift.Int) {
     
     
     
     
     
    i -= 1
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
     
     
     
     
     
    return i + distance
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
     
     
     
     
     
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
  @inlinable public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
     
     
     
     
     
    return end - start
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
     
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
     
  }
  @inlinable public subscript(index: Swift.Int) -> Element {
    get {
       
       
       
      let wasNativeTypeChecked = _hoistableIsNativeTypeChecked()

       
       
      let token = _checkSubscript(
        index, wasNativeTypeChecked: wasNativeTypeChecked)

      return _getElement(
        index, wasNativeTypeChecked: wasNativeTypeChecked,
        matchingSubscriptCheck: token)
    }
    _modify {
      _makeMutableAndUnique()  
      _checkSubscript_native(index)
      let address = _buffer.subscriptBaseAddress + index
      defer { _endMutation() }
      yield &address.pointee
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
       
       
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
  @inlinable public var count: Swift.Int {
    get {
    return _getCount()
  }
  }
  public typealias SubSequence = Swift.ArraySlice<Element>
}
extension Swift.ArraySlice : Swift.ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
    self.init(_buffer: ContiguousArray(elements)._buffer)
  }
  public typealias ArrayLiteralElement = Element
}
extension Swift.ArraySlice : Swift.RangeReplaceableCollection {
  @inlinable @_semantics("array.init.empty") public init() {
    _buffer = _Buffer()
  }
  @inlinable public init<S>(_ s: S) where Element == S.Element, S : Swift.Sequence {

    self.init(_buffer: s._copyToContiguousArray()._buffer)
  }
  @inlinable @_semantics("array.init") public init(repeating repeatedValue: Element, count: Swift.Int) {
    _precondition(count >= 0, "Can't construct ArraySlice with count < 0")
    if count > 0 {
      _buffer = ArraySlice._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.count = count
      var p = _buffer.firstElementAddress
      for _ in 0..<count {
        p.initialize(to: repeatedValue)
        p += 1
      }
    } else {
      _buffer = _Buffer()
    }
    _endMutation()
  }
  @usableFromInline
  @inline(never) internal static func _allocateBufferUninitialized(minimumCapacity: Swift.Int) -> Swift.ArraySlice<Element>._Buffer
  @inlinable @_semantics("array.init") internal init(_uninitializedCount count: Swift.Int) {
    _precondition(count >= 0, "Can't construct ArraySlice with count < 0")
     
     
    _buffer = _Buffer()
    if count > 0 {
       
       
       
      _buffer = ArraySlice._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.count = count
    }
     
     
    _endMutation()
  }
  @inlinable @_semantics("array.uninitialized") internal static func _allocateUninitialized(_ count: Swift.Int) -> (Swift.ArraySlice<Element>, Swift.UnsafeMutablePointer<Element>) {
    let result = ArraySlice(_uninitializedCount: count)
    return (result, result._buffer.firstElementAddress)
  }
  @inlinable @_semantics("array.mutate_unknown") public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
    if !_buffer.beginCOWMutation() || _buffer.capacity < minimumCapacity {
      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
    _endMutation()
  }
  @inline(never) @inlinable internal mutating func _copyToNewBuffer(oldCount: Swift.Int) {
    let newCount = oldCount &+ 1
    var newBuffer = _buffer._forceCreateUniqueMutableBuffer(
      countForNewBuffer: oldCount, minNewCapacity: newCount)
    _buffer._arrayOutOfPlaceUpdate(
      &newBuffer, oldCount, 0)
  }
  @inlinable @_semantics("array.make_mutable") internal mutating func _makeUniqueAndReserveCapacityIfNotUnique() {
    if _slowPath(!_buffer.beginCOWMutation()) {
      _copyToNewBuffer(oldCount: _buffer.count)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") internal mutating func _reserveCapacityAssumingUniqueBuffer(oldCount: Swift.Int) {
     
     
     
     
     
     
     
     
     
    let capacity = _buffer.capacity
    _internalInvariant(capacity == 0 || _buffer.isMutableAndUniquelyReferenced())

    if _slowPath(oldCount &+ 1 > capacity) {
      _copyToNewBuffer(oldCount: oldCount)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") internal mutating func _appendElementAssumeUniqueAndCapacity(_ oldCount: Swift.Int, newElement: __owned Element) {
    _internalInvariant(_buffer.isMutableAndUniquelyReferenced())
    _internalInvariant(_buffer.capacity >= _buffer.count &+ 1)

    _buffer.count = oldCount &+ 1
    (_buffer.firstElementAddress + oldCount).initialize(to: newElement)
  }
  @inlinable @_semantics("array.append_element") public mutating func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
    _endMutation()
  }
  @inlinable @_semantics("array.append_contentsOf") public mutating func append<S>(contentsOf newElements: __owned S) where Element == S.Element, S : Swift.Sequence {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)
    _ = _buffer.beginCOWMutation()

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
     
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    _precondition(newElementsCount <= writtenCount,
      "newElements.underestimatedCount was an overestimate")
     

     
    if writtenCount > 0 {
      _buffer.count += writtenCount
    }

    if writtenUpTo == buf.endIndex {
       
       
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
    _endMutation()
  }
  @inlinable @_semantics("array.reserve_capacity_for_append") internal mutating func reserveCapacityForAppend(newElementsCount: Swift.Int) {
    let oldCount = self.count
    let oldCapacity = self.capacity
    let newCount = oldCount + newElementsCount

     
     
    self.reserveCapacity(
      newCount > oldCapacity ?
      Swift.max(newCount, _growArrayCapacity(oldCapacity))
      : newCount)
  }
  @inlinable public mutating func _customRemoveLast() -> Element? {
    _precondition(count > 0, "Can't removeLast from an empty ArraySlice")
     
     
     
     
     
    let i = endIndex
     
     
    let result = self[i &- 1]
    self.replaceSubrange((i &- 1)..<i, with: EmptyCollection())
    return result
  }
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Int) -> Element {
    let result = self[index]
    self.replaceSubrange(index..<(index + 1), with: EmptyCollection())
    return result
  }
  @inlinable public mutating func insert(_ newElement: __owned Element, at i: Swift.Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else if _buffer.isMutableAndUniquelyReferenced() {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
    else {
      let buffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: 0,
        minimumCapacity: capacity
      )
      _buffer = _Buffer(_buffer: buffer, shiftedToStartIndex: startIndex)
    }
  }
  @available(*, deprecated, renamed: "withContiguousMutableStorageIfAvailable")
  @inlinable public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    if let n = _buffer.requestNativeBuffer() {
      return ContiguousArray(_buffer: n)
    }
    return _copyCollectionToContiguousArray(self)
  }
}
extension Swift.ArraySlice : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.ArraySlice : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.ArraySlice {
  @usableFromInline
  @_transparent internal func _cPointerArgs() -> (Swift.AnyObject?, Swift.UnsafeRawPointer?) {
    let p = _baseAddressIfContiguous
    if _fastPath(p != nil || isEmpty) {
      return (_owner, UnsafeRawPointer(p))
    }
    let n = ContiguousArray(self._buffer)._buffer
    return (n.owner, UnsafeRawPointer(n.firstElementAddress))
  }
}
extension Swift.ArraySlice {
  @inlinable public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
  @_semantics("array.withUnsafeMutableBufferPointer") @inlinable @inline(__always) public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    let count = self.count
     
    _makeMutableAndUnique()

     
    let pointer = _buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    defer {
      _precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "ArraySlice withUnsafeMutableBufferPointer: replacing the buffer is not allowed")
      _endMutation()
      _fixLifetime(self)
    }

     
    return try body(&inoutBufferPointer)
  }
  @inlinable public __consuming func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.ArraySlice<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {

    guard !self.isEmpty else { return (makeIterator(),buffer.startIndex) }

     
     
    guard var p = buffer.baseAddress
      else { _preconditionFailure("Attempt to copy contents into nil buffer pointer") }
    _precondition(self.count <= buffer.count, 
      "Insufficient space allocated to copy array contents")

    if let s = _baseAddressIfContiguous {
      p.initialize(from: s, count: self.count)
       
       
      _fixLifetime(self._owner)
    } else {
      for x in self {
        p.initialize(to: x)
        p += 1
      }
    }

    var it = IndexingIterator(_elements: self)
    it._position = endIndex
    return (it,buffer.index(buffer.startIndex, offsetBy: self.count))
  }
}
extension Swift.ArraySlice {
  @inlinable @_semantics("array.mutate_unknown") public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Int>, with newElements: __owned C) where Element == C.Element, C : Swift.Collection {
    _precondition(subrange.lowerBound >= _buffer.startIndex,
      "ArraySlice replace: subrange start is before the startIndex")

    _precondition(subrange.upperBound <= _buffer.endIndex,
      "ArraySlice replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.beginCOWMutation() && _buffer.capacity >= oldCount + growth {
      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
    _endMutation()
  }
}
extension Swift.ArraySlice : Swift.Equatable where Element : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.ArraySlice<Element>, rhs: Swift.ArraySlice<Element>) -> Swift.Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

     
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    var streamLHS = lhs.makeIterator()
    var streamRHS = rhs.makeIterator()

    var nextLHS = streamLHS.next()
    while nextLHS != nil {
      let nextRHS = streamRHS.next()
      if nextLHS != nextRHS {
        return false
      }
      nextLHS = streamLHS.next()
    }


    return true
  }
}
extension Swift.ArraySlice : Swift.Hashable where Element : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(count)  
    for element in self {
      hasher.combine(element)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.ArraySlice {
  @inlinable public mutating func withUnsafeMutableBytes<R>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}
extension Swift.ArraySlice {
  @inlinable public init(_startIndex: Swift.Int) {
    self.init(
      _buffer: _Buffer(
        _buffer: ContiguousArray()._buffer,
        shiftedToStartIndex: _startIndex))
  }
}
extension Swift.ArraySlice : @unchecked Swift.Sendable where Element : Swift.Sendable {
}
@usableFromInline
internal protocol _ArrayProtocol : Swift.ExpressibleByArrayLiteral, Swift.RangeReplaceableCollection where Self.Indices == Swift.Range<Swift.Int> {
  var capacity: Swift.Int { get }
  var _owner: Swift.AnyObject? { get }
  var _baseAddressIfContiguous: Swift.UnsafeMutablePointer<Self.Element>? { get }
  override mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
  override mutating func insert(_ newElement: __owned Self.Element, at i: Swift.Int)
  @discardableResult
  override mutating func remove(at index: Swift.Int) -> Self.Element
  associatedtype _Buffer : Swift._ArrayBufferProtocol where Self.Element == Self._Buffer.Element
  init(_ buffer: Self._Buffer)
  var _buffer: Self._Buffer { get }
}
extension Swift._ArrayProtocol {
  @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Swift.Bool) rethrows -> [Self.Element] {
    return try _filter(isIncluded)
  }
}
extension Swift.Unicode {
  @frozen public enum ASCII {
  }
}
extension Swift.Unicode.ASCII : Swift.Unicode.Encoding {
  public typealias CodeUnit = Swift.UInt8
  public typealias EncodedScalar = Swift.CollectionOfOne<Swift.Unicode.ASCII.CodeUnit>
  @inlinable public static var encodedReplacementCharacter: Swift.Unicode.ASCII.EncodedScalar {
    get {
    return EncodedScalar(0x1a)  
  }
  }
  @_alwaysEmitIntoClient public static func isASCII(_ x: Swift.Unicode.ASCII.CodeUnit) -> Swift.Bool { return UTF8.isASCII(x) }
  @inline(__always) @inlinable public static func _isScalar(_ x: Swift.Unicode.ASCII.CodeUnit) -> Swift.Bool {
    return true
  }
  @inline(__always) @inlinable public static func decode(_ source: Swift.Unicode.ASCII.EncodedScalar) -> Swift.Unicode.Scalar {
    return Unicode.Scalar(_unchecked: UInt32(
        source.first._unsafelyUnwrappedUnchecked))
  }
  @inline(__always) @inlinable public static func encode(_ source: Swift.Unicode.Scalar) -> Swift.Unicode.ASCII.EncodedScalar? {
    guard source.value < (1&<<7) else { return nil }
    return EncodedScalar(UInt8(truncatingIfNeeded: source.value))
  }
  @inline(__always) @inlinable public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Swift.Unicode.ASCII.EncodedScalar? where FromEncoding : Swift._UnicodeEncoding {
    if _fastPath(FromEncoding.self == UTF16.self) {
      let c = _identityCast(content, to: UTF16.EncodedScalar.self)
      guard (c._storage & 0xFF80 == 0) else { return nil }
      return EncodedScalar(CodeUnit(c._storage & 0x7f))
    }
    else if _fastPath(FromEncoding.self == UTF8.self) {
      let c = _identityCast(content, to: UTF8.EncodedScalar.self)
      let first = c.first.unsafelyUnwrapped
      guard (first < 0x80) else { return nil }
      return EncodedScalar(CodeUnit(first))
    }
    return encode(FromEncoding.decode(content))
  }
  @frozen public struct Parser {
    @inlinable public init() { }
  }
  public typealias ForwardParser = Swift.Unicode.ASCII.Parser
  public typealias ReverseParser = Swift.Unicode.ASCII.Parser
}
extension Swift.Unicode.ASCII.Parser : Swift.Unicode.Parser {
  public typealias Encoding = Swift.Unicode.ASCII
  @inlinable public mutating func parseScalar<I>(from input: inout I) -> Swift.Unicode.ParseResult<Swift.Unicode.ASCII.Parser.Encoding.EncodedScalar> where I : Swift.IteratorProtocol, I.Element == Swift.UInt8 {
    let n = input.next()
    if _fastPath(n != nil), let x = n {
      guard _fastPath(Int8(truncatingIfNeeded: x) >= 0)
      else { return .error(length: 1) }
      return .valid(Unicode.ASCII.EncodedScalar(x))
    }
    return .emptyInput
  }
}
@_transparent public func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
   
  if _isDebugAssertConfiguration() {
    if !_fastPath(condition()) {
      _assertionFailure("Assertion failed", message(), file: file, line: line,
        flags: _fatalErrorFlags())
    }
  }
}
@_transparent public func precondition(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
   
  if _isDebugAssertConfiguration() {
    if !_fastPath(condition()) {
      _assertionFailure("Precondition failed", message(), file: file, line: line,
        flags: _fatalErrorFlags())
    }
  } else if _isReleaseAssertConfiguration() {
    let error = !condition()
    Builtin.condfail_message(error._value,
      StaticString("precondition failure").unsafeRawPointer)
  }
}
@inlinable @inline(__always) public func assertionFailure(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
  if _isDebugAssertConfiguration() {
    _assertionFailure("Fatal error", message(), file: file, line: line,
      flags: _fatalErrorFlags())
  }
  else if _isFastAssertConfiguration() {
    _conditionallyUnreachable()
  }
}
@_transparent public func preconditionFailure(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never {
   
  if _isDebugAssertConfiguration() {
    _assertionFailure("Fatal error", message(), file: file, line: line,
      flags: _fatalErrorFlags())
  } else if _isReleaseAssertConfiguration() {
    Builtin.condfail_message(true._value,
      StaticString("precondition failure").unsafeRawPointer)
  }
  _conditionallyUnreachable()
}
@_transparent public func fatalError(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never {
  _assertionFailure("Fatal error", message(), file: file, line: line,
    flags: _fatalErrorFlags())
}
@usableFromInline
@_transparent internal func _precondition(_ condition: @autoclosure () -> Swift.Bool, _ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
   
  if _isDebugAssertConfiguration() {
    if !_fastPath(condition()) {
      _assertionFailure("Fatal error", message, file: file, line: line,
        flags: _fatalErrorFlags())
    }
  } else if _isReleaseAssertConfiguration() {
    let error = !condition()
    Builtin.condfail_message(error._value, message.unsafeRawPointer)
  }
}
@usableFromInline
@_transparent internal func _preconditionFailure(_ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never {
  _precondition(false, message, file: file, line: line)
  _conditionallyUnreachable()
}
@_transparent public func _overflowChecked<T>(_ args: (T, Swift.Bool), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> T {
  let (result, error) = args
  if _isDebugAssertConfiguration() {
    if _slowPath(error) {
      _fatalErrorMessage("Fatal error", "Overflow/underflow",
        file: file, line: line, flags: _fatalErrorFlags())
    }
  } else {
    Builtin.condfail_message(error._value,
      StaticString("_overflowChecked failure").unsafeRawPointer)
  }
  return result
}
@usableFromInline
@_transparent internal func _debugPrecondition(_ condition: @autoclosure () -> Swift.Bool, _ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
   
  if _slowPath(_isDebugAssertConfiguration()) {
    if !_fastPath(condition()) {
      _fatalErrorMessage("Fatal error", message, file: file, line: line,
        flags: _fatalErrorFlags())
    }
  }
}
@usableFromInline
@_transparent internal func _debugPreconditionFailure(_ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never {
  if _slowPath(_isDebugAssertConfiguration()) {
    _precondition(false, message, file: file, line: line)
  }
  _conditionallyUnreachable()
}
@usableFromInline
@_transparent internal func _internalInvariant(_ condition: @autoclosure () -> Swift.Bool, _ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
}
@_alwaysEmitIntoClient @_transparent internal func _internalInvariant_5_1(_ condition: @autoclosure () -> Swift.Bool, _ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
}
@usableFromInline
@_transparent internal func _internalInvariantFailure(_ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never {
  _internalInvariant(false, message, file: file, line: line)
  _conditionallyUnreachable()
}
@_transparent public func _isDebugAssertConfiguration() -> Swift.Bool {
   
   
   
   
  return Int32(Builtin.assert_configuration()) == 0
}
@_transparent public func _isReleaseAssertConfiguration() -> Swift.Bool {
   
   
   
   
  return Int32(Builtin.assert_configuration()) == 1
}
@_transparent public func _isFastAssertConfiguration() -> Swift.Bool {
   
   
   
   
  return Int32(Builtin.assert_configuration()) == 2
}
@_transparent public func _isStdlibInternalChecksEnabled() -> Swift.Bool {
  return false
}
@_transparent @_alwaysEmitIntoClient public func _isStdlibDebugChecksEnabled() -> Swift.Bool {
  return _isDebugAssertConfiguration()
}
@usableFromInline
@_transparent internal func _fatalErrorFlags() -> Swift.UInt32 {
   
   
  return 0
}
@usableFromInline
@inline(never) @_semantics("programtermination_point") internal func _assertionFailure(_ prefix: Swift.StaticString, _ message: Swift.StaticString, file: Swift.StaticString, line: Swift.UInt, flags: Swift.UInt32) -> Swift.Never
@usableFromInline
@inline(never) @_semantics("programtermination_point") internal func _assertionFailure(_ prefix: Swift.StaticString, _ message: Swift.String, file: Swift.StaticString, line: Swift.UInt, flags: Swift.UInt32) -> Swift.Never
@usableFromInline
@inline(never) @_semantics("programtermination_point") internal func _assertionFailure(_ prefix: Swift.StaticString, _ message: Swift.String, flags: Swift.UInt32) -> Swift.Never
@usableFromInline
@inline(never) @_semantics("programtermination_point") internal func _fatalErrorMessage(_ prefix: Swift.StaticString, _ message: Swift.StaticString, file: Swift.StaticString, line: Swift.UInt, flags: Swift.UInt32) -> Swift.Never
@_transparent public func _unimplementedInitializer(className: Swift.StaticString, initName: Swift.StaticString = #function, file: Swift.StaticString = #file, line: Swift.UInt = #line, column: Swift.UInt = #column) -> Swift.Never {
   
   
   
   

#if !$Embedded
  if _isDebugAssertConfiguration() {
    className.withUTF8Buffer {
      (className) in
      initName.withUTF8Buffer {
        (initName) in
        file.withUTF8Buffer {
          (file) in
          _swift_stdlib_reportUnimplementedInitializerInFile(
            className.baseAddress!, CInt(className.count),
            initName.baseAddress!, CInt(initName.count),
            file.baseAddress!, CInt(file.count),
            UInt32(line), UInt32(column),
              0)
        }
      }
    }
  } else {
    className.withUTF8Buffer {
      (className) in
      initName.withUTF8Buffer {
        (initName) in
        _swift_stdlib_reportUnimplementedInitializer(
          className.baseAddress!, CInt(className.count),
          initName.baseAddress!, CInt(initName.count),
            0)
      }
    }
  }
#endif

  Builtin.int_trap()
}
public func _undefined<T>(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> T
@usableFromInline
@inline(never) internal func _diagnoseUnexpectedEnumCaseValue<SwitchedValue, RawValue>(type: SwitchedValue.Type, rawValue: RawValue) -> Swift.Never
@usableFromInline
@inline(never) internal func _diagnoseUnexpectedEnumCase<SwitchedValue>(type: SwitchedValue.Type) -> Swift.Never
@backDeployed(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
@usableFromInline
@inline(never) @_semantics("unavailable_code_reached") internal func _diagnoseUnavailableCodeReached() -> Swift.Never {
  _diagnoseUnavailableCodeReached_aeic()
}
@_alwaysEmitIntoClient @inline(never) @_semantics("unavailable_code_reached") internal func _diagnoseUnavailableCodeReached_aeic() -> Swift.Never {
  _assertionFailure(
    "Fatal error", "Unavailable code reached", flags: _fatalErrorFlags())
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol BidirectionalCollection<Element> : Swift.Collection where Self.Indices : Swift.BidirectionalCollection, Self.SubSequence : Swift.BidirectionalCollection {
  override associatedtype Element
  override associatedtype Index
  override associatedtype SubSequence
  override associatedtype Indices
  func index(before i: Self.Index) -> Self.Index
  func formIndex(before i: inout Self.Index)
  override func index(after i: Self.Index) -> Self.Index
  override func formIndex(after i: inout Self.Index)
  @_nonoverride func index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index
  @_nonoverride func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index?
  @_nonoverride func distance(from start: Self.Index, to end: Self.Index) -> Swift.Int
  override var indices: Self.Indices { get }
  override subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get }
  @_borrowed override subscript(position: Self.Index) -> Self.Element { get }
  override var startIndex: Self.Index { get }
  override var endIndex: Self.Index { get }
}
#else
public protocol BidirectionalCollection : Swift.Collection where Self.Indices : Swift.BidirectionalCollection, Self.SubSequence : Swift.BidirectionalCollection {
  override associatedtype Element
  override associatedtype Index
  override associatedtype SubSequence
  override associatedtype Indices
  func index(before i: Self.Index) -> Self.Index
  func formIndex(before i: inout Self.Index)
  override func index(after i: Self.Index) -> Self.Index
  override func formIndex(after i: inout Self.Index)
  @_nonoverride func index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index
  @_nonoverride func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index?
  @_nonoverride func distance(from start: Self.Index, to end: Self.Index) -> Swift.Int
  override var indices: Self.Indices { get }
  override subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get }
  @_borrowed override subscript(position: Self.Index) -> Self.Element { get }
  override var startIndex: Self.Index { get }
  override var endIndex: Self.Index { get }
}
#endif
extension Swift.BidirectionalCollection {
  @inlinable @inline(__always) public func formIndex(before i: inout Self.Index) {
    i = index(before: i)
  }
  @inlinable public func index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index {
    return _index(i, offsetBy: distance)
  }
  @inlinable internal func _index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index {
    if distance >= 0 {
      return _advanceForward(i, by: distance)
    }
    var i = i
    for _ in stride(from: 0, to: distance, by: -1) {
      formIndex(before: &i)
    }
    return i
  }
  @inlinable public func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index? {
    return _index(i, offsetBy: distance, limitedBy: limit)
  }
  @inlinable internal func _index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index? {
    if distance >= 0 {
      return _advanceForward(i, by: distance, limitedBy: limit)
    }
    var i = i
    for _ in stride(from: 0, to: distance, by: -1) {
      if i == limit {
        return nil
      }
      formIndex(before: &i)
    }
    return i
  }
  @inlinable public func distance(from start: Self.Index, to end: Self.Index) -> Swift.Int {
    return _distance(from: start, to: end)
  }
  @inlinable internal func _distance(from start: Self.Index, to end: Self.Index) -> Swift.Int {
    var start = start
    var count = 0

    if start < end {
      while start != end {
        count += 1
        formIndex(after: &start)
      }
    }
    else if start > end {
      while start != end {
        count -= 1
        formIndex(before: &start)
      }
    }

    return count
  }
}
extension Swift.BidirectionalCollection where Self == Self.SubSequence {
  @inlinable public mutating func popLast() -> Self.Element? {
    guard !isEmpty else { return nil }
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
  @discardableResult
  @inlinable public mutating func removeLast() -> Self.Element {
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
  @inlinable public mutating func removeLast(_ k: Swift.Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    guard let end = index(endIndex, offsetBy: -k, limitedBy: startIndex)
    else {
      _preconditionFailure(
        "Can't remove more items from a collection than it contains")
    }
    self = self[startIndex..<end]
  }
}
extension Swift.BidirectionalCollection {
  @inlinable public __consuming func dropLast(_ k: Swift.Int) -> Self.SubSequence {
    _precondition(
      k >= 0, "Can't drop a negative number of elements from a collection")
    let end = index(
      endIndex,
      offsetBy: -k,
      limitedBy: startIndex) ?? startIndex
    return self[startIndex..<end]
  }
  @inlinable public __consuming func suffix(_ maxLength: Swift.Int) -> Self.SubSequence {
    _precondition(
      maxLength >= 0,
      "Can't take a suffix of negative length from a collection")
    let start = index(
      endIndex,
      offsetBy: -maxLength,
      limitedBy: startIndex) ?? startIndex
    return self[start..<endIndex]
  }
}
@usableFromInline
@frozen internal struct _UnsafeBitset {
  @usableFromInline
  internal let words: Swift.UnsafeMutablePointer<Swift._UnsafeBitset.Word>
  @usableFromInline
  internal let wordCount: Swift.Int
  @inlinable @inline(__always) internal init(words: Swift.UnsafeMutablePointer<Swift._UnsafeBitset.Word>, wordCount: Swift.Int) {
    self.words = words
    self.wordCount = wordCount
  }
}
@available(*, unavailable)
extension Swift._UnsafeBitset : Swift.Sendable {
}
extension Swift._UnsafeBitset {
  @inlinable @inline(__always) internal static func word(for element: Swift.Int) -> Swift.Int {
    _internalInvariant(element >= 0)
     
    let element = UInt(bitPattern: element)
    let capacity = UInt(bitPattern: Word.capacity)
    return Int(bitPattern: element / capacity)
  }
  @inlinable @inline(__always) internal static func bit(for element: Swift.Int) -> Swift.Int {
    _internalInvariant(element >= 0)
     
    let element = UInt(bitPattern: element)
    let capacity = UInt(bitPattern: Word.capacity)
    return Int(bitPattern: element % capacity)
  }
  @inlinable @inline(__always) internal static func split(_ element: Swift.Int) -> (word: Swift.Int, bit: Swift.Int) {
    return (word(for: element), bit(for: element))
  }
  @inlinable @inline(__always) internal static func join(word: Swift.Int, bit: Swift.Int) -> Swift.Int {
    _internalInvariant(bit >= 0 && bit < Word.capacity)
    return word &* Word.capacity &+ bit
  }
}
extension Swift._UnsafeBitset {
  @inlinable @inline(__always) internal static func wordCount(forCapacity capacity: Swift.Int) -> Swift.Int {
    return word(for: capacity &+ Word.capacity &- 1)
  }
  @inlinable internal var capacity: Swift.Int {
    @inline(__always) get {
      return wordCount &* Word.capacity
    }
  }
  @inlinable @inline(__always) internal func isValid(_ element: Swift.Int) -> Swift.Bool {
    return element >= 0 && element <= capacity
  }
  @inlinable @inline(__always) internal func uncheckedContains(_ element: Swift.Int) -> Swift.Bool {
    _internalInvariant(isValid(element))
    let (word, bit) = _UnsafeBitset.split(element)
    return words[word].uncheckedContains(bit)
  }
  @discardableResult
  @inlinable @inline(__always) internal func uncheckedInsert(_ element: Swift.Int) -> Swift.Bool {
    _internalInvariant(isValid(element))
    let (word, bit) = _UnsafeBitset.split(element)
    return words[word].uncheckedInsert(bit)
  }
  @discardableResult
  @inlinable @inline(__always) internal func uncheckedRemove(_ element: Swift.Int) -> Swift.Bool {
    _internalInvariant(isValid(element))
    let (word, bit) = _UnsafeBitset.split(element)
    return words[word].uncheckedRemove(bit)
  }
  @inlinable @inline(__always) internal func clear() {
    words.update(repeating: .empty, count: wordCount)
  }
}
extension Swift._UnsafeBitset : Swift.Sequence {
  @usableFromInline
  internal typealias Element = Swift.Int
  @inlinable internal var count: Swift.Int {
    get {
    var count = 0
    for w in 0 ..< wordCount {
      count += words[w].count
    }
    return count
  }
  }
  @inlinable internal var underestimatedCount: Swift.Int {
    get {
    return count
  }
  }
  @inlinable internal func makeIterator() -> Swift._UnsafeBitset.Iterator {
    return Iterator(self)
  }
  @usableFromInline
  @frozen internal struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal let bitset: Swift._UnsafeBitset
    @usableFromInline
    internal var index: Swift.Int
    @usableFromInline
    internal var word: Swift._UnsafeBitset.Word
    @inlinable internal init(_ bitset: Swift._UnsafeBitset) {
      self.bitset = bitset
      self.index = 0
      self.word = bitset.wordCount > 0 ? bitset.words[0] : .empty
    }
    @inlinable internal mutating func next() -> Swift.Int? {
      if let bit = word.next() {
        return _UnsafeBitset.join(word: index, bit: bit)
      }
      while (index + 1) < bitset.wordCount {
        index += 1
        word = bitset.words[index]
        if let bit = word.next() {
          return _UnsafeBitset.join(word: index, bit: bit)
        }
      }
      return nil
    }
    @usableFromInline
    internal typealias Element = Swift.Int
  }
}
@available(*, unavailable)
extension Swift._UnsafeBitset.Iterator : Swift.Sendable {
}
extension Swift._UnsafeBitset {
  @usableFromInline
  @frozen internal struct Word {
    @usableFromInline
    internal var value: Swift.UInt
    @inlinable internal init(_ value: Swift.UInt) {
      self.value = value
    }
  }
}
extension Swift._UnsafeBitset.Word {
  @inlinable internal static var capacity: Swift.Int {
    @inline(__always) get {
      return UInt.bitWidth
    }
  }
  @inlinable @inline(__always) internal func uncheckedContains(_ bit: Swift.Int) -> Swift.Bool {
    _internalInvariant(bit >= 0 && bit < UInt.bitWidth)
    return value & (1 &<< bit) != 0
  }
  @discardableResult
  @inlinable @inline(__always) internal mutating func uncheckedInsert(_ bit: Swift.Int) -> Swift.Bool {
    _internalInvariant(bit >= 0 && bit < UInt.bitWidth)
    let mask: UInt = 1 &<< bit
    let inserted = value & mask == 0
    value |= mask
    return inserted
  }
  @discardableResult
  @inlinable @inline(__always) internal mutating func uncheckedRemove(_ bit: Swift.Int) -> Swift.Bool {
    _internalInvariant(bit >= 0 && bit < UInt.bitWidth)
    let mask: UInt = 1 &<< bit
    let removed = value & mask != 0
    value &= ~mask
    return removed
  }
}
extension Swift._UnsafeBitset.Word {
  @inlinable internal var minimum: Swift.Int? {
    @inline(__always) get {
      guard value != 0 else { return nil }
      return value.trailingZeroBitCount
    }
  }
  @inlinable internal var maximum: Swift.Int? {
    @inline(__always) get {
      guard value != 0 else { return nil }
      return _UnsafeBitset.Word.capacity &- 1 &- value.leadingZeroBitCount
    }
  }
  @inlinable internal var complement: Swift._UnsafeBitset.Word {
    @inline(__always) get {
      return _UnsafeBitset.Word(~value)
    }
  }
  @inlinable @inline(__always) internal func subtracting(elementsBelow bit: Swift.Int) -> Swift._UnsafeBitset.Word {
    _internalInvariant(bit >= 0 && bit < _UnsafeBitset.Word.capacity)
    let mask = UInt.max &<< bit
    return _UnsafeBitset.Word(value & mask)
  }
  @inlinable @inline(__always) internal func intersecting(elementsBelow bit: Swift.Int) -> Swift._UnsafeBitset.Word {
    _internalInvariant(bit >= 0 && bit < _UnsafeBitset.Word.capacity)
    let mask: UInt = (1 as UInt &<< bit) &- 1
    return _UnsafeBitset.Word(value & mask)
  }
  @inlinable @inline(__always) internal func intersecting(elementsAbove bit: Swift.Int) -> Swift._UnsafeBitset.Word {
    _internalInvariant(bit >= 0 && bit < _UnsafeBitset.Word.capacity)
    let mask = (UInt.max &<< bit) &<< 1
    return _UnsafeBitset.Word(value & mask)
  }
}
extension Swift._UnsafeBitset.Word {
  @inlinable internal static var empty: Swift._UnsafeBitset.Word {
    @inline(__always) get {
      return _UnsafeBitset.Word(0)
    }
  }
  @inlinable internal static var allBits: Swift._UnsafeBitset.Word {
    @inline(__always) get {
      return _UnsafeBitset.Word(UInt.max)
    }
  }
}
extension Swift._UnsafeBitset.Word : Swift.Sequence, Swift.IteratorProtocol {
  @usableFromInline
  internal typealias Element = Swift.Int
  @inlinable internal var count: Swift.Int {
    get {
    return value.nonzeroBitCount
  }
  }
  @inlinable internal var underestimatedCount: Swift.Int {
    get {
    return count
  }
  }
  @inlinable internal var isEmpty: Swift.Bool {
    @inline(__always) get {
      return value == 0
    }
  }
  @inlinable internal mutating func next() -> Swift.Int? {
    guard value != 0 else { return nil }
    let bit = value.trailingZeroBitCount
    value &= value &- 1        
    return bit
  }
  @usableFromInline
  internal typealias Iterator = Swift._UnsafeBitset.Word
}
extension Swift._UnsafeBitset {
  @_alwaysEmitIntoClient @inline(__always) internal static func _withTemporaryUninitializedBitset<R>(wordCount: Swift.Int, body: (Swift._UnsafeBitset) throws -> R) rethrows -> R {
    try withUnsafeTemporaryAllocation(
      of: _UnsafeBitset.Word.self, capacity: wordCount
    ) { buffer in
      let bitset = _UnsafeBitset(
        words: buffer.baseAddress!, wordCount: buffer.count)
      return try body(bitset)
    }
  }
  @_alwaysEmitIntoClient @inline(__always) internal static func withTemporaryBitset<R>(capacity: Swift.Int, body: (Swift._UnsafeBitset) throws -> R) rethrows -> R {
    let wordCount = Swift.max(1, Self.wordCount(forCapacity: capacity))
    return try _withTemporaryUninitializedBitset(
      wordCount: wordCount
    ) { bitset in
      bitset.clear()
      return try body(bitset)
    }
  }
}
extension Swift._UnsafeBitset {
  @_alwaysEmitIntoClient @inline(__always) internal static func withTemporaryCopy<R>(of original: Swift._UnsafeBitset, body: (Swift._UnsafeBitset) throws -> R) rethrows -> R {
    try _withTemporaryUninitializedBitset(
      wordCount: original.wordCount
    ) { bitset in
      bitset.words.initialize(from: original.words, count: original.wordCount)
      return try body(bitset)
    }
  }
}
@frozen public struct Bool : Swift.Sendable {
  public var _value: Builtin.Int1
  @_transparent public init() {
    let zero: Int8 = 0
    self._value = Builtin.trunc_Int8_Int1(zero._value)
  }
  @_transparent public init(_ _v: Builtin.Int1) { self._value = _v }
  @inlinable public init(_ value: Swift.Bool) {
    self = value
  }
  @inlinable public static func random<T>(using generator: inout T) -> Swift.Bool where T : Swift.RandomNumberGenerator {
    return (generator.next() >> 17) & 1 == 0
  }
  @inlinable public static func random() -> Swift.Bool {
    var g = SystemRandomNumberGenerator()
    return Bool.random(using: &g)
  }
}
extension Swift.Bool : Swift._ExpressibleByBuiltinBooleanLiteral, Swift.ExpressibleByBooleanLiteral {
  @_transparent @_semantics("bool.literal_init") public init(_builtinBooleanLiteral value: Builtin.Int1) {
    self._value = value
  }
  @_transparent public init(booleanLiteral value: Swift.Bool) {
    self = value
  }
  public typealias BooleanLiteralType = Swift.Bool
}
extension Swift.Bool : Swift.CustomStringConvertible {
  @inlinable public var description: Swift.String {
    get {
    return self ? "true" : "false"
  }
  }
}
extension Swift.Bool : Swift.Equatable {
  @_transparent public static func == (lhs: Swift.Bool, rhs: Swift.Bool) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int1(lhs._value, rhs._value))
  }
}
extension Swift.Bool : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine((self ? 1 : 0) as UInt8)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Bool : Swift.LosslessStringConvertible {
  @inlinable public init?(_ description: Swift.String) {
    if description == "true" {
      self = true
    } else if description == "false" {
      self = false
    } else {
      return nil
    }
  }
}
extension Swift.Bool {
  @_transparent prefix public static func ! (a: Swift.Bool) -> Swift.Bool {
    return Bool(Builtin.xor_Int1(a._value, true._value))
  }
}
extension Swift.Bool {
  @_transparent @inline(__always) public static func && (lhs: Swift.Bool, rhs: @autoclosure () throws -> Swift.Bool) rethrows -> Swift.Bool {
    return lhs ? try rhs() : false
  }
  @_transparent @inline(__always) public static func || (lhs: Swift.Bool, rhs: @autoclosure () throws -> Swift.Bool) rethrows -> Swift.Bool {
    return lhs ? true : try rhs()
  }
}
extension Swift.Bool {
  @inlinable public mutating func toggle() {
    self = !self
  }
}
public protocol _ObjectiveCBridgeable {
  associatedtype _ObjectiveCType : AnyObject
  func _bridgeToObjectiveC() -> Self._ObjectiveCType
  static func _forceBridgeFromObjectiveC(_ source: Self._ObjectiveCType, result: inout Self?)
  @discardableResult
  static func _conditionallyBridgeFromObjectiveC(_ source: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: Self._ObjectiveCType?) -> Self
}
@available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
@_cdecl("_SwiftCreateBridgedArray")
@usableFromInline
internal func _SwiftCreateBridgedArray_DoNotCall(values: Swift.UnsafePointer<Swift.AnyObject>, numValues: Swift.Int) -> Swift.Unmanaged<Swift.AnyObject>
@available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
@_cdecl("_SwiftCreateBridgedMutableArray")
@usableFromInline
internal func _SwiftCreateBridgedMutableArray_DoNotCall(values: Swift.UnsafePointer<Swift.AnyObject>, numValues: Swift.Int) -> Swift.Unmanaged<Swift.AnyObject>
public struct _BridgeableMetatype : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = Swift.AnyObject
  public func _bridgeToObjectiveC() -> Swift.AnyObject
  public static func _forceBridgeFromObjectiveC(_ source: Swift.AnyObject, result: inout Swift._BridgeableMetatype?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Swift.AnyObject, result: inout Swift._BridgeableMetatype?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Swift.AnyObject?) -> Swift._BridgeableMetatype
}
extension Swift._BridgeableMetatype : Swift.Sendable {
}
@inlinable public func _bridgeAnythingToObjectiveC<T>(_ x: T) -> Swift.AnyObject {
  if _fastPath(_isClassOrObjCExistential(T.self)) {
    return unsafeBitCast(x, to: AnyObject.self)
  }
  return _bridgeAnythingNonVerbatimToObjectiveC(x)
}
@_silgen_name("")
public func _bridgeAnythingNonVerbatimToObjectiveC<T>(_ x: __owned T) -> Swift.AnyObject
public func _bridgeAnyObjectToAny(_ possiblyNullObject: Swift.AnyObject?) -> Any
@inlinable public func _forceBridgeFromObjectiveC<T>(_ x: Swift.AnyObject, _: T.Type) -> T {
  if _fastPath(_isClassOrObjCExistential(T.self)) {
    return x as! T
  }

  var result: T?
  _bridgeNonVerbatimFromObjectiveC(x, T.self, &result)
  return result!
}
@inlinable public func _forceBridgeFromObjectiveC_bridgeable<T>(_ x: T._ObjectiveCType, _: T.Type) -> T where T : Swift._ObjectiveCBridgeable {
  var result: T?
  T._forceBridgeFromObjectiveC(x, result: &result)
  return result!
}
@inlinable public func _conditionallyBridgeFromObjectiveC<T>(_ x: Swift.AnyObject, _: T.Type) -> T? {
  if _fastPath(_isClassOrObjCExistential(T.self)) {
    return x as? T
  }

  var result: T?
  _ = _bridgeNonVerbatimFromObjectiveCConditional(x, T.self, &result)
  return result
}
@inlinable public func _conditionallyBridgeFromObjectiveC_bridgeable<T>(_ x: T._ObjectiveCType, _: T.Type) -> T? where T : Swift._ObjectiveCBridgeable {
  var result: T?
  T._conditionallyBridgeFromObjectiveC (x, result: &result)
  return result
}
@_silgen_name("")
@usableFromInline
internal func _bridgeNonVerbatimFromObjectiveC<T>(_ x: Swift.AnyObject, _ nativeType: T.Type, _ result: inout T?)
@_silgen_name("")
public func _bridgeNonVerbatimFromObjectiveCConditional<T>(_ x: Swift.AnyObject, _ nativeType: T.Type, _ result: inout T?) -> Swift.Bool
public func _isBridgedToObjectiveC<T>(_: T.Type) -> Swift.Bool
@_silgen_name("")
public func _isBridgedNonVerbatimToObjectiveC<T>(_: T.Type) -> Swift.Bool
@inlinable public func _isBridgedVerbatimToObjectiveC<T>(_: T.Type) -> Swift.Bool {
  return _isClassOrObjCExistential(T.self)
}
@inlinable public func _getBridgedObjectiveCType<T>(_: T.Type) -> (any Any.Type)? {
  if _fastPath(_isClassOrObjCExistential(T.self)) {
    return T.self
  }
  return _getBridgedNonVerbatimObjectiveCType(T.self)
}
@_silgen_name("")
public func _getBridgedNonVerbatimObjectiveCType<T>(_: T.Type) -> (any Any.Type)?
@frozen public struct AutoreleasingUnsafeMutablePointer<Pointee> : Swift._Pointer {
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
  @inlinable public var pointee: Pointee {
    @_transparent get {
       
       
       
       
       
       
       
       
       
      let unmanaged =
        UnsafePointer<Optional<Unmanaged<AnyObject>>>(_rawValue).pointee
      return _unsafeReferenceCast(
        unmanaged?.takeUnretainedValue(),
        to: Pointee.self)
    }
    @_transparent nonmutating set {
       
      let object = _unsafeReferenceCast(newValue, to: Optional<AnyObject>.self)
      Builtin.retain(object)
      Builtin.autorelease(object)

       
       
      let unmanaged: Optional<Unmanaged<AnyObject>>
      if let object = object {
        unmanaged = Unmanaged.passUnretained(object)
      } else {
        unmanaged = nil
      }
      UnsafeMutablePointer<Optional<Unmanaged<AnyObject>>>(_rawValue).pointee =
        unmanaged
    }
  }
  @inlinable public subscript(i: Swift.Int) -> Pointee {
    @_transparent get {
      return self.advanced(by: i).pointee
    }
  }
  @_transparent public init<U>(@_nonEphemeral _ from: Swift.UnsafeMutablePointer<U>) {
   self._rawValue = from._rawValue
  }
  @_transparent public init?<U>(@_nonEphemeral _ from: Swift.UnsafeMutablePointer<U>?) {
   guard let unwrapped = from else { return nil }
   self.init(unwrapped)
  }
  @usableFromInline
  @_transparent internal init<U>(@_nonEphemeral _ from: Swift.UnsafePointer<U>) {
    self._rawValue = from._rawValue
  }
  @usableFromInline
  @_transparent internal init?<U>(@_nonEphemeral _ from: Swift.UnsafePointer<U>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
  public typealias Stride = Swift.Int
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.UnsafeMutableRawPointer {
  @_transparent public init<T>(@_nonEphemeral _ other: Swift.AutoreleasingUnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }
  @_transparent public init?<T>(@_nonEphemeral _ other: Swift.AutoreleasingUnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped)
  }
}
extension Swift.UnsafeRawPointer {
  @_transparent public init<T>(@_nonEphemeral _ other: Swift.AutoreleasingUnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }
  @_transparent public init?<T>(@_nonEphemeral _ other: Swift.AutoreleasingUnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped)
  }
}
@available(*, unavailable)
extension Swift.AutoreleasingUnsafeMutablePointer : Swift.Sendable {
}
@_transparent public func _getObjCTypeEncoding<T>(_ type: T.Type) -> Swift.UnsafePointer<Swift.Int8> {
   
   
   
  return UnsafePointer(Builtin.getObjCTypeEncoding(type))
}
@usableFromInline
@frozen internal struct _BridgeStorage<NativeClass> where NativeClass : AnyObject {
  @usableFromInline
  internal typealias Native = NativeClass
  @usableFromInline
  internal typealias ObjC = Swift.AnyObject
  @usableFromInline
  internal var rawValue: Builtin.BridgeObject
  @inlinable @inline(__always) internal init(native: Swift._BridgeStorage<NativeClass>.Native, isFlagged flag: Swift.Bool) {
     
     

    _internalInvariant(_usesNativeSwiftReferenceCounting(NativeClass.self))

    rawValue = _makeNativeBridgeObject(
      native,
      flag ? (1 as UInt) << _objectPointerLowSpareBitShift : 0)
  }
  @inlinable @inline(__always) internal init(objC: Swift._BridgeStorage<NativeClass>.ObjC) {
    _internalInvariant(_usesNativeSwiftReferenceCounting(NativeClass.self))
    rawValue = _makeObjCBridgeObject(objC)
  }
  @inlinable @inline(__always) internal init(native: Swift._BridgeStorage<NativeClass>.Native) {
    _internalInvariant(_usesNativeSwiftReferenceCounting(NativeClass.self))
    rawValue = Builtin.reinterpretCast(native)
  }
  @inlinable @inline(__always) internal init(taggedPayload: Swift.UInt) {
    rawValue = _bridgeObject(taggingPayload: taggedPayload)
  }
  @inlinable @inline(__always) internal mutating func isUniquelyReferencedNative() -> Swift.Bool {
    return isNative && _isUnique(&rawValue)
  }
  @_alwaysEmitIntoClient @inline(__always) internal mutating func beginCOWMutationNative() -> Swift.Bool {
    return Bool(Builtin.beginCOWMutation(&rawValue))
  }
  @inlinable internal var isNative: Swift.Bool {
    @inline(__always) get {
      let result = Builtin.classifyBridgeObject(rawValue)
      return !Bool(Builtin.or_Int1(result.isObjCObject,
                                   result.isObjCTaggedPointer))
    }
  }
  @inlinable internal static var flagMask: Swift.UInt {
    @inline(__always) get {
      return (1 as UInt) << _objectPointerLowSpareBitShift
    }
  }
  @inlinable internal var isUnflaggedNative: Swift.Bool {
    @inline(__always) get {
      return (_bitPattern(rawValue) &
        (_bridgeObjectTaggedPointerBits | _objCTaggedPointerBits |
          _objectPointerIsObjCBit | _BridgeStorage.flagMask)) == 0
    }
  }
  @inlinable internal var isObjC: Swift.Bool {
    @inline(__always) get {
      return !isNative
    }
  }
  @inlinable internal var nativeInstance: Swift._BridgeStorage<NativeClass>.Native {
    @inline(__always) get {
      _internalInvariant(isNative)
      return Builtin.castReferenceFromBridgeObject(rawValue)
    }
  }
  @inlinable internal var unflaggedNativeInstance: Swift._BridgeStorage<NativeClass>.Native {
    @inline(__always) get {
      _internalInvariant(isNative)
      _internalInvariant(_nonPointerBits(rawValue) == 0)
      return Builtin.reinterpretCast(rawValue)
    }
  }
  @inlinable @inline(__always) internal mutating func isUniquelyReferencedUnflaggedNative() -> Swift.Bool {
    _internalInvariant(isNative)
    return _isUnique_native(&rawValue)
  }
  @_alwaysEmitIntoClient @inline(__always) internal mutating func beginCOWMutationUnflaggedNative() -> Swift.Bool {
    _internalInvariant(isNative)
    return Bool(Builtin.beginCOWMutation_native(&rawValue))
  }
  @_alwaysEmitIntoClient @inline(__always) internal mutating func endCOWMutation() {
    _internalInvariant(isNative)
    Builtin.endCOWMutation(&rawValue)
  }
  @inlinable internal var objCInstance: Swift._BridgeStorage<NativeClass>.ObjC {
    @inline(__always) get {
      _internalInvariant(isObjC)
      return Builtin.castReferenceFromBridgeObject(rawValue)
    }
  }
}
@inlinable @inline(__always) internal func _roundUpImpl(_ offset: Swift.UInt, toAlignment alignment: Swift.Int) -> Swift.UInt {
  _internalInvariant(alignment > 0)
  _internalInvariant(_isPowerOf2(alignment))
   
   
  let x = offset + UInt(bitPattern: alignment) &- 1
   
   
  return x & ~(UInt(bitPattern: alignment) &- 1)
}
@inlinable internal func _roundUp(_ offset: Swift.UInt, toAlignment alignment: Swift.Int) -> Swift.UInt {
  return _roundUpImpl(offset, toAlignment: alignment)
}
@inlinable internal func _roundUp(_ offset: Swift.Int, toAlignment alignment: Swift.Int) -> Swift.Int {
  _internalInvariant(offset >= 0)
  let offset = UInt(bitPattern: offset)
  let result = Int(bitPattern: _roundUpImpl(offset, toAlignment: alignment))
  _internalInvariant(result >= 0)
  return result
}
@_transparent public func _canBeClass<T>(_: T.Type) -> Swift.Int8 {
  return Int8(Builtin.canBeClass(T.self))
}
@inlinable @_transparent public func unsafeBitCast<T, U>(_ x: T, to type: U.Type) -> U {
  _precondition(MemoryLayout<T>.size == MemoryLayout<U>.size,
    "Can't unsafeBitCast between types of different sizes")
  return Builtin.reinterpretCast(x)
}
@_transparent public func _identityCast<T, U>(_ x: T, to expectedType: U.Type) -> U {
  _precondition(T.self == expectedType, "_identityCast to wrong type")
  return Builtin.reinterpretCast(x)
}
@_alwaysEmitIntoClient @_transparent public func _specialize<T, U>(_ x: T, for: U.Type) -> U? {
  guard T.self == U.self else {
    return nil
  }

  let result: U = Builtin.reinterpretCast(x)
  return result
}
@usableFromInline
@_transparent internal func _reinterpretCastToAnyObject<T>(_ x: T) -> Swift.AnyObject {
  return unsafeBitCast(x, to: AnyObject.self)
}
@usableFromInline
@_transparent internal func == (lhs: Builtin.NativeObject, rhs: Builtin.NativeObject) -> Swift.Bool {
  return unsafeBitCast(lhs, to: Int.self) == unsafeBitCast(rhs, to: Int.self)
}
@usableFromInline
@_transparent internal func != (lhs: Builtin.NativeObject, rhs: Builtin.NativeObject) -> Swift.Bool {
  return !(lhs == rhs)
}
@usableFromInline
@_transparent internal func == (lhs: Builtin.RawPointer, rhs: Builtin.RawPointer) -> Swift.Bool {
  return unsafeBitCast(lhs, to: Int.self) == unsafeBitCast(rhs, to: Int.self)
}
@usableFromInline
@_transparent internal func != (lhs: Builtin.RawPointer, rhs: Builtin.RawPointer) -> Swift.Bool {
  return !(lhs == rhs)
}
@inlinable @_transparent public func == (t0: (any Any.Type)?, t1: (any Any.Type)?) -> Swift.Bool {
  switch (t0, t1) {
  case (.none, .none): return true
  case let (.some(ty0), .some(ty1)):
    return Bool(Builtin.is_same_metatype(ty0, ty1))
  default: return false
  }
}
@inlinable @_transparent public func != (t0: (any Any.Type)?, t1: (any Any.Type)?) -> Swift.Bool {
  return !(t0 == t1)
}
@usableFromInline
@_transparent internal func _unreachable(_ condition: Swift.Bool = true) {
  if condition {
     
     
    Builtin.unreachable()
  }
}
@usableFromInline
@_transparent internal func _conditionallyUnreachable() -> Swift.Never {
  Builtin.conditionallyUnreachable()
}
@usableFromInline
@_silgen_name("_swift_isClassOrObjCExistentialType")
internal func _swift_isClassOrObjCExistentialType<T>(_ x: T.Type) -> Swift.Bool
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@usableFromInline
@_silgen_name("_swift_setClassMetadata")
internal func _swift_setClassMetadata<T>(_ x: T.Type, onObject: Swift.AnyObject) -> Swift.Bool
@inlinable @inline(__always) internal func _isClassOrObjCExistential<T>(_ x: T.Type) -> Swift.Bool {

  switch _canBeClass(x) {
   
  case 0:
    return false
   
  case 1:
    return true
   
  default:
    return _swift_isClassOrObjCExistentialType(x)
  }
}
@_transparent public func _unsafeReferenceCast<T, U>(_ x: T, to: U.Type) -> U {
  return Builtin.castReference(x)
}
@_transparent public func unsafeDowncast<T>(_ x: Swift.AnyObject, to type: T.Type) -> T where T : AnyObject {
  _debugPrecondition(x is T, "invalid unsafeDowncast")
  return Builtin.castReference(x)
}
@_transparent public func _unsafeUncheckedDowncast<T>(_ x: Swift.AnyObject, to type: T.Type) -> T where T : AnyObject {
  _internalInvariant(x is T, "invalid unsafeDowncast")
  return Builtin.castReference(x)
}
@inlinable @inline(__always) public func _getUnsafePointerToStoredProperties(_ x: Swift.AnyObject) -> Swift.UnsafeMutableRawPointer {
  let storedPropertyOffset = _roundUp(
    MemoryLayout<SwiftShims.HeapObject>.size,
    toAlignment: MemoryLayout<Optional<AnyObject>>.alignment)
  return UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(x)) +
    storedPropertyOffset
}
@inlinable @inline(__always) internal func _minAllocationAlignment() -> Swift.Int {
  return _swift_MinAllocationAlignment
}
@_transparent @_semantics("fastpath") public func _fastPath(_ x: Swift.Bool) -> Swift.Bool {
  return Bool(Builtin.int_expect_Int1(x._value, true._value))
}
@_transparent @_semantics("slowpath") public func _slowPath(_ x: Swift.Bool) -> Swift.Bool {
  return Bool(Builtin.int_expect_Int1(x._value, false._value))
}
@_transparent public func _onFastPath() {
  Builtin.onFastPath()
}
@usableFromInline
@_transparent internal func _uncheckedUnsafeAssume(_ condition: Swift.Bool) {
  _ = Builtin.assume_Int1(condition._value)
}
@usableFromInline
@_silgen_name("_swift_objcClassUsesNativeSwiftReferenceCounting")
internal func _usesNativeSwiftReferenceCounting(_ theClass: Swift.AnyClass) -> Swift.Bool
@usableFromInline
@_silgen_name("_swift_getSwiftClassInstanceExtents")
internal func getSwiftClassInstanceExtents(_ theClass: Swift.AnyClass) -> (negative: Swift.UInt, positive: Swift.UInt)
@usableFromInline
@_silgen_name("_swift_getObjCClassInstanceExtents")
internal func getObjCClassInstanceExtents(_ theClass: Swift.AnyClass) -> (negative: Swift.UInt, positive: Swift.UInt)
@inlinable @inline(__always) internal func _class_getInstancePositiveExtentSize(_ theClass: Swift.AnyClass) -> Swift.Int {
  return Int(getObjCClassInstanceExtents(theClass).positive)
}
@inlinable internal func _isValidAddress(_ address: Swift.UInt) -> Swift.Bool {
   
  return address >= _swift_abi_LeastValidPointerValue
}
@inlinable internal var _bridgeObjectTaggedPointerBits: Swift.UInt {
  @inline(__always) get { return UInt(_swift_BridgeObject_TaggedPointerBits) }
}
@inlinable internal var _objCTaggedPointerBits: Swift.UInt {
  @inline(__always) get { return UInt(_swift_abi_ObjCReservedBitsMask) }
}
@inlinable internal var _objectPointerSpareBits: Swift.UInt {
  @inline(__always) get {
      return UInt(_swift_abi_SwiftSpareBitsMask) & ~_bridgeObjectTaggedPointerBits
    }
}
@inlinable internal var _objectPointerLowSpareBitShift: Swift.UInt {
  @inline(__always) get {
      _internalInvariant(_swift_abi_ObjCReservedLowBits < 2,
        "num bits now differs from num-shift-amount, new platform?")
      return UInt(_swift_abi_ObjCReservedLowBits)
    }
}
@inlinable internal var _objectPointerIsObjCBit: Swift.UInt {
  @inline(__always) get {
    return 0x4000_0000_0000_0000
  }
}
@inlinable @inline(__always) internal func _bitPattern(_ x: Builtin.BridgeObject) -> Swift.UInt {
  return UInt(Builtin.castBitPatternFromBridgeObject(x))
}
@inlinable @inline(__always) internal func _nonPointerBits(_ x: Builtin.BridgeObject) -> Swift.UInt {
  return _bitPattern(x) & _objectPointerSpareBits
}
@inlinable @inline(__always) internal func _isObjCTaggedPointer(_ x: Swift.AnyObject) -> Swift.Bool {
  return (Builtin.reinterpretCast(x) & _objCTaggedPointerBits) != 0
}
@inlinable @inline(__always) internal func _isObjCTaggedPointer(_ x: Swift.UInt) -> Swift.Bool {
  return (x & _objCTaggedPointerBits) != 0
}
@inlinable @inline(__always) public func _isTaggedObject(_ x: Builtin.BridgeObject) -> Swift.Bool {
  return _bitPattern(x) & _bridgeObjectTaggedPointerBits != 0
}
@inlinable @inline(__always) public func _isNativePointer(_ x: Builtin.BridgeObject) -> Swift.Bool {
  return (
    _bitPattern(x) & (_bridgeObjectTaggedPointerBits | _objectPointerIsObjCBit)
  ) == 0
}
@inlinable @inline(__always) public func _isNonTaggedObjCPointer(_ x: Builtin.BridgeObject) -> Swift.Bool {
  return !_isTaggedObject(x) && !_isNativePointer(x)
}
@inlinable @inline(__always) internal func _getNonTagBits(_ x: Builtin.BridgeObject) -> Swift.UInt {
   
  _internalInvariant(_isTaggedObject(x), "not tagged!")
  return (_bitPattern(x) & ~_bridgeObjectTaggedPointerBits)
    >> _objectPointerLowSpareBitShift
}
@inline(__always) @inlinable public func _bridgeObject(fromNative x: Swift.AnyObject) -> Builtin.BridgeObject {
  _internalInvariant(!_isObjCTaggedPointer(x))
  let object = Builtin.castToBridgeObject(x, 0._builtinWordValue)
  _internalInvariant(_isNativePointer(object))
  return object
}
@inline(__always) @inlinable public func _bridgeObject(fromNonTaggedObjC x: Swift.AnyObject) -> Builtin.BridgeObject {
  _internalInvariant(!_isObjCTaggedPointer(x))
  let object = _makeObjCBridgeObject(x)
  _internalInvariant(_isNonTaggedObjCPointer(object))
  return object
}
@inline(__always) @inlinable public func _bridgeObject(fromTagged x: Swift.UInt) -> Builtin.BridgeObject {
  _internalInvariant(x & _bridgeObjectTaggedPointerBits != 0)
  let object: Builtin.BridgeObject = Builtin.valueToBridgeObject(x._value)
  _internalInvariant(_isTaggedObject(object))
  return object
}
@inline(__always) @inlinable public func _bridgeObject(taggingPayload x: Swift.UInt) -> Builtin.BridgeObject {
  let shifted = x &<< _objectPointerLowSpareBitShift
  _internalInvariant(x == (shifted &>> _objectPointerLowSpareBitShift),
    "out-of-range: limited bit range requires some zero top bits")
  _internalInvariant(shifted & _bridgeObjectTaggedPointerBits == 0,
    "out-of-range: post-shift use of tag bits")
  return _bridgeObject(fromTagged: shifted | _bridgeObjectTaggedPointerBits)
}
@inline(__always) @inlinable public func _bridgeObject(toNative x: Builtin.BridgeObject) -> Swift.AnyObject {
  _internalInvariant(_isNativePointer(x))
  return Builtin.castReferenceFromBridgeObject(x)
}
@inline(__always) @inlinable public func _bridgeObject(toNonTaggedObjC x: Builtin.BridgeObject) -> Swift.AnyObject {
  _internalInvariant(_isNonTaggedObjCPointer(x))
  return Builtin.castReferenceFromBridgeObject(x)
}
@inline(__always) @inlinable public func _bridgeObject(toTagged x: Builtin.BridgeObject) -> Swift.UInt {
  _internalInvariant(_isTaggedObject(x))
  let bits = _bitPattern(x)
  _internalInvariant(bits & _bridgeObjectTaggedPointerBits != 0)
  return bits
}
@inline(__always) @inlinable public func _bridgeObject(toTagPayload x: Builtin.BridgeObject) -> Swift.UInt {
  return _getNonTagBits(x)
}
@inline(__always) @inlinable public func _bridgeObject(fromNativeObject x: Builtin.NativeObject) -> Builtin.BridgeObject {
  return _bridgeObject(fromNative: _nativeObject(toNative: x))
}
@inlinable @inline(__always) public func _nativeObject(fromNative x: Swift.AnyObject) -> Builtin.NativeObject {
  _internalInvariant(!_isObjCTaggedPointer(x))
  let native = Builtin.unsafeCastToNativeObject(x)
   
  return native
}
@inlinable @inline(__always) public func _nativeObject(fromBridge x: Builtin.BridgeObject) -> Builtin.NativeObject {
  return _nativeObject(fromNative: _bridgeObject(toNative: x))
}
@inlinable @inline(__always) public func _nativeObject(toNative x: Builtin.NativeObject) -> Swift.AnyObject {
  return Builtin.castFromNativeObject(x)
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.ManagedBufferPointer {
  @inline(__always) @inlinable public init(_nativeObject buffer: Builtin.NativeObject) {
    self._nativeBuffer = buffer
  }
}
#else
extension Swift.ManagedBufferPointer {
  @inline(__always) @inlinable public init(_nativeObject buffer: Builtin.NativeObject) {
    self._nativeBuffer = buffer
  }
}
#endif
@inlinable @inline(__always) internal func _makeNativeBridgeObject(_ nativeObject: Swift.AnyObject, _ bits: Swift.UInt) -> Builtin.BridgeObject {
  _internalInvariant(
    (bits & _objectPointerIsObjCBit) == 0,
    "BridgeObject is treated as non-native when ObjC bit is set"
  )
  return _makeBridgeObject(nativeObject, bits)
}
@inlinable @inline(__always) public func _makeObjCBridgeObject(_ objCObject: Swift.AnyObject) -> Builtin.BridgeObject {
  return _makeBridgeObject(
    objCObject,
    _isObjCTaggedPointer(objCObject) ? 0 : _objectPointerIsObjCBit)
}
@inlinable @inline(__always) internal func _makeBridgeObject(_ object: Swift.AnyObject, _ bits: Swift.UInt) -> Builtin.BridgeObject {
  _internalInvariant(!_isObjCTaggedPointer(object) || bits == 0,
    "Tagged pointers cannot be combined with bits")

  _internalInvariant(
    _isObjCTaggedPointer(object)
    || _usesNativeSwiftReferenceCounting(type(of: object))
    || bits == _objectPointerIsObjCBit,
    "All spare bits must be set in non-native, non-tagged bridge objects"
  )

  _internalInvariant(
    bits & _objectPointerSpareBits == bits,
    "Can't store non-spare bits into Builtin.BridgeObject")

  return Builtin.castToBridgeObject(
    object, bits._builtinWordValue
  )
}
public func _getSuperclass(_ t: Swift.AnyClass) -> Swift.AnyClass?
@inlinable @inline(__always) public func _getSuperclass(_ t: any Any.Type) -> Swift.AnyClass? {
  return (t as? AnyClass).flatMap { _getSuperclass($0) }
}
@usableFromInline
@_transparent internal func _isUnique<T>(_ object: inout T) -> Swift.Bool {
  return Bool(Builtin.isUnique(&object))
}
@_transparent public func _isUnique_native<T>(_ object: inout T) -> Swift.Bool {
   
   
   
  #if !$Embedded
  _internalInvariant(
    (_bitPattern(Builtin.reinterpretCast(object)) & _objectPointerSpareBits)
    == 0)
  #endif
  _internalInvariant(_usesNativeSwiftReferenceCounting(
      type(of: Builtin.reinterpretCast(object) as AnyObject)))
  return Bool(Builtin.isUnique_native(&object))
}
@_alwaysEmitIntoClient @_transparent public func _COWBufferForReading<T>(_ object: T) -> T where T : AnyObject {
  return Builtin.COWBufferForReading(object)
}
@_transparent public func _isPOD<T>(_ type: T.Type) -> Swift.Bool {
  return Bool(Builtin.ispod(type))
}
@_alwaysEmitIntoClient @_transparent public func _isConcrete<T>(_ type: T.Type) -> Swift.Bool {
  return Bool(Builtin.isConcrete(type))
}
@_transparent public func _isBitwiseTakable<T>(_ type: T.Type) -> Swift.Bool {
  return Bool(Builtin.isbitwisetakable(type))
}
@_transparent public func _isOptional<T>(_ type: T.Type) -> Swift.Bool {
  return Bool(Builtin.isOptional(type))
}
@_alwaysEmitIntoClient @inline(__always) internal func _isComputed(_ value: Swift.Int) -> Swift.Bool {
  return !Bool(Builtin.int_is_constant_Word(value._builtinWordValue))
}
@inlinable internal func _unsafeDowncastToAnyObject(fromAny any: Any) -> Swift.AnyObject {
  _internalInvariant(type(of: any) is AnyObject.Type
               || type(of: any) is AnyObject.Protocol,
               "Any expected to contain object reference")
   
   
   
   
   
   
   
   
   
   
   
   
  return any as AnyObject
}
@inlinable @inline(__always) public func _trueAfterDiagnostics() -> Builtin.Int1 {
  return true._value
}
@_transparent @_semantics("typechecker.type(of:)") public func type<T, Metatype>(of value: T) -> Metatype {
   
   
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: 'type(of:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}
#if compiler(>=5.3) && $TypedThrows
@_alwaysEmitIntoClient @_transparent @_semantics("typechecker.withoutActuallyEscaping(_:do:)") public func withoutActuallyEscaping<ClosureType, ResultType, Failure>(_ closure: ClosureType, do body: (_ escapingClosure: ClosureType) throws(Failure) -> ResultType) throws(Failure) -> ResultType where Failure : Swift.Error {
   
   
   
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: 'withoutActuallyEscaping(_:do:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}
#endif
@_silgen_name("$ss23withoutActuallyEscaping_2doq_x_q_xKXEtKr0_lF")
@usableFromInline
internal func __abi_withoutActuallyEscaping<ClosureType, ResultType>(_ closure: ClosureType, do body: (_ escapingClosure: ClosureType) throws -> ResultType) throws -> ResultType
#if compiler(>=5.3) && $TypedThrows
@_alwaysEmitIntoClient @_transparent @_semantics("typechecker._openExistential(_:do:)") public func _openExistential<ExistentialType, ContainedType, ResultType, Failure>(_ existential: ExistentialType, do body: (_ escapingClosure: ContainedType) throws(Failure) -> ResultType) throws(Failure) -> ResultType where Failure : Swift.Error {
   
   
   
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: '_openExistential(_:do:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}
#endif
@usableFromInline
@_silgen_name("$ss16_openExistential_2doq0_x_q0_q_KXEtKr1_lF")
internal func __abi_openExistential<ExistentialType, ContainedType, ResultType>(_ existential: ExistentialType, do body: (_ escapingClosure: ContainedType) throws -> ResultType) throws -> ResultType
@_transparent @_alwaysEmitIntoClient public func _getGlobalStringTablePointer(_ constant: Swift.String) -> Swift.UnsafePointer<Swift.CChar> {
  return UnsafePointer<CChar>(Builtin.globalStringTablePointer(constant));
}
@_transparent @_alwaysEmitIntoClient public func _allocateVector<Element>(elementType: Element.Type, capacity: Swift.Int) -> Swift.UnsafeMutablePointer<Element> {
#if $BuiltinAllocVector
  return UnsafeMutablePointer(Builtin.allocVector(elementType, capacity._builtinWordValue))
#else
  fatalError("unsupported compiler")
#endif
}
@_transparent public func _cos(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_cos_FPIEEE32(x._value))
}
@_transparent public func _sin(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_sin_FPIEEE32(x._value))
}
@_transparent public func _exp(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_exp_FPIEEE32(x._value))
}
@_transparent public func _exp2(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_exp2_FPIEEE32(x._value))
}
@_transparent public func _log(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_log_FPIEEE32(x._value))
}
@_transparent public func _log10(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_log10_FPIEEE32(x._value))
}
@_transparent public func _log2(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_log2_FPIEEE32(x._value))
}
@_transparent public func _nearbyint(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_nearbyint_FPIEEE32(x._value))
}
@_transparent public func _rint(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_rint_FPIEEE32(x._value))
}
@_transparent public func _cos(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_cos_FPIEEE64(x._value))
}
@_transparent public func _sin(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_sin_FPIEEE64(x._value))
}
@_transparent public func _exp(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_exp_FPIEEE64(x._value))
}
@_transparent public func _exp2(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_exp2_FPIEEE64(x._value))
}
@_transparent public func _log(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_log_FPIEEE64(x._value))
}
@_transparent public func _log10(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_log10_FPIEEE64(x._value))
}
@_transparent public func _log2(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_log2_FPIEEE64(x._value))
}
@_transparent public func _nearbyint(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_nearbyint_FPIEEE64(x._value))
}
@_transparent public func _rint(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_rint_FPIEEE64(x._value))
}
@frozen public struct Character : Swift.Sendable {
  @usableFromInline
  internal var _str: Swift.String
  @inlinable @inline(__always) internal init(unchecked str: Swift.String) {
    self._str = str
    _invariantCheck()
  }
}
extension Swift.Character {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension Swift.Character {
  public typealias UTF8View = Swift.String.UTF8View
  @inlinable public var utf8: Swift.Character.UTF8View {
    get { return _str.utf8 }
  }
  public typealias UTF16View = Swift.String.UTF16View
  @inlinable public var utf16: Swift.Character.UTF16View {
    get { return _str.utf16 }
  }
  public typealias UnicodeScalarView = Swift.String.UnicodeScalarView
  @inlinable public var unicodeScalars: Swift.Character.UnicodeScalarView {
    get { return _str.unicodeScalars }
  }
}
extension Swift.Character : Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral, Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  @inlinable @inline(__always) public init(_ content: Swift.Unicode.Scalar) {
    self.init(unchecked: String(content))
  }
  @inlinable @inline(__always) @_effects(readonly) public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self.init(Unicode.Scalar(_builtinUnicodeScalarLiteral: value))
  }
  @inlinable @inline(__always) @_effects(readonly) public init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    self.init(unchecked: String(
      _builtinExtendedGraphemeClusterLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII))
  }
  @inlinable @inline(__always) public init(extendedGraphemeClusterLiteral value: Swift.Character) {
    self.init(unchecked: value._str)
  }
  @inlinable @inline(__always) public init(_ s: Swift.String) {
    _precondition(!s.isEmpty,
      "Can't form a Character from an empty String")
    _debugPrecondition(s.index(after: s.startIndex) == s.endIndex,
      "Can't form a Character from a String containing more than one extended grapheme cluster")

    if _fastPath(s._guts._object.isPreferredRepresentation) {
      self.init(unchecked: s)
      return
    }
    self.init(unchecked: String._copying(s))
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.Character
  public typealias UnicodeScalarLiteralType = Swift.Character
}
extension Swift.Character : Swift.CustomStringConvertible {
  @inlinable public var description: Swift.String {
    get {
   return _str
 }
  }
}
extension Swift.Character : Swift.LosslessStringConvertible {
}
extension Swift.Character : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.String {
  @inlinable @inline(__always) public init(_ c: Swift.Character) {
    self.init(c._str._guts)
  }
}
extension Swift.Character : Swift.Equatable {
  @inlinable @inline(__always) @_effects(readonly) public static func == (lhs: Swift.Character, rhs: Swift.Character) -> Swift.Bool {
    return lhs._str == rhs._str
  }
}
extension Swift.Character : Swift.Comparable {
  @inlinable @inline(__always) @_effects(readonly) public static func < (lhs: Swift.Character, rhs: Swift.Character) -> Swift.Bool {
    return lhs._str < rhs._str
  }
}
extension Swift.Character : Swift.Hashable {
  @_effects(releasenone) public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Character {
  @usableFromInline
  internal var _isSmall: Swift.Bool {
    get
  }
}
@usableFromInline
@frozen internal struct _CocoaArrayWrapper : Swift.RandomAccessCollection {
  @usableFromInline
  internal typealias Indices = Swift.Range<Swift.Int>
  @usableFromInline
  internal var buffer: Swift.AnyObject
  @usableFromInline
  @_transparent internal init(_ buffer: Swift.AnyObject) {
    self.buffer = buffer
  }
  @inlinable internal var startIndex: Swift.Int {
    get {
    return 0
  }
  }
  @usableFromInline
  internal var endIndex: Swift.Int {
    get
  }
  @usableFromInline
  internal subscript(i: Swift.Int) -> Swift.AnyObject {
    get
  }
  @usableFromInline
  internal subscript(bounds: Swift.Range<Swift.Int>) -> Swift._SliceBuffer<Swift.AnyObject> {
    get
  }
  @usableFromInline
  internal __consuming func _copyContents(subRange bounds: Swift.Range<Swift.Int>, initializing target: Swift.UnsafeMutablePointer<Swift.AnyObject>) -> Swift.UnsafeMutablePointer<Swift.AnyObject>
  @_alwaysEmitIntoClient internal __consuming func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Swift._CocoaArrayWrapper.Element>) -> (Swift._CocoaArrayWrapper.Iterator, Swift.UnsafeMutableBufferPointer<Swift._CocoaArrayWrapper.Element>.Index) {
    guard buffer.count > 0 else { return (makeIterator(), 0) }
    let start = buffer.baseAddress!
    let c = Swift.min(self.count, buffer.count)
    _ = _copyContents(subRange: 0 ..< c, initializing: start)
    return (IndexingIterator(_elements: self, _position: c), c)
  }
  @usableFromInline
  internal typealias Element = Swift.AnyObject
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._CocoaArrayWrapper>
  @usableFromInline
  internal typealias SubSequence = Swift._SliceBuffer<Swift.AnyObject>
}
@available(*, unavailable)
extension Swift._CocoaArrayWrapper : Swift.Sendable {
}
public protocol Encodable {
  func encode(to encoder: any Swift.Encoder) throws
}
public protocol Decodable {
  init(from decoder: any Swift.Decoder) throws
}
public typealias Codable = Swift.Decodable & Swift.Encodable
public protocol CodingKey : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.Sendable {
  var stringValue: Swift.String { get }
  init?(stringValue: Swift.String)
  var intValue: Swift.Int? { get }
  init?(intValue: Swift.Int)
}
extension Swift.CodingKey {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
public protocol Encoder {
  var codingPath: [any Swift.CodingKey] { get }
  var userInfo: [Swift.CodingUserInfoKey : Any] { get }
  func container<Key>(keyedBy type: Key.Type) -> Swift.KeyedEncodingContainer<Key> where Key : Swift.CodingKey
  func unkeyedContainer() -> any Swift.UnkeyedEncodingContainer
  func singleValueContainer() -> any Swift.SingleValueEncodingContainer
}
public protocol Decoder {
  var codingPath: [any Swift.CodingKey] { get }
  var userInfo: [Swift.CodingUserInfoKey : Any] { get }
  func container<Key>(keyedBy type: Key.Type) throws -> Swift.KeyedDecodingContainer<Key> where Key : Swift.CodingKey
  func unkeyedContainer() throws -> any Swift.UnkeyedDecodingContainer
  func singleValueContainer() throws -> any Swift.SingleValueDecodingContainer
}
public protocol KeyedEncodingContainerProtocol {
  associatedtype Key : Swift.CodingKey
  var codingPath: [any Swift.CodingKey] { get }
  mutating func encodeNil(forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Bool, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.String, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Double, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Float, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Int, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Int8, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Int16, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Int32, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Int64, forKey key: Self.Key) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func encode(_ value: Swift.Int128, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.UInt, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.UInt8, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.UInt16, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.UInt32, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.UInt64, forKey key: Self.Key) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func encode(_ value: Swift.UInt128, forKey key: Self.Key) throws
  mutating func encode<T>(_ value: T, forKey key: Self.Key) throws where T : Swift.Encodable
  mutating func encodeConditional<T>(_ object: T, forKey key: Self.Key) throws where T : AnyObject, T : Swift.Encodable
  mutating func encodeIfPresent(_ value: Swift.Bool?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.String?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Double?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Float?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Int?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Int8?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Int16?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Int32?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Int64?, forKey key: Self.Key) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func encodeIfPresent(_ value: Swift.Int128?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.UInt?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.UInt8?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.UInt16?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.UInt32?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.UInt64?, forKey key: Self.Key) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func encodeIfPresent(_ value: Swift.UInt128?, forKey key: Self.Key) throws
  mutating func encodeIfPresent<T>(_ value: T?, forKey key: Self.Key) throws where T : Swift.Encodable
  mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: Self.Key) -> Swift.KeyedEncodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  mutating func nestedUnkeyedContainer(forKey key: Self.Key) -> any Swift.UnkeyedEncodingContainer
  mutating func superEncoder() -> any Swift.Encoder
  mutating func superEncoder(forKey key: Self.Key) -> any Swift.Encoder
}
public struct KeyedEncodingContainer<K> : Swift.KeyedEncodingContainerProtocol where K : Swift.CodingKey {
  public typealias Key = K
  public init<Container>(_ container: Container) where K == Container.Key, Container : Swift.KeyedEncodingContainerProtocol
  public var codingPath: [any Swift.CodingKey] {
    get
  }
  public mutating func encodeNil(forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Bool, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.String, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Double, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Float, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Int, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Int8, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Int16, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Int32, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Int64, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encode(_ value: Swift.Int128, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.UInt, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.UInt8, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.UInt16, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.UInt32, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.UInt64, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encode(_ value: Swift.UInt128, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode<T>(_ value: T, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws where T : Swift.Encodable
  public mutating func encodeConditional<T>(_ object: T, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws where T : AnyObject, T : Swift.Encodable
  public mutating func encodeIfPresent(_ value: Swift.Bool?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.String?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Double?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Float?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int8?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int16?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int32?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int64?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encodeIfPresent(_ value: Swift.Int128?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt8?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt16?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt32?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt64?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encodeIfPresent(_ value: Swift.UInt128?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent<T>(_ value: T?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws where T : Swift.Encodable
  public mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: Swift.KeyedEncodingContainer<K>.Key) -> Swift.KeyedEncodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  public mutating func nestedUnkeyedContainer(forKey key: Swift.KeyedEncodingContainer<K>.Key) -> any Swift.UnkeyedEncodingContainer
  public mutating func superEncoder() -> any Swift.Encoder
  public mutating func superEncoder(forKey key: Swift.KeyedEncodingContainer<K>.Key) -> any Swift.Encoder
}
@available(*, unavailable)
extension Swift.KeyedEncodingContainer : Swift.Sendable {
}
public protocol KeyedDecodingContainerProtocol {
  associatedtype Key : Swift.CodingKey
  var codingPath: [any Swift.CodingKey] { get }
  var allKeys: [Self.Key] { get }
  func contains(_ key: Self.Key) -> Swift.Bool
  func decodeNil(forKey key: Self.Key) throws -> Swift.Bool
  func decode(_ type: Swift.Bool.Type, forKey key: Self.Key) throws -> Swift.Bool
  func decode(_ type: Swift.String.Type, forKey key: Self.Key) throws -> Swift.String
  func decode(_ type: Swift.Double.Type, forKey key: Self.Key) throws -> Swift.Double
  func decode(_ type: Swift.Float.Type, forKey key: Self.Key) throws -> Swift.Float
  func decode(_ type: Swift.Int.Type, forKey key: Self.Key) throws -> Swift.Int
  func decode(_ type: Swift.Int8.Type, forKey key: Self.Key) throws -> Swift.Int8
  func decode(_ type: Swift.Int16.Type, forKey key: Self.Key) throws -> Swift.Int16
  func decode(_ type: Swift.Int32.Type, forKey key: Self.Key) throws -> Swift.Int32
  func decode(_ type: Swift.Int64.Type, forKey key: Self.Key) throws -> Swift.Int64
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  func decode(_ type: Swift.Int128.Type, forKey key: Self.Key) throws -> Swift.Int128
  func decode(_ type: Swift.UInt.Type, forKey key: Self.Key) throws -> Swift.UInt
  func decode(_ type: Swift.UInt8.Type, forKey key: Self.Key) throws -> Swift.UInt8
  func decode(_ type: Swift.UInt16.Type, forKey key: Self.Key) throws -> Swift.UInt16
  func decode(_ type: Swift.UInt32.Type, forKey key: Self.Key) throws -> Swift.UInt32
  func decode(_ type: Swift.UInt64.Type, forKey key: Self.Key) throws -> Swift.UInt64
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  func decode(_ type: Swift.UInt128.Type, forKey key: Self.Key) throws -> Swift.UInt128
  func decode<T>(_ type: T.Type, forKey key: Self.Key) throws -> T where T : Swift.Decodable
  func decodeIfPresent(_ type: Swift.Bool.Type, forKey key: Self.Key) throws -> Swift.Bool?
  func decodeIfPresent(_ type: Swift.String.Type, forKey key: Self.Key) throws -> Swift.String?
  func decodeIfPresent(_ type: Swift.Double.Type, forKey key: Self.Key) throws -> Swift.Double?
  func decodeIfPresent(_ type: Swift.Float.Type, forKey key: Self.Key) throws -> Swift.Float?
  func decodeIfPresent(_ type: Swift.Int.Type, forKey key: Self.Key) throws -> Swift.Int?
  func decodeIfPresent(_ type: Swift.Int8.Type, forKey key: Self.Key) throws -> Swift.Int8?
  func decodeIfPresent(_ type: Swift.Int16.Type, forKey key: Self.Key) throws -> Swift.Int16?
  func decodeIfPresent(_ type: Swift.Int32.Type, forKey key: Self.Key) throws -> Swift.Int32?
  func decodeIfPresent(_ type: Swift.Int64.Type, forKey key: Self.Key) throws -> Swift.Int64?
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  func decodeIfPresent(_ type: Swift.Int128.Type, forKey key: Self.Key) throws -> Swift.Int128?
  func decodeIfPresent(_ type: Swift.UInt.Type, forKey key: Self.Key) throws -> Swift.UInt?
  func decodeIfPresent(_ type: Swift.UInt8.Type, forKey key: Self.Key) throws -> Swift.UInt8?
  func decodeIfPresent(_ type: Swift.UInt16.Type, forKey key: Self.Key) throws -> Swift.UInt16?
  func decodeIfPresent(_ type: Swift.UInt32.Type, forKey key: Self.Key) throws -> Swift.UInt32?
  func decodeIfPresent(_ type: Swift.UInt64.Type, forKey key: Self.Key) throws -> Swift.UInt64?
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  func decodeIfPresent(_ type: Swift.UInt128.Type, forKey key: Self.Key) throws -> Swift.UInt128?
  func decodeIfPresent<T>(_ type: T.Type, forKey key: Self.Key) throws -> T? where T : Swift.Decodable
  func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Self.Key) throws -> Swift.KeyedDecodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  func nestedUnkeyedContainer(forKey key: Self.Key) throws -> any Swift.UnkeyedDecodingContainer
  func superDecoder() throws -> any Swift.Decoder
  func superDecoder(forKey key: Self.Key) throws -> any Swift.Decoder
}
public struct KeyedDecodingContainer<K> : Swift.KeyedDecodingContainerProtocol where K : Swift.CodingKey {
  public typealias Key = K
  public init<Container>(_ container: Container) where K == Container.Key, Container : Swift.KeyedDecodingContainerProtocol
  public var codingPath: [any Swift.CodingKey] {
    get
  }
  public var allKeys: [Swift.KeyedDecodingContainer<K>.Key] {
    get
  }
  public func contains(_ key: Swift.KeyedDecodingContainer<K>.Key) -> Swift.Bool
  public func decodeNil(forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Bool
  public func decode(_ type: Swift.Bool.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Bool
  public func decode(_ type: Swift.String.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.String
  public func decode(_ type: Swift.Double.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Double
  public func decode(_ type: Swift.Float.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Float
  public func decode(_ type: Swift.Int.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int
  public func decode(_ type: Swift.Int8.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int8
  public func decode(_ type: Swift.Int16.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int16
  public func decode(_ type: Swift.Int32.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int32
  public func decode(_ type: Swift.Int64.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int64
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func decode(_ type: Swift.Int128.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int128
  public func decode(_ type: Swift.UInt.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt
  public func decode(_ type: Swift.UInt8.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt8
  public func decode(_ type: Swift.UInt16.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt16
  public func decode(_ type: Swift.UInt32.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt32
  public func decode(_ type: Swift.UInt64.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt64
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func decode(_ type: Swift.UInt128.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt128
  public func decode<T>(_ type: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> T where T : Swift.Decodable
  public func decodeIfPresent(_ type: Swift.Bool.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Bool?
  public func decodeIfPresent(_ type: Swift.String.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.String?
  public func decodeIfPresent(_ type: Swift.Double.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Double?
  public func decodeIfPresent(_ type: Swift.Float.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Float?
  public func decodeIfPresent(_ type: Swift.Int.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int?
  public func decodeIfPresent(_ type: Swift.Int8.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int8?
  public func decodeIfPresent(_ type: Swift.Int16.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int16?
  public func decodeIfPresent(_ type: Swift.Int32.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int32?
  public func decodeIfPresent(_ type: Swift.Int64.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int64?
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func decodeIfPresent(_ type: Swift.Int128.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int128?
  public func decodeIfPresent(_ type: Swift.UInt.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt?
  public func decodeIfPresent(_ type: Swift.UInt8.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt8?
  public func decodeIfPresent(_ type: Swift.UInt16.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt16?
  public func decodeIfPresent(_ type: Swift.UInt32.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt32?
  public func decodeIfPresent(_ type: Swift.UInt64.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt64?
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func decodeIfPresent(_ type: Swift.UInt128.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt128?
  public func decodeIfPresent<T>(_ type: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> T? where T : Swift.Decodable
  public func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.KeyedDecodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  public func nestedUnkeyedContainer(forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> any Swift.UnkeyedDecodingContainer
  public func superDecoder() throws -> any Swift.Decoder
  public func superDecoder(forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> any Swift.Decoder
}
@available(*, unavailable)
extension Swift.KeyedDecodingContainer : Swift.Sendable {
}
public protocol UnkeyedEncodingContainer {
  var codingPath: [any Swift.CodingKey] { get }
  var count: Swift.Int { get }
  mutating func encodeNil() throws
  mutating func encode(_ value: Swift.Bool) throws
  mutating func encode(_ value: Swift.String) throws
  mutating func encode(_ value: Swift.Double) throws
  mutating func encode(_ value: Swift.Float) throws
  mutating func encode(_ value: Swift.Int) throws
  mutating func encode(_ value: Swift.Int8) throws
  mutating func encode(_ value: Swift.Int16) throws
  mutating func encode(_ value: Swift.Int32) throws
  mutating func encode(_ value: Swift.Int64) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func encode(_ value: Swift.Int128) throws
  mutating func encode(_ value: Swift.UInt) throws
  mutating func encode(_ value: Swift.UInt8) throws
  mutating func encode(_ value: Swift.UInt16) throws
  mutating func encode(_ value: Swift.UInt32) throws
  mutating func encode(_ value: Swift.UInt64) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func encode(_ value: Swift.UInt128) throws
  mutating func encode<T>(_ value: T) throws where T : Swift.Encodable
  mutating func encodeConditional<T>(_ object: T) throws where T : AnyObject, T : Swift.Encodable
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Bool
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.String
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Double
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Float
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int8
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int16
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int32
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int64
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int128
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt8
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt16
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt32
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt64
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt128
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element : Swift.Encodable
  mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type) -> Swift.KeyedEncodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  mutating func nestedUnkeyedContainer() -> any Swift.UnkeyedEncodingContainer
  mutating func superEncoder() -> any Swift.Encoder
}
public protocol UnkeyedDecodingContainer {
  var codingPath: [any Swift.CodingKey] { get }
  var count: Swift.Int? { get }
  var isAtEnd: Swift.Bool { get }
  var currentIndex: Swift.Int { get }
  mutating func decodeNil() throws -> Swift.Bool
  mutating func decode(_ type: Swift.Bool.Type) throws -> Swift.Bool
  mutating func decode(_ type: Swift.String.Type) throws -> Swift.String
  mutating func decode(_ type: Swift.Double.Type) throws -> Swift.Double
  mutating func decode(_ type: Swift.Float.Type) throws -> Swift.Float
  mutating func decode(_ type: Swift.Int.Type) throws -> Swift.Int
  mutating func decode(_ type: Swift.Int8.Type) throws -> Swift.Int8
  mutating func decode(_ type: Swift.Int16.Type) throws -> Swift.Int16
  mutating func decode(_ type: Swift.Int32.Type) throws -> Swift.Int32
  mutating func decode(_ type: Swift.Int64.Type) throws -> Swift.Int64
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func decode(_ type: Swift.Int128.Type) throws -> Swift.Int128
  mutating func decode(_ type: Swift.UInt.Type) throws -> Swift.UInt
  mutating func decode(_ type: Swift.UInt8.Type) throws -> Swift.UInt8
  mutating func decode(_ type: Swift.UInt16.Type) throws -> Swift.UInt16
  mutating func decode(_ type: Swift.UInt32.Type) throws -> Swift.UInt32
  mutating func decode(_ type: Swift.UInt64.Type) throws -> Swift.UInt64
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func decode(_ type: Swift.UInt128.Type) throws -> Swift.UInt128
  mutating func decode<T>(_ type: T.Type) throws -> T where T : Swift.Decodable
  mutating func decodeIfPresent(_ type: Swift.Bool.Type) throws -> Swift.Bool?
  mutating func decodeIfPresent(_ type: Swift.String.Type) throws -> Swift.String?
  mutating func decodeIfPresent(_ type: Swift.Double.Type) throws -> Swift.Double?
  mutating func decodeIfPresent(_ type: Swift.Float.Type) throws -> Swift.Float?
  mutating func decodeIfPresent(_ type: Swift.Int.Type) throws -> Swift.Int?
  mutating func decodeIfPresent(_ type: Swift.Int8.Type) throws -> Swift.Int8?
  mutating func decodeIfPresent(_ type: Swift.Int16.Type) throws -> Swift.Int16?
  mutating func decodeIfPresent(_ type: Swift.Int32.Type) throws -> Swift.Int32?
  mutating func decodeIfPresent(_ type: Swift.Int64.Type) throws -> Swift.Int64?
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func decodeIfPresent(_ type: Swift.Int128.Type) throws -> Swift.Int128?
  mutating func decodeIfPresent(_ type: Swift.UInt.Type) throws -> Swift.UInt?
  mutating func decodeIfPresent(_ type: Swift.UInt8.Type) throws -> Swift.UInt8?
  mutating func decodeIfPresent(_ type: Swift.UInt16.Type) throws -> Swift.UInt16?
  mutating func decodeIfPresent(_ type: Swift.UInt32.Type) throws -> Swift.UInt32?
  mutating func decodeIfPresent(_ type: Swift.UInt64.Type) throws -> Swift.UInt64?
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func decodeIfPresent(_ type: Swift.UInt128.Type) throws -> Swift.UInt128?
  mutating func decodeIfPresent<T>(_ type: T.Type) throws -> T? where T : Swift.Decodable
  mutating func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type) throws -> Swift.KeyedDecodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  mutating func nestedUnkeyedContainer() throws -> any Swift.UnkeyedDecodingContainer
  mutating func superDecoder() throws -> any Swift.Decoder
}
public protocol SingleValueEncodingContainer {
  var codingPath: [any Swift.CodingKey] { get }
  mutating func encodeNil() throws
  mutating func encode(_ value: Swift.Bool) throws
  mutating func encode(_ value: Swift.String) throws
  mutating func encode(_ value: Swift.Double) throws
  mutating func encode(_ value: Swift.Float) throws
  mutating func encode(_ value: Swift.Int) throws
  mutating func encode(_ value: Swift.Int8) throws
  mutating func encode(_ value: Swift.Int16) throws
  mutating func encode(_ value: Swift.Int32) throws
  mutating func encode(_ value: Swift.Int64) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func encode(_ value: Swift.Int128) throws
  mutating func encode(_ value: Swift.UInt) throws
  mutating func encode(_ value: Swift.UInt8) throws
  mutating func encode(_ value: Swift.UInt16) throws
  mutating func encode(_ value: Swift.UInt32) throws
  mutating func encode(_ value: Swift.UInt64) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func encode(_ value: Swift.UInt128) throws
  mutating func encode<T>(_ value: T) throws where T : Swift.Encodable
}
public protocol SingleValueDecodingContainer {
  var codingPath: [any Swift.CodingKey] { get }
  func decodeNil() -> Swift.Bool
  func decode(_ type: Swift.Bool.Type) throws -> Swift.Bool
  func decode(_ type: Swift.String.Type) throws -> Swift.String
  func decode(_ type: Swift.Double.Type) throws -> Swift.Double
  func decode(_ type: Swift.Float.Type) throws -> Swift.Float
  func decode(_ type: Swift.Int.Type) throws -> Swift.Int
  func decode(_ type: Swift.Int8.Type) throws -> Swift.Int8
  func decode(_ type: Swift.Int16.Type) throws -> Swift.Int16
  func decode(_ type: Swift.Int32.Type) throws -> Swift.Int32
  func decode(_ type: Swift.Int64.Type) throws -> Swift.Int64
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  func decode(_ type: Swift.Int128.Type) throws -> Swift.Int128
  func decode(_ type: Swift.UInt.Type) throws -> Swift.UInt
  func decode(_ type: Swift.UInt8.Type) throws -> Swift.UInt8
  func decode(_ type: Swift.UInt16.Type) throws -> Swift.UInt16
  func decode(_ type: Swift.UInt32.Type) throws -> Swift.UInt32
  func decode(_ type: Swift.UInt64.Type) throws -> Swift.UInt64
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  func decode(_ type: Swift.UInt128.Type) throws -> Swift.UInt128
  func decode<T>(_ type: T.Type) throws -> T where T : Swift.Decodable
}
public struct CodingUserInfoKey : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public typealias RawValue = Swift.String
  public let rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public static func == (lhs: Swift.CodingUserInfoKey, rhs: Swift.CodingUserInfoKey) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum EncodingError : Swift.Error {
  public struct Context : Swift.Sendable {
    public let codingPath: [any Swift.CodingKey]
    public let debugDescription: Swift.String
    public let underlyingError: (any Swift.Error)?
    public init(codingPath: [any Swift.CodingKey], debugDescription: Swift.String, underlyingError: (any Swift.Error)? = nil)
  }
  case invalidValue(Any, Swift.EncodingError.Context)
  public var _domain: Swift.String {
    get
  }
  public var _code: Swift.Int {
    get
  }
  public var _userInfo: Swift.AnyObject? {
    get
  }
}
public enum DecodingError : Swift.Error {
  public struct Context : Swift.Sendable {
    public let codingPath: [any Swift.CodingKey]
    public let debugDescription: Swift.String
    public let underlyingError: (any Swift.Error)?
    public init(codingPath: [any Swift.CodingKey], debugDescription: Swift.String, underlyingError: (any Swift.Error)? = nil)
  }
  case typeMismatch(any Any.Type, Swift.DecodingError.Context)
  case valueNotFound(any Any.Type, Swift.DecodingError.Context)
  case keyNotFound(any Swift.CodingKey, Swift.DecodingError.Context)
  case dataCorrupted(Swift.DecodingError.Context)
  public var _domain: Swift.String {
    get
  }
  public var _code: Swift.Int {
    get
  }
  public var _userInfo: Swift.AnyObject? {
    get
  }
}
extension Swift.DecodingError {
  public static func dataCorruptedError<C>(forKey key: C.Key, in container: C, debugDescription: Swift.String) -> Swift.DecodingError where C : Swift.KeyedDecodingContainerProtocol
  public static func dataCorruptedError(in container: any Swift.UnkeyedDecodingContainer, debugDescription: Swift.String) -> Swift.DecodingError
  public static func dataCorruptedError(in container: any Swift.SingleValueDecodingContainer, debugDescription: Swift.String) -> Swift.DecodingError
}
extension Swift.Bool : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Bool {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Bool {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.String : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.String {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.String {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.Double : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Double {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Double {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.Float : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Float {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Float {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.Int : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.Int8 : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int8 {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int8 {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.Int16 : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int16 {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int16 {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.Int32 : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int32 {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int32 {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.Int64 : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int64 {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int64 {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.UInt : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.UInt8 : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt8 {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt8 {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.UInt16 : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt16 {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt16 {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.UInt32 : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt32 {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt32 {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.UInt64 : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt64 {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt64 {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public init(from decoder: any Swift.Decoder) throws
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : Swift.Encodable where Wrapped : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
#else
extension Swift.Optional : Swift.Encodable where Wrapped : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : Swift.Decodable where Wrapped : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
#else
extension Swift.Optional : Swift.Decodable where Wrapped : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
#endif
extension Swift.Array : Swift.Encodable where Element : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.Array : Swift.Decodable where Element : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.ContiguousArray : Swift.Encodable where Element : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.ContiguousArray : Swift.Decodable where Element : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.Set : Swift.Encodable where Element : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.Set : Swift.Decodable where Element : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
public protocol CodingKeyRepresentable {
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  var codingKey: any Swift.CodingKey { get }
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  init?<T>(codingKey: T) where T : Swift.CodingKey
}
@available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
extension Swift.RawRepresentable where Self : Swift.CodingKeyRepresentable, Self.RawValue == Swift.String {
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  public var codingKey: any Swift.CodingKey {
    get
  }
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  public init?<T>(codingKey: T) where T : Swift.CodingKey
}
@available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
extension Swift.RawRepresentable where Self : Swift.CodingKeyRepresentable, Self.RawValue == Swift.Int {
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  public var codingKey: any Swift.CodingKey {
    get
  }
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  public init?<T>(codingKey: T) where T : Swift.CodingKey
}
@available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
extension Swift.Int : Swift.CodingKeyRepresentable {
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  public var codingKey: any Swift.CodingKey {
    get
  }
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  public init?<T>(codingKey: T) where T : Swift.CodingKey
}
@available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
extension Swift.String : Swift.CodingKeyRepresentable {
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  public var codingKey: any Swift.CodingKey {
    get
  }
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  public init?<T>(codingKey: T) where T : Swift.CodingKey
}
extension Swift.Dictionary : Swift.Encodable where Key : Swift.Encodable, Value : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.Dictionary : Swift.Decodable where Key : Swift.Decodable, Value : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.KeyedEncodingContainerProtocol {
  public mutating func encodeConditional<T>(_ object: T, forKey key: Self.Key) throws where T : AnyObject, T : Swift.Encodable
}
extension Swift.KeyedEncodingContainerProtocol {
  public mutating func encodeIfPresent(_ value: Swift.Bool?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.String?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Double?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Float?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int8?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int16?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int32?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int64?, forKey key: Self.Key) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encodeIfPresent(_ value: Swift.Int128?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt8?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt16?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt32?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt64?, forKey key: Self.Key) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encodeIfPresent(_ value: Swift.UInt128?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent<T>(_ value: T?, forKey key: Self.Key) throws where T : Swift.Encodable
}
extension Swift.KeyedEncodingContainerProtocol {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encode(_ value: Swift.Int128, forKey key: Self.Key) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encode(_ value: Swift.UInt128, forKey key: Self.Key) throws
}
extension Swift.KeyedDecodingContainerProtocol {
  public func decodeIfPresent(_ type: Swift.Bool.Type, forKey key: Self.Key) throws -> Swift.Bool?
  public func decodeIfPresent(_ type: Swift.String.Type, forKey key: Self.Key) throws -> Swift.String?
  public func decodeIfPresent(_ type: Swift.Double.Type, forKey key: Self.Key) throws -> Swift.Double?
  public func decodeIfPresent(_ type: Swift.Float.Type, forKey key: Self.Key) throws -> Swift.Float?
  public func decodeIfPresent(_ type: Swift.Int.Type, forKey key: Self.Key) throws -> Swift.Int?
  public func decodeIfPresent(_ type: Swift.Int8.Type, forKey key: Self.Key) throws -> Swift.Int8?
  public func decodeIfPresent(_ type: Swift.Int16.Type, forKey key: Self.Key) throws -> Swift.Int16?
  public func decodeIfPresent(_ type: Swift.Int32.Type, forKey key: Self.Key) throws -> Swift.Int32?
  public func decodeIfPresent(_ type: Swift.Int64.Type, forKey key: Self.Key) throws -> Swift.Int64?
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func decodeIfPresent(_ type: Swift.Int128.Type, forKey key: Self.Key) throws -> Swift.Int128?
  public func decodeIfPresent(_ type: Swift.UInt.Type, forKey key: Self.Key) throws -> Swift.UInt?
  public func decodeIfPresent(_ type: Swift.UInt8.Type, forKey key: Self.Key) throws -> Swift.UInt8?
  public func decodeIfPresent(_ type: Swift.UInt16.Type, forKey key: Self.Key) throws -> Swift.UInt16?
  public func decodeIfPresent(_ type: Swift.UInt32.Type, forKey key: Self.Key) throws -> Swift.UInt32?
  public func decodeIfPresent(_ type: Swift.UInt64.Type, forKey key: Self.Key) throws -> Swift.UInt64?
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func decodeIfPresent(_ type: Swift.UInt128.Type, forKey key: Self.Key) throws -> Swift.UInt128?
  public func decodeIfPresent<T>(_ type: T.Type, forKey key: Self.Key) throws -> T? where T : Swift.Decodable
}
extension Swift.KeyedDecodingContainerProtocol {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func decode(_ type: Swift.Int128.Type, forKey key: Self.Key) throws -> Swift.Int128
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func decode(_ type: Swift.UInt128.Type, forKey key: Self.Key) throws -> Swift.UInt128
}
extension Swift.UnkeyedEncodingContainer {
  public mutating func encodeConditional<T>(_ object: T) throws where T : AnyObject, T : Swift.Encodable
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Bool
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.String
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Double
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Float
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int8
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int16
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int32
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int64
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int128
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt8
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt16
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt32
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt64
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt128
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element : Swift.Encodable
}
extension Swift.UnkeyedEncodingContainer {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encode(_ value: Swift.Int128) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encode(_ value: Swift.UInt128) throws
}
extension Swift.UnkeyedDecodingContainer {
  public mutating func decodeIfPresent(_ type: Swift.Bool.Type) throws -> Swift.Bool?
  public mutating func decodeIfPresent(_ type: Swift.String.Type) throws -> Swift.String?
  public mutating func decodeIfPresent(_ type: Swift.Double.Type) throws -> Swift.Double?
  public mutating func decodeIfPresent(_ type: Swift.Float.Type) throws -> Swift.Float?
  public mutating func decodeIfPresent(_ type: Swift.Int.Type) throws -> Swift.Int?
  public mutating func decodeIfPresent(_ type: Swift.Int8.Type) throws -> Swift.Int8?
  public mutating func decodeIfPresent(_ type: Swift.Int16.Type) throws -> Swift.Int16?
  public mutating func decodeIfPresent(_ type: Swift.Int32.Type) throws -> Swift.Int32?
  public mutating func decodeIfPresent(_ type: Swift.Int64.Type) throws -> Swift.Int64?
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func decodeIfPresent(_ type: Swift.Int128.Type) throws -> Swift.Int128?
  public mutating func decodeIfPresent(_ type: Swift.UInt.Type) throws -> Swift.UInt?
  public mutating func decodeIfPresent(_ type: Swift.UInt8.Type) throws -> Swift.UInt8?
  public mutating func decodeIfPresent(_ type: Swift.UInt16.Type) throws -> Swift.UInt16?
  public mutating func decodeIfPresent(_ type: Swift.UInt32.Type) throws -> Swift.UInt32?
  public mutating func decodeIfPresent(_ type: Swift.UInt64.Type) throws -> Swift.UInt64?
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func decodeIfPresent(_ type: Swift.UInt128.Type) throws -> Swift.UInt128?
  public mutating func decodeIfPresent<T>(_ type: T.Type) throws -> T? where T : Swift.Decodable
}
extension Swift.UnkeyedDecodingContainer {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func decode(_ type: Swift.Int128.Type) throws -> Swift.Int128
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func decode(_ type: Swift.UInt128.Type) throws -> Swift.UInt128
}
extension Swift.SingleValueEncodingContainer {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encode(_ value: Swift.Int128) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encode(_ value: Swift.UInt128) throws
}
extension Swift.SingleValueDecodingContainer {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func decode(_ type: Swift.Int128.Type) throws -> Swift.Int128
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func decode(_ type: Swift.UInt128.Type) throws -> Swift.UInt128
}
extension Swift.SingleValueEncodingContainer where Self : Swift.UnkeyedEncodingContainer {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encode(_ value: Swift.Int128) throws
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public mutating func encode(_ value: Swift.UInt128) throws
}
extension Swift.SingleValueDecodingContainer where Self : Swift.UnkeyedDecodingContainer {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func decode(_ type: Swift.Int128.Type) throws -> Swift.Int128
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func decode(_ type: Swift.UInt128.Type) throws -> Swift.UInt128
}
@frozen public struct IndexingIterator<Elements> where Elements : Swift.Collection {
  @usableFromInline
  internal let _elements: Elements
  @usableFromInline
  internal var _position: Elements.Index
  @inlinable @inline(__always) public init(_elements: Elements) {
    self._elements = _elements
    self._position = _elements.startIndex
  }
  @inlinable @inline(__always) public init(_elements: Elements, _position: Elements.Index) {
    self._elements = _elements
    self._position = _position
  }
}
extension Swift.IndexingIterator : Swift.IteratorProtocol, Swift.Sequence {
  public typealias Element = Elements.Element
  public typealias Iterator = Swift.IndexingIterator<Elements>
  public typealias SubSequence = Swift.AnySequence<Swift.IndexingIterator<Elements>.Element>
  @inlinable @inline(__always) public mutating func next() -> Elements.Element? {
    if _position == _elements.endIndex { return nil }
    let element = _elements[_position]
    _elements.formIndex(after: &_position)
    return element
  }
}
extension Swift.IndexingIterator : Swift.Sendable where Elements : Swift.Sendable, Elements.Index : Swift.Sendable {
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol Collection<Element> : Swift.Sequence {
  @available(*, deprecated, message: "all index distances are now of type Int")
  typealias IndexDistance = Swift.Int
  override associatedtype Element
  @available(swift, deprecated: 3.2, obsoleted: 5.0, renamed: "Element")
  typealias _Element = Self.Element
  associatedtype Index : Swift.Comparable where Self.Index == Self.Indices.Element, Self.Indices.Element == Self.Indices.Index, Self.Indices.Index == Self.SubSequence.Index
  var startIndex: Self.Index { get }
  var endIndex: Self.Index { get }
  associatedtype Iterator = Swift.IndexingIterator<Self>
  override __consuming func makeIterator() -> Self.Iterator
  associatedtype SubSequence : Swift.Collection = Swift.Slice<Self> where Self.Element == Self.SubSequence.Element, Self.SubSequence == Self.SubSequence.SubSequence
  @_borrowed subscript(position: Self.Index) -> Self.Element { get }
  subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get }
  associatedtype Indices : Swift.Collection = Swift.DefaultIndices<Self> where Self.Indices == Self.Indices.SubSequence
  var indices: Self.Indices { get }
  var isEmpty: Swift.Bool { get }
  var count: Swift.Int { get }
  func _customIndexOfEquatableElement(_ element: Self.Element) -> Self.Index??
  func _customLastIndexOfEquatableElement(_ element: Self.Element) -> Self.Index??
  func index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index
  func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index?
  func distance(from start: Self.Index, to end: Self.Index) -> Swift.Int
  func _failEarlyRangeCheck(_ index: Self.Index, bounds: Swift.Range<Self.Index>)
  func _failEarlyRangeCheck(_ index: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
  func _failEarlyRangeCheck(_ range: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
  func index(after i: Self.Index) -> Self.Index
  func formIndex(after i: inout Self.Index)
}
#else
public protocol Collection : Swift.Sequence {
  @available(*, deprecated, message: "all index distances are now of type Int")
  typealias IndexDistance = Swift.Int
  override associatedtype Element
  @available(swift, deprecated: 3.2, obsoleted: 5.0, renamed: "Element")
  typealias _Element = Self.Element
  associatedtype Index : Swift.Comparable where Self.Index == Self.Indices.Element, Self.Indices.Element == Self.Indices.Index, Self.Indices.Index == Self.SubSequence.Index
  var startIndex: Self.Index { get }
  var endIndex: Self.Index { get }
  associatedtype Iterator = Swift.IndexingIterator<Self>
  override __consuming func makeIterator() -> Self.Iterator
  associatedtype SubSequence : Swift.Collection = Swift.Slice<Self> where Self.Element == Self.SubSequence.Element, Self.SubSequence == Self.SubSequence.SubSequence
  @_borrowed subscript(position: Self.Index) -> Self.Element { get }
  subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get }
  associatedtype Indices : Swift.Collection = Swift.DefaultIndices<Self> where Self.Indices == Self.Indices.SubSequence
  var indices: Self.Indices { get }
  var isEmpty: Swift.Bool { get }
  var count: Swift.Int { get }
  func _customIndexOfEquatableElement(_ element: Self.Element) -> Self.Index??
  func _customLastIndexOfEquatableElement(_ element: Self.Element) -> Self.Index??
  func index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index
  func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index?
  func distance(from start: Self.Index, to end: Self.Index) -> Swift.Int
  func _failEarlyRangeCheck(_ index: Self.Index, bounds: Swift.Range<Self.Index>)
  func _failEarlyRangeCheck(_ index: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
  func _failEarlyRangeCheck(_ range: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
  func index(after i: Self.Index) -> Self.Index
  func formIndex(after i: inout Self.Index)
}
#endif
extension Swift.Collection {
  @inlinable @inline(__always) public func formIndex(after i: inout Self.Index) {
    i = index(after: i)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Self.Index, bounds: Swift.Range<Self.Index>) {
     
    _precondition(
      bounds.lowerBound <= index && index < bounds.upperBound,
      "Index out of bounds")
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Self.Index, bounds: Swift.ClosedRange<Self.Index>) {
     
    _precondition(
      bounds.lowerBound <= index && index <= bounds.upperBound,
      "Index out of bounds")
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>) {
     
    _precondition(
      bounds.lowerBound <= range.lowerBound &&
      range.upperBound <= bounds.upperBound,
      "Range out of bounds")
  }
  @inlinable public func index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index {
    return self._advanceForward(i, by: distance)
  }
  @inlinable public func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index? {
    return self._advanceForward(i, by: distance, limitedBy: limit)
  }
  @inlinable public func formIndex(_ i: inout Self.Index, offsetBy distance: Swift.Int) {
    i = index(i, offsetBy: distance)
  }
  @inlinable public func formIndex(_ i: inout Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Swift.Bool {
    if let advancedIndex = index(i, offsetBy: distance, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
  @inlinable public func distance(from start: Self.Index, to end: Self.Index) -> Swift.Int {
    _precondition(start <= end,
      "Only BidirectionalCollections can have end come before start")

    var start = start
    var count = 0
    while start != end {
      count = count + 1
      formIndex(after: &start)
    }
    return count
  }
  @inlinable public func randomElement<T>(using generator: inout T) -> Self.Element? where T : Swift.RandomNumberGenerator {
    guard !isEmpty else { return nil }
    let random = Int.random(in: 0 ..< count, using: &generator)
    let idx = index(startIndex, offsetBy: random)
    return self[idx]
  }
  @inlinable public func randomElement() -> Self.Element? {
    var g = SystemRandomNumberGenerator()
    return randomElement(using: &g)
  }
  @inlinable @inline(__always) internal func _advanceForward(_ i: Self.Index, by n: Swift.Int) -> Self.Index {
    _precondition(n >= 0,
      "Only BidirectionalCollections can be advanced by a negative amount")

    var i = i
    for _ in stride(from: 0, to: n, by: 1) {
      formIndex(after: &i)
    }
    return i
  }
  @inlinable @inline(__always) internal func _advanceForward(_ i: Self.Index, by n: Swift.Int, limitedBy limit: Self.Index) -> Self.Index? {
    _precondition(n >= 0,
      "Only BidirectionalCollections can be advanced by a negative amount")

    var i = i
    for _ in stride(from: 0, to: n, by: 1) {
      if i == limit {
        return nil
      }
      formIndex(after: &i)
    }
    return i
  }
}
extension Swift.Collection where Self.Iterator == Swift.IndexingIterator<Self> {
  @inlinable @inline(__always) public __consuming func makeIterator() -> Swift.IndexingIterator<Self> {
    return IndexingIterator(_elements: self)
  }
}
extension Swift.Collection where Self.SubSequence == Swift.Slice<Self> {
  @inlinable public subscript(bounds: Swift.Range<Self.Index>) -> Swift.Slice<Self> {
    get {
    _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
    return Slice(base: self, bounds: bounds)
  }
  }
}
extension Swift.Collection {
  @available(*, unavailable)
  @_alwaysEmitIntoClient public subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence {
    get { fatalError() }
  }
}
extension Swift.Collection where Self == Self.SubSequence {
  @inlinable public mutating func popFirst() -> Self.Element? {
     
    guard !isEmpty else { return nil }
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
}
extension Swift.Collection {
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return startIndex == endIndex
  }
  }
  @inlinable public var first: Self.Element? {
    get {
    let start = startIndex
    if start != endIndex { return self[start] }
    else { return nil }
  }
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
     
    return count
  }
  }
  @inlinable public var count: Swift.Int {
    get {
    return distance(from: startIndex, to: endIndex)
  }
  }
  @inlinable @inline(__always) public func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index?? {
    return nil
  }
  @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ element: Self.Element) -> Self.Index?? {
    return nil
  }
}
extension Swift.Collection {
  #if compiler(>=5.3) && $TypedThrows
  @inlinable @_alwaysEmitIntoClient public func map<T, E>(_ transform: (Self.Element) throws(E) -> T) throws(E) -> [T] where E : Swift.Error {
     
    let n = self.count
    if n == 0 {
      return []
    }

    var result = ContiguousArray<T>()
    result.reserveCapacity(n)

    var i = self.startIndex

    for _ in 0..<n {
      result.append(try transform(self[i]))
      formIndex(after: &i)
    }

    _expectEnd(of: self, is: i)
    return Array(result)
  }
  #endif
  @usableFromInline
  @_silgen_name("$sSlsE3mapySayqd__Gqd__7ElementQzKXEKlF")
  internal func __rethrows_map<T>(_ transform: (Self.Element) throws -> T) throws -> [T]
  @inlinable public __consuming func dropFirst(_ k: Swift.Int = 1) -> Self.SubSequence {
    _precondition(k >= 0, "Can't drop a negative number of elements from a collection")
    let start = index(startIndex, offsetBy: k, limitedBy: endIndex) ?? endIndex
    return self[start..<endIndex]
  }
  @inlinable public __consuming func dropLast(_ k: Swift.Int = 1) -> Self.SubSequence {
    _precondition(
      k >= 0, "Can't drop a negative number of elements from a collection")
    let amount = Swift.max(0, count - k)
    let end = index(startIndex,
      offsetBy: amount, limitedBy: endIndex) ?? endIndex
    return self[startIndex..<end]
  }
  @inlinable public __consuming func drop(while predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.SubSequence {
    var start = startIndex
    while try start != endIndex && predicate(self[start]) {
      formIndex(after: &start)
    } 
    return self[start..<endIndex]
  }
  @inlinable public __consuming func prefix(_ maxLength: Swift.Int) -> Self.SubSequence {
    _precondition(
      maxLength >= 0,
      "Can't take a prefix of negative length from a collection")
    let end = index(startIndex,
      offsetBy: maxLength, limitedBy: endIndex) ?? endIndex
    return self[startIndex..<end]
  }
  @inlinable public __consuming func prefix(while predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.SubSequence {
    var end = startIndex
    while try end != endIndex && predicate(self[end]) {
      formIndex(after: &end)
    }
    return self[startIndex..<end]
  }
  @inlinable public __consuming func suffix(_ maxLength: Swift.Int) -> Self.SubSequence {
    _precondition(
      maxLength >= 0,
      "Can't take a suffix of negative length from a collection")
    let amount = Swift.max(0, count - maxLength)
    let start = index(startIndex,
      offsetBy: amount, limitedBy: endIndex) ?? endIndex
    return self[start..<endIndex]
  }
  @inlinable public __consuming func prefix(upTo end: Self.Index) -> Self.SubSequence {
    return self[startIndex..<end]
  }
  @inlinable public __consuming func suffix(from start: Self.Index) -> Self.SubSequence {
    return self[start..<endIndex]
  }
  @inlinable public __consuming func prefix(through position: Self.Index) -> Self.SubSequence {
    return prefix(upTo: index(after: position))
  }
  @inlinable public __consuming func split(maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true, whereSeparator isSeparator: (Self.Element) throws -> Swift.Bool) rethrows -> [Self.SubSequence] {
     
    _precondition(maxSplits >= 0, "Must take zero or more splits")

    var result: [SubSequence] = []
    var subSequenceStart: Index = startIndex

    func appendSubsequence(end: Index) -> Bool {
      if subSequenceStart == end && omittingEmptySubsequences {
        return false
      }
      result.append(self[subSequenceStart..<end])
      return true
    }

    if maxSplits == 0 || isEmpty {
      _ = appendSubsequence(end: endIndex)
      return result
    }

    var subSequenceEnd = subSequenceStart
    let cachedEndIndex = endIndex
    while subSequenceEnd != cachedEndIndex {
      if try isSeparator(self[subSequenceEnd]) {
        let didAppend = appendSubsequence(end: subSequenceEnd)
        formIndex(after: &subSequenceEnd)
        subSequenceStart = subSequenceEnd
        if didAppend && result.count == maxSplits {
          break
        }
        continue
      }
      formIndex(after: &subSequenceEnd)
    }

    if subSequenceStart != cachedEndIndex || !omittingEmptySubsequences {
      result.append(self[subSequenceStart..<cachedEndIndex])
    }

    return result
  }
}
extension Swift.Collection where Self.Element : Swift.Equatable {
  @inlinable public __consuming func split(separator: Self.Element, maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true) -> [Self.SubSequence] {
     
    return split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      whereSeparator: { $0 == separator })
  }
}
extension Swift.Collection where Self == Self.SubSequence {
  @discardableResult
  @inlinable public mutating func removeFirst() -> Self.Element {
     
    _precondition(!isEmpty, "Can't remove items from an empty collection")
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
  @inlinable public mutating func removeFirst(_ k: Swift.Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    guard let idx = index(startIndex, offsetBy: k, limitedBy: endIndex) else {
      _preconditionFailure(
        "Can't remove more items from a collection than it contains")
    }
    self = self[idx..<endIndex]
  }
}
extension Swift.BidirectionalCollection {
  @inlinable public var last: Self.Element? {
    get {
    return isEmpty ? nil : self[index(before: endIndex)]
  }
  }
}
extension Swift.Collection where Self.Element : Swift.Equatable {
  @inlinable public func firstIndex(of element: Self.Element) -> Self.Index? {
    if let result = _customIndexOfEquatableElement(element) {
      return result
    }

    var i = self.startIndex
    while i != self.endIndex {
      if self[i] == element {
        return i
      }
      self.formIndex(after: &i)
    }
    return nil
  }
}
extension Swift.Collection {
  @inlinable public func firstIndex(where predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index? {
    var i = self.startIndex
    while i != self.endIndex {
      if try predicate(self[i]) {
        return i
      }
      self.formIndex(after: &i)
    }
    return nil
  }
}
extension Swift.BidirectionalCollection {
  @inlinable public func last(where predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Element? {
    return try lastIndex(where: predicate).map { self[$0] }
  }
  @inlinable public func lastIndex(where predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index? {
    var i = endIndex
    while i != startIndex {
      formIndex(before: &i)
      if try predicate(self[i]) {
        return i
      }
    }
    return nil
  }
}
extension Swift.BidirectionalCollection where Self.Element : Swift.Equatable {
  @inlinable public func lastIndex(of element: Self.Element) -> Self.Index? {
    if let result = _customLastIndexOfEquatableElement(element) {
      return result
    }
    return lastIndex(where: { $0 == element })
  }
}
extension Swift.Collection {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public func indices(where predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Swift.RangeSet<Self.Index> {
    var result: [Range<Index>] = []
    var end = startIndex
    while let begin = try self[end...].firstIndex(where: predicate) {
      end = try self[begin...].prefix(while: predicate).endIndex
      result.append(begin ..< end)

      guard end < self.endIndex else {
        break
      }
      self.formIndex(after: &end)
    }

    return RangeSet(_orderedRanges: result)
  }
}
extension Swift.Collection where Self.Element : Swift.Equatable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public func indices(of element: Self.Element) -> Swift.RangeSet<Self.Index> {
    indices(where: { $0 == element })
  }
}
extension Swift.MutableCollection {
  @inlinable public mutating func partition(by belongsInSecondPartition: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index {
    return try _halfStablePartition(isSuffixElement: belongsInSecondPartition)
  }
  @inlinable internal mutating func _halfStablePartition(isSuffixElement: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index {
    guard var i = try firstIndex(where: isSuffixElement)
    else { return endIndex }
    
    var j = index(after: i)
    while j != endIndex {
      if try !isSuffixElement(self[j]) { swapAt(i, j); formIndex(after: &i) }
      formIndex(after: &j)
    }
    return i
  }
}
extension Swift.MutableCollection where Self : Swift.BidirectionalCollection {
  @inlinable public mutating func partition(by belongsInSecondPartition: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index {
    let maybeOffset = try withContiguousMutableStorageIfAvailable {
      (bufferPointer) -> Int in
      let unsafeBufferPivot = try bufferPointer._partitionImpl(
        by: belongsInSecondPartition)
      return unsafeBufferPivot - bufferPointer.startIndex
    }
    if let offset = maybeOffset {
      return index(startIndex, offsetBy: offset)
    } else {
      return try _partitionImpl(by: belongsInSecondPartition)
    }
  }
  @inlinable internal mutating func _partitionImpl(by belongsInSecondPartition: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index {
    var lo = startIndex
    var hi = endIndex
    while true {
       
       
       
       
       

       
      while true {
        guard lo < hi else { return lo }
        if try belongsInSecondPartition(self[lo]) { break }
        formIndex(after: &lo)
      }

       
      while true {
        formIndex(before: &hi)
        guard lo < hi else { return lo }
        if try !belongsInSecondPartition(self[hi]) { break }
      }

      swapAt(lo, hi)
      formIndex(after: &lo)
    }
  }
}
extension Swift.Sequence {
  @inlinable public func shuffled<T>(using generator: inout T) -> [Self.Element] where T : Swift.RandomNumberGenerator {
    var result = ContiguousArray(self)
    result.shuffle(using: &generator)
    return Array(result)
  }
  @inlinable public func shuffled() -> [Self.Element] {
    var g = SystemRandomNumberGenerator()
    return shuffled(using: &g)
  }
}
extension Swift.MutableCollection where Self : Swift.RandomAccessCollection {
  @inlinable public mutating func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator {
    guard count > 1 else { return }
    var amount = count
    var currentIndex = startIndex
    while amount > 1 {
      let random = Int.random(in: 0 ..< amount, using: &generator)
      amount -= 1
      swapAt(
        currentIndex,
        index(currentIndex, offsetBy: random)
      )
      formIndex(after: &currentIndex)
    }
  }
  @inlinable public mutating func shuffle() {
    var g = SystemRandomNumberGenerator()
    shuffle(using: &g)
  }
}
public protocol Comparable : Swift.Equatable {
  static func < (lhs: Self, rhs: Self) -> Swift.Bool
  static func <= (lhs: Self, rhs: Self) -> Swift.Bool
  static func >= (lhs: Self, rhs: Self) -> Swift.Bool
  static func > (lhs: Self, rhs: Self) -> Swift.Bool
}
extension Swift.Comparable {
  @inlinable public static func > (lhs: Self, rhs: Self) -> Swift.Bool {
    return rhs < lhs
  }
  @inlinable public static func <= (lhs: Self, rhs: Self) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @inlinable public static func >= (lhs: Self, rhs: Self) -> Swift.Bool {
    return !(lhs < rhs)
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol RawRepresentable<RawValue> {
  associatedtype RawValue
  init?(rawValue: Self.RawValue)
  var rawValue: Self.RawValue { get }
}
#else
public protocol RawRepresentable {
  associatedtype RawValue
  init?(rawValue: Self.RawValue)
  var rawValue: Self.RawValue { get }
}
#endif
@inlinable public func == <T>(lhs: T, rhs: T) -> Swift.Bool where T : Swift.RawRepresentable, T.RawValue : Swift.Equatable {
  return lhs.rawValue == rhs.rawValue
}
@inlinable public func != <T>(lhs: T, rhs: T) -> Swift.Bool where T : Swift.RawRepresentable, T.RawValue : Swift.Equatable {
  return lhs.rawValue != rhs.rawValue
}
@inlinable public func != <T>(lhs: T, rhs: T) -> Swift.Bool where T : Swift.Equatable, T : Swift.RawRepresentable, T.RawValue : Swift.Equatable {
  return lhs.rawValue != rhs.rawValue
}
extension Swift.RawRepresentable where Self : Swift.Hashable, Self.RawValue : Swift.Hashable {
  @inlinable public var hashValue: Swift.Int {
    get {
     
     
     
     
    _hashValue(for: self)
  }
  }
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(rawValue)
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
     
     
     
     
     
     
    var hasher = Hasher(_seed: seed)
    self.hash(into: &hasher)
    return hasher._finalize()
  }
}
public protocol CaseIterable {
  associatedtype AllCases : Swift.Collection = [Self] where Self == Self.AllCases.Element
  static var allCases: Self.AllCases { get }
}
#if compiler(>=5.3) && $NoncopyableGenerics
public protocol ExpressibleByNilLiteral : ~Copyable {
  init(nilLiteral: ())
}
#else
public protocol ExpressibleByNilLiteral {
  init(nilLiteral: ())
}
#endif
public protocol _ExpressibleByBuiltinIntegerLiteral {
  init(_builtinIntegerLiteral value: Builtin.IntLiteral)
}
public protocol ExpressibleByIntegerLiteral {
  associatedtype IntegerLiteralType : Swift._ExpressibleByBuiltinIntegerLiteral
  init(integerLiteral value: Self.IntegerLiteralType)
}
public protocol _ExpressibleByBuiltinFloatLiteral {
  init(_builtinFloatLiteral value: Swift._MaxBuiltinFloatType)
}
public protocol ExpressibleByFloatLiteral {
  associatedtype FloatLiteralType : Swift._ExpressibleByBuiltinFloatLiteral
  init(floatLiteral value: Self.FloatLiteralType)
}
public protocol _ExpressibleByBuiltinBooleanLiteral {
  init(_builtinBooleanLiteral value: Builtin.Int1)
}
public protocol ExpressibleByBooleanLiteral {
  associatedtype BooleanLiteralType : Swift._ExpressibleByBuiltinBooleanLiteral
  init(booleanLiteral value: Self.BooleanLiteralType)
}
public protocol _ExpressibleByBuiltinUnicodeScalarLiteral {
  init(_builtinUnicodeScalarLiteral value: Builtin.Int32)
}
public protocol ExpressibleByUnicodeScalarLiteral {
  associatedtype UnicodeScalarLiteralType : Swift._ExpressibleByBuiltinUnicodeScalarLiteral
  init(unicodeScalarLiteral value: Self.UnicodeScalarLiteralType)
}
public protocol _ExpressibleByBuiltinExtendedGraphemeClusterLiteral : Swift._ExpressibleByBuiltinUnicodeScalarLiteral {
  init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1)
}
public protocol ExpressibleByExtendedGraphemeClusterLiteral : Swift.ExpressibleByUnicodeScalarLiteral {
  associatedtype ExtendedGraphemeClusterLiteralType : Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral
  init(extendedGraphemeClusterLiteral value: Self.ExtendedGraphemeClusterLiteralType)
}
extension Swift.ExpressibleByExtendedGraphemeClusterLiteral where Self.ExtendedGraphemeClusterLiteralType == Self.UnicodeScalarLiteralType {
  @_transparent public init(unicodeScalarLiteral value: Self.ExtendedGraphemeClusterLiteralType) {
    self.init(extendedGraphemeClusterLiteral: value)
  }
}
public protocol _ExpressibleByBuiltinStringLiteral : Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral {
  init(_builtinStringLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1)
}
public protocol ExpressibleByStringLiteral : Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  associatedtype StringLiteralType : Swift._ExpressibleByBuiltinStringLiteral
  init(stringLiteral value: Self.StringLiteralType)
}
extension Swift.ExpressibleByStringLiteral where Self.ExtendedGraphemeClusterLiteralType == Self.StringLiteralType {
  @_transparent public init(extendedGraphemeClusterLiteral value: Self.StringLiteralType) {
    self.init(stringLiteral: value)
  }
}
public protocol ExpressibleByArrayLiteral {
  associatedtype ArrayLiteralElement
  init(arrayLiteral elements: Self.ArrayLiteralElement...)
}
public protocol ExpressibleByDictionaryLiteral {
  associatedtype Key
  associatedtype Value
  init(dictionaryLiteral elements: (Self.Key, Self.Value)...)
}
public protocol ExpressibleByStringInterpolation : Swift.ExpressibleByStringLiteral {
  associatedtype StringInterpolation : Swift.StringInterpolationProtocol = Swift.DefaultStringInterpolation where Self.StringLiteralType == Self.StringInterpolation.StringLiteralType
  init(stringInterpolation: Self.StringInterpolation)
}
extension Swift.ExpressibleByStringInterpolation where Self.StringInterpolation == Swift.DefaultStringInterpolation {
  public init(stringInterpolation: Swift.DefaultStringInterpolation)
}
public protocol StringInterpolationProtocol {
  associatedtype StringLiteralType : Swift._ExpressibleByBuiltinStringLiteral
  init(literalCapacity: Swift.Int, interpolationCount: Swift.Int)
  mutating func appendLiteral(_ literal: Self.StringLiteralType)
}
public protocol _ExpressibleByColorLiteral {
  init(_colorLiteralRed red: Swift.Float, green: Swift.Float, blue: Swift.Float, alpha: Swift.Float)
}
public protocol _ExpressibleByImageLiteral {
  init(imageLiteralResourceName path: Swift.String)
}
public protocol _ExpressibleByFileReferenceLiteral {
  init(fileReferenceLiteralResourceName path: Swift.String)
}
public protocol _DestructorSafeContainer {
}
#if compiler(>=5.3) && $NoncopyableGenerics
@_marker public protocol Sendable {
}
#else
@_marker public protocol Sendable {
}
#endif
@available(*, deprecated, message: "Use @unchecked Sendable instead")
@available(swift, obsoleted: 6.0, message: "Use @unchecked Sendable instead")
@_marker public protocol UnsafeSendable : Swift.Sendable {
}
@available(*, deprecated, renamed: "Sendable")
@available(swift, obsoleted: 6.0, renamed: "Sendable")
public typealias ConcurrentValue = Swift.Sendable
@available(*, deprecated, renamed: "Sendable")
@available(swift, obsoleted: 6.0, renamed: "Sendable")
public typealias UnsafeConcurrentValue = Swift.UnsafeSendable
#if compiler(>=5.3) && $LexicalLifetimes
@frozen @_eagerMove public struct ContiguousArray<Element> : Swift._DestructorSafeContainer {
  @usableFromInline
  internal typealias _Buffer = Swift._ContiguousArrayBuffer<Element>
  @usableFromInline
  internal var _buffer: Swift.ContiguousArray<Element>._Buffer
  @inlinable internal init(_buffer: Swift.ContiguousArray<Element>._Buffer) {
    self._buffer = _buffer
  }
}
#else
@frozen public struct ContiguousArray<Element> : Swift._DestructorSafeContainer {
  @usableFromInline
  internal typealias _Buffer = Swift._ContiguousArrayBuffer<Element>
  @usableFromInline
  internal var _buffer: Swift.ContiguousArray<Element>._Buffer
  @inlinable internal init(_buffer: Swift.ContiguousArray<Element>._Buffer) {
    self._buffer = _buffer
  }
}
#endif
extension Swift.ContiguousArray {
  @inlinable @inline(__always) @_semantics("array.get_count") internal func _getCount() -> Swift.Int {
    return _buffer.immutableCount
  }
  @inlinable @_semantics("array.get_capacity") internal func _getCapacity() -> Swift.Int {
    return _buffer.immutableCapacity
  }
  @inlinable @_semantics("array.make_mutable") internal mutating func _makeMutableAndUnique() {
    if _slowPath(!_buffer.beginCOWMutation()) {
      _buffer = _buffer._consumeAndCreateNew()
    }
  }
  @_alwaysEmitIntoClient @_semantics("array.end_mutation") internal mutating func _endMutation() {
    _buffer.endCOWMutation()
  }
  @inlinable @inline(__always) internal func _checkSubscript_native(_ index: Swift.Int) {
    _buffer._checkValidSubscript(index)
  }
  @_alwaysEmitIntoClient @_semantics("array.check_subscript") internal func _checkSubscript_mutating(_ index: Swift.Int) {
    _buffer._checkValidSubscriptMutating(index)
  }
  @inlinable @_semantics("array.check_index") internal func _checkIndex(_ index: Swift.Int) {
    _precondition(index <= endIndex, "ContiguousArray index is out of range")
    _precondition(index >= startIndex, "Negative ContiguousArray index is out of range")
  }
  @inlinable @_semantics("array.get_element_address") internal func _getElementAddress(_ index: Swift.Int) -> Swift.UnsafeMutablePointer<Element> {
    return _buffer.firstElementAddress + index
  }
}
extension Swift.ContiguousArray : Swift._ArrayProtocol {
  @inlinable public var capacity: Swift.Int {
    get {
    return _getCapacity()
  }
  }
  @inlinable public var _owner: Swift.AnyObject? {
    get {
    return _buffer.owner
  }
  }
  @inlinable public var _baseAddressIfContiguous: Swift.UnsafeMutablePointer<Element>? {
    @inline(__always) get { return _buffer.firstElementAddressIfContiguous }
  }
  @inlinable internal var _baseAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    return _buffer.firstElementAddress
  }
  }
}
extension Swift.ContiguousArray : Swift.RandomAccessCollection, Swift.MutableCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = Swift.IndexingIterator<Swift.ContiguousArray<Element>>
  @inlinable public var startIndex: Swift.Int {
    get {
    return 0
  }
  }
  public var endIndex: Swift.Int {
    @inlinable @inline(__always) get {
      return _getCount()
    }
  }
  @inlinable public func index(after i: Swift.Int) -> Swift.Int {
     
     
     
     
     
    return i + 1
  }
  @inlinable public func formIndex(after i: inout Swift.Int) {
     
     
     
     
     
    i += 1
  }
  @inlinable public func index(before i: Swift.Int) -> Swift.Int {
     
     
     
     
     
    return i - 1
  }
  @inlinable public func formIndex(before i: inout Swift.Int) {
     
     
     
     
     
    i -= 1
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
     
     
     
     
     
    return i + distance
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
     
     
     
     
     
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
  @inlinable public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
     
     
     
     
     
    return end - start
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
     
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
     
  }
  @inlinable public subscript(index: Swift.Int) -> Element {
    get {
      _checkSubscript_native(index)
      return _buffer.getElement(index)
    }
    _modify {
      _makeMutableAndUnique()
      _checkSubscript_mutating(index)
      let address = _buffer.mutableFirstElementAddress + index
      defer { _endMutation() }
      yield &address.pointee
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
       
       
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
  @inlinable public var count: Swift.Int {
    get {
    return _getCount()
  }
  }
  public typealias SubSequence = Swift.ArraySlice<Element>
}
extension Swift.ContiguousArray : Swift.ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
    self.init(_buffer: ContiguousArray(elements)._buffer)
  }
  public typealias ArrayLiteralElement = Element
}
extension Swift.ContiguousArray : Swift.RangeReplaceableCollection {
  @inlinable @_semantics("array.init.empty") public init() {
    _buffer = _Buffer()
  }
  @inlinable public init<S>(_ s: S) where Element == S.Element, S : Swift.Sequence {
    self.init(_buffer: s._copyToContiguousArray()._buffer)
  }
  @inlinable @_semantics("array.init") public init(repeating repeatedValue: Element, count: Swift.Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = ContiguousArray._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
    _endMutation()
  }
  @usableFromInline
  @inline(never) internal static func _allocateBufferUninitialized(minimumCapacity: Swift.Int) -> Swift.ContiguousArray<Element>._Buffer
  @inlinable internal init(_uninitializedCount count: Swift.Int) {
    _precondition(count >= 0, "Can't construct ContiguousArray with count < 0")
     
     
    _buffer = _Buffer()
    if count > 0 {
       
       
       
      _buffer = ContiguousArray._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.mutableCount = count
    }
     
     
  }
  @inlinable @_semantics("array.uninitialized") internal static func _allocateUninitialized(_ count: Swift.Int) -> (Swift.ContiguousArray<Element>, Swift.UnsafeMutablePointer<Element>) {
    let result = ContiguousArray(_uninitializedCount: count)
    return (result, result._buffer.firstElementAddress)
  }
  @inlinable @_semantics("array.mutate_unknown") public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
    _reserveCapacityImpl(minimumCapacity: minimumCapacity,
                         growForAppend: false)
    _endMutation()
  }
  @_alwaysEmitIntoClient internal mutating func _reserveCapacityImpl(minimumCapacity: Swift.Int, growForAppend: Swift.Bool) {
    let isUnique = _buffer.beginCOWMutation()
    if _slowPath(!isUnique || _buffer.mutableCapacity < minimumCapacity) {
      _createNewBuffer(bufferIsUnique: isUnique,
                       minimumCapacity: Swift.max(minimumCapacity, _buffer.count),
                       growForAppend: growForAppend)
    }
    _internalInvariant(_buffer.mutableCapacity >= minimumCapacity)
    _internalInvariant(_buffer.mutableCapacity == 0 || _buffer.isUniquelyReferenced())
  }
  @_alwaysEmitIntoClient @inline(never) internal mutating func _createNewBuffer(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) {
    _internalInvariant(!bufferIsUnique || _buffer.isUniquelyReferenced())
    _buffer = _buffer._consumeAndCreateNew(bufferIsUnique: bufferIsUnique,
                                           minimumCapacity: minimumCapacity,
                                           growForAppend: growForAppend)
  }
  @inline(never) @inlinable internal mutating func _copyToNewBuffer(oldCount: Swift.Int) {
    let newCount = oldCount &+ 1
    var newBuffer = _buffer._forceCreateUniqueMutableBuffer(
      countForNewBuffer: oldCount, minNewCapacity: newCount)
    _buffer._arrayOutOfPlaceUpdate(
      &newBuffer, oldCount, 0)
  }
  @inlinable @_semantics("array.make_mutable") internal mutating func _makeUniqueAndReserveCapacityIfNotUnique() {
    if _slowPath(!_buffer.beginCOWMutation()) {
      _createNewBuffer(bufferIsUnique: false,
                       minimumCapacity: count &+ 1,
                       growForAppend: true)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") internal mutating func _reserveCapacityAssumingUniqueBuffer(oldCount: Swift.Int) {
     
     
     
     
     
     
     
     
     
    let capacity = _buffer.mutableCapacity
    _internalInvariant(capacity == 0 || _buffer.isMutableAndUniquelyReferenced())

    if _slowPath(oldCount &+ 1 > capacity) {
      _createNewBuffer(bufferIsUnique: capacity > 0,
                       minimumCapacity: oldCount &+ 1,
                       growForAppend: true)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") internal mutating func _appendElementAssumeUniqueAndCapacity(_ oldCount: Swift.Int, newElement: __owned Element) {
    _internalInvariant(_buffer.isMutableAndUniquelyReferenced())
    _internalInvariant(_buffer.mutableCapacity >= _buffer.mutableCount &+ 1)

    _buffer.mutableCount = oldCount &+ 1
    (_buffer.mutableFirstElementAddress + oldCount).initialize(to: newElement)
  }
  @inlinable @_semantics("array.append_element") public mutating func append(_ newElement: __owned Element) {
     
     
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _buffer.mutableCount
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
    _endMutation()
  }
  @inlinable @_semantics("array.append_contentsOf") public mutating func append<S>(contentsOf newElements: __owned S) where Element == S.Element, S : Swift.Sequence {

    defer {
      _endMutation()
    }

    let newElementsCount = newElements.underestimatedCount
    _reserveCapacityImpl(minimumCapacity: self.count + newElementsCount,
                         growForAppend: true)

    let oldCount = _buffer.mutableCount
    let startNewElements = _buffer.mutableFirstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: _buffer.mutableCapacity - oldCount)

    var (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
     
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    _precondition(newElementsCount <= writtenCount, 
      "newElements.underestimatedCount was an overestimate")
     

     
    if writtenCount > 0 {
      _buffer.mutableCount = _buffer.mutableCount + writtenCount
    }

    if writtenUpTo == buf.endIndex {
       
       
      var newCount = _buffer.mutableCount
      var nextItem = remainder.next()
      while nextItem != nil {
        _reserveCapacityAssumingUniqueBuffer(oldCount: newCount)

        let currentCapacity = _buffer.mutableCapacity
        let base = _buffer.mutableFirstElementAddress

         
        while let next = nextItem, newCount < currentCapacity {
          (base + newCount).initialize(to: next)
          newCount += 1
          nextItem = remainder.next()
        }
        _buffer.mutableCount = newCount
      }
    }
  }
  @inlinable @_semantics("array.reserve_capacity_for_append") internal mutating func reserveCapacityForAppend(newElementsCount: Swift.Int) {
     
     
    _reserveCapacityImpl(minimumCapacity: self.count + newElementsCount,
                         growForAppend: true)
    _endMutation()
  }
  @inlinable @_semantics("array.mutate_unknown") public mutating func _customRemoveLast() -> Element? {
    _makeMutableAndUnique()
    let newCount = _buffer.mutableCount - 1
    _precondition(newCount >= 0, "Can't removeLast from an empty ContiguousArray")
    let pointer = (_buffer.mutableFirstElementAddress + newCount)
    let element = pointer.move()
    _buffer.mutableCount = newCount
    _endMutation()
    return element
  }
  @discardableResult
  @inlinable @_semantics("array.mutate_unknown") public mutating func remove(at index: Swift.Int) -> Element {
    _makeMutableAndUnique()
    let currentCount = _buffer.mutableCount
    _precondition(index < currentCount, "Index out of range")
    _precondition(index >= 0, "Index out of range")
    let newCount = currentCount - 1
    let pointer = (_buffer.mutableFirstElementAddress + index)
    let result = pointer.move()
    pointer.moveInitialize(from: pointer + 1, count: newCount - index)
    _buffer.mutableCount = newCount
    _endMutation()
    return result
  }
  @inlinable public mutating func insert(_ newElement: __owned Element, at i: Swift.Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else if _buffer.isMutableAndUniquelyReferenced() {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
    else {
      _buffer = _Buffer(_uninitializedCount: 0, minimumCapacity: capacity)
    }
  }
  @available(*, deprecated, renamed: "withContiguousMutableStorageIfAvailable")
  @inlinable public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    if let n = _buffer.requestNativeBuffer() {
      return ContiguousArray(_buffer: n)
    }
    return _copyCollectionToContiguousArray(self)
  }
}
extension Swift.ContiguousArray : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.ContiguousArray : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.ContiguousArray {
  @usableFromInline
  @_transparent internal func _cPointerArgs() -> (Swift.AnyObject?, Swift.UnsafeRawPointer?) {
    let p = _baseAddressIfContiguous
    if _fastPath(p != nil || isEmpty) {
      return (_owner, UnsafeRawPointer(p))
    }
    let n = ContiguousArray(self._buffer)._buffer
    return (n.owner, UnsafeRawPointer(n.firstElementAddress))
  }
}
extension Swift.ContiguousArray {
  @_alwaysEmitIntoClient @inlinable public init(unsafeUninitializedCapacity: Swift.Int, initializingWith initializer: (_ buffer: inout Swift.UnsafeMutableBufferPointer<Element>, _ initializedCount: inout Swift.Int) throws -> Swift.Void) rethrows {
    self = try ContiguousArray(Array(
      _unsafeUninitializedCapacity: unsafeUninitializedCapacity,
      initializingWith: initializer))
  }
  @inlinable public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
  @_semantics("array.withUnsafeMutableBufferPointer") @inlinable @inline(__always) public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    _makeMutableAndUnique()
    let count = _buffer.mutableCount

     
    let pointer = _buffer.mutableFirstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    defer {
      _precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "ContiguousArray withUnsafeMutableBufferPointer: replacing the buffer is not allowed")
      _endMutation()
      _fixLifetime(self)
    }

     
    return try body(&inoutBufferPointer)
  }
  @inlinable public __consuming func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.ContiguousArray<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {

    guard !self.isEmpty else { return (makeIterator(),buffer.startIndex) }

     
     
    guard var p = buffer.baseAddress
      else { _preconditionFailure("Attempt to copy contents into nil buffer pointer") }
    _precondition(self.count <= buffer.count, 
      "Insufficient space allocated to copy array contents")

    if let s = _baseAddressIfContiguous {
      p.initialize(from: s, count: self.count)
       
       
      _fixLifetime(self._owner)
    } else {
      for x in self {
        p.initialize(to: x)
        p += 1
      }
    }

    var it = IndexingIterator(_elements: self)
    it._position = endIndex
    return (it,buffer.index(buffer.startIndex, offsetBy: self.count))
  }
}
extension Swift.ContiguousArray {
  @inlinable @_semantics("array.mutate_unknown") public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Int>, with newElements: __owned C) where Element == C.Element, C : Swift.Collection {
    _precondition(subrange.lowerBound >= self._buffer.startIndex,
      "ContiguousArray replace: subrange start is negative")

    _precondition(subrange.upperBound <= _buffer.endIndex,
      "ContiguousArray replace: subrange extends past the end")

    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    _reserveCapacityImpl(minimumCapacity: self.count + growth,
                         growForAppend: true)
    _buffer.replaceSubrange(subrange, with: insertCount, elementsOf: newElements)
    _endMutation()
  }
}
extension Swift.ContiguousArray : Swift.Equatable where Element : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.ContiguousArray<Element>, rhs: Swift.ContiguousArray<Element>) -> Swift.Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

     
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    _internalInvariant(lhs.startIndex == 0 && rhs.startIndex == 0)
    _internalInvariant(lhs.endIndex == lhsCount && rhs.endIndex == lhsCount)

     
    for idx in 0..<lhsCount {
      if lhs[idx] != rhs[idx] {
        return false
      }
    }

    return true
  }
}
extension Swift.ContiguousArray : Swift.Hashable where Element : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(count)  
    for element in self {
      hasher.combine(element)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.ContiguousArray {
  @inlinable public mutating func withUnsafeMutableBytes<R>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}
extension Swift.ContiguousArray : @unchecked Swift.Sendable where Element : Swift.Sendable {
}
@usableFromInline
internal protocol _HasContiguousBytes {
  func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  var _providesContiguousBytesNoCopy: Swift.Bool { get }
}
extension Swift._HasContiguousBytes {
  @inlinable internal var _providesContiguousBytesNoCopy: Swift.Bool {
    @inline(__always) get { return true }
  }
}
extension Swift.Array : Swift._HasContiguousBytes {
  @inlinable internal var _providesContiguousBytesNoCopy: Swift.Bool {
    @inline(__always) get {
      return _buffer._isNative
    }
  }
}
extension Swift.ContiguousArray : Swift._HasContiguousBytes {
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeBufferPointer : Swift._HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    let ptr = UnsafeRawPointer(self.baseAddress)
    let len = self.count &* MemoryLayout<Element>.stride
    return try body(UnsafeRawBufferPointer(start: ptr, count: len))
  }
}
#else
extension Swift.UnsafeBufferPointer : Swift._HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    let ptr = UnsafeRawPointer(self.baseAddress)
    let len = self.count &* MemoryLayout<Element>.stride
    return try body(UnsafeRawBufferPointer(start: ptr, count: len))
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer : Swift._HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    let ptr = UnsafeRawPointer(self.baseAddress)
    let len = self.count &* MemoryLayout<Element>.stride
    return try body(UnsafeRawBufferPointer(start: ptr, count: len))
  }
}
#else
extension Swift.UnsafeMutableBufferPointer : Swift._HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    let ptr = UnsafeRawPointer(self.baseAddress)
    let len = self.count &* MemoryLayout<Element>.stride
    return try body(UnsafeRawBufferPointer(start: ptr, count: len))
  }
}
#endif
extension Swift.UnsafeRawBufferPointer : Swift._HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try body(self)
  }
}
extension Swift.UnsafeMutableRawBufferPointer : Swift._HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try body(UnsafeRawBufferPointer(self))
  }
}
extension Swift.String : Swift._HasContiguousBytes {
  @inlinable internal var _providesContiguousBytesNoCopy: Swift.Bool {
    @inline(__always) get { return self._guts.isFastUTF8 }
  }
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    var copy = self
    return try copy.withUTF8 { return try body(UnsafeRawBufferPointer($0)) }
  }
}
extension Swift.Substring : Swift._HasContiguousBytes {
  @inlinable internal var _providesContiguousBytesNoCopy: Swift.Bool {
    @inline(__always) get { return self._wholeGuts.isFastUTF8 }
  }
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    var copy = self
    return try copy.withUTF8 { return try body(UnsafeRawBufferPointer($0)) }
  }
}
@frozen public struct ClosedRange<Bound> where Bound : Swift.Comparable {
  public let lowerBound: Bound
  public let upperBound: Bound
  @_alwaysEmitIntoClient @inline(__always) internal init(_uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    self.lowerBound = bounds.lower
    self.upperBound = bounds.upper
  }
  @inlinable public init(uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    _debugPrecondition(bounds.lower <= bounds.upper,
      "ClosedRange requires lowerBound <= upperBound")
    self.init(_uncheckedBounds: (lower: bounds.lower, upper: bounds.upper))
  }
}
extension Swift.ClosedRange {
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return false
  }
  }
}
extension Swift.ClosedRange : Swift.RangeExpression {
  @inlinable public func relative<C>(to collection: C) -> Swift.Range<Bound> where Bound == C.Index, C : Swift.Collection {
    return Range(
      _uncheckedBounds: (
        lower: lowerBound,
        upper: collection.index(after: self.upperBound)))
  }
  @inlinable public func contains(_ element: Bound) -> Swift.Bool {
    return element >= self.lowerBound && element <= self.upperBound
  }
}
extension Swift.ClosedRange : Swift.Sequence where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias Element = Bound
  public typealias Iterator = Swift.IndexingIterator<Swift.ClosedRange<Bound>>
}
extension Swift.ClosedRange where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  @frozen public enum Index {
    case pastEnd
    case inRange(Bound)
  }
}
extension Swift.ClosedRange.Index : Swift.Comparable {
  @inlinable public static func == (lhs: Swift.ClosedRange<Bound>.Index, rhs: Swift.ClosedRange<Bound>.Index) -> Swift.Bool {
    switch (lhs, rhs) {
    case (.inRange(let l), .inRange(let r)):
      return l == r
    case (.pastEnd, .pastEnd):
      return true
    default:
      return false
    }
  }
  @inlinable public static func < (lhs: Swift.ClosedRange<Bound>.Index, rhs: Swift.ClosedRange<Bound>.Index) -> Swift.Bool {
    switch (lhs, rhs) {
    case (.inRange(let l), .inRange(let r)):
      return l < r
    case (.inRange, .pastEnd):
      return true
    default:
      return false
    }
  }
}
extension Swift.ClosedRange.Index : Swift.Hashable where Bound : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    switch self {
    case .inRange(let value):
      hasher.combine(0 as Int8)
      hasher.combine(value)
    case .pastEnd:
      hasher.combine(1 as Int8)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.ClosedRange : Swift.Collection, Swift.BidirectionalCollection, Swift.RandomAccessCollection where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias SubSequence = Swift.Slice<Swift.ClosedRange<Bound>>
  @inlinable public var startIndex: Swift.ClosedRange<Bound>.Index {
    get {
    return .inRange(lowerBound)
  }
  }
  @inlinable public var endIndex: Swift.ClosedRange<Bound>.Index {
    get {
    return .pastEnd
  }
  }
  @inlinable public func index(after i: Swift.ClosedRange<Bound>.Index) -> Swift.ClosedRange<Bound>.Index {
    switch i {
    case .inRange(let x):
      return x == upperBound
        ? .pastEnd
        : .inRange(x.advanced(by: 1))
    case .pastEnd: 
      _preconditionFailure("Incrementing past end index")
    }
  }
  @inlinable public func index(before i: Swift.ClosedRange<Bound>.Index) -> Swift.ClosedRange<Bound>.Index {
    switch i {
    case .inRange(let x):
      _precondition(x > lowerBound, "Incrementing past start index")
      return .inRange(x.advanced(by: -1))
    case .pastEnd: 
      _precondition(upperBound >= lowerBound, "Incrementing past start index")
      return .inRange(upperBound)
    }
  }
  @inlinable public func index(_ i: Swift.ClosedRange<Bound>.Index, offsetBy distance: Swift.Int) -> Swift.ClosedRange<Bound>.Index {
    switch i {
    case .inRange(let x):
      let d = x.distance(to: upperBound)
      if distance <= d {
        let newPosition = x.advanced(by: numericCast(distance))
        _precondition(newPosition >= lowerBound,
          "Advancing past start index")
        return .inRange(newPosition)
      }
      if d - -1 == distance { return .pastEnd }
      _preconditionFailure("Advancing past end index")
    case .pastEnd:
      if distance == 0 {
        return i
      } 
      if distance < 0 {
        return index(.inRange(upperBound), offsetBy: numericCast(distance + 1))
      }
      _preconditionFailure("Advancing past end index")
    }
  }
  @inlinable public func distance(from start: Swift.ClosedRange<Bound>.Index, to end: Swift.ClosedRange<Bound>.Index) -> Swift.Int {
    switch (start, end) {
    case let (.inRange(left), .inRange(right)):
       
      return numericCast(left.distance(to: right))
    case let (.inRange(left), .pastEnd):
       
      return numericCast(1 + left.distance(to: upperBound))
    case let (.pastEnd, .inRange(right)):
       
      return numericCast(upperBound.distance(to: right) - 1)
    case (.pastEnd, .pastEnd):
       
      return 0
    }
  }
  @inlinable public subscript(position: Swift.ClosedRange<Bound>.Index) -> Bound {
    get {
     
    switch position {
    case .inRange(let x): return x
    case .pastEnd: _preconditionFailure("Index out of range")
    }
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.ClosedRange<Bound>.Index>) -> Swift.Slice<Swift.ClosedRange<Bound>> {
    get {
    return Slice(base: self, bounds: bounds)
  }
  }
  @inlinable public func _customContainsEquatableElement(_ element: Bound) -> Swift.Bool? {
    return lowerBound <= element && element <= upperBound
  }
  @inlinable public func _customIndexOfEquatableElement(_ element: Bound) -> Swift.ClosedRange<Bound>.Index?? {
    return lowerBound <= element && element <= upperBound
              ? .inRange(element) : nil
  }
  @inlinable public func _customLastIndexOfEquatableElement(_ element: Bound) -> Swift.ClosedRange<Bound>.Index?? {
     
    return _customIndexOfEquatableElement(element)
  }
  public typealias Indices = Swift.DefaultIndices<Swift.ClosedRange<Bound>>
}
extension Swift.Comparable {
  @_transparent public static func ... (minimum: Self, maximum: Self) -> Swift.ClosedRange<Self> {
    _precondition(
      minimum <= maximum, "Range requires lowerBound <= upperBound")
    return ClosedRange(_uncheckedBounds: (lower: minimum, upper: maximum))
  }
}
extension Swift.ClosedRange : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.ClosedRange<Bound>, rhs: Swift.ClosedRange<Bound>) -> Swift.Bool {
    return lhs.lowerBound == rhs.lowerBound && lhs.upperBound == rhs.upperBound
  }
}
extension Swift.ClosedRange : Swift.Hashable where Bound : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(lowerBound)
    hasher.combine(upperBound)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.ClosedRange : Swift.CustomStringConvertible {
  @inlinable public var description: Swift.String {
    get {
    return "\(lowerBound)...\(upperBound)"
  }
  }
}
extension Swift.ClosedRange : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.ClosedRange : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.ClosedRange {
  @inlinable @inline(__always) public func clamped(to limits: Swift.ClosedRange<Bound>) -> Swift.ClosedRange<Bound> {
    let lower =         
      limits.lowerBound > self.lowerBound ? limits.lowerBound
          : limits.upperBound < self.lowerBound ? limits.upperBound
          : self.lowerBound
    let upper =
      limits.upperBound < self.upperBound ? limits.upperBound
          : limits.lowerBound > self.upperBound ? limits.lowerBound
          : self.upperBound
    return ClosedRange(_uncheckedBounds: (lower: lower, upper: upper))
  }
}
extension Swift.ClosedRange where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  @inlinable public init(_ other: Swift.Range<Bound>) {
    _precondition(!other.isEmpty, "Can't form an empty closed range")
    let upperBound = other.upperBound.advanced(by: -1)
    self.init(_uncheckedBounds: (lower: other.lowerBound, upper: upperBound))
  }
}
extension Swift.ClosedRange {
  @inlinable public func overlaps(_ other: Swift.ClosedRange<Bound>) -> Swift.Bool {
     
     
     
    let isDisjoint = other.upperBound < self.lowerBound
      || self.upperBound < other.lowerBound
    return !isDisjoint
  }
  @inlinable public func overlaps(_ other: Swift.Range<Bound>) -> Swift.Bool {
    return other.overlaps(self)
  }
}
public typealias CountableClosedRange<Bound> = Swift.ClosedRange<Bound> where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger
extension Swift.ClosedRange : Swift.Decodable where Bound : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.ClosedRange : Swift.Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.ClosedRange : Swift.Sendable where Bound : Swift.Sendable {
}
extension Swift.ClosedRange.Index : Swift.Sendable where Bound : Swift.Sendable {
}
@objc @usableFromInline
@_fixed_layout @_objc_non_lazy_realization final internal class __EmptyArrayStorage : Swift.__ContiguousArrayStorageBase {
  @inlinable @nonobjc internal init(_doNotCallMe: ()) {
    _internalInvariantFailure("creating instance of __EmptyArrayStorage")
  }
  @inlinable override final internal func canStoreElements(ofDynamicType _: any Any.Type) -> Swift.Bool {
    return false
  }
  @inlinable override final internal var staticElementType: any Any.Type {
    get {
    return Void.self
  }
  }
  @objc @usableFromInline
  deinit
}
@available(*, unavailable)
extension Swift.__EmptyArrayStorage : Swift.Sendable {
}
@objc @usableFromInline
@_fixed_layout @_objc_non_lazy_realization final internal class __StaticArrayStorage : Swift.__ContiguousArrayStorageBase {
  @inlinable @nonobjc internal init(_doNotCallMe: ()) {
    _internalInvariantFailure("creating instance of __StaticArrayStorage")
  }
  @inlinable override final internal func canStoreElements(ofDynamicType _: any Any.Type) -> Swift.Bool {
    return false
  }
  @inlinable override final internal var staticElementType: any Any.Type {
    get {
    fatalError("__StaticArrayStorage.staticElementType must not be called")
  }
  }
  @objc @usableFromInline
  deinit
}
@available(*, unavailable)
extension Swift.__StaticArrayStorage : Swift.Sendable {
}
@inlinable internal var _emptyArrayStorage: Swift.__EmptyArrayStorage {
  get {
  return Builtin.bridgeFromRawPointer(
    Builtin.addressof(&_swiftEmptyArrayStorage))
}
}
@_inheritsConvenienceInitializers @usableFromInline
@_fixed_layout final internal class _ContiguousArrayStorage<Element> : Swift.__ContiguousArrayStorageBase {
  @objc @inlinable deinit {
    _elementPointer.deinitialize(count: countAndCapacity.count)
    _fixLifetime(self)
  }
  @inlinable override final internal func canStoreElements(ofDynamicType proposedElementType: any Any.Type) -> Swift.Bool {
    return proposedElementType is Element.Type
  }
  @inlinable override final internal var staticElementType: any Any.Type {
    get {
    return Element.self
  }
  }
  @inlinable final internal var _elementPointer: Swift.UnsafeMutablePointer<Element> {
    get {
    return UnsafeMutablePointer(Builtin.projectTailElems(self, Element.self))
  }
  }
  @inlinable override internal init(_doNotCallMeBase: ())
}
@available(*, unavailable)
extension Swift._ContiguousArrayStorage : Swift.Sendable {
}
@_alwaysEmitIntoClient @inline(__always) internal func _uncheckedUnsafeBitCast<T, U>(_ x: T, to type: U.Type) -> U {
  return Builtin.reinterpretCast(x)
}
@_alwaysEmitIntoClient @inline(never) @_effects(readonly) @_semantics("array.getContiguousArrayStorageType") internal func getContiguousArrayStorageType<Element>(for: Element.Type) -> Swift._ContiguousArrayStorage<Element>.Type {
     
     
    if #available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *) {  
      if Element.self is AnyObject.Type {
        return _uncheckedUnsafeBitCast(
          _ContiguousArrayStorage<AnyObject>.self,
          to: _ContiguousArrayStorage<Element>.Type.self)
      }
    }
    return _ContiguousArrayStorage<Element>.self
}
@usableFromInline
@frozen internal struct _ContiguousArrayBuffer<Element> : Swift._ArrayBufferProtocol {
  @usableFromInline
  internal var _storage: Swift.__ContiguousArrayStorageBase
  @inlinable internal init(_uninitializedCount uninitializedCount: Swift.Int, minimumCapacity: Swift.Int) {
    let realMinimumCapacity = Swift.max(uninitializedCount, minimumCapacity)
    if realMinimumCapacity == 0 {
      self = _ContiguousArrayBuffer<Element>()
    }
    else {
      #if !$Embedded
      _storage = Builtin.allocWithTailElems_1(
         getContiguousArrayStorageType(for: Element.self), realMinimumCapacity._builtinWordValue, Element.self)
      #else
      _storage = Builtin.allocWithTailElems_1(
         _ContiguousArrayStorage<Element>.self, realMinimumCapacity._builtinWordValue, Element.self)
      #endif

      let storageAddr = UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(_storage))
      let allocSize: Int?
      #if !$Embedded
      allocSize = _mallocSize(ofAllocation: storageAddr)
      #else
      allocSize = nil
      #endif
      if let allocSize {
        let endAddr = storageAddr + allocSize
        let realCapacity = endAddr.assumingMemoryBound(to: Element.self) - firstElementAddress
        _initStorageHeader(
          count: uninitializedCount, capacity: realCapacity)
      } else {
        _initStorageHeader(
          count: uninitializedCount, capacity: realMinimumCapacity)
      }
    }
  }
  @inlinable internal init(count: Swift.Int, storage: Swift._ContiguousArrayStorage<Element>) {
    _storage = storage

    _initStorageHeader(count: count, capacity: count)
  }
  @inlinable internal init(_ storage: Swift.__ContiguousArrayStorageBase) {
    _storage = storage
  }
  @inlinable internal func _initStorageHeader(count: Swift.Int, capacity: Swift.Int) {
    let verbatim = _isBridgedVerbatimToObjectiveC(Element.self)

     
     
    _storage.countAndCapacity = _ArrayBody(
      count: count,
      capacity: capacity,
      elementTypeIsBridgedVerbatim: verbatim)
  }
  @inlinable internal var arrayPropertyIsNativeTypeChecked: Swift.Bool {
    get {
    return true
  }
  }
  @inlinable internal var firstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    return UnsafeMutablePointer(Builtin.projectTailElems(_storage,
                                                         Element.self))
  }
  }
  @_alwaysEmitIntoClient internal var mutableFirstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    return UnsafeMutablePointer(Builtin.projectTailElems(mutableOrEmptyStorage,
                                                         Element.self))
  }
  }
  @inlinable internal var firstElementAddressIfContiguous: Swift.UnsafeMutablePointer<Element>? {
    get {
    return firstElementAddress
  }
  }
  @inlinable internal func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(UnsafeBufferPointer(start: firstElementAddress,
      count: count))
  }
  @inlinable internal mutating func withUnsafeMutableBufferPointer<R>(_ body: (Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(
      UnsafeMutableBufferPointer(start: firstElementAddress, count: count))
  }
  @inlinable internal init() {
    _storage = _emptyArrayStorage
  }
  @inlinable internal init(_buffer buffer: Swift._ContiguousArrayBuffer<Element>, shiftedToStartIndex: Swift.Int) {
    _internalInvariant(shiftedToStartIndex == 0, "shiftedToStartIndex must be 0")
    self = buffer
  }
  @inlinable internal mutating func requestUniqueMutableBackingBuffer(minimumCapacity: Swift.Int) -> Swift._ContiguousArrayBuffer<Element>? {
    if _fastPath(isUniquelyReferenced() && capacity >= minimumCapacity) {
      return self
    }
    return nil
  }
  @inlinable internal mutating func isMutableAndUniquelyReferenced() -> Swift.Bool {
    return isUniquelyReferenced()
  }
  @inlinable internal func requestNativeBuffer() -> Swift._ContiguousArrayBuffer<Element>? {
    return self
  }
  @inlinable @inline(__always) internal func getElement(_ i: Swift.Int) -> Element {
    _internalInvariant(i >= 0 && i < count, "Array index out of range")
    let addr = UnsafePointer<Element>(
      Builtin.projectTailElems(immutableStorage, Element.self))
    return addr[i]
  }
  @_alwaysEmitIntoClient @inline(__always) internal var immutableStorage: Swift.__ContiguousArrayStorageBase {
    get {
    return Builtin.COWBufferForReading(_storage)
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var mutableStorage: Swift.__ContiguousArrayStorageBase {
    get {
    return _storage
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var mutableOrEmptyStorage: Swift.__ContiguousArrayStorageBase {
    get {
    return _storage
  }
  }
  @inlinable internal subscript(i: Swift.Int) -> Element {
    @inline(__always) get {
      return getElement(i)
    }
    @inline(__always) nonmutating set {
      _internalInvariant(i >= 0 && i < count, "Array index out of range")

       
       
       
      var nv = newValue
      let tmp = nv
      nv = firstElementAddress[i]
      firstElementAddress[i] = tmp
    }
  }
  @inlinable internal var count: Swift.Int {
    get {
      return _storage.countAndCapacity.count
    }
    nonmutating set {
      _internalInvariant(newValue >= 0)

      _internalInvariant(
        newValue <= mutableCapacity,
        "Can't grow an array buffer past its capacity")

      mutableStorage.countAndCapacity.count = newValue
    }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var immutableCount: Swift.Int {
    get {
    return immutableStorage.countAndCapacity.count
  }
  }
  @_alwaysEmitIntoClient internal var mutableCount: Swift.Int {
    @inline(__always) get {
      return mutableOrEmptyStorage.countAndCapacity.count
    }
    @inline(__always) nonmutating set {
      _internalInvariant(newValue >= 0)

      _internalInvariant(
        newValue <= mutableCapacity,
        "Can't grow an array buffer past its capacity")

      mutableStorage.countAndCapacity.count = newValue
    }
  }
  @inlinable @inline(__always) internal func _checkValidSubscript(_ index: Swift.Int) {
    _precondition(
      (index >= 0) && (index < immutableCount),
      "Index out of range"
    )
  }
  @_alwaysEmitIntoClient @inline(__always) internal func _checkValidSubscriptMutating(_ index: Swift.Int) {
    _precondition(
      (index >= 0) && (index < mutableCount),
      "Index out of range"
    )
  }
  @inlinable internal var capacity: Swift.Int {
    get {
    return _storage.countAndCapacity.capacity
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var immutableCapacity: Swift.Int {
    get {
    return immutableStorage.countAndCapacity.capacity
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var mutableCapacity: Swift.Int {
    get {
    return mutableOrEmptyStorage.countAndCapacity.capacity
  }
  }
  @discardableResult
  @inlinable internal __consuming func _copyContents(subRange bounds: Swift.Range<Swift.Int>, initializing target: Swift.UnsafeMutablePointer<Element>) -> Swift.UnsafeMutablePointer<Element> {
    _internalInvariant(bounds.lowerBound >= 0)
    _internalInvariant(bounds.upperBound >= bounds.lowerBound)
    _internalInvariant(bounds.upperBound <= count)

    let initializedCount = bounds.upperBound - bounds.lowerBound
    target.initialize(
      from: firstElementAddress + bounds.lowerBound, count: initializedCount)
    _fixLifetime(owner)
    return target + initializedCount
  }
  @inlinable internal __consuming func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift._ContiguousArrayBuffer<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    guard buffer.count > 0 else { return (makeIterator(), 0) }
    let c = Swift.min(self.count, buffer.count)
    buffer.baseAddress!.initialize(
      from: firstElementAddress,
      count: c)
    _fixLifetime(owner)
    return (IndexingIterator(_elements: self, _position: c), c)
  }
  @inlinable internal subscript(bounds: Swift.Range<Swift.Int>) -> Swift._SliceBuffer<Element> {
    get {
      #if $Embedded
      let storage = Builtin.castToNativeObject(_storage)
      #else
      let storage = _storage
      #endif
      return _SliceBuffer(
        owner: storage,
        subscriptBaseAddress: firstElementAddress,
        indices: bounds,
        hasNativeBuffer: true)
    }
    set {
      fatalError("not implemented")
    }
  }
  @inlinable internal mutating func isUniquelyReferenced() -> Swift.Bool {
    return _isUnique(&_storage)
  }
  @_alwaysEmitIntoClient internal mutating func beginCOWMutation() -> Swift.Bool {
    if Bool(Builtin.beginCOWMutation(&_storage)) {
      return true
    }
    return false;
  }
  @_alwaysEmitIntoClient @inline(__always) internal mutating func endCOWMutation() {
    Builtin.endCOWMutation(&_storage)
  }
  @_alwaysEmitIntoClient @inline(never) @_semantics("optimize.sil.specialize.owned2guarantee.never") internal __consuming func _consumeAndCreateNew() -> Swift._ContiguousArrayBuffer<Element> {
    return _consumeAndCreateNew(bufferIsUnique: false,
                                minimumCapacity: count,
                                growForAppend: false)
  }
  @_alwaysEmitIntoClient @inline(never) @_semantics("optimize.sil.specialize.owned2guarantee.never") internal __consuming func _consumeAndCreateNew(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) -> Swift._ContiguousArrayBuffer<Element> {
    let newCapacity = _growArrayCapacity(oldCapacity: capacity,
                                         minimumCapacity: minimumCapacity,
                                         growForAppend: growForAppend)
    let c = count
    _internalInvariant(newCapacity >= c)
    
    let newBuffer = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: c, minimumCapacity: newCapacity)

    if bufferIsUnique {
       
       
      let dest = newBuffer.mutableFirstElementAddress
      dest.moveInitialize(from: firstElementAddress,
                          count: c)
      mutableCount = 0
    } else {
      _copyContents(
        subRange: 0..<c,
        initializing: newBuffer.mutableFirstElementAddress)
    }
    return newBuffer
  }
  @usableFromInline
  internal __consuming func _asCocoaArray() -> Swift.AnyObject
  @inlinable internal var owner: Swift.AnyObject {
    get {
    #if !$Embedded
    return _storage
    #else
    return Builtin.castToNativeObject(_storage)
    #endif
  }
  }
  @inlinable internal var nativeOwner: Swift.AnyObject {
    get {
    return owner
  }
  }
  @inlinable internal var identity: Swift.UnsafeRawPointer {
    get {
    return UnsafeRawPointer(firstElementAddress)
  }
  }
  @inlinable internal func canStoreElements(ofDynamicType proposedElementType: any Any.Type) -> Swift.Bool {
    return _storage.canStoreElements(ofDynamicType: proposedElementType)
  }
  @inlinable internal func storesOnlyElementsOfType<U>(_: U.Type) -> Swift.Bool {
    _internalInvariant(_isClassOrObjCExistential(U.self))

    if _fastPath(_storage.staticElementType is U.Type) {
       
      return true
    }

     
    for x in self {
      if !(x is U) {
        return false
      }
    }
    return true
  }
}
@available(*, unavailable)
extension Swift._ContiguousArrayBuffer : Swift.Sendable {
}
@inlinable internal func += <Element, C>(lhs: inout Swift._ContiguousArrayBuffer<Element>, rhs: __owned C) where Element == C.Element, C : Swift.Collection {

  let oldCount = lhs.count
  let newCount = oldCount + rhs.count

  let buf: UnsafeMutableBufferPointer<Element>
  
  if _fastPath(newCount <= lhs.capacity) {
    buf = UnsafeMutableBufferPointer(
      start: lhs.firstElementAddress + oldCount,
      count: rhs.count)
    lhs.mutableCount = newCount
  }
  else {
    var newLHS = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: newCount,
      minimumCapacity: _growArrayCapacity(lhs.capacity))

    newLHS.firstElementAddress.moveInitialize(
      from: lhs.firstElementAddress, count: oldCount)
    lhs.mutableCount = 0
    (lhs, newLHS) = (newLHS, lhs)
    buf = UnsafeMutableBufferPointer(
      start: lhs.firstElementAddress + oldCount,
      count: rhs.count)
  }

  var (remainders,writtenUpTo) = buf.initialize(from: rhs)

   
  _precondition(remainders.next() == nil, "rhs underreported its count")
  _precondition(writtenUpTo == buf.endIndex, "rhs overreported its count")    
}
extension Swift._ContiguousArrayBuffer : Swift.RandomAccessCollection {
  @inlinable internal var startIndex: Swift.Int {
    get {
    return 0
  }
  }
  @inlinable internal var endIndex: Swift.Int {
    get {
    return count
  }
  }
  @usableFromInline
  internal typealias Indices = Swift.Range<Swift.Int>
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._ContiguousArrayBuffer<Element>>
  @usableFromInline
  internal typealias SubSequence = Swift._SliceBuffer<Element>
}
extension Swift.Sequence {
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element> {
    return _copySequenceToContiguousArray(self)
  }
}
@inlinable internal func _copySequenceToContiguousArray<S>(_ source: S) -> Swift.ContiguousArray<S.Element> where S : Swift.Sequence {
  let initialCapacity = source.underestimatedCount
  var builder =
    _UnsafePartiallyInitializedContiguousArrayBuffer<S.Element>(
      initialCapacity: initialCapacity)

  var iterator = source.makeIterator()

   

   
  for _ in 0..<initialCapacity {
    builder.addWithExistingCapacity(iterator.next()!)
  }

   
  while let element = iterator.next() {
    builder.add(element)
  }

  return builder.finish()
}
extension Swift.Collection {
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element> {
    return _copyCollectionToContiguousArray(self)
  }
}
extension Swift._ContiguousArrayBuffer {
  @inlinable internal __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    return ContiguousArray(_buffer: self)
  }
}
@inlinable internal func _copyCollectionToContiguousArray<C>(_ source: C) -> Swift.ContiguousArray<C.Element> where C : Swift.Collection {
  let count = source.count
  if count == 0 {
    return ContiguousArray()
  }

  var result = _ContiguousArrayBuffer<C.Element>(
    _uninitializedCount: count,
    minimumCapacity: 0)

  let p = UnsafeMutableBufferPointer(
    start: result.firstElementAddress,
    count: count)
  var (itr, end) = source._copyContents(initializing: p)

  _debugPrecondition(itr.next() == nil,
    "invalid Collection: more than 'count' elements in collection")
   
   
   
  _precondition(end == p.endIndex,
    "invalid Collection: less than 'count' elements in collection")

  result.endCOWMutation()
  return ContiguousArray(_buffer: result)
}
@usableFromInline
@frozen internal struct _UnsafePartiallyInitializedContiguousArrayBuffer<Element> {
  @usableFromInline
  internal var result: Swift._ContiguousArrayBuffer<Element>
  @usableFromInline
  internal var p: Swift.UnsafeMutablePointer<Element>
  @usableFromInline
  internal var remainingCapacity: Swift.Int
  @inlinable @inline(__always) internal init(initialCapacity: Swift.Int) {
    if initialCapacity == 0 {
      result = _ContiguousArrayBuffer()
    } else {
      result = _ContiguousArrayBuffer(
        _uninitializedCount: initialCapacity,
        minimumCapacity: 0)
    }

    p = result.firstElementAddress
    remainingCapacity = result.capacity
  }
  @inlinable @inline(__always) internal mutating func add(_ element: Element) {
    if remainingCapacity == 0 {
       
      let newCapacity = max(_growArrayCapacity(result.capacity), 1)
      var newResult = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: newCapacity, minimumCapacity: 0)
      p = newResult.firstElementAddress + result.capacity
      remainingCapacity = newResult.capacity - result.capacity
      if !result.isEmpty {
         
         
        newResult.firstElementAddress.moveInitialize(
          from: result.firstElementAddress, count: result.capacity)
        result.mutableCount = 0
      }
      (result, newResult) = (newResult, result)
    }
    addWithExistingCapacity(element)
  }
  @inlinable @inline(__always) internal mutating func addWithExistingCapacity(_ element: Element) {
    _internalInvariant(remainingCapacity > 0,
      "_UnsafePartiallyInitializedContiguousArrayBuffer has no more capacity")
    remainingCapacity -= 1

    p.initialize(to: element)
    p += 1
  }
  @inlinable @inline(__always) internal mutating func finish() -> Swift.ContiguousArray<Element> {
     
    if (result.capacity != 0) {
      result.mutableCount = result.capacity - remainingCapacity
    } else {
      _internalInvariant(remainingCapacity == 0)
      _internalInvariant(result.count == 0)      
    }

    return finishWithOriginalCount()
  }
  @inlinable @inline(__always) internal mutating func finishWithOriginalCount() -> Swift.ContiguousArray<Element> {
    _internalInvariant(remainingCapacity == result.capacity - result.count,
      "_UnsafePartiallyInitializedContiguousArrayBuffer has incorrect count")
    var finalResult = _ContiguousArrayBuffer<Element>()
    (finalResult, result) = (result, finalResult)
    remainingCapacity = 0
    finalResult.endCOWMutation()
    return ContiguousArray(_buffer: finalResult)
  }
}
@available(*, unavailable)
extension Swift._UnsafePartiallyInitializedContiguousArrayBuffer : Swift.Sendable {
}
extension Swift.String {
  public init(cString nullTerminatedUTF8: Swift.UnsafePointer<Swift.CChar>)
  @available(swift, deprecated: 6, message: "Use String(decoding: array, as: UTF8.self) instead, after truncating the null termination.")
  @inlinable @_alwaysEmitIntoClient public init(cString nullTerminatedUTF8: [Swift.CChar]) {
    self = nullTerminatedUTF8.withUnsafeBufferPointer {
      $0.withMemoryRebound(to: UInt8.self, String.init(_checkingCString:))
    }
  }
  @_alwaysEmitIntoClient private init(_checkingCString bytes: Swift.UnsafeBufferPointer<Swift.UInt8>) {
    guard let length = bytes.firstIndex(of: 0) else {
      _preconditionFailure(
        "input of String.init(cString:) must be null-terminated"
      )
    }
    self = String._fromUTF8Repairing(
      UnsafeBufferPointer(
        start: bytes.baseAddress._unsafelyUnwrappedUnchecked,
        count: length
      )
    ).0
  }
  @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
  @inlinable @_alwaysEmitIntoClient public init(cString nullTerminatedUTF8: inout Swift.CChar) {
    guard nullTerminatedUTF8 == 0 else {
      _preconditionFailure(
        "input of String.init(cString:) must be null-terminated"
      )
    }
    self = ""
  }
  public init(cString nullTerminatedUTF8: Swift.UnsafePointer<Swift.UInt8>)
  @available(swift, deprecated: 6, message: "Use String(decoding: array, as: UTF8.self) instead, after truncating the null termination.")
  @inlinable @_alwaysEmitIntoClient public init(cString nullTerminatedUTF8: [Swift.UInt8]) {
    self = nullTerminatedUTF8.withUnsafeBufferPointer {
      String(_checkingCString: $0)
    }
  }
  @available(*, deprecated, message: "Use a copy of the String argument")
  @inlinable @_alwaysEmitIntoClient public init(cString nullTerminatedUTF8: Swift.String) {
    self = nullTerminatedUTF8.withCString(String.init(cString:))
  }
  @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
  @inlinable @_alwaysEmitIntoClient public init(cString nullTerminatedUTF8: inout Swift.UInt8) {
    guard nullTerminatedUTF8 == 0 else {
      _preconditionFailure(
        "input of String.init(cString:) must be null-terminated"
      )
    }
    self = ""
  }
  @_silgen_name("$sSS14validatingUTF8SSSgSPys4Int8VG_tcfC")
  public init?(validatingCString nullTerminatedUTF8: Swift.UnsafePointer<Swift.CChar>)
  @available(swift, deprecated: 6, renamed: "String.init(validatingCString:)")
  @_silgen_name("_swift_se0405_String_validatingUTF8")
  @inlinable @_alwaysEmitIntoClient public init?(validatingUTF8 cString: Swift.UnsafePointer<Swift.CChar>) {
    self.init(validatingCString: cString)
  }
  @available(swift, deprecated: 6, message: "Use String(validating: array, as: UTF8.self) instead, after truncating the null termination.")
  @inlinable @_alwaysEmitIntoClient public init?(validatingCString nullTerminatedUTF8: [Swift.CChar]) {
    guard let length = nullTerminatedUTF8.firstIndex(of: 0) else {
      _preconditionFailure(
        "input of String.init(validatingCString:) must be null-terminated"
      )
    }
    let string = nullTerminatedUTF8.prefix(length).withUnsafeBufferPointer {
      $0.withMemoryRebound(to: UInt8.self, String._tryFromUTF8(_:))
    }
    guard let string else { return nil }
    self = string
  }
  @available(swift, deprecated: 6, message: "Use String(validating: array, as: UTF8.self) instead, after truncating the null termination.")
  @inlinable @_alwaysEmitIntoClient public init?(validatingUTF8 cString: [Swift.CChar]) {
    self.init(validatingCString: cString)
  }
  @available(*, deprecated, message: "Use a copy of the String argument")
  @inlinable @_alwaysEmitIntoClient public init?(validatingCString nullTerminatedUTF8: Swift.String) {
    self = nullTerminatedUTF8.withCString(String.init(cString:))
  }
  @available(*, deprecated, message: "Use a copy of the String argument")
  @inlinable @_alwaysEmitIntoClient public init?(validatingUTF8 cString: Swift.String) {
    self.init(validatingCString: cString)
  }
  @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
  @inlinable @_alwaysEmitIntoClient public init?(validatingCString nullTerminatedUTF8: inout Swift.CChar) {
    guard nullTerminatedUTF8 == 0 else {
      _preconditionFailure(
        "input of String.init(validatingCString:) must be null-terminated"
      )
    }
    self = ""
  }
  @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
  @inlinable @_alwaysEmitIntoClient public init?(validatingUTF8 cString: inout Swift.CChar) {
    self.init(validatingCString: &cString)
  }
  @_specialize(exported: false, kind: full, where Encoding == Swift.Unicode.UTF8)
  @_specialize(exported: false, kind: full, where Encoding == Swift.Unicode.UTF16)
  @inlinable public static func decodeCString<Encoding>(_ cString: Swift.UnsafePointer<Encoding.CodeUnit>?, as encoding: Encoding.Type, repairingInvalidCodeUnits isRepairing: Swift.Bool = true) -> (result: Swift.String, repairsMade: Swift.Bool)? where Encoding : Swift._UnicodeEncoding {
    guard let cPtr = cString else { return nil }

    if _fastPath(encoding == Unicode.UTF8.self) {
      let len = UTF8._nullCodeUnitOffset(
        in: UnsafeRawPointer(cPtr).assumingMemoryBound(to: UInt8.self)
      )
      let bytes = UnsafeBufferPointer(start: cPtr, count: len)
      return bytes.withMemoryRebound(to: UInt8.self) { codeUnits in
        if isRepairing {
          return String._fromUTF8Repairing(codeUnits)
        }
        else if let str = String._tryFromUTF8(codeUnits) {
          return (str, false)
        }
        return nil
      }
    }

    var end = cPtr
    while end.pointee != 0 { end += 1 }
    let len = end - cPtr
    let codeUnits = UnsafeBufferPointer(start: cPtr, count: len)
    return String._fromCodeUnits(
      codeUnits, encoding: encoding, repair: isRepairing)
  }
  @inlinable @_alwaysEmitIntoClient public static func decodeCString<Encoding>(_ cString: [Encoding.CodeUnit], as encoding: Encoding.Type, repairingInvalidCodeUnits isRepairing: Swift.Bool = true) -> (result: Swift.String, repairsMade: Swift.Bool)? where Encoding : Swift._UnicodeEncoding {
    guard let length = cString.firstIndex(of: 0) else {
      _preconditionFailure(
        "input of decodeCString(_:as:repairingInvalidCodeUnits:) must be null-terminated"
      )
    }

    if _fastPath(encoding == Unicode.UTF8.self) {
      return cString.prefix(length).withUnsafeBufferPointer {
        buffer -> (result: String, repairsMade: Bool)? in
        return buffer.withMemoryRebound(to: UInt8.self) { codeUnits in
          if isRepairing {
            return String._fromUTF8Repairing(codeUnits)
          }
          else if let str = String._tryFromUTF8(codeUnits) {
            return (str, false)
          }
          return nil
        }
      }
    }

    return cString.prefix(length).withUnsafeBufferPointer {
      buf -> (result: String, repairsMade: Bool)? in
      String._fromCodeUnits(buf, encoding: encoding, repair: isRepairing)
    }
  }
  @available(*, deprecated, message: "Use a copy of the String argument")
  @inlinable @_alwaysEmitIntoClient public static func decodeCString<Encoding>(_ cString: Swift.String, as encoding: Encoding.Type, repairingInvalidCodeUnits isRepairing: Swift.Bool = true) -> (result: Swift.String, repairsMade: Swift.Bool)? where Encoding : Swift._UnicodeEncoding {
    return cString.withCString(encodedAs: encoding) {
      String.decodeCString(
        $0, as: encoding, repairingInvalidCodeUnits: isRepairing
      )
    }
  }
  @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
  @inlinable @_alwaysEmitIntoClient public static func decodeCString<Encoding>(_ cString: inout Encoding.CodeUnit, as encoding: Encoding.Type, repairingInvalidCodeUnits isRepairing: Swift.Bool = true) -> (result: Swift.String, repairsMade: Swift.Bool)? where Encoding : Swift._UnicodeEncoding {
    guard cString == 0 else {
      _preconditionFailure(
        "input of decodeCString(_:as:repairingInvalidCodeUnits:) must be null-terminated"
      )
    }
    return ("", false)
  }
  @_specialize(exported: false, kind: full, where Encoding == Swift.Unicode.UTF8)
  @_specialize(exported: false, kind: full, where Encoding == Swift.Unicode.UTF16)
  @inlinable public init<Encoding>(decodingCString nullTerminatedCodeUnits: Swift.UnsafePointer<Encoding.CodeUnit>, as encoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding {
    self = String.decodeCString(nullTerminatedCodeUnits, as: encoding)!.0
  }
  @available(swift, deprecated: 6, message: "Use String(decoding: array, as: Encoding.self) instead, after truncating the null termination.")
  @inlinable @_alwaysEmitIntoClient public init<Encoding>(decodingCString nullTerminatedCodeUnits: [Encoding.CodeUnit], as encoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding {
    self = String.decodeCString(nullTerminatedCodeUnits, as: encoding)!.0
  }
  @available(*, deprecated, message: "Use a copy of the String argument")
  @inlinable @_alwaysEmitIntoClient public init<Encoding>(decodingCString nullTerminatedCodeUnits: Swift.String, as encoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding {
    self = nullTerminatedCodeUnits.withCString(encodedAs: encoding) {
      String(decodingCString: $0, as: encoding.self)
    }
  }
  @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
  @inlinable @_alwaysEmitIntoClient public init<Encoding>(decodingCString nullTerminatedCodeUnits: inout Encoding.CodeUnit, as encoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding {
    guard nullTerminatedCodeUnits == 0 else {
      _preconditionFailure(
        "input of String.init(decodingCString:as:) must be null-terminated"
      )
    }
    self = ""
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafePointer where Pointee == Swift.UInt8 {
  @inlinable internal var _asCChar: Swift.UnsafePointer<Swift.CChar> {
    @inline(__always) get {
      return UnsafeRawPointer(self).assumingMemoryBound(to: CChar.self)
    }
  }
}
#else
extension Swift.UnsafePointer where Pointee == Swift.UInt8 {
  @inlinable internal var _asCChar: Swift.UnsafePointer<Swift.CChar> {
    @inline(__always) get {
      return UnsafeRawPointer(self).assumingMemoryBound(to: CChar.self)
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafePointer where Pointee == Swift.Int8 {
  @inlinable internal var _asUInt8: Swift.UnsafePointer<Swift.UInt8> {
    @inline(__always) get {
      return UnsafeRawPointer(self).assumingMemoryBound(to: UInt8.self)
    }
  }
}
#else
extension Swift.UnsafePointer where Pointee == Swift.Int8 {
  @inlinable internal var _asUInt8: Swift.UnsafePointer<Swift.UInt8> {
    @inline(__always) get {
      return UnsafeRawPointer(self).assumingMemoryBound(to: UInt8.self)
    }
  }
}
#endif
public typealias CChar = Swift.Int8
public typealias CUnsignedChar = Swift.UInt8
public typealias CUnsignedShort = Swift.UInt16
public typealias CUnsignedInt = Swift.UInt32
public typealias CUnsignedLong = Swift.UInt
public typealias CUnsignedLongLong = Swift.UInt64
public typealias CSignedChar = Swift.Int8
public typealias CShort = Swift.Int16
public typealias CInt = Swift.Int32
public typealias CLong = Swift.Int
public typealias CLongLong = Swift.Int64
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public typealias CFloat16 = Swift.Float16
public typealias CFloat = Swift.Float
public typealias CDouble = Swift.Double
public typealias CLongDouble = Swift.Double
public typealias CWideChar = Swift.Unicode.Scalar
public typealias CChar16 = Swift.UInt16
public typealias CChar32 = Swift.Unicode.Scalar
public typealias CBool = Swift.Bool
@frozen public struct OpaquePointer {
  @usableFromInline
  internal var _rawValue: Builtin.RawPointer
  @usableFromInline
  @_transparent internal init(_ v: Builtin.RawPointer) {
    self._rawValue = v
  }
}
@available(*, unavailable)
extension Swift.OpaquePointer : Swift.Sendable {
}
extension Swift.OpaquePointer {
  @_transparent public init?(bitPattern: Swift.Int) {
    if bitPattern == 0 { return nil }
    self._rawValue = Builtin.inttoptr_Word(bitPattern._builtinWordValue)
  }
  @_transparent public init?(bitPattern: Swift.UInt) {
    if bitPattern == 0 { return nil }
    self._rawValue = Builtin.inttoptr_Word(bitPattern._builtinWordValue)
  }
}
extension Swift.OpaquePointer {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_transparent @_preInverseGenerics public init<T>(@_nonEphemeral _ from: Swift.UnsafePointer<T>) where T : ~Copyable {
    self._rawValue = from._rawValue
  }
  #else
  @_transparent public init<T>(@_nonEphemeral _ from: Swift.UnsafePointer<T>) {
    self._rawValue = from._rawValue
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_transparent @_preInverseGenerics public init?<T>(@_nonEphemeral _ from: Swift.UnsafePointer<T>?) where T : ~Copyable {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
  #else
  @_transparent public init?<T>(@_nonEphemeral _ from: Swift.UnsafePointer<T>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
  #endif
}
extension Swift.OpaquePointer {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_transparent @_preInverseGenerics public init<T>(@_nonEphemeral _ from: Swift.UnsafeMutablePointer<T>) where T : ~Copyable {
    self._rawValue = from._rawValue
  }
  #else
  @_transparent public init<T>(@_nonEphemeral _ from: Swift.UnsafeMutablePointer<T>) {
    self._rawValue = from._rawValue
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_transparent @_preInverseGenerics public init?<T>(@_nonEphemeral _ from: Swift.UnsafeMutablePointer<T>?) where T : ~Copyable {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
  #else
  @_transparent public init?<T>(@_nonEphemeral _ from: Swift.UnsafeMutablePointer<T>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
  #endif
}
extension Swift.OpaquePointer : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.OpaquePointer, rhs: Swift.OpaquePointer) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}
extension Swift.OpaquePointer : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(Int(Builtin.ptrtoint_Word(_rawValue)))
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.OpaquePointer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.Int {
  @inlinable public init(bitPattern pointer: Swift.OpaquePointer?) {
    self.init(bitPattern: UnsafeRawPointer(pointer))
  }
}
extension Swift.UInt {
  @inlinable public init(bitPattern pointer: Swift.OpaquePointer?) {
    self.init(bitPattern: UnsafeRawPointer(pointer))
  }
}
@frozen public struct CVaListPointer {
  @usableFromInline
  internal var _value: Swift.UnsafeMutableRawPointer
  @inlinable public init(_fromUnsafeMutablePointer from: Swift.UnsafeMutableRawPointer) {
    _value = from
  }
}
extension Swift.CVaListPointer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(*, unavailable)
extension Swift.CVaListPointer : Swift.Sendable {
}
@inlinable internal func _memcpy(dest destination: Swift.UnsafeMutableRawPointer, src: Swift.UnsafeRawPointer, size: Swift.UInt) {
  let dest = destination._rawValue
  let src = src._rawValue
  let size = UInt64(size)._value
  Builtin.int_memcpy_RawPointer_RawPointer_Int64(
    dest, src, size,
      false._value)
}
@inlinable internal func _memmove(dest destination: Swift.UnsafeMutableRawPointer, src: Swift.UnsafeRawPointer, size: Swift.UInt) {
  let dest = destination._rawValue
  let src = src._rawValue
  let size = UInt64(size)._value
  Builtin.int_memmove_RawPointer_RawPointer_Int64(
    dest, src, size,
      false._value)
}
#if compiler(>=5.3) && $Macros && $AttachedMacros
@attached(member) @attached(memberAttribute) public macro DebugDescription() = #externalMacro(module: "SwiftMacros", type: "DebugDescriptionMacro")
#endif
#if compiler(>=5.3) && $Macros && $AttachedMacros
@attached(peer, names: named(_lldb_summary)) public macro _DebugDescriptionProperty(_ debugIdentifier: Swift.String, _ computedProperties: [Swift.String]) = #externalMacro(module: "SwiftMacros", type: "_DebugDescriptionPropertyMacro")
#endif
@frozen public enum _DebuggerSupport {
  public static func stringForPrintObject(_ value: Any) -> Swift.String
}
public func _stringForPrintObject(_ value: Any) -> Swift.String
public func _debuggerTestingCheckExpect(_: Swift.String, _: Swift.String)
@_alwaysEmitIntoClient @_transparent internal func _withHeapObject<R>(of object: Swift.AnyObject, _ body: (Swift.UnsafeMutableRawPointer) -> R) -> R {
  defer { _fixLifetime(object) }
  let unmanaged = Unmanaged.passUnretained(object)
  return body(unmanaged.toOpaque())
}
#if compiler(>=5.3) && $Extern
@usableFromInline
@_extern(c, "swift_retainCount") internal func _swift_retainCount(_: Swift.UnsafeMutableRawPointer) -> Swift.Int
#else
@usableFromInline
internal func _swift_retainCount(_: Swift.UnsafeMutableRawPointer) -> Swift.Int
#endif
#if compiler(>=5.3) && $Extern
@usableFromInline
@_extern(c, "swift_unownedRetainCount") internal func _swift_unownedRetainCount(_: Swift.UnsafeMutableRawPointer) -> Swift.Int
#else
@usableFromInline
internal func _swift_unownedRetainCount(_: Swift.UnsafeMutableRawPointer) -> Swift.Int
#endif
#if compiler(>=5.3) && $Extern
@usableFromInline
@_extern(c, "swift_weakRetainCount") internal func _swift_weakRetainCount(_: Swift.UnsafeMutableRawPointer) -> Swift.Int
#else
@usableFromInline
internal func _swift_weakRetainCount(_: Swift.UnsafeMutableRawPointer) -> Swift.Int
#endif
@_alwaysEmitIntoClient public func _getRetainCount(_ object: Swift.AnyObject) -> Swift.UInt {
  let count = _withHeapObject(of: object) { _swift_retainCount($0) }
  return UInt(bitPattern: count)
}
@_alwaysEmitIntoClient public func _getUnownedRetainCount(_ object: Swift.AnyObject) -> Swift.UInt {
  let count = _withHeapObject(of: object) { _swift_unownedRetainCount($0) }
  return UInt(bitPattern: count)
}
@_alwaysEmitIntoClient public func _getWeakRetainCount(_ object: Swift.AnyObject) -> Swift.UInt {
  let count = _withHeapObject(of: object) { _swift_weakRetainCount($0) }
  return UInt(bitPattern: count)
}
#if compiler(>=5.3) && $LexicalLifetimes
@frozen @_eagerMove public struct Dictionary<Key, Value> where Key : Swift.Hashable {
  public typealias Element = (key: Key, value: Value)
  @usableFromInline
  internal var _variant: Swift.Dictionary<Key, Value>._Variant
  @inlinable internal init(_native: __owned Swift._NativeDictionary<Key, Value>) {
    _variant = _Variant(native: _native)
  }
  @inlinable internal init(_cocoa: __owned Swift.__CocoaDictionary) {
    _variant = _Variant(cocoa: _cocoa)
  }
  @inlinable public init(_immutableCocoaDictionary: __owned Swift.AnyObject) {
    _internalInvariant(
      _isBridgedVerbatimToObjectiveC(Key.self) &&
      _isBridgedVerbatimToObjectiveC(Value.self),
      """
      Dictionary can be backed by NSDictionary buffer only when both Key \
      and Value are bridged verbatim to Objective-C
      """)
    self.init(_cocoa: __CocoaDictionary(_immutableCocoaDictionary))
  }
  @inlinable public init() {
    self.init(_native: _NativeDictionary())
  }
  public init(minimumCapacity: Swift.Int)
  @inlinable public init<S>(uniqueKeysWithValues keysAndValues: __owned S) where S : Swift.Sequence, S.Element == (Key, Value) {
    if let d = keysAndValues as? Dictionary<Key, Value> {
      self = d
      return
    }
    var native = _NativeDictionary<Key, Value>(
      capacity: keysAndValues.underestimatedCount)
     
     
     
     
     
    try! native.merge(
      keysAndValues,
      isUnique: true,
      uniquingKeysWith: { _, _ in throw _MergeError.keyCollision })
    self.init(_native: native)
  }
  @inlinable public init<S>(_ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    var native = _NativeDictionary<Key, Value>(
      capacity: keysAndValues.underestimatedCount)
    try native.merge(keysAndValues, isUnique: true, uniquingKeysWith: combine)
    self.init(_native: native)
  }
  @inlinable public init<S>(grouping values: __owned S, by keyForValue: (S.Element) throws -> Key) rethrows where Value == [S.Element], S : Swift.Sequence {
    try self.init(_native: _NativeDictionary(grouping: values, by: keyForValue))
  }
}
#else
@frozen public struct Dictionary<Key, Value> where Key : Swift.Hashable {
  public typealias Element = (key: Key, value: Value)
  @usableFromInline
  internal var _variant: Swift.Dictionary<Key, Value>._Variant
  @inlinable internal init(_native: __owned Swift._NativeDictionary<Key, Value>) {
    _variant = _Variant(native: _native)
  }
  @inlinable internal init(_cocoa: __owned Swift.__CocoaDictionary) {
    _variant = _Variant(cocoa: _cocoa)
  }
  @inlinable public init(_immutableCocoaDictionary: __owned Swift.AnyObject) {
    _internalInvariant(
      _isBridgedVerbatimToObjectiveC(Key.self) &&
      _isBridgedVerbatimToObjectiveC(Value.self),
      """
      Dictionary can be backed by NSDictionary buffer only when both Key \
      and Value are bridged verbatim to Objective-C
      """)
    self.init(_cocoa: __CocoaDictionary(_immutableCocoaDictionary))
  }
  @inlinable public init() {
    self.init(_native: _NativeDictionary())
  }
  public init(minimumCapacity: Swift.Int)
  @inlinable public init<S>(uniqueKeysWithValues keysAndValues: __owned S) where S : Swift.Sequence, S.Element == (Key, Value) {
    if let d = keysAndValues as? Dictionary<Key, Value> {
      self = d
      return
    }
    var native = _NativeDictionary<Key, Value>(
      capacity: keysAndValues.underestimatedCount)
     
     
     
     
     
    try! native.merge(
      keysAndValues,
      isUnique: true,
      uniquingKeysWith: { _, _ in throw _MergeError.keyCollision })
    self.init(_native: native)
  }
  @inlinable public init<S>(_ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    var native = _NativeDictionary<Key, Value>(
      capacity: keysAndValues.underestimatedCount)
    try native.merge(keysAndValues, isUnique: true, uniquingKeysWith: combine)
    self.init(_native: native)
  }
  @inlinable public init<S>(grouping values: __owned S, by keyForValue: (S.Element) throws -> Key) rethrows where Value == [S.Element], S : Swift.Sequence {
    try self.init(_native: _NativeDictionary(grouping: values, by: keyForValue))
  }
}
#endif
extension Swift.Dictionary : Swift.Sequence {
  @inlinable @inline(__always) public __consuming func makeIterator() -> Swift.Dictionary<Key, Value>.Iterator {
    return _variant.makeIterator()
  }
}
extension Swift.Dictionary {
  @available(swift 4.0)
  @inlinable public __consuming func filter(_ isIncluded: (Swift.Dictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows -> [Key : Value] {
    guard _variant.isNative else {
       
      var result = _NativeDictionary<Key, Value>()
      for element in self {
        if try isIncluded(element) {
          result.insertNew(key: element.key, value: element.value)
        }
      }
      return Dictionary(_native: result)
    }
    return Dictionary(_native: try _variant.asNative.filter(isIncluded))
  }
}
extension Swift.Dictionary : Swift.Collection {
  public typealias SubSequence = Swift.Slice<Swift.Dictionary<Key, Value>>
  @inlinable public var startIndex: Swift.Dictionary<Key, Value>.Index {
    get {
    return _variant.startIndex
  }
  }
  @inlinable public var endIndex: Swift.Dictionary<Key, Value>.Index {
    get {
    return _variant.endIndex
  }
  }
  @inlinable public func index(after i: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Index {
    return _variant.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Swift.Dictionary<Key, Value>.Index) {
    _variant.formIndex(after: &i)
  }
  @inlinable @inline(__always) public func index(forKey key: Key) -> Swift.Dictionary<Key, Value>.Index? {
     
     
    return _variant.index(forKey: key)
  }
  @inlinable public subscript(position: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Element {
    get {
    return _variant.lookup(position)
  }
  }
  @inlinable public var count: Swift.Int {
    get {
    return _variant.count
  }
  }
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return count == 0
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.Dictionary<Key, Value>>
}
extension Swift.Dictionary {
  @inlinable public subscript(key: Key) -> Value? {
    get {
      return _variant.lookup(key)
    }
    set(newValue) {
      if let x = newValue {
        _variant.setValue(x, forKey: key)
      } else {
        removeValue(forKey: key)
      }
    }
    _modify {
      defer { _fixLifetime(self) }
      yield &_variant[key]
    }
  }
}
extension Swift.Dictionary : Swift.ExpressibleByDictionaryLiteral {
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") public init(dictionaryLiteral elements: (Key, Value)...) {
    let native = _NativeDictionary<Key, Value>(capacity: elements.count)
    for (key, value) in elements {
      let (bucket, found) = native.find(key)
      _precondition(!found, "Dictionary literal contains duplicate keys")
      native._insert(at: bucket, key: key, value: value)
    }
    self.init(_native: native)
  }
}
extension Swift.Dictionary {
  @inlinable public subscript(key: Key, default defaultValue: @autoclosure () -> Value) -> Value {
    @inline(__always) get {
      return _variant.lookup(key) ?? defaultValue()
    }
    @inline(__always) _modify {
      let (bucket, found) = _variant.mutatingFind(key)
      let native = _variant.asNative
      if !found {
        let value = defaultValue()
        native._insert(at: bucket, key: key, value: value)
      }
      let address = native._values + bucket.offset
      defer { _fixLifetime(self) }
      yield &address.pointee
    }
  }
  @inlinable public func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> Swift.Dictionary<Key, T> {
    return try Dictionary<Key, T>(_native: _variant.mapValues(transform))
  }
  @inlinable public func compactMapValues<T>(_ transform: (Value) throws -> T?) rethrows -> Swift.Dictionary<Key, T> {
    let result: _NativeDictionary<Key, T> =
      try self.reduce(into: _NativeDictionary<Key, T>()) { (result, element) in
      if let value = try transform(element.value) {
        result.insertNew(key: element.key, value: value)
      }
    }
    return Dictionary<Key, T>(_native: result)
  }
  @discardableResult
  @inlinable public mutating func updateValue(_ value: __owned Value, forKey key: Key) -> Value? {
    return _variant.updateValue(value, forKey: key)
  }
  @inlinable public mutating func merge<S>(_ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    try _variant.merge(other, uniquingKeysWith: combine)
  }
  @inlinable public mutating func merge(_ other: __owned [Key : Value], uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows {
    try _variant.merge(
      other.lazy.map { ($0, $1) }, uniquingKeysWith: combine)
  }
  @inlinable public __consuming func merging<S>(_ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> [Key : Value] where S : Swift.Sequence, S.Element == (Key, Value) {
    var result = self
    try result._variant.merge(other, uniquingKeysWith: combine)
    return result
  }
  @inlinable public __consuming func merging(_ other: __owned [Key : Value], uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> [Key : Value] {
    var result = self
    try result.merge(other, uniquingKeysWith: combine)
    return result
  }
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Element {
    return _variant.remove(at: index)
  }
  @discardableResult
  @inlinable public mutating func removeValue(forKey key: Key) -> Value? {
    return _variant.removeValue(forKey: key)
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
     
     
     
    _variant.removeAll(keepingCapacity: keepCapacity)
  }
}
extension Swift.Dictionary {
  @available(swift 4.0)
  @inlinable public var keys: Swift.Dictionary<Key, Value>.Keys {
    get {
      return Keys(_dictionary: self)
    }
  }
  @available(swift 4.0)
  @inlinable public var values: Swift.Dictionary<Key, Value>.Values {
    get {
      return Values(_dictionary: self)
    }
    _modify {
      var values = Values(_variant: _Variant(dummy: ()))
      swap(&values._variant, &_variant)
      defer { self._variant = values._variant }
      yield &values
    }
  }
  @frozen public struct Keys : Swift.Collection, Swift.Equatable {
    public typealias Element = Key
    public typealias SubSequence = Swift.Slice<Swift.Dictionary<Key, Value>.Keys>
    @usableFromInline
    internal var _variant: Swift.Dictionary<Key, Value>._Variant
    @inlinable internal init(_dictionary: __owned Swift.Dictionary<Key, Value>) {
      self._variant = _dictionary._variant
    }
    @inlinable public var startIndex: Swift.Dictionary<Key, Value>.Index {
      get {
      return _variant.startIndex
    }
    }
    @inlinable public var endIndex: Swift.Dictionary<Key, Value>.Index {
      get {
      return _variant.endIndex
    }
    }
    @inlinable public func index(after i: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Index {
      return _variant.index(after: i)
    }
    @inlinable public func formIndex(after i: inout Swift.Dictionary<Key, Value>.Index) {
      _variant.formIndex(after: &i)
    }
    @inlinable public subscript(position: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Keys.Element {
      get {
      return _variant.key(at: position)
    }
    }
    @inlinable public var count: Swift.Int {
      get {
      return _variant.count
    }
    }
    @inlinable public var isEmpty: Swift.Bool {
      get {
      return count == 0
    }
    }
    @inlinable @inline(__always) public func _customContainsEquatableElement(_ element: Swift.Dictionary<Key, Value>.Keys.Element) -> Swift.Bool? {
      return _variant.contains(element)
    }
    @inlinable @inline(__always) public func _customIndexOfEquatableElement(_ element: Swift.Dictionary<Key, Value>.Keys.Element) -> Swift.Dictionary<Key, Value>.Index?? {
      return Optional(_variant.index(forKey: element))
    }
    @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ element: Swift.Dictionary<Key, Value>.Keys.Element) -> Swift.Dictionary<Key, Value>.Index?? {
       
      return _customIndexOfEquatableElement(element)
    }
    @inlinable public static func == (lhs: Swift.Dictionary<Key, Value>.Keys, rhs: Swift.Dictionary<Key, Value>.Keys) -> Swift.Bool {
       
      if
        lhs._variant.isNative,
        rhs._variant.isNative,
        lhs._variant.asNative._storage === rhs._variant.asNative._storage
      {
        return true
      }
      if
        !lhs._variant.isNative,
        !rhs._variant.isNative,
        lhs._variant.asCocoa.object === rhs._variant.asCocoa.object
      {
        return true
      }

       
      if lhs.count != rhs.count {
        return false
      }

       
      for key in lhs {
        if !rhs.contains(key) {
          return false
        }
      }

      return true
    }
    public typealias Index = Swift.Dictionary<Key, Value>.Index
    public typealias Indices = Swift.DefaultIndices<Swift.Dictionary<Key, Value>.Keys>
  }
  @frozen public struct Values : Swift.MutableCollection {
    public typealias Element = Value
    @usableFromInline
    internal var _variant: Swift.Dictionary<Key, Value>._Variant
    @inlinable internal init(_variant: __owned Swift.Dictionary<Key, Value>._Variant) {
      self._variant = _variant
    }
    @inlinable internal init(_dictionary: __owned Swift.Dictionary<Key, Value>) {
      self._variant = _dictionary._variant
    }
    @inlinable public var startIndex: Swift.Dictionary<Key, Value>.Index {
      get {
      return _variant.startIndex
    }
    }
    @inlinable public var endIndex: Swift.Dictionary<Key, Value>.Index {
      get {
      return _variant.endIndex
    }
    }
    @inlinable public func index(after i: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Index {
      return _variant.index(after: i)
    }
    @inlinable public func formIndex(after i: inout Swift.Dictionary<Key, Value>.Index) {
      _variant.formIndex(after: &i)
    }
    @inlinable public subscript(position: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Values.Element {
      get {
        return _variant.value(at: position)
      }
      _modify {
        let native = _variant.ensureUniqueNative()
        let bucket = native.validatedBucket(for: position)
        let address = native._values + bucket.offset
        defer { _fixLifetime(self) }
        yield &address.pointee
      }
    }
    @inlinable public var count: Swift.Int {
      get {
      return _variant.count
    }
    }
    @inlinable public var isEmpty: Swift.Bool {
      get {
      return count == 0
    }
    }
    @inlinable public mutating func swapAt(_ i: Swift.Dictionary<Key, Value>.Index, _ j: Swift.Dictionary<Key, Value>.Index) {
      guard i != j else { return }
      if !_variant.isNative {
        _variant = .init(native: _NativeDictionary(_variant.asCocoa))
      }
      let isUnique = _variant.isUniquelyReferenced()
      let native = _variant.asNative
      let a = native.validatedBucket(for: i)
      let b = native.validatedBucket(for: j)
      _variant.asNative.swapValuesAt(a, b, isUnique: isUnique)
    }
    public typealias Index = Swift.Dictionary<Key, Value>.Index
    public typealias Indices = Swift.DefaultIndices<Swift.Dictionary<Key, Value>.Values>
    public typealias SubSequence = Swift.Slice<Swift.Dictionary<Key, Value>.Values>
  }
}
extension Swift.Dictionary.Keys : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.Dictionary.Values : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.Dictionary.Keys {
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal var _base: Swift.Dictionary<Key, Value>.Iterator
    @inlinable @inline(__always) internal init(_ base: Swift.Dictionary<Key, Value>.Iterator) {
      self._base = base
    }
    @inlinable @inline(__always) public mutating func next() -> Key? {
      if case .cocoa(let cocoa) = _base._variant {
        _base._cocoaPath()
        guard let cocoaKey = cocoa.nextKey() else { return nil }
        return _forceBridgeFromObjectiveC(cocoaKey, Key.self)
      }
      return _base._asNative.nextKey()
    }
    public typealias Element = Key
  }
  @inlinable @inline(__always) public __consuming func makeIterator() -> Swift.Dictionary<Key, Value>.Keys.Iterator {
    return Iterator(_variant.makeIterator())
  }
}
extension Swift.Dictionary.Values {
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal var _base: Swift.Dictionary<Key, Value>.Iterator
    @inlinable @inline(__always) internal init(_ base: Swift.Dictionary<Key, Value>.Iterator) {
      self._base = base
    }
    @inlinable @inline(__always) public mutating func next() -> Value? {
      if case .cocoa(let cocoa) = _base._variant {
        _base._cocoaPath()
        guard let (_, cocoaValue) = cocoa.next() else { return nil }
        return _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      }
      return _base._asNative.nextValue()
    }
    public typealias Element = Value
  }
  @inlinable @inline(__always) public __consuming func makeIterator() -> Swift.Dictionary<Key, Value>.Values.Iterator {
    return Iterator(_variant.makeIterator())
  }
}
extension Swift.Dictionary : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (lhs: [Key : Value], rhs: [Key : Value]) -> Swift.Bool {
    switch (lhs._variant.isNative, rhs._variant.isNative) {
    case (true, true):
      return lhs._variant.asNative.isEqual(to: rhs._variant.asNative)
    case (false, false):
      return lhs._variant.asCocoa.isEqual(to: rhs._variant.asCocoa)
    case (true, false):
      return lhs._variant.asNative.isEqual(to: rhs._variant.asCocoa)
    case (false, true):
      return rhs._variant.asNative.isEqual(to: lhs._variant.asCocoa)
    }
  }
}
extension Swift.Dictionary : Swift.Hashable where Value : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    var commutativeHash = 0
    for (k, v) in self {
       
       
      var elementHasher = hasher
      elementHasher.combine(k)
      elementHasher.combine(v)
      commutativeHash ^= elementHasher._finalize()
    }
    hasher.combine(commutativeHash)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Dictionary : Swift._HasCustomAnyHashableRepresentation where Value : Swift.Hashable {
  public __consuming func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.Dictionary : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@usableFromInline
@frozen internal enum _MergeError : Swift.Error {
  case keyCollision
  @usableFromInline
  internal static func == (a: Swift._MergeError, b: Swift._MergeError) -> Swift.Bool
  @usableFromInline
  internal func hash(into hasher: inout Swift.Hasher)
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
}
extension Swift.Dictionary {
  @frozen public struct Index {
    @usableFromInline
    @frozen internal enum _Variant {
      case native(Swift._HashTable.Index)
      case cocoa(Swift.__CocoaDictionary.Index)
    }
    @usableFromInline
    internal var _variant: Swift.Dictionary<Key, Value>.Index._Variant
    @inlinable @inline(__always) internal init(_variant: __owned Swift.Dictionary<Key, Value>.Index._Variant) {
      self._variant = _variant
    }
    @inlinable @inline(__always) internal init(_native index: Swift._HashTable.Index) {
      self.init(_variant: .native(index))
    }
    @inlinable @inline(__always) internal init(_cocoa index: __owned Swift.__CocoaDictionary.Index) {
      self.init(_variant: .cocoa(index))
    }
  }
}
extension Swift.Dictionary.Index._Variant : @unchecked Swift.Sendable {
}
extension Swift.Dictionary.Index {
  @usableFromInline
  @_transparent internal var _guaranteedNative: Swift.Bool {
    @_transparent get {
    return _canBeClass(Key.self) == 0 || _canBeClass(Value.self) == 0
  }
  }
  @usableFromInline
  @_transparent internal func _cocoaPath() {
    if _guaranteedNative {
      _conditionallyUnreachable()
    }
  }
  @inlinable @inline(__always) internal mutating func _isUniquelyReferenced() -> Swift.Bool {
    defer { _fixLifetime(self) }
    var handle = _asCocoa.handleBitPattern
    return handle == 0 || _isUnique_native(&handle)
  }
  @usableFromInline
  @_transparent internal var _isNative: Swift.Bool {
    @_transparent get {
    switch _variant {
    case .native:
      return true
    case .cocoa:
      _cocoaPath()
      return false
    }
  }
  }
  @usableFromInline
  @_transparent internal var _asNative: Swift._HashTable.Index {
    @_transparent get {
    switch _variant {
    case .native(let nativeIndex):
      return nativeIndex
    case .cocoa:
      _preconditionFailure(
        "Attempting to access Dictionary elements using an invalid index")
    }
  }
  }
  @usableFromInline
  internal var _asCocoa: Swift.__CocoaDictionary.Index {
    @_transparent get {
      switch _variant {
      case .native:
        _preconditionFailure(
          "Attempting to access Dictionary elements using an invalid index")
      case .cocoa(let cocoaIndex):
        return cocoaIndex
      }
    }
    _modify
  }
}
extension Swift.Dictionary.Index : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.Dictionary<Key, Value>.Index, rhs: Swift.Dictionary<Key, Value>.Index) -> Swift.Bool {
    switch (lhs._variant, rhs._variant) {
    case (.native(let lhsNative), .native(let rhsNative)):
      return lhsNative == rhsNative
    case (.cocoa(let lhsCocoa), .cocoa(let rhsCocoa)):
      lhs._cocoaPath()
      return lhsCocoa == rhsCocoa
    default:
      _preconditionFailure("Comparing indexes from different dictionaries")
    }
  }
}
extension Swift.Dictionary.Index : Swift.Comparable {
  @inlinable public static func < (lhs: Swift.Dictionary<Key, Value>.Index, rhs: Swift.Dictionary<Key, Value>.Index) -> Swift.Bool {
    switch (lhs._variant, rhs._variant) {
    case (.native(let lhsNative), .native(let rhsNative)):
      return lhsNative < rhsNative
    case (.cocoa(let lhsCocoa), .cocoa(let rhsCocoa)):
      lhs._cocoaPath()
      return lhsCocoa < rhsCocoa
    default:
      _preconditionFailure("Comparing indexes from different dictionaries")
    }
  }
}
extension Swift.Dictionary.Index : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Dictionary {
  @frozen public struct Iterator {
    @usableFromInline
    @frozen internal enum _Variant {
      case native(Swift._NativeDictionary<Key, Value>.Iterator)
      case cocoa(Swift.__CocoaDictionary.Iterator)
    }
    @usableFromInline
    internal var _variant: Swift.Dictionary<Key, Value>.Iterator._Variant
    @inlinable internal init(_variant: __owned Swift.Dictionary<Key, Value>.Iterator._Variant) {
      self._variant = _variant
    }
    @inlinable internal init(_native: __owned Swift._NativeDictionary<Key, Value>.Iterator) {
      self.init(_variant: .native(_native))
    }
    @inlinable internal init(_cocoa: __owned Swift.__CocoaDictionary.Iterator) {
      self.init(_variant: .cocoa(_cocoa))
    }
  }
}
extension Swift.Dictionary.Iterator._Variant : @unchecked Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension Swift.Dictionary.Iterator {
  @usableFromInline
  @_transparent internal var _guaranteedNative: Swift.Bool {
    @_transparent get {
    return _canBeClass(Key.self) == 0 || _canBeClass(Value.self) == 0
  }
  }
  @usableFromInline
  @_transparent internal func _cocoaPath() {
    if _guaranteedNative {
      _conditionallyUnreachable()
    }
  }
  @usableFromInline
  @_transparent internal var _isNative: Swift.Bool {
    @_transparent get {
    switch _variant {
    case .native:
      return true
    case .cocoa:
      _cocoaPath()
      return false
    }
  }
  }
  @usableFromInline
  @_transparent internal var _asNative: Swift._NativeDictionary<Key, Value>.Iterator {
    @_transparent get {
      switch _variant {
      case .native(let nativeIterator):
        return nativeIterator
      case .cocoa:
        _internalInvariantFailure("internal error: does not contain a native index")
      }
    }
    @_transparent set {
      self._variant = .native(newValue)
    }
  }
  @usableFromInline
  @_transparent internal var _asCocoa: Swift.__CocoaDictionary.Iterator {
    @_transparent get {
      switch _variant {
      case .native:
        _internalInvariantFailure("internal error: does not contain a Cocoa index")
      case .cocoa(let cocoa):
        return cocoa
      }
    }
  }
}
extension Swift.Dictionary.Iterator : Swift.IteratorProtocol {
  @inlinable @inline(__always) public mutating func next() -> (key: Key, value: Value)? {
    guard _isNative else {
      if let (cocoaKey, cocoaValue) = _asCocoa.next() {
        let nativeKey = _forceBridgeFromObjectiveC(cocoaKey, Key.self)
        let nativeValue = _forceBridgeFromObjectiveC(cocoaValue, Value.self)
        return (nativeKey, nativeValue)
      }
      return nil
    }
    return _asNative.next()
  }
  public typealias Element = (key: Key, value: Value)
}
extension Swift.Dictionary.Iterator : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Dictionary : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Dictionary {
  @inlinable public mutating func popFirst() -> Swift.Dictionary<Key, Value>.Element? {
    guard !isEmpty else { return nil }
    return remove(at: startIndex)
  }
  @inlinable public var capacity: Swift.Int {
    get {
    return _variant.capacity
  }
  }
  public mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
}
public typealias DictionaryIndex<Key, Value> = Swift.Dictionary<Key, Value>.Index where Key : Swift.Hashable
public typealias DictionaryIterator<Key, Value> = Swift.Dictionary<Key, Value>.Iterator where Key : Swift.Hashable
extension Swift.Dictionary : @unchecked Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension Swift.Dictionary.Keys : @unchecked Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension Swift.Dictionary.Values : @unchecked Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension Swift.Dictionary.Keys.Iterator : @unchecked Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension Swift.Dictionary.Values.Iterator : @unchecked Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension Swift.Dictionary.Index : @unchecked Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension Swift.Dictionary.Iterator : @unchecked Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension Swift._NativeDictionary {
  @usableFromInline
  internal __consuming func bridged() -> Swift.AnyObject
}
@usableFromInline
@frozen internal struct __CocoaDictionary {
  @usableFromInline
  internal let object: Swift.AnyObject
  @inlinable internal init(_ object: __owned Swift.AnyObject) {
    self.object = object
  }
}
@available(*, unavailable)
extension Swift.__CocoaDictionary : Swift.Sendable {
}
extension Swift.__CocoaDictionary {
  @usableFromInline
  internal func isEqual(to other: Swift.__CocoaDictionary) -> Swift.Bool
}
extension Swift.__CocoaDictionary {
  @usableFromInline
  internal typealias Key = Swift.AnyObject
  @usableFromInline
  internal typealias Value = Swift.AnyObject
  @usableFromInline
  internal var startIndex: Swift.__CocoaDictionary.Index {
    @_effects(releasenone) get
  }
  @usableFromInline
  internal var endIndex: Swift.__CocoaDictionary.Index {
    @_effects(releasenone) get
  }
  @usableFromInline
  @_effects(releasenone) internal func index(after index: Swift.__CocoaDictionary.Index) -> Swift.__CocoaDictionary.Index
  @usableFromInline
  internal func formIndex(after index: inout Swift.__CocoaDictionary.Index, isUnique: Swift.Bool)
  @usableFromInline
  @_effects(releasenone) internal func index(forKey key: Swift.__CocoaDictionary.Key) -> Swift.__CocoaDictionary.Index?
  @usableFromInline
  internal var count: Swift.Int {
    get
  }
  @usableFromInline
  internal func contains(_ key: Swift.__CocoaDictionary.Key) -> Swift.Bool
  @usableFromInline
  internal func lookup(_ key: Swift.__CocoaDictionary.Key) -> Swift.__CocoaDictionary.Value?
  @usableFromInline
  @_effects(releasenone) internal func lookup(_ index: Swift.__CocoaDictionary.Index) -> (key: Swift.__CocoaDictionary.Key, value: Swift.__CocoaDictionary.Value)
  @usableFromInline
  @_effects(releasenone) internal func key(at index: Swift.__CocoaDictionary.Index) -> Swift.__CocoaDictionary.Key
  @usableFromInline
  @_effects(releasenone) internal func value(at index: Swift.__CocoaDictionary.Index) -> Swift.__CocoaDictionary.Value
}
extension Swift.__CocoaDictionary {
  @inlinable internal func mapValues<Key, Value, T>(_ transform: (Value) throws -> T) rethrows -> Swift._NativeDictionary<Key, T> where Key : Swift.Hashable {
    var result = _NativeDictionary<Key, T>(capacity: self.count)
    for (cocoaKey, cocoaValue) in self {
      let key = _forceBridgeFromObjectiveC(cocoaKey, Key.self)
      let value = _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      try result.insertNew(key: key, value: transform(value))
    }
    return result
  }
}
extension Swift.__CocoaDictionary {
  @usableFromInline
  @frozen internal struct Index {
    internal var _storage: Builtin.BridgeObject
    internal var _offset: Swift.Int
  }
}
extension Swift.__CocoaDictionary.Index {
  @usableFromInline
  internal var handleBitPattern: Swift.UInt {
    @_effects(readonly) get
  }
  @usableFromInline
  internal var dictionary: Swift.__CocoaDictionary {
    @_effects(releasenone) get
  }
}
extension Swift.__CocoaDictionary.Index {
  @usableFromInline
  @nonobjc internal var key: Swift.AnyObject {
    @_effects(readonly) get
  }
  @usableFromInline
  @nonobjc internal var age: Swift.Int32 {
    @_effects(readonly) get
  }
}
extension Swift.__CocoaDictionary.Index : Swift.Equatable {
  @usableFromInline
  @_effects(readonly) internal static func == (lhs: Swift.__CocoaDictionary.Index, rhs: Swift.__CocoaDictionary.Index) -> Swift.Bool
}
extension Swift.__CocoaDictionary.Index : Swift.Comparable {
  @usableFromInline
  @_effects(readonly) internal static func < (lhs: Swift.__CocoaDictionary.Index, rhs: Swift.__CocoaDictionary.Index) -> Swift.Bool
}
extension Swift.__CocoaDictionary : Swift.Sequence {
  @_hasMissingDesignatedInitializers @usableFromInline
  final internal class Iterator {
    @objc @usableFromInline
    deinit
  }
  @usableFromInline
  @_effects(releasenone) internal __consuming func makeIterator() -> Swift.__CocoaDictionary.Iterator
  @usableFromInline
  internal typealias Element = Swift.__CocoaDictionary.Iterator.Element
}
@available(*, unavailable)
extension Swift.__CocoaDictionary.Iterator : Swift.Sendable {
}
extension Swift.__CocoaDictionary.Iterator : Swift.IteratorProtocol {
  @usableFromInline
  internal typealias Element = (key: Swift.AnyObject, value: Swift.AnyObject)
  @usableFromInline
  final internal func nextKey() -> Swift.AnyObject?
  @usableFromInline
  final internal func next() -> Swift.__CocoaDictionary.Iterator.Element?
}
extension Swift.Dictionary {
  @inlinable public __consuming func _bridgeToObjectiveCImpl() -> Swift.AnyObject {
    guard _variant.isNative else {
      return _variant.asCocoa.object
    }
    return _variant.asNative.bridged()
  }
  public static func _bridgeFromObjectiveCAdoptingNativeStorageOf(_ s: __owned Swift.AnyObject) -> Swift.Dictionary<Key, Value>?
}
@frozen public struct _DictionaryBuilder<Key, Value> where Key : Swift.Hashable {
  @usableFromInline
  internal var _target: Swift._NativeDictionary<Key, Value>
  @usableFromInline
  internal let _requestedCount: Swift.Int
  @inlinable public init(count: Swift.Int) {
    _target = _NativeDictionary(capacity: count)
    _requestedCount = count
  }
  @inlinable public mutating func add(key newKey: Key, value: Value) {
    _precondition(_target.count < _requestedCount,
      "Can't add more members than promised")
    _target._unsafeInsertNew(key: newKey, value: value)
  }
  @inlinable public __consuming func take() -> Swift.Dictionary<Key, Value> {
    _precondition(_target.count == _requestedCount,
      "The number of members added does not match the promised count")
    return Dictionary(_native: _target)
  }
}
@available(*, unavailable)
extension Swift._DictionaryBuilder : Swift.Sendable {
}
extension Swift.Dictionary {
  @_alwaysEmitIntoClient public init(_unsafeUninitializedCapacity capacity: Swift.Int, allowingDuplicates: Swift.Bool, initializingWith initializer: (_ keys: Swift.UnsafeMutableBufferPointer<Key>, _ values: Swift.UnsafeMutableBufferPointer<Value>) -> Swift.Int) {
    self.init(_native: _NativeDictionary(
        _unsafeUninitializedCapacity: capacity,
        allowingDuplicates: allowingDuplicates,
        initializingWith: initializer))
  }
}
extension Swift._NativeDictionary {
  @_alwaysEmitIntoClient internal init(_unsafeUninitializedCapacity capacity: Swift.Int, allowingDuplicates: Swift.Bool, initializingWith initializer: (_ keys: Swift.UnsafeMutableBufferPointer<Key>, _ values: Swift.UnsafeMutableBufferPointer<Value>) -> Swift.Int) {
    self.init(capacity: capacity)
    let initializedCount = initializer(
      UnsafeMutableBufferPointer(start: _keys, count: capacity),
      UnsafeMutableBufferPointer(start: _values, count: capacity))
    _precondition(initializedCount >= 0 && initializedCount <= capacity)
    _storage._count = initializedCount

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
    var bucket = _HashTable.Bucket(offset: initializedCount - 1)
    while bucket.offset >= 0 {
      if hashTable._isOccupied(bucket) {
         
        bucket.offset -= 1
        continue
      }
       
      let target: Bucket
      if _isDebugAssertConfiguration() || allowingDuplicates {
        let (b, found) = find(_keys[bucket.offset])
        if found {
          _internalInvariant(b != bucket)
          _precondition(allowingDuplicates, "Duplicate keys found")
           
          uncheckedDestroy(at: bucket)
          _storage._count -= 1
          bucket.offset -= 1
          continue
        }
        hashTable.insert(b)
        target = b
      } else {
        let hashValue = self.hashValue(for: _keys[bucket.offset])
        target = hashTable.insertNew(hashValue: hashValue)
      }

      if target > bucket {
         
         
        moveEntry(from: bucket, to: target)
         
        bucket.offset -= 1
      } else if target == bucket {
         
        bucket.offset -= 1
      } else {
         
         
         
        swapEntry(target, with: bucket)
      }
    }
     
     
  }
}
extension Swift.Dictionary {
  @_alwaysEmitIntoClient @inlinable @inline(__always) internal init?<C>(_mapping source: C, allowingDuplicates: Swift.Bool, transform: (C.Element) -> (key: Key, value: Value)?) where C : Swift.Collection {
    var target = _NativeDictionary<Key, Value>(capacity: source.count)
    if allowingDuplicates {
      for member in source {
        guard let (key, value) = transform(member) else { return nil }
        target._unsafeUpdate(key: key, value: value)
      }
    } else {
      for member in source {
        guard let (key, value) = transform(member) else { return nil }
        target._unsafeInsertNew(key: key, value: value)
      }
    }
    self.init(_native: target)
  }
}
@inlinable public func _dictionaryUpCast<DerivedKey, DerivedValue, BaseKey, BaseValue>(_ source: Swift.Dictionary<DerivedKey, DerivedValue>) -> Swift.Dictionary<BaseKey, BaseValue> where DerivedKey : Swift.Hashable, BaseKey : Swift.Hashable {
  return Dictionary(
    _mapping: source,
     
     
     
    allowingDuplicates: (BaseKey.self == String.self)
  ) { k, v in
    (k as! BaseKey, v as! BaseValue)
  }!
}
@inlinable public func _dictionaryDownCast<BaseKey, BaseValue, DerivedKey, DerivedValue>(_ source: Swift.Dictionary<BaseKey, BaseValue>) -> Swift.Dictionary<DerivedKey, DerivedValue> where BaseKey : Swift.Hashable, DerivedKey : Swift.Hashable {

  if _isClassOrObjCExistential(BaseKey.self)
  && _isClassOrObjCExistential(BaseValue.self)
  && _isClassOrObjCExistential(DerivedKey.self)
  && _isClassOrObjCExistential(DerivedValue.self) {

    guard source._variant.isNative else {
      return Dictionary(
        _immutableCocoaDictionary: source._variant.asCocoa.object)
    }
     
     
    return Dictionary(
      _immutableCocoaDictionary: source._variant.asNative.bridged())
  }

   
   
   

  return Dictionary(
    _mapping: source,
     
     
     
    allowingDuplicates: (DerivedKey.self == String.self)
  ) { k, v in
    (k as! DerivedKey, v as! DerivedValue)
  }!
}
@inlinable public func _dictionaryDownCastConditional<BaseKey, BaseValue, DerivedKey, DerivedValue>(_ source: Swift.Dictionary<BaseKey, BaseValue>) -> Swift.Dictionary<DerivedKey, DerivedValue>? where BaseKey : Swift.Hashable, DerivedKey : Swift.Hashable {
  return Dictionary(
    _mapping: source,
     
     
     
    allowingDuplicates: (DerivedKey.self == String.self)
  ) { k, v in
    guard
      let key = k as? DerivedKey,
      let value = v as? DerivedValue
    else {
      return nil
    }
    return (key, value)
  }
}
@objc @_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @_objc_non_lazy_realization internal class __RawDictionaryStorage : Swift.__SwiftNativeNSDictionary {
  @usableFromInline
  @nonobjc final internal var _count: Swift.Int
  @usableFromInline
  @nonobjc final internal var _capacity: Swift.Int
  @usableFromInline
  @nonobjc final internal var _scale: Swift.Int8
  @usableFromInline
  @nonobjc final internal var _reservedScale: Swift.Int8
  @nonobjc final internal var _extra: Swift.Int16
  @usableFromInline
  @nonobjc final internal var _age: Swift.Int32
  @usableFromInline
  final internal var _seed: Swift.Int
  @usableFromInline
  @nonobjc final internal var _rawKeys: Swift.UnsafeMutableRawPointer
  @usableFromInline
  @nonobjc final internal var _rawValues: Swift.UnsafeMutableRawPointer
  @inlinable @nonobjc final internal var _bucketCount: Swift.Int {
    @inline(__always) get { return 1 &<< _scale }
  }
  @inlinable @nonobjc final internal var _metadata: Swift.UnsafeMutablePointer<Swift._HashTable.Word> {
    @inline(__always) get {
      let address = Builtin.projectTailElems(self, _HashTable.Word.self)
      return UnsafeMutablePointer(address)
    }
  }
  @inlinable @nonobjc final internal var _hashTable: Swift._HashTable {
    @inline(__always) get {
      return _HashTable(words: _metadata, bucketCount: _bucketCount)
    }
  }
  @objc @usableFromInline
  deinit
}
@available(*, unavailable)
extension Swift.__RawDictionaryStorage : Swift.Sendable {
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @_objc_non_lazy_realization internal class __EmptyDictionarySingleton : Swift.__RawDictionaryStorage {
  @objc @usableFromInline
  deinit
}
@available(*, unavailable)
extension Swift.__EmptyDictionarySingleton : Swift.Sendable {
}
extension Swift.__RawDictionaryStorage {
  @inlinable @nonobjc internal static var empty: Swift.__EmptyDictionarySingleton {
    get {
    return Builtin.bridgeFromRawPointer(
      Builtin.addressof(&_swiftEmptyDictionarySingleton))
  }
  }
  @_alwaysEmitIntoClient @inline(__always) final internal func uncheckedKey<Key>(at bucket: Swift._HashTable.Bucket) -> Key where Key : Swift.Hashable {
    defer { _fixLifetime(self) }
    _internalInvariant(_hashTable.isOccupied(bucket))
    let keys = _rawKeys.assumingMemoryBound(to: Key.self)
    return keys[bucket.offset]
  }
  @_alwaysEmitIntoClient @inline(never) final internal func find<Key>(_ key: Key) -> (bucket: Swift._HashTable.Bucket, found: Swift.Bool) where Key : Swift.Hashable {
    return find(key, hashValue: key._rawHashValue(seed: _seed))
  }
  @_alwaysEmitIntoClient @inline(never) final internal func find<Key>(_ key: Key, hashValue: Swift.Int) -> (bucket: Swift._HashTable.Bucket, found: Swift.Bool) where Key : Swift.Hashable {
      let hashTable = _hashTable
      var bucket = hashTable.idealBucket(forHashValue: hashValue)
      while hashTable._isOccupied(bucket) {
        if uncheckedKey(at: bucket) == key {
          return (bucket, true)
        }
        bucket = hashTable.bucket(wrappedAfter: bucket)
      }
      return (bucket, false)
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @usableFromInline
final internal class _DictionaryStorage<Key, Value> : Swift.__RawDictionaryStorage where Key : Swift.Hashable {
  @objc deinit
  @inlinable final internal var _keys: Swift.UnsafeMutablePointer<Key> {
    @inline(__always) get {
      return self._rawKeys.assumingMemoryBound(to: Key.self)
    }
  }
  @inlinable final internal var _values: Swift.UnsafeMutablePointer<Value> {
    @inline(__always) get {
      return self._rawValues.assumingMemoryBound(to: Value.self)
    }
  }
}
extension Swift._DictionaryStorage {
  @usableFromInline
  @_effects(releasenone) internal static func copy(original: Swift.__RawDictionaryStorage) -> Swift._DictionaryStorage<Key, Value>
  @usableFromInline
  @_effects(releasenone) internal static func resize(original: Swift.__RawDictionaryStorage, capacity: Swift.Int, move: Swift.Bool) -> Swift._DictionaryStorage<Key, Value>
  @usableFromInline
  @_effects(releasenone) internal static func allocate(capacity: Swift.Int) -> Swift._DictionaryStorage<Key, Value>
  @usableFromInline
  @_effects(releasenone) internal static func convert(_ cocoa: Swift.__CocoaDictionary, capacity: Swift.Int) -> Swift._DictionaryStorage<Key, Value>
}
extension Swift._DictionaryStorage : @unchecked Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension Swift.Dictionary {
  @usableFromInline
  @frozen internal struct _Variant {
    @usableFromInline
    internal var object: Swift._BridgeStorage<Swift.__RawDictionaryStorage>
    @inlinable @inline(__always) internal init(native: __owned Swift._NativeDictionary<Key, Value>) {
      self.object = _BridgeStorage(native: native._storage)
    }
    @inlinable @inline(__always) internal init(dummy: Swift.Void) {
#if _pointerBitWidth(_64) && !$Embedded
      self.object = _BridgeStorage(taggedPayload: 0)
#elseif _pointerBitWidth(_32) || $Embedded
      self.init(native: _NativeDictionary())
#else
#error("Unknown platform")
#endif
    }
    @inlinable @inline(__always) internal init(cocoa: __owned Swift.__CocoaDictionary) {
      self.object = _BridgeStorage(objC: cocoa.object)
    }
  }
}
extension Swift.Dictionary._Variant {
  @usableFromInline
  @_transparent internal var guaranteedNative: Swift.Bool {
    @_transparent get {
    return _canBeClass(Key.self) == 0 || _canBeClass(Value.self) == 0
  }
  }
  @inlinable internal mutating func isUniquelyReferenced() -> Swift.Bool {
    return object.isUniquelyReferencedUnflaggedNative()
  }
  @usableFromInline
  @_transparent internal var isNative: Swift.Bool {
    @_transparent get {
    if guaranteedNative { return true }
    return object.isUnflaggedNative
  }
  }
  @usableFromInline
  @_transparent internal var asNative: Swift._NativeDictionary<Key, Value> {
    @_transparent get {
      return _NativeDictionary<Key, Value>(object.unflaggedNativeInstance)
    }
    @_transparent set {
      self = .init(native: newValue)
    }
    @_transparent _modify {
      var native = _NativeDictionary<Key, Value>(object.unflaggedNativeInstance)
      self = .init(dummy: ())
      defer { object = .init(native: native._storage) }
      yield &native
    }
  }
  @inlinable internal var asCocoa: Swift.__CocoaDictionary {
    get {
    return __CocoaDictionary(object.objCInstance)
  }
  }
  @inlinable internal var capacity: Swift.Int {
    get {
    guard isNative else {
      return asCocoa.count
    }
    return asNative.capacity
  }
  }
}
extension Swift.Dictionary._Variant {
  @usableFromInline
  internal typealias Element = (key: Key, value: Value)
  @usableFromInline
  internal typealias Index = Swift.Dictionary<Key, Value>.Index
  @inlinable internal var startIndex: Swift.Dictionary<Key, Value>._Variant.Index {
    get {
    guard isNative else {
      return Index(_cocoa: asCocoa.startIndex)
    }
    return asNative.startIndex
  }
  }
  @inlinable internal var endIndex: Swift.Dictionary<Key, Value>._Variant.Index {
    get {
    guard isNative else {
      return Index(_cocoa: asCocoa.endIndex)
    }
    return asNative.endIndex
  }
  }
  @inlinable internal func index(after index: Swift.Dictionary<Key, Value>._Variant.Index) -> Swift.Dictionary<Key, Value>._Variant.Index {
    guard isNative else {
      return Index(_cocoa: asCocoa.index(after: index._asCocoa))
    }
    return asNative.index(after: index)
  }
  @inlinable internal func formIndex(after index: inout Swift.Dictionary<Key, Value>._Variant.Index) {
    guard isNative else {
      let isUnique = index._isUniquelyReferenced()
      asCocoa.formIndex(after: &index._asCocoa, isUnique: isUnique)
      return
    }
    index = asNative.index(after: index)
  }
  @inlinable @inline(__always) internal func index(forKey key: Key) -> Swift.Dictionary<Key, Value>._Variant.Index? {
    guard isNative else {
      let cocoaKey = _bridgeAnythingToObjectiveC(key)
      guard let index = asCocoa.index(forKey: cocoaKey) else { return nil }
      return Index(_cocoa: index)
    }
    return asNative.index(forKey: key)
  }
  @inlinable internal var count: Swift.Int {
    @inline(__always) get {
      guard isNative else {
        return asCocoa.count
      }
      return asNative.count
    }
  }
  @inlinable @inline(__always) internal func contains(_ key: Key) -> Swift.Bool {
    guard isNative else {
      let cocoaKey = _bridgeAnythingToObjectiveC(key)
      return asCocoa.contains(cocoaKey)
    }
    return asNative.contains(key)
  }
  @inlinable @inline(__always) internal func lookup(_ key: Key) -> Value? {
    guard isNative else {
      let cocoaKey = _bridgeAnythingToObjectiveC(key)
      guard let cocoaValue = asCocoa.lookup(cocoaKey) else { return nil }
      return _forceBridgeFromObjectiveC(cocoaValue, Value.self)
    }
    return asNative.lookup(key)
  }
  @inlinable @inline(__always) internal func lookup(_ index: Swift.Dictionary<Key, Value>._Variant.Index) -> (key: Key, value: Value) {
    guard isNative else {
      let (cocoaKey, cocoaValue) = asCocoa.lookup(index._asCocoa)
      let nativeKey = _forceBridgeFromObjectiveC(cocoaKey, Key.self)
      let nativeValue = _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      return (nativeKey, nativeValue)
    }
    return asNative.lookup(index)
  }
  @inlinable @inline(__always) internal func key(at index: Swift.Dictionary<Key, Value>._Variant.Index) -> Key {
    guard isNative else {
      let cocoaKey = asCocoa.key(at: index._asCocoa)
      return _forceBridgeFromObjectiveC(cocoaKey, Key.self)
    }
    return asNative.key(at: index)
  }
  @inlinable @inline(__always) internal func value(at index: Swift.Dictionary<Key, Value>._Variant.Index) -> Value {
    guard isNative else {
      let cocoaValue = asCocoa.value(at: index._asCocoa)
      return _forceBridgeFromObjectiveC(cocoaValue, Value.self)
    }
    return asNative.value(at: index)
  }
}
extension Swift.Dictionary._Variant {
  @inlinable internal subscript(key: Key) -> Value? {
    @inline(__always) get {
      return lookup(key)
    }
    @inline(__always) _modify {
      guard isNative else {
        let cocoa = asCocoa
        var native = _NativeDictionary<Key, Value>(
          cocoa, capacity: cocoa.count + 1)
        self = .init(native: native)
        yield &native[key, isUnique: true]
        return
      }
      let isUnique = isUniquelyReferenced()
      yield &asNative[key, isUnique: isUnique]
    }
  }
}
extension Swift.Dictionary._Variant {
  @inlinable @inline(__always) internal mutating func mutatingFind(_ key: Key) -> (bucket: Swift._NativeDictionary<Key, Value>.Bucket, found: Swift.Bool) {
    guard isNative else {
      let cocoa = asCocoa
      var native = _NativeDictionary<Key, Value>(
        cocoa, capacity: cocoa.count + 1)
      let result = native.mutatingFind(key, isUnique: true)
      self = .init(native: native)
      return result
    }
    let isUnique = isUniquelyReferenced()
    return asNative.mutatingFind(key, isUnique: isUnique)
  }
  @inlinable @inline(__always) internal mutating func ensureUniqueNative() -> Swift._NativeDictionary<Key, Value> {
    guard isNative else {
      let native = _NativeDictionary<Key, Value>(asCocoa)
      self = .init(native: native)
      return native
    }
    let isUnique = isUniquelyReferenced()
    if !isUnique {
      asNative.copy()
    }
    return asNative
  }
  @inlinable internal mutating func updateValue(_ value: __owned Value, forKey key: Key) -> Value? {
    guard isNative else {
       
      let cocoa = asCocoa
      var native = _NativeDictionary<Key, Value>(
        cocoa,
        capacity: cocoa.count + 1)
      let result = native.updateValue(value, forKey: key, isUnique: true)
      self = .init(native: native)
      return result
    }
    let isUnique = self.isUniquelyReferenced()
    return asNative.updateValue(value, forKey: key, isUnique: isUnique)
  }
  @inlinable internal mutating func setValue(_ value: __owned Value, forKey key: Key) {
    if !isNative {
       
      let cocoa = asCocoa
      self = .init(native: _NativeDictionary<Key, Value>(
        cocoa,
        capacity: cocoa.count + 1))
    }
    let isUnique = self.isUniquelyReferenced()
    asNative.setValue(value, forKey: key, isUnique: isUnique)
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") internal mutating func remove(at index: Swift.Dictionary<Key, Value>._Variant.Index) -> Swift.Dictionary<Key, Value>._Variant.Element {
     
     
    let native = ensureUniqueNative()
    let bucket = native.validatedBucket(for: index)
    return asNative.uncheckedRemove(at: bucket, isUnique: true)
  }
  @inlinable internal mutating func removeValue(forKey key: Key) -> Value? {
    guard isNative else {
      let cocoaKey = _bridgeAnythingToObjectiveC(key)
      let cocoa = asCocoa
      guard cocoa.lookup(cocoaKey) != nil else { return nil }
      var native = _NativeDictionary<Key, Value>(cocoa)
      let (bucket, found) = native.find(key)
      _precondition(found, "Bridging did not preserve equality")
      let old = native.uncheckedRemove(at: bucket, isUnique: true).value
      self = .init(native: native)
      return old
    }
    let (bucket, found) = asNative.find(key)
    guard found else { return nil }
    let isUnique = isUniquelyReferenced()
    return asNative.uncheckedRemove(at: bucket, isUnique: isUnique).value
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") internal mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool) {
    if !keepCapacity {
      self = .init(native: _NativeDictionary())
      return
    }
    guard count > 0 else { return }

    guard isNative else {
      self = .init(native: _NativeDictionary(capacity: asCocoa.count))
      return
    }
    let isUnique = isUniquelyReferenced()
    asNative.removeAll(isUnique: isUnique)
  }
}
extension Swift.Dictionary._Variant {
  @inlinable @inline(__always) internal __consuming func makeIterator() -> Swift.Dictionary<Key, Value>.Iterator {
    guard isNative else {
      return Dictionary.Iterator(_cocoa: asCocoa.makeIterator())
    }
    return Dictionary.Iterator(_native: asNative.makeIterator())
  }
}
extension Swift.Dictionary._Variant {
  @inlinable internal func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> Swift._NativeDictionary<Key, T> {
    guard isNative else {
      return try asCocoa.mapValues(transform)
    }
    return try asNative.mapValues(transform)
  }
  @inlinable internal mutating func merge<S>(_ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    guard isNative else {
      var native = _NativeDictionary<Key, Value>(asCocoa)
      try native.merge(
        keysAndValues,
        isUnique: true,
        uniquingKeysWith: combine)
      self = .init(native: native)
      return
    }
    let isUnique = isUniquelyReferenced()
    try asNative.merge(
      keysAndValues,
      isUnique: isUnique,
      uniquingKeysWith: combine)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public struct DiscontiguousSlice<Base> where Base : Swift.Collection {
  public let subranges: Swift.RangeSet<Base.Index>
  public var base: Base {
    get
  }
  @usableFromInline
  internal init(_base: Base, subranges: Swift.RangeSet<Base.Index>)
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice : Swift.Sendable where Base : Swift.Sendable, Base.Index : Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice : Swift.Equatable where Base.Element : Swift.Equatable {
  public static func == (lhs: Swift.DiscontiguousSlice<Base>, rhs: Swift.DiscontiguousSlice<Base>) -> Swift.Bool
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice : Swift.Hashable where Base.Element : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice {
  public struct Index {
    public let base: Base.Index
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice.Index : Swift.Equatable {
  public static func == (left: Swift.DiscontiguousSlice<Base>.Index, right: Swift.DiscontiguousSlice<Base>.Index) -> Swift.Bool
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice.Index : Swift.Hashable where Base.Index : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice.Index : Swift.Comparable {
  public static func < (left: Swift.DiscontiguousSlice<Base>.Index, right: Swift.DiscontiguousSlice<Base>.Index) -> Swift.Bool
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice.Index : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice.Index : Swift.Sendable where Base.Index : Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice : Swift.Sequence {
  public typealias Element = Base.Element
  public typealias Iterator = Swift.IndexingIterator<Swift.DiscontiguousSlice<Base>>
  public func _customContainsEquatableElement(_ element: Swift.DiscontiguousSlice<Base>.Element) -> Swift.Bool?
  public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Swift.DiscontiguousSlice<Base>.Element>
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice : Swift.Collection {
  public typealias SubSequence = Swift.DiscontiguousSlice<Base>
  public typealias Indices = Swift.DefaultIndices<Swift.DiscontiguousSlice<Base>>
  public var startIndex: Swift.DiscontiguousSlice<Base>.Index {
    get
  }
  public var endIndex: Swift.DiscontiguousSlice<Base>.Index {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public func distance(from start: Swift.DiscontiguousSlice<Base>.Index, to end: Swift.DiscontiguousSlice<Base>.Index) -> Swift.Int
  public func index(after i: Swift.DiscontiguousSlice<Base>.Index) -> Swift.DiscontiguousSlice<Base>.Index
  public subscript(i: Swift.DiscontiguousSlice<Base>.Index) -> Base.Element {
    get
  }
  public subscript(bounds: Swift.Range<Swift.DiscontiguousSlice<Base>.Index>) -> Swift.DiscontiguousSlice<Base> {
    get
  }
  @usableFromInline
  internal func _index(of baseIndex: Base.Index) -> Swift.DiscontiguousSlice<Base>.Index?
  public func _customIndexOfEquatableElement(_ element: Swift.DiscontiguousSlice<Base>.Element) -> Swift.DiscontiguousSlice<Base>.Index??
  public func _customLastIndexOfEquatableElement(_ element: Swift.DiscontiguousSlice<Base>.Element) -> Swift.DiscontiguousSlice<Base>.Index??
  public func _failEarlyRangeCheck(_ index: Swift.DiscontiguousSlice<Base>.Index, bounds: Swift.Range<Swift.DiscontiguousSlice<Base>.Index>)
  public func _failEarlyRangeCheck(_ index: Swift.DiscontiguousSlice<Base>.Index, bounds: Swift.ClosedRange<Swift.DiscontiguousSlice<Base>.Index>)
  public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.DiscontiguousSlice<Base>.Index>, bounds: Swift.Range<Swift.DiscontiguousSlice<Base>.Index>)
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection {
  public func index(before i: Swift.DiscontiguousSlice<Base>.Index) -> Swift.DiscontiguousSlice<Base>.Index
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.DiscontiguousSlice where Base : Swift.MutableCollection {
  public subscript(i: Swift.DiscontiguousSlice<Base>.Index) -> Base.Element {
    get
    set
  }
}
extension Swift.Collection {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public subscript(subranges: Swift.RangeSet<Self.Index>) -> Swift.DiscontiguousSlice<Self> {
    get
  }
}
extension Swift.Collection {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func removingSubranges(_ subranges: Swift.RangeSet<Self.Index>) -> Swift.DiscontiguousSlice<Self>
}
@frozen public struct LazyDropWhileSequence<Base> where Base : Swift.Sequence {
  public typealias Element = Base.Element
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _predicate: (Swift.LazyDropWhileSequence<Base>.Element) -> Swift.Bool
  @inlinable internal init(_base: Base, predicate: @escaping (Swift.LazyDropWhileSequence<Base>.Element) -> Swift.Bool) {
    self._base = _base
    self._predicate = predicate
  }
}
@available(*, unavailable)
extension Swift.LazyDropWhileSequence : Swift.Sendable {
}
extension Swift.LazyDropWhileSequence {
  @frozen public struct Iterator {
    public typealias Element = Base.Element
    @usableFromInline
    internal var _predicateHasFailed: Swift.Bool = false
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal let _predicate: (Swift.LazyDropWhileSequence<Base>.Iterator.Element) -> Swift.Bool
    @inlinable internal init(_base: Base.Iterator, predicate: @escaping (Swift.LazyDropWhileSequence<Base>.Iterator.Element) -> Swift.Bool) {
      self._base = _base
      self._predicate = predicate
    }
  }
}
@available(*, unavailable)
extension Swift.LazyDropWhileSequence.Iterator : Swift.Sendable {
}
extension Swift.LazyDropWhileSequence.Iterator : Swift.IteratorProtocol {
  @inlinable public mutating func next() -> Swift.LazyDropWhileSequence<Base>.Iterator.Element? {
     
     
    if _predicateHasFailed {
      return _base.next()
    }

     
     
    while let nextElement = _base.next() {
      if !_predicate(nextElement) {
        _predicateHasFailed = true
        return nextElement
      }
    }
    return nil
  }
}
extension Swift.LazyDropWhileSequence : Swift.Sequence {
  @inlinable public __consuming func makeIterator() -> Swift.LazyDropWhileSequence<Base>.Iterator {
    return Iterator(_base: _base.makeIterator(), predicate: _predicate)
  }
}
extension Swift.LazyDropWhileSequence : Swift.LazySequenceProtocol {
  public typealias Elements = Swift.LazyDropWhileSequence<Base>
}
extension Swift.LazySequenceProtocol {
  @inlinable public __consuming func drop(while predicate: @escaping (Self.Elements.Element) -> Swift.Bool) -> Swift.LazyDropWhileSequence<Self.Elements> {
    return LazyDropWhileSequence(_base: self.elements, predicate: predicate)
  }
}
public typealias LazyDropWhileCollection<T> = Swift.LazyDropWhileSequence<T> where T : Swift.Collection
extension Swift.LazyDropWhileCollection : Swift.Collection where Base : Swift.Collection {
  public typealias SubSequence = Swift.Slice<Swift.LazyDropWhileCollection<Base>>
  public typealias Index = Base.Index
  @inlinable public var startIndex: Swift.LazyDropWhileSequence<Base>.Index {
    get {
    var index = _base.startIndex
    while index != _base.endIndex && _predicate(_base[index]) {
      _base.formIndex(after: &index)
    }
    return index
  }
  }
  @inlinable public var endIndex: Swift.LazyDropWhileSequence<Base>.Index {
    get {
    return _base.endIndex
  }
  }
  @inlinable public func index(after i: Swift.LazyDropWhileSequence<Base>.Index) -> Swift.LazyDropWhileSequence<Base>.Index {
    _precondition(i < _base.endIndex, "Can't advance past endIndex")
    return _base.index(after: i)
  }
  @inlinable public subscript(position: Swift.LazyDropWhileSequence<Base>.Index) -> Swift.LazyDropWhileSequence<Base>.Element {
    get {
    return _base[position]
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.LazyDropWhileSequence<Base>>
}
extension Swift.LazyDropWhileCollection : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.LazyDropWhileSequence<Base>.Index) -> Swift.LazyDropWhileSequence<Base>.Index {
    _precondition(i > startIndex, "Can't move before startIndex")
    return _base.index(before: i)
  }
}
extension Swift.LazyDropWhileCollection : Swift.LazyCollectionProtocol where Base : Swift.Collection {
}
@discardableResult
@_semantics("optimize.sil.specialize.generic.never") public func dump<T, TargetStream>(_ value: T, to target: inout TargetStream, name: Swift.String? = nil, indent: Swift.Int = 0, maxDepth: Swift.Int = .max, maxItems: Swift.Int = .max) -> T where TargetStream : Swift.TextOutputStream
@discardableResult
@_semantics("optimize.sil.specialize.generic.never") public func dump<T>(_ value: T, name: Swift.String? = nil, indent: Swift.Int = 0, maxDepth: Swift.Int = .max, maxItems: Swift.Int = .max) -> T
@frozen public struct EmptyCollection<Element> {
  @inlinable public init() {}
}
extension Swift.EmptyCollection {
  @frozen public struct Iterator {
    @inlinable public init() {}
  }
}
extension Swift.EmptyCollection.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  @inlinable public mutating func next() -> Element? {
    return nil
  }
  public typealias Iterator = Swift.EmptyCollection<Element>.Iterator
}
extension Swift.EmptyCollection : Swift.Sequence {
  @inlinable public func makeIterator() -> Swift.EmptyCollection<Element>.Iterator {
    return Iterator()
  }
}
extension Swift.EmptyCollection : Swift.RandomAccessCollection, Swift.MutableCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = Swift.EmptyCollection<Element>
  @inlinable public var startIndex: Swift.EmptyCollection<Element>.Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.EmptyCollection<Element>.Index {
    get {
    return 0
  }
  }
  @inlinable public func index(after i: Swift.EmptyCollection<Element>.Index) -> Swift.EmptyCollection<Element>.Index {
    _preconditionFailure("EmptyCollection can't advance indices")
  }
  @inlinable public func index(before i: Swift.EmptyCollection<Element>.Index) -> Swift.EmptyCollection<Element>.Index {
    _preconditionFailure("EmptyCollection can't advance indices")
  }
  @inlinable public subscript(position: Swift.EmptyCollection<Element>.Index) -> Element {
    get {
      _preconditionFailure("Index out of range")
    }
    set {
      _preconditionFailure("Index out of range")
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.EmptyCollection<Element>.Index>) -> Swift.EmptyCollection<Element>.SubSequence {
    get {
      _debugPrecondition(bounds.lowerBound == 0 && bounds.upperBound == 0,
        "Index out of range")
      return self
    }
    set {
      _debugPrecondition(bounds.lowerBound == 0 && bounds.upperBound == 0,
        "Index out of range")
    }
  }
  @inlinable public var count: Swift.Int {
    get {
    return 0
  }
  }
  @inlinable public func index(_ i: Swift.EmptyCollection<Element>.Index, offsetBy n: Swift.Int) -> Swift.EmptyCollection<Element>.Index {
    _debugPrecondition(i == startIndex && n == 0, "Index out of range")
    return i
  }
  @inlinable public func index(_ i: Swift.EmptyCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.EmptyCollection<Element>.Index) -> Swift.EmptyCollection<Element>.Index? {
    _debugPrecondition(i == startIndex && limit == startIndex,
      "Index out of range")
    return n == 0 ? i : nil
  }
  @inlinable public func distance(from start: Swift.EmptyCollection<Element>.Index, to end: Swift.EmptyCollection<Element>.Index) -> Swift.Int {
    _debugPrecondition(start == 0, "From must be startIndex (or endIndex)")
    _debugPrecondition(end == 0, "To must be endIndex (or startIndex)")
    return 0
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.EmptyCollection<Element>.Index, bounds: Swift.Range<Swift.EmptyCollection<Element>.Index>) {
    _debugPrecondition(index == 0, "out of bounds")
    _debugPrecondition(bounds == indices, "invalid bounds for an empty collection")
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.EmptyCollection<Element>.Index>, bounds: Swift.Range<Swift.EmptyCollection<Element>.Index>) {
    _debugPrecondition(range == indices, "invalid range for an empty collection")
    _debugPrecondition(bounds == indices, "invalid bounds for an empty collection")
  }
}
extension Swift.EmptyCollection : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.EmptyCollection<Element>, rhs: Swift.EmptyCollection<Element>) -> Swift.Bool {
    return true
  }
}
extension Swift.EmptyCollection : Swift.Sendable {
}
extension Swift.EmptyCollection.Iterator : Swift.Sendable {
}
public protocol Equatable {
  static func == (lhs: Self, rhs: Self) -> Swift.Bool
}
extension Swift.Equatable {
  @_transparent public static func != (lhs: Self, rhs: Self) -> Swift.Bool {
    return !(lhs == rhs)
  }
}
@inlinable public func === (lhs: Swift.AnyObject?, rhs: Swift.AnyObject?) -> Swift.Bool {
  switch (lhs, rhs) {
  case let (l?, r?):
    return ObjectIdentifier(l) == ObjectIdentifier(r)
  case (nil, nil):
    return true
  default:
    return false
  }
}
@inlinable public func !== (lhs: Swift.AnyObject?, rhs: Swift.AnyObject?) -> Swift.Bool {
  return !(lhs === rhs)
}
public protocol Error : Swift.Sendable {
  var _domain: Swift.String { get }
  var _code: Swift.Int { get }
  var _userInfo: Swift.AnyObject? { get }
  func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Swift.Error {
  public func _getEmbeddedNSError() -> Swift.AnyObject?
}
public func _getErrorEmbeddedNSError<T>(_ x: T) -> Swift.AnyObject? where T : Swift.Error
@_silgen_name("_swift_stdlib_bridgeErrorToNSError")
public func _bridgeErrorToNSError(_ error: __owned any Swift.Error) -> Swift.AnyObject
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@_silgen_name("swift_willThrowTypedImpl")
@usableFromInline
internal func _willThrowTypedImpl<E>(_ error: E) where E : Swift.Error
@_silgen_name("swift_willThrowTyped")
@inlinable @_alwaysEmitIntoClient public func _willThrowTyped<E>(_ error: E) where E : Swift.Error {
  if #available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *) {
    _willThrowTypedImpl(error)
  }
}
@_silgen_name("swift_unexpectedError")
public func _unexpectedError(_ error: __owned any Swift.Error, filenameStart: Builtin.RawPointer, filenameLength: Builtin.Word, filenameIsASCII: Builtin.Int1, line: Builtin.Word)
@_silgen_name("swift_unexpectedErrorTyped")
@_alwaysEmitIntoClient @inlinable public func _unexpectedErrorTyped<E>(_ error: __owned E, filenameStart: Builtin.RawPointer, filenameLength: Builtin.Word, filenameIsASCII: Builtin.Int1, line: Builtin.Word) where E : Swift.Error {
  #if !$Embedded
  _unexpectedError(
    error, filenameStart: filenameStart, filenameLength: filenameLength,
    filenameIsASCII: filenameIsASCII, line: line
  )
  #else
  Builtin.int_trap()
  #endif
}
@_silgen_name("swift_errorInMain")
public func _errorInMain(_ error: any Swift.Error)
@_alwaysEmitIntoClient public func _errorInMainTyped<Failure>(_ error: Failure) -> Swift.Never where Failure : Swift.Error {
  #if !$Embedded
  fatalError("Error raised at top level: \(String(reflecting: error))")
  #else
  Builtin.int_trap()
  #endif
}
@_silgen_name("_swift_stdlib_getDefaultErrorCode")
public func _getDefaultErrorCode<T>(_ error: T) -> Swift.Int where T : Swift.Error
extension Swift.Error {
  public var _code: Swift.Int {
    get
  }
  public var _domain: Swift.String {
    get
  }
  public var _userInfo: Swift.AnyObject? {
    get
  }
}
extension Swift.Error where Self : Swift.RawRepresentable, Self.RawValue : Swift.FixedWidthInteger {
  public var _code: Swift.Int {
    get
  }
}
@usableFromInline
@inline(never) internal func _abstract(file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never
@frozen public struct AnyIterator<Element> {
  @usableFromInline
  internal let _box: Swift._AnyIteratorBoxBase<Element>
  @inlinable public init<I>(_ base: I) where Element == I.Element, I : Swift.IteratorProtocol {
    self._box = _IteratorBox(base)
  }
  @inlinable public init(_ body: @escaping () -> Element?) {
    self._box = _IteratorBox(_ClosureBasedIterator(body))
  }
  @inlinable internal init(_box: Swift._AnyIteratorBoxBase<Element>) {
    self._box = _box
  }
}
@available(*, unavailable)
extension Swift.AnyIterator : Swift.Sendable {
}
extension Swift.AnyIterator : Swift.IteratorProtocol {
  @inlinable public func next() -> Element? {
    return _box.next()
  }
}
extension Swift.AnyIterator : Swift.Sequence {
  public typealias Iterator = Swift.AnyIterator<Element>
}
@usableFromInline
@frozen internal struct _ClosureBasedIterator<Element> : Swift.IteratorProtocol {
  @usableFromInline
  internal let _body: () -> Element?
  @inlinable internal init(_ body: @escaping () -> Element?) {
    self._body = body
  }
  @inlinable internal func next() -> Element? { return _body() }
}
@available(*, unavailable)
extension Swift._ClosureBasedIterator : Swift.Sendable {
}
@usableFromInline
@_fixed_layout internal class _AnyIteratorBoxBase<Element> : Swift.IteratorProtocol {
  @inlinable internal init() {}
  @objc @inlinable deinit {}
  @inlinable internal func next() -> Element? { _abstract() }
}
@available(*, unavailable)
extension Swift._AnyIteratorBoxBase : Swift.Sendable {
}
@usableFromInline
@_fixed_layout final internal class _IteratorBox<Base> : Swift._AnyIteratorBoxBase<Base.Element> where Base : Swift.IteratorProtocol {
  @inlinable internal init(_ base: Base) { self._base = base }
  @objc @inlinable deinit {}
  @inlinable override final internal func next() -> Base.Element? { return _base.next() }
  @usableFromInline
  final internal var _base: Base
}
@available(*, unavailable)
extension Swift._IteratorBox : Swift.Sendable {
}
@usableFromInline
@_fixed_layout internal class _AnySequenceBox<Element> {
  @inlinable internal init() { }
  @inlinable internal func _makeIterator() -> Swift.AnyIterator<Element> { _abstract() }
  @inlinable internal var _underestimatedCount: Swift.Int {
    get { _abstract() }
  }
  @inlinable internal func _map<T>(_ transform: (Element) throws -> T) throws -> [T] {
    _abstract()
  }
  @inlinable internal func _filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    _abstract()
  }
  @inlinable internal func _forEach(_ body: (Element) throws -> Swift.Void) rethrows {
    _abstract()
  }
  @inlinable internal func __customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    _abstract()
  }
  @inlinable internal func __copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    _abstract()
  }
  @inlinable internal func __copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.AnyIterator<Element>, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    _abstract()
  }
  @objc @inlinable deinit {}
  @inlinable internal func _drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnySequenceBox<Element> {
    _abstract()
  }
  @inlinable internal func _dropFirst(_ n: Swift.Int) -> Swift._AnySequenceBox<Element> {
    _abstract()
  }
  @inlinable internal func _dropLast(_ n: Swift.Int) -> [Element] {
    _abstract()
  }
  @inlinable internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnySequenceBox<Element> {
    _abstract()
  }
  @inlinable internal func _prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    _abstract()
  }
  @inlinable internal func _suffix(_ maxLength: Swift.Int) -> [Element] {
    _abstract()
  }
}
@available(*, unavailable)
extension Swift._AnySequenceBox : Swift.Sendable {
}
@usableFromInline
@_fixed_layout internal class _AnyCollectionBox<Element> : Swift._AnySequenceBox<Element> {
  @objc @inlinable deinit {}
  @inlinable override internal func _drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropFirst(_ n: Swift.Int) -> Swift._AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable internal func _dropLast(_ n: Swift.Int) -> Swift._AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable internal func _prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable internal func _suffix(_ maxLength: Swift.Int) -> Swift._AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable internal subscript(i: any Swift._AnyIndexBox) -> Element {
    get { _abstract() }
  }
  @inlinable internal func _index(after i: any Swift._AnyIndexBox) -> any Swift._AnyIndexBox { _abstract() }
  @inlinable internal func _formIndex(after i: any Swift._AnyIndexBox) { _abstract() }
  @inlinable internal func _index(_ i: any Swift._AnyIndexBox, offsetBy n: Swift.Int) -> any Swift._AnyIndexBox {
    _abstract()
  }
  @inlinable internal func _index(_ i: any Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: any Swift._AnyIndexBox) -> (any Swift._AnyIndexBox)? {
    _abstract()
  }
  @inlinable internal func _formIndex(_ i: inout any Swift._AnyIndexBox, offsetBy n: Swift.Int) {
    _abstract()
  }
  @inlinable internal func _formIndex(_ i: inout any Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: any Swift._AnyIndexBox) -> Swift.Bool {
    _abstract()
  }
  @inlinable internal func _distance(from start: any Swift._AnyIndexBox, to end: any Swift._AnyIndexBox) -> Swift.Int {
    _abstract()
  }
  @inlinable internal var _count: Swift.Int {
    get { _abstract() }
  }
  @inlinable internal init(_startIndex: any Swift._AnyIndexBox, endIndex: any Swift._AnyIndexBox) {
    self._startIndex = _startIndex
    self._endIndex = endIndex
  }
  @usableFromInline
  final internal let _startIndex: any Swift._AnyIndexBox
  @usableFromInline
  final internal let _endIndex: any Swift._AnyIndexBox
  @inlinable internal subscript(start start: any Swift._AnyIndexBox, end end: any Swift._AnyIndexBox) -> Swift._AnyCollectionBox<Element> {
    get { _abstract() }
  }
}
@available(*, unavailable)
extension Swift._AnyCollectionBox : Swift.Sendable {
}
@_inheritsConvenienceInitializers @usableFromInline
@_fixed_layout internal class _AnyBidirectionalCollectionBox<Element> : Swift._AnyCollectionBox<Element> {
  @objc @inlinable deinit {}
  @inlinable override internal func _drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropFirst(_ n: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropLast(_ n: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _suffix(_ maxLength: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal subscript(start start: any Swift._AnyIndexBox, end end: any Swift._AnyIndexBox) -> Swift._AnyBidirectionalCollectionBox<Element> {
    get { _abstract() }
  }
  @inlinable internal func _index(before i: any Swift._AnyIndexBox) -> any Swift._AnyIndexBox { _abstract() }
  @inlinable internal func _formIndex(before i: any Swift._AnyIndexBox) { _abstract() }
  @inlinable override internal init(_startIndex: any Swift._AnyIndexBox, endIndex: any Swift._AnyIndexBox)
}
@available(*, unavailable)
extension Swift._AnyBidirectionalCollectionBox : Swift.Sendable {
}
@_inheritsConvenienceInitializers @usableFromInline
@_fixed_layout internal class _AnyRandomAccessCollectionBox<Element> : Swift._AnyBidirectionalCollectionBox<Element> {
  @objc @inlinable deinit {}
  @inlinable override internal func _drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropFirst(_ n: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropLast(_ n: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _suffix(_ maxLength: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal subscript(start start: any Swift._AnyIndexBox, end end: any Swift._AnyIndexBox) -> Swift._AnyRandomAccessCollectionBox<Element> {
    get { _abstract() }
  }
  @inlinable override internal init(_startIndex: any Swift._AnyIndexBox, endIndex: any Swift._AnyIndexBox)
}
@available(*, unavailable)
extension Swift._AnyRandomAccessCollectionBox : Swift.Sendable {
}
@usableFromInline
@_fixed_layout final internal class _SequenceBox<S> : Swift._AnySequenceBox<S.Element> where S : Swift.Sequence {
  @usableFromInline
  internal typealias Element = S.Element
  @inline(__always) @inlinable override final internal func _makeIterator() -> Swift.AnyIterator<Swift._SequenceBox<S>.Element> {
    return AnyIterator(_base.makeIterator())
  }
  @inlinable override final internal var _underestimatedCount: Swift.Int {
    get {
    return _base.underestimatedCount
  }
  }
  @inlinable override final internal func _map<T>(_ transform: (Swift._SequenceBox<S>.Element) throws -> T) throws -> [T] {
#if $TypedThrows
    try _base.map(transform)
#else
    try _base.__rethrows_map(transform)
#endif
  }
  @inlinable override final internal func _filter(_ isIncluded: (Swift._SequenceBox<S>.Element) throws -> Swift.Bool) rethrows -> [Swift._SequenceBox<S>.Element] {
    return try _base.filter(isIncluded)
  }
  @inlinable override final internal func _forEach(_ body: (Swift._SequenceBox<S>.Element) throws -> Swift.Void) rethrows {
    return try _base.forEach(body)
  }
  @inlinable override final internal func __customContainsEquatableElement(_ element: Swift._SequenceBox<S>.Element) -> Swift.Bool? {
    return _base._customContainsEquatableElement(element)
  }
  @inlinable override final internal func __copyToContiguousArray() -> Swift.ContiguousArray<Swift._SequenceBox<S>.Element> {
    return _base._copyToContiguousArray()
  }
  @inlinable override final internal func __copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Swift._SequenceBox<S>.Element>) -> (Swift.AnyIterator<Swift._SequenceBox<S>.Element>, Swift.UnsafeMutableBufferPointer<Swift._SequenceBox<S>.Element>.Index) {
    let (it,idx) = _base._copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
  @inlinable override final internal func _dropFirst(_ n: Swift.Int) -> Swift._AnySequenceBox<Swift._SequenceBox<S>.Element> {
    return _SequenceBox<DropFirstSequence<S>>(_base: _base.dropFirst(n))
  }
  @inlinable override final internal func _drop(while predicate: (Swift._SequenceBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnySequenceBox<Swift._SequenceBox<S>.Element> {
    return try _SequenceBox<DropWhileSequence<S>>(_base: _base.drop(while: predicate))
  }
  @inlinable override final internal func _dropLast(_ n: Swift.Int) -> [Swift._SequenceBox<S>.Element] {
    return _base.dropLast(n)
  }
  @inlinable override final internal func _prefix(_ n: Swift.Int) -> Swift._AnySequenceBox<Swift._SequenceBox<S>.Element> {
    return _SequenceBox<PrefixSequence<S>>(_base: _base.prefix(n))
  }
  @inlinable override final internal func _prefix(while predicate: (Swift._SequenceBox<S>.Element) throws -> Swift.Bool) rethrows -> [Swift._SequenceBox<S>.Element] {
    return try _base.prefix(while: predicate)
  }
  @inlinable override final internal func _suffix(_ maxLength: Swift.Int) -> [Swift._SequenceBox<S>.Element] {
    return _base.suffix(maxLength)
  }
  @objc @inlinable deinit {}
  @inlinable internal init(_base: S) {
    self._base = _base
  }
  @usableFromInline
  final internal var _base: S
}
@available(*, unavailable)
extension Swift._SequenceBox : Swift.Sendable {
}
@usableFromInline
@_fixed_layout final internal class _CollectionBox<S> : Swift._AnyCollectionBox<S.Element> where S : Swift.Collection {
  @usableFromInline
  internal typealias Element = S.Element
  @inline(__always) @inlinable override final internal func _makeIterator() -> Swift.AnyIterator<Swift._CollectionBox<S>.Element> {
    return AnyIterator(_base.makeIterator())
  }
  @inlinable override final internal var _underestimatedCount: Swift.Int {
    get {
    return _base.underestimatedCount
  }
  }
  @inlinable override final internal func _map<T>(_ transform: (Swift._CollectionBox<S>.Element) throws -> T) throws -> [T] {
#if $TypedThrows
    try _base.map(transform)
#else
    try _base.__rethrows_map(transform)
#endif
  }
  @inlinable override final internal func _filter(_ isIncluded: (Swift._CollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> [Swift._CollectionBox<S>.Element] {
    return try _base.filter(isIncluded)
  }
  @inlinable override final internal func _forEach(_ body: (Swift._CollectionBox<S>.Element) throws -> Swift.Void) rethrows {
    return try _base.forEach(body)
  }
  @inlinable override final internal func __customContainsEquatableElement(_ element: Swift._CollectionBox<S>.Element) -> Swift.Bool? {
    return _base._customContainsEquatableElement(element)
  }
  @inlinable override final internal func __copyToContiguousArray() -> Swift.ContiguousArray<Swift._CollectionBox<S>.Element> {
    return _base._copyToContiguousArray()
  }
  @inlinable override final internal func __copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Swift._CollectionBox<S>.Element>) -> (Swift.AnyIterator<Swift._CollectionBox<S>.Element>, Swift.UnsafeMutableBufferPointer<Swift._CollectionBox<S>.Element>.Index) {
    let (it,idx) = _base._copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
  @inline(__always) @inlinable override final internal func _drop(while predicate: (Swift._CollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    return try _CollectionBox<S.SubSequence>(_base: _base.drop(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _dropFirst(_ n: Swift.Int) -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    return _CollectionBox<S.SubSequence>(_base: _base.dropFirst(n))
  }
  @inline(__always) @inlinable override final internal func _dropLast(_ n: Swift.Int) -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    return _CollectionBox<S.SubSequence>(_base: _base.dropLast(n))
  }
  @inline(__always) @inlinable override final internal func _prefix(while predicate: (Swift._CollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    return try _CollectionBox<S.SubSequence>(_base: _base.prefix(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    return _CollectionBox<S.SubSequence>(_base: _base.prefix(maxLength))
  }
  @inline(__always) @inlinable override final internal func _suffix(_ maxLength: Swift.Int) -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    return _CollectionBox<S.SubSequence>(_base: _base.suffix(maxLength))
  }
  @objc @inlinable deinit {}
  @inlinable internal init(_base: S) {
    self._base = _base
    super.init(
      _startIndex: _IndexBox(_base: _base.startIndex),
      endIndex: _IndexBox(_base: _base.endIndex)
    )
  }
  @inlinable final internal func _unbox(_ position: any Swift._AnyIndexBox, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> S.Index {
    if let i = position._unbox() as S.Index? {
      return i
    }
    fatalError("Index type mismatch!", file: file, line: line)
  }
  @inlinable override final internal subscript(position: any Swift._AnyIndexBox) -> Swift._CollectionBox<S>.Element {
    get {
    return _base[_unbox(position)]
  }
  }
  @inlinable override final internal subscript(start start: any Swift._AnyIndexBox, end end: any Swift._AnyIndexBox) -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    get {
    return _CollectionBox<S.SubSequence>(_base:
      _base[_unbox(start)..<_unbox(end)]
    )
  }
  }
  @inlinable override final internal func _index(after position: any Swift._AnyIndexBox) -> any Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(after: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(after position: any Swift._AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(after: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _index(_ i: any Swift._AnyIndexBox, offsetBy n: Swift.Int) -> any Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(_unbox(i), offsetBy: n))
  }
  @inlinable override final internal func _index(_ i: any Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: any Swift._AnyIndexBox) -> (any Swift._AnyIndexBox)? {
    return _base.index(_unbox(i), offsetBy: n, limitedBy: _unbox(limit))
      .map { _IndexBox(_base: $0) }
  }
  @inlinable override final internal func _formIndex(_ i: inout any Swift._AnyIndexBox, offsetBy n: Swift.Int) {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: n)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _formIndex(_ i: inout any Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: any Swift._AnyIndexBox) -> Swift.Bool {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: n, limitedBy: _unbox(limit))
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _distance(from start: any Swift._AnyIndexBox, to end: any Swift._AnyIndexBox) -> Swift.Int {
    return _base.distance(from: _unbox(start), to: _unbox(end))
  }
  @inlinable override final internal var _count: Swift.Int {
    get {
    return _base.count
  }
  }
  @usableFromInline
  final internal var _base: S
}
@available(*, unavailable)
extension Swift._CollectionBox : Swift.Sendable {
}
@usableFromInline
@_fixed_layout final internal class _BidirectionalCollectionBox<S> : Swift._AnyBidirectionalCollectionBox<S.Element> where S : Swift.BidirectionalCollection {
  @usableFromInline
  internal typealias Element = S.Element
  @inline(__always) @inlinable override final internal func _makeIterator() -> Swift.AnyIterator<Swift._BidirectionalCollectionBox<S>.Element> {
    return AnyIterator(_base.makeIterator())
  }
  @inlinable override final internal var _underestimatedCount: Swift.Int {
    get {
    return _base.underestimatedCount
  }
  }
  @inlinable override final internal func _map<T>(_ transform: (Swift._BidirectionalCollectionBox<S>.Element) throws -> T) throws -> [T] {
#if $TypedThrows
    try _base.map(transform)
#else
    try _base.__rethrows_map(transform)
#endif
  }
  @inlinable override final internal func _filter(_ isIncluded: (Swift._BidirectionalCollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> [Swift._BidirectionalCollectionBox<S>.Element] {
    return try _base.filter(isIncluded)
  }
  @inlinable override final internal func _forEach(_ body: (Swift._BidirectionalCollectionBox<S>.Element) throws -> Swift.Void) rethrows {
    return try _base.forEach(body)
  }
  @inlinable override final internal func __customContainsEquatableElement(_ element: Swift._BidirectionalCollectionBox<S>.Element) -> Swift.Bool? {
    return _base._customContainsEquatableElement(element)
  }
  @inlinable override final internal func __copyToContiguousArray() -> Swift.ContiguousArray<Swift._BidirectionalCollectionBox<S>.Element> {
    return _base._copyToContiguousArray()
  }
  @inlinable override final internal func __copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Swift._BidirectionalCollectionBox<S>.Element>) -> (Swift.AnyIterator<Swift._BidirectionalCollectionBox<S>.Element>, Swift.UnsafeMutableBufferPointer<Swift._BidirectionalCollectionBox<S>.Element>.Index) {
    let (it,idx) = _base._copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
  @inline(__always) @inlinable override final internal func _drop(while predicate: (Swift._BidirectionalCollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    return try _BidirectionalCollectionBox<S.SubSequence>(_base: _base.drop(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _dropFirst(_ n: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    return _BidirectionalCollectionBox<S.SubSequence>(_base: _base.dropFirst(n))
  }
  @inline(__always) @inlinable override final internal func _dropLast(_ n: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    return _BidirectionalCollectionBox<S.SubSequence>(_base: _base.dropLast(n))
  }
  @inline(__always) @inlinable override final internal func _prefix(while predicate: (Swift._BidirectionalCollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    return try _BidirectionalCollectionBox<S.SubSequence>(_base: _base.prefix(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    return _BidirectionalCollectionBox<S.SubSequence>(_base: _base.prefix(maxLength))
  }
  @inline(__always) @inlinable override final internal func _suffix(_ maxLength: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    return _BidirectionalCollectionBox<S.SubSequence>(_base: _base.suffix(maxLength))
  }
  @objc @inlinable deinit {}
  @inlinable internal init(_base: S) {
    self._base = _base
    super.init(
      _startIndex: _IndexBox(_base: _base.startIndex),
      endIndex: _IndexBox(_base: _base.endIndex)
    )
  }
  @inlinable final internal func _unbox(_ position: any Swift._AnyIndexBox, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> S.Index {
    if let i = position._unbox() as S.Index? {
      return i
    }
    fatalError("Index type mismatch!", file: file, line: line)
  }
  @inlinable override final internal subscript(position: any Swift._AnyIndexBox) -> Swift._BidirectionalCollectionBox<S>.Element {
    get {
    return _base[_unbox(position)]
  }
  }
  @inlinable override final internal subscript(start start: any Swift._AnyIndexBox, end end: any Swift._AnyIndexBox) -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    get {
    return _BidirectionalCollectionBox<S.SubSequence>(_base:
      _base[_unbox(start)..<_unbox(end)]
    )
  }
  }
  @inlinable override final internal func _index(after position: any Swift._AnyIndexBox) -> any Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(after: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(after position: any Swift._AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(after: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _index(_ i: any Swift._AnyIndexBox, offsetBy n: Swift.Int) -> any Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(_unbox(i), offsetBy: n))
  }
  @inlinable override final internal func _index(_ i: any Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: any Swift._AnyIndexBox) -> (any Swift._AnyIndexBox)? {
    return _base.index(_unbox(i), offsetBy: n, limitedBy: _unbox(limit))
      .map { _IndexBox(_base: $0) }
  }
  @inlinable override final internal func _formIndex(_ i: inout any Swift._AnyIndexBox, offsetBy n: Swift.Int) {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: n)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _formIndex(_ i: inout any Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: any Swift._AnyIndexBox) -> Swift.Bool {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: n, limitedBy: _unbox(limit))
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _distance(from start: any Swift._AnyIndexBox, to end: any Swift._AnyIndexBox) -> Swift.Int {
    return _base.distance(from: _unbox(start), to: _unbox(end))
  }
  @inlinable override final internal var _count: Swift.Int {
    get {
    return _base.count
  }
  }
  @inlinable override final internal func _index(before position: any Swift._AnyIndexBox) -> any Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(before: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(before position: any Swift._AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(before: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @usableFromInline
  final internal var _base: S
}
@available(*, unavailable)
extension Swift._BidirectionalCollectionBox : Swift.Sendable {
}
@usableFromInline
@_fixed_layout final internal class _RandomAccessCollectionBox<S> : Swift._AnyRandomAccessCollectionBox<S.Element> where S : Swift.RandomAccessCollection {
  @usableFromInline
  internal typealias Element = S.Element
  @inline(__always) @inlinable override final internal func _makeIterator() -> Swift.AnyIterator<Swift._RandomAccessCollectionBox<S>.Element> {
    return AnyIterator(_base.makeIterator())
  }
  @inlinable override final internal var _underestimatedCount: Swift.Int {
    get {
    return _base.underestimatedCount
  }
  }
  @inlinable override final internal func _map<T>(_ transform: (Swift._RandomAccessCollectionBox<S>.Element) throws -> T) throws -> [T] {
#if $TypedThrows
    try _base.map(transform)
#else
    try _base.__rethrows_map(transform)
#endif
  }
  @inlinable override final internal func _filter(_ isIncluded: (Swift._RandomAccessCollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> [Swift._RandomAccessCollectionBox<S>.Element] {
    return try _base.filter(isIncluded)
  }
  @inlinable override final internal func _forEach(_ body: (Swift._RandomAccessCollectionBox<S>.Element) throws -> Swift.Void) rethrows {
    return try _base.forEach(body)
  }
  @inlinable override final internal func __customContainsEquatableElement(_ element: Swift._RandomAccessCollectionBox<S>.Element) -> Swift.Bool? {
    return _base._customContainsEquatableElement(element)
  }
  @inlinable override final internal func __copyToContiguousArray() -> Swift.ContiguousArray<Swift._RandomAccessCollectionBox<S>.Element> {
    return _base._copyToContiguousArray()
  }
  @inlinable override final internal func __copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Swift._RandomAccessCollectionBox<S>.Element>) -> (Swift.AnyIterator<Swift._RandomAccessCollectionBox<S>.Element>, Swift.UnsafeMutableBufferPointer<Swift._RandomAccessCollectionBox<S>.Element>.Index) {
    let (it,idx) = _base._copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
  @inline(__always) @inlinable override final internal func _drop(while predicate: (Swift._RandomAccessCollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    return try _RandomAccessCollectionBox<S.SubSequence>(_base: _base.drop(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _dropFirst(_ n: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    return _RandomAccessCollectionBox<S.SubSequence>(_base: _base.dropFirst(n))
  }
  @inline(__always) @inlinable override final internal func _dropLast(_ n: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    return _RandomAccessCollectionBox<S.SubSequence>(_base: _base.dropLast(n))
  }
  @inline(__always) @inlinable override final internal func _prefix(while predicate: (Swift._RandomAccessCollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    return try _RandomAccessCollectionBox<S.SubSequence>(_base: _base.prefix(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    return _RandomAccessCollectionBox<S.SubSequence>(_base: _base.prefix(maxLength))
  }
  @inline(__always) @inlinable override final internal func _suffix(_ maxLength: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    return _RandomAccessCollectionBox<S.SubSequence>(_base: _base.suffix(maxLength))
  }
  @objc @inlinable deinit {}
  @inlinable internal init(_base: S) {
    self._base = _base
    super.init(
      _startIndex: _IndexBox(_base: _base.startIndex),
      endIndex: _IndexBox(_base: _base.endIndex)
    )
  }
  @inlinable final internal func _unbox(_ position: any Swift._AnyIndexBox, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> S.Index {
    if let i = position._unbox() as S.Index? {
      return i
    }
    fatalError("Index type mismatch!", file: file, line: line)
  }
  @inlinable override final internal subscript(position: any Swift._AnyIndexBox) -> Swift._RandomAccessCollectionBox<S>.Element {
    get {
    return _base[_unbox(position)]
  }
  }
  @inlinable override final internal subscript(start start: any Swift._AnyIndexBox, end end: any Swift._AnyIndexBox) -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    get {
    return _RandomAccessCollectionBox<S.SubSequence>(_base:
      _base[_unbox(start)..<_unbox(end)]
    )
  }
  }
  @inlinable override final internal func _index(after position: any Swift._AnyIndexBox) -> any Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(after: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(after position: any Swift._AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(after: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _index(_ i: any Swift._AnyIndexBox, offsetBy n: Swift.Int) -> any Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(_unbox(i), offsetBy: n))
  }
  @inlinable override final internal func _index(_ i: any Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: any Swift._AnyIndexBox) -> (any Swift._AnyIndexBox)? {
    return _base.index(_unbox(i), offsetBy: n, limitedBy: _unbox(limit))
      .map { _IndexBox(_base: $0) }
  }
  @inlinable override final internal func _formIndex(_ i: inout any Swift._AnyIndexBox, offsetBy n: Swift.Int) {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: n)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _formIndex(_ i: inout any Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: any Swift._AnyIndexBox) -> Swift.Bool {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: n, limitedBy: _unbox(limit))
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _distance(from start: any Swift._AnyIndexBox, to end: any Swift._AnyIndexBox) -> Swift.Int {
    return _base.distance(from: _unbox(start), to: _unbox(end))
  }
  @inlinable override final internal var _count: Swift.Int {
    get {
    return _base.count
  }
  }
  @inlinable override final internal func _index(before position: any Swift._AnyIndexBox) -> any Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(before: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(before position: any Swift._AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(before: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @usableFromInline
  final internal var _base: S
}
@available(*, unavailable)
extension Swift._RandomAccessCollectionBox : Swift.Sendable {
}
@usableFromInline
@frozen internal struct _ClosureBasedSequence<Iterator> where Iterator : Swift.IteratorProtocol {
  @usableFromInline
  internal var _makeUnderlyingIterator: () -> Iterator
  @inlinable internal init(_ makeUnderlyingIterator: @escaping () -> Iterator) {
    self._makeUnderlyingIterator = makeUnderlyingIterator
  }
}
@available(*, unavailable)
extension Swift._ClosureBasedSequence : Swift.Sendable {
}
extension Swift._ClosureBasedSequence : Swift.Sequence {
  public typealias Element = Iterator.Element
  @inlinable internal func makeIterator() -> Iterator {
    return _makeUnderlyingIterator()
  }
}
@frozen public struct AnySequence<Element> {
  @usableFromInline
  internal let _box: Swift._AnySequenceBox<Element>
  @inlinable public init<I>(_ makeUnderlyingIterator: @escaping () -> I) where Element == I.Element, I : Swift.IteratorProtocol {
    self.init(_ClosureBasedSequence(makeUnderlyingIterator))
  }
  @inlinable internal init(_box: Swift._AnySequenceBox<Element>) {
    self._box = _box
  }
}
@available(*, unavailable)
extension Swift.AnySequence : Swift.Sendable {
}
extension Swift.AnySequence : Swift.Sequence {
  public typealias Iterator = Swift.AnyIterator<Element>
  @inlinable public init<S>(_ base: S) where Element == S.Element, S : Swift.Sequence {
    self._box = _SequenceBox(_base: base)
  }
}
extension Swift.AnySequence {
  @inline(__always) @inlinable public __consuming func makeIterator() -> Swift.AnySequence<Element>.Iterator {
    return _box._makeIterator()
  }
  @inlinable public __consuming func dropLast(_ n: Swift.Int = 1) -> [Element] {
    return _box._dropLast(n)
  }
  @inlinable public __consuming func prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    return try _box._prefix(while: predicate)
  }
  @inlinable public __consuming func suffix(_ maxLength: Swift.Int) -> [Element] {
    return _box._suffix(maxLength)
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return _box._underestimatedCount
  }
  }
  #if compiler(>=5.3) && $TypedThrows
  @inlinable @_alwaysEmitIntoClient public func map<T, E>(_ transform: (Element) throws(E) -> T) throws(E) -> [T] where E : Swift.Error {
    do {
      return try _box._map(transform)
    } catch {
      throw error as! E
    }
  }
  #endif
  @usableFromInline
  @_silgen_name("$ss11AnySequenceV3mapySayqd__Gqd__xKXEKlF")
  internal func __rethrows_map<T>(_ transform: (Element) throws -> T) throws -> [T]
  @inlinable public __consuming func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    return try _box._filter(isIncluded)
  }
  @inlinable public __consuming func forEach(_ body: (Element) throws -> Swift.Void) rethrows {
    return try _box._forEach(body)
  }
  @inlinable public __consuming func drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnySequence<Element> {
    return try AnySequence(_box: _box._drop(while: predicate))
  }
  @inlinable public __consuming func dropFirst(_ n: Swift.Int = 1) -> Swift.AnySequence<Element> {
    return AnySequence(_box: _box._dropFirst(n))
  }
  @inlinable public __consuming func prefix(_ maxLength: Swift.Int = 1) -> Swift.AnySequence<Element> {
    return AnySequence(_box: _box._prefix(maxLength))
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    return _box.__customContainsEquatableElement(element)
  }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    return self._box.__copyToContiguousArray()
  }
  @inlinable public __consuming func _copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.AnyIterator<Element>, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _box.__copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
}
extension Swift.AnyCollection {
  @inline(__always) @inlinable public __consuming func makeIterator() -> Swift.AnyCollection<Element>.Iterator {
    return _box._makeIterator()
  }
  @inlinable public __consuming func dropLast(_ n: Swift.Int = 1) -> Swift.AnyCollection<Element> {
    return AnyCollection(_box: _box._dropLast(n))
  }
  @inlinable public __consuming func prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnyCollection<Element> {
    return try AnyCollection(_box: _box._prefix(while: predicate))
  }
  @inlinable public __consuming func suffix(_ maxLength: Swift.Int) -> Swift.AnyCollection<Element> {
    return AnyCollection(_box: _box._suffix(maxLength))
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return _box._underestimatedCount
  }
  }
  #if compiler(>=5.3) && $TypedThrows
  @inlinable @_alwaysEmitIntoClient public func map<T, E>(_ transform: (Element) throws(E) -> T) throws(E) -> [T] where E : Swift.Error {
    do {
      return try _box._map(transform)
    } catch {
      throw error as! E
    }
  }
  #endif
  @usableFromInline
  @_silgen_name("$ss13AnyCollectionV3mapySayqd__Gqd__xKXEKlF")
  internal func __rethrows_map<T>(_ transform: (Element) throws -> T) throws -> [T]
  @inlinable public __consuming func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    return try _box._filter(isIncluded)
  }
  @inlinable public __consuming func forEach(_ body: (Element) throws -> Swift.Void) rethrows {
    return try _box._forEach(body)
  }
  @inlinable public __consuming func drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnyCollection<Element> {
    return try AnyCollection(_box: _box._drop(while: predicate))
  }
  @inlinable public __consuming func dropFirst(_ n: Swift.Int = 1) -> Swift.AnyCollection<Element> {
    return AnyCollection(_box: _box._dropFirst(n))
  }
  @inlinable public __consuming func prefix(_ maxLength: Swift.Int = 1) -> Swift.AnyCollection<Element> {
    return AnyCollection(_box: _box._prefix(maxLength))
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    return _box.__customContainsEquatableElement(element)
  }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    return self._box.__copyToContiguousArray()
  }
  @inlinable public __consuming func _copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.AnyIterator<Element>, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _box.__copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
}
extension Swift.AnyBidirectionalCollection {
  @inline(__always) @inlinable public __consuming func makeIterator() -> Swift.AnyBidirectionalCollection<Element>.Iterator {
    return _box._makeIterator()
  }
  @inlinable public __consuming func dropLast(_ n: Swift.Int = 1) -> Swift.AnyBidirectionalCollection<Element> {
    return AnyBidirectionalCollection(_box: _box._dropLast(n))
  }
  @inlinable public __consuming func prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnyBidirectionalCollection<Element> {
    return try AnyBidirectionalCollection(_box: _box._prefix(while: predicate))
  }
  @inlinable public __consuming func suffix(_ maxLength: Swift.Int) -> Swift.AnyBidirectionalCollection<Element> {
    return AnyBidirectionalCollection(_box: _box._suffix(maxLength))
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return _box._underestimatedCount
  }
  }
  #if compiler(>=5.3) && $TypedThrows
  @inlinable @_alwaysEmitIntoClient public func map<T, E>(_ transform: (Element) throws(E) -> T) throws(E) -> [T] where E : Swift.Error {
    do {
      return try _box._map(transform)
    } catch {
      throw error as! E
    }
  }
  #endif
  @usableFromInline
  @_silgen_name("$ss26AnyBidirectionalCollectionV3mapySayqd__Gqd__xKXEKlF")
  internal func __rethrows_map<T>(_ transform: (Element) throws -> T) throws -> [T]
  @inlinable public __consuming func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    return try _box._filter(isIncluded)
  }
  @inlinable public __consuming func forEach(_ body: (Element) throws -> Swift.Void) rethrows {
    return try _box._forEach(body)
  }
  @inlinable public __consuming func drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnyBidirectionalCollection<Element> {
    return try AnyBidirectionalCollection(_box: _box._drop(while: predicate))
  }
  @inlinable public __consuming func dropFirst(_ n: Swift.Int = 1) -> Swift.AnyBidirectionalCollection<Element> {
    return AnyBidirectionalCollection(_box: _box._dropFirst(n))
  }
  @inlinable public __consuming func prefix(_ maxLength: Swift.Int = 1) -> Swift.AnyBidirectionalCollection<Element> {
    return AnyBidirectionalCollection(_box: _box._prefix(maxLength))
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    return _box.__customContainsEquatableElement(element)
  }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    return self._box.__copyToContiguousArray()
  }
  @inlinable public __consuming func _copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.AnyIterator<Element>, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _box.__copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
}
extension Swift.AnyRandomAccessCollection {
  @inline(__always) @inlinable public __consuming func makeIterator() -> Swift.AnyRandomAccessCollection<Element>.Iterator {
    return _box._makeIterator()
  }
  @inlinable public __consuming func dropLast(_ n: Swift.Int = 1) -> Swift.AnyRandomAccessCollection<Element> {
    return AnyRandomAccessCollection(_box: _box._dropLast(n))
  }
  @inlinable public __consuming func prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnyRandomAccessCollection<Element> {
    return try AnyRandomAccessCollection(_box: _box._prefix(while: predicate))
  }
  @inlinable public __consuming func suffix(_ maxLength: Swift.Int) -> Swift.AnyRandomAccessCollection<Element> {
    return AnyRandomAccessCollection(_box: _box._suffix(maxLength))
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return _box._underestimatedCount
  }
  }
  #if compiler(>=5.3) && $TypedThrows
  @inlinable @_alwaysEmitIntoClient public func map<T, E>(_ transform: (Element) throws(E) -> T) throws(E) -> [T] where E : Swift.Error {
    do {
      return try _box._map(transform)
    } catch {
      throw error as! E
    }
  }
  #endif
  @usableFromInline
  @_silgen_name("$ss25AnyRandomAccessCollectionV3mapySayqd__Gqd__xKXEKlF")
  internal func __rethrows_map<T>(_ transform: (Element) throws -> T) throws -> [T]
  @inlinable public __consuming func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    return try _box._filter(isIncluded)
  }
  @inlinable public __consuming func forEach(_ body: (Element) throws -> Swift.Void) rethrows {
    return try _box._forEach(body)
  }
  @inlinable public __consuming func drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnyRandomAccessCollection<Element> {
    return try AnyRandomAccessCollection(_box: _box._drop(while: predicate))
  }
  @inlinable public __consuming func dropFirst(_ n: Swift.Int = 1) -> Swift.AnyRandomAccessCollection<Element> {
    return AnyRandomAccessCollection(_box: _box._dropFirst(n))
  }
  @inlinable public __consuming func prefix(_ maxLength: Swift.Int = 1) -> Swift.AnyRandomAccessCollection<Element> {
    return AnyRandomAccessCollection(_box: _box._prefix(maxLength))
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    return _box.__customContainsEquatableElement(element)
  }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    return self._box.__copyToContiguousArray()
  }
  @inlinable public __consuming func _copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.AnyIterator<Element>, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _box.__copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
}
@usableFromInline
internal protocol _AnyIndexBox : AnyObject {
  var _typeID: Swift.ObjectIdentifier { get }
  func _unbox<T>() -> T? where T : Swift.Comparable
  func _isEqual(to rhs: any Swift._AnyIndexBox) -> Swift.Bool
  func _isLess(than rhs: any Swift._AnyIndexBox) -> Swift.Bool
}
@usableFromInline
@_fixed_layout final internal class _IndexBox<BaseIndex> : Swift._AnyIndexBox where BaseIndex : Swift.Comparable {
  @usableFromInline
  final internal var _base: BaseIndex
  @inlinable internal init(_base: BaseIndex) {
    self._base = _base
  }
  @inlinable final internal func _unsafeUnbox(_ other: any Swift._AnyIndexBox) -> BaseIndex {
    return unsafeDowncast(other, to: _IndexBox.self)._base
  }
  @inlinable final internal var _typeID: Swift.ObjectIdentifier {
    get {
    return ObjectIdentifier(type(of: self))
  }
  }
  @inlinable final internal func _unbox<T>() -> T? where T : Swift.Comparable {
    return (self as _AnyIndexBox as? _IndexBox<T>)?._base
  }
  @inlinable final internal func _isEqual(to rhs: any Swift._AnyIndexBox) -> Swift.Bool {
    return _base == _unsafeUnbox(rhs)
  }
  @inlinable final internal func _isLess(than rhs: any Swift._AnyIndexBox) -> Swift.Bool {
    return _base < _unsafeUnbox(rhs)
  }
  @objc @usableFromInline
  deinit
}
@available(*, unavailable)
extension Swift._IndexBox : Swift.Sendable {
}
@frozen public struct AnyIndex {
  @usableFromInline
  internal var _box: any Swift._AnyIndexBox
  @inlinable public init<BaseIndex>(_ base: BaseIndex) where BaseIndex : Swift.Comparable {
    self._box = _IndexBox(_base: base)
  }
  @inlinable internal init(_box: any Swift._AnyIndexBox) {
    self._box = _box
  }
  @inlinable internal var _typeID: Swift.ObjectIdentifier {
    get {
    return _box._typeID
  }
  }
}
@available(*, unavailable)
extension Swift.AnyIndex : Swift.Sendable {
}
extension Swift.AnyIndex : Swift.Comparable {
  @inlinable public static func == (lhs: Swift.AnyIndex, rhs: Swift.AnyIndex) -> Swift.Bool {
    _precondition(lhs._typeID == rhs._typeID, "Base index types differ")
    return lhs._box._isEqual(to: rhs._box)
  }
  @inlinable public static func < (lhs: Swift.AnyIndex, rhs: Swift.AnyIndex) -> Swift.Bool {
    _precondition(lhs._typeID == rhs._typeID, "Base index types differ")
    return lhs._box._isLess(than: rhs._box)
  }
}
public protocol _AnyCollectionProtocol : Swift.Collection {
  var _boxID: Swift.ObjectIdentifier { get }
}
@frozen public struct AnyCollection<Element> {
  @usableFromInline
  internal let _box: Swift._AnyCollectionBox<Element>
  @inlinable internal init(_box: Swift._AnyCollectionBox<Element>) {
    self._box = _box
  }
}
@available(*, unavailable)
extension Swift.AnyCollection : Swift.Sendable {
}
extension Swift.AnyCollection : Swift.Collection {
  public typealias Indices = Swift.DefaultIndices<Swift.AnyCollection<Element>>
  public typealias Iterator = Swift.AnyIterator<Element>
  public typealias Index = Swift.AnyIndex
  public typealias SubSequence = Swift.AnyCollection<Element>
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.Collection {
     
     
    self._box = _CollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: Swift.AnyCollection<Element>) {
    self._box = other._box
  }
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.BidirectionalCollection {
     
     
    self._box = _BidirectionalCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: Swift.AnyBidirectionalCollection<Element>) {
    self._box = other._box
  }
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.RandomAccessCollection {
     
     
    self._box = _RandomAccessCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: Swift.AnyRandomAccessCollection<Element>) {
    self._box = other._box
  }
  @inlinable public var startIndex: Swift.AnyCollection<Element>.Index {
    get {
    return AnyIndex(_box: _box._startIndex)
  }
  }
  @inlinable public var endIndex: Swift.AnyCollection<Element>.Index {
    get {
    return AnyIndex(_box: _box._endIndex)
  }
  }
  @inlinable public subscript(position: Swift.AnyCollection<Element>.Index) -> Element {
    get {
    return _box[position._box]
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.AnyCollection<Element>.Index>) -> Swift.AnyCollection<Element>.SubSequence {
    get {
    return AnyCollection(_box:
      _box[start: bounds.lowerBound._box, end: bounds.upperBound._box])
  }
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.AnyCollection<Element>.Index, bounds: Swift.Range<Swift.AnyCollection<Element>.Index>) {
     
     
     
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.AnyCollection<Element>.Index>, bounds: Swift.Range<Swift.AnyCollection<Element>.Index>) {
     
     
     
  }
  @inlinable public func index(after i: Swift.AnyCollection<Element>.Index) -> Swift.AnyCollection<Element>.Index {
    return AnyIndex(_box: _box._index(after: i._box))
  }
  @inlinable public func formIndex(after i: inout Swift.AnyCollection<Element>.Index) {
    if _isUnique(&i._box) {
      _box._formIndex(after: i._box)
    }
    else {
      i = index(after: i)
    }
  }
  @inlinable public func index(_ i: Swift.AnyCollection<Element>.Index, offsetBy n: Swift.Int) -> Swift.AnyCollection<Element>.Index {
    return AnyIndex(_box: _box._index(i._box, offsetBy: n))
  }
  @inlinable public func index(_ i: Swift.AnyCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.AnyCollection<Element>.Index) -> Swift.AnyCollection<Element>.Index? {
    return _box._index(i._box, offsetBy: n, limitedBy: limit._box)
      .map { AnyIndex(_box:$0) }
  }
  @inlinable public func formIndex(_ i: inout Swift.AnyCollection<Element>.Index, offsetBy n: Swift.Int) {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n)
    } else {
      i = index(i, offsetBy: n)
    }
  }
  @inlinable public func formIndex(_ i: inout Swift.AnyCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.AnyCollection<Element>.Index) -> Swift.Bool {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n, limitedBy: limit._box)
    }
    if let advanced = index(i, offsetBy: n, limitedBy: limit) {
      i = advanced
      return true
    }
    i = limit
    return false
  }
  @inlinable public func distance(from start: Swift.AnyCollection<Element>.Index, to end: Swift.AnyCollection<Element>.Index) -> Swift.Int {
    return _box._distance(from: start._box, to: end._box)
  }
  @inlinable public var count: Swift.Int {
    get {
    return _box._count
  }
  }
}
extension Swift.AnyCollection : Swift._AnyCollectionProtocol {
  @inlinable public var _boxID: Swift.ObjectIdentifier {
    get {
    return ObjectIdentifier(_box)
  }
  }
}
@frozen public struct AnyBidirectionalCollection<Element> {
  @usableFromInline
  internal let _box: Swift._AnyBidirectionalCollectionBox<Element>
  @inlinable internal init(_box: Swift._AnyBidirectionalCollectionBox<Element>) {
    self._box = _box
  }
}
@available(*, unavailable)
extension Swift.AnyBidirectionalCollection : Swift.Sendable {
}
extension Swift.AnyBidirectionalCollection : Swift.BidirectionalCollection {
  public typealias Indices = Swift.DefaultIndices<Swift.AnyBidirectionalCollection<Element>>
  public typealias Iterator = Swift.AnyIterator<Element>
  public typealias Index = Swift.AnyIndex
  public typealias SubSequence = Swift.AnyBidirectionalCollection<Element>
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.BidirectionalCollection {
     
     
    self._box = _BidirectionalCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: Swift.AnyBidirectionalCollection<Element>) {
    self._box = other._box
  }
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.RandomAccessCollection {
     
     
    self._box = _RandomAccessCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: Swift.AnyRandomAccessCollection<Element>) {
    self._box = other._box
  }
  @inlinable public init?(_ other: Swift.AnyCollection<Element>) {
    guard let box =
      other._box as? _AnyBidirectionalCollectionBox<Element> else {
      return nil
    }
    self._box = box
  }
  @inlinable public var startIndex: Swift.AnyBidirectionalCollection<Element>.Index {
    get {
    return AnyIndex(_box: _box._startIndex)
  }
  }
  @inlinable public var endIndex: Swift.AnyBidirectionalCollection<Element>.Index {
    get {
    return AnyIndex(_box: _box._endIndex)
  }
  }
  @inlinable public subscript(position: Swift.AnyBidirectionalCollection<Element>.Index) -> Element {
    get {
    return _box[position._box]
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.AnyBidirectionalCollection<Element>.Index>) -> Swift.AnyBidirectionalCollection<Element>.SubSequence {
    get {
    return AnyBidirectionalCollection(_box:
      _box[start: bounds.lowerBound._box, end: bounds.upperBound._box])
  }
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.AnyBidirectionalCollection<Element>.Index, bounds: Swift.Range<Swift.AnyBidirectionalCollection<Element>.Index>) {
     
     
     
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.AnyBidirectionalCollection<Element>.Index>, bounds: Swift.Range<Swift.AnyBidirectionalCollection<Element>.Index>) {
     
     
     
  }
  @inlinable public func index(after i: Swift.AnyBidirectionalCollection<Element>.Index) -> Swift.AnyBidirectionalCollection<Element>.Index {
    return AnyIndex(_box: _box._index(after: i._box))
  }
  @inlinable public func formIndex(after i: inout Swift.AnyBidirectionalCollection<Element>.Index) {
    if _isUnique(&i._box) {
      _box._formIndex(after: i._box)
    }
    else {
      i = index(after: i)
    }
  }
  @inlinable public func index(_ i: Swift.AnyBidirectionalCollection<Element>.Index, offsetBy n: Swift.Int) -> Swift.AnyBidirectionalCollection<Element>.Index {
    return AnyIndex(_box: _box._index(i._box, offsetBy: n))
  }
  @inlinable public func index(_ i: Swift.AnyBidirectionalCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.AnyBidirectionalCollection<Element>.Index) -> Swift.AnyBidirectionalCollection<Element>.Index? {
    return _box._index(i._box, offsetBy: n, limitedBy: limit._box)
      .map { AnyIndex(_box:$0) }
  }
  @inlinable public func formIndex(_ i: inout Swift.AnyBidirectionalCollection<Element>.Index, offsetBy n: Swift.Int) {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n)
    } else {
      i = index(i, offsetBy: n)
    }
  }
  @inlinable public func formIndex(_ i: inout Swift.AnyBidirectionalCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.AnyBidirectionalCollection<Element>.Index) -> Swift.Bool {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n, limitedBy: limit._box)
    }
    if let advanced = index(i, offsetBy: n, limitedBy: limit) {
      i = advanced
      return true
    }
    i = limit
    return false
  }
  @inlinable public func distance(from start: Swift.AnyBidirectionalCollection<Element>.Index, to end: Swift.AnyBidirectionalCollection<Element>.Index) -> Swift.Int {
    return _box._distance(from: start._box, to: end._box)
  }
  @inlinable public var count: Swift.Int {
    get {
    return _box._count
  }
  }
  @inlinable public func index(before i: Swift.AnyBidirectionalCollection<Element>.Index) -> Swift.AnyBidirectionalCollection<Element>.Index {
    return AnyIndex(_box: _box._index(before: i._box))
  }
  @inlinable public func formIndex(before i: inout Swift.AnyBidirectionalCollection<Element>.Index) {
    if _isUnique(&i._box) {
      _box._formIndex(before: i._box)
    }
    else {
      i = index(before: i)
    }
  }
}
extension Swift.AnyBidirectionalCollection : Swift._AnyCollectionProtocol {
  @inlinable public var _boxID: Swift.ObjectIdentifier {
    get {
    return ObjectIdentifier(_box)
  }
  }
}
@frozen public struct AnyRandomAccessCollection<Element> {
  @usableFromInline
  internal let _box: Swift._AnyRandomAccessCollectionBox<Element>
  @inlinable internal init(_box: Swift._AnyRandomAccessCollectionBox<Element>) {
    self._box = _box
  }
}
@available(*, unavailable)
extension Swift.AnyRandomAccessCollection : Swift.Sendable {
}
extension Swift.AnyRandomAccessCollection : Swift.RandomAccessCollection {
  public typealias Indices = Swift.DefaultIndices<Swift.AnyRandomAccessCollection<Element>>
  public typealias Iterator = Swift.AnyIterator<Element>
  public typealias Index = Swift.AnyIndex
  public typealias SubSequence = Swift.AnyRandomAccessCollection<Element>
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.RandomAccessCollection {
     
     
    self._box = _RandomAccessCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: Swift.AnyRandomAccessCollection<Element>) {
    self._box = other._box
  }
  @inlinable public init?(_ other: Swift.AnyCollection<Element>) {
    guard let box =
      other._box as? _AnyRandomAccessCollectionBox<Element> else {
      return nil
    }
    self._box = box
  }
  @inlinable public init?(_ other: Swift.AnyBidirectionalCollection<Element>) {
    guard let box =
      other._box as? _AnyRandomAccessCollectionBox<Element> else {
      return nil
    }
    self._box = box
  }
  @inlinable public var startIndex: Swift.AnyRandomAccessCollection<Element>.Index {
    get {
    return AnyIndex(_box: _box._startIndex)
  }
  }
  @inlinable public var endIndex: Swift.AnyRandomAccessCollection<Element>.Index {
    get {
    return AnyIndex(_box: _box._endIndex)
  }
  }
  @inlinable public subscript(position: Swift.AnyRandomAccessCollection<Element>.Index) -> Element {
    get {
    return _box[position._box]
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.AnyRandomAccessCollection<Element>.Index>) -> Swift.AnyRandomAccessCollection<Element>.SubSequence {
    get {
    return AnyRandomAccessCollection(_box:
      _box[start: bounds.lowerBound._box, end: bounds.upperBound._box])
  }
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.AnyRandomAccessCollection<Element>.Index, bounds: Swift.Range<Swift.AnyRandomAccessCollection<Element>.Index>) {
     
     
     
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.AnyRandomAccessCollection<Element>.Index>, bounds: Swift.Range<Swift.AnyRandomAccessCollection<Element>.Index>) {
     
     
     
  }
  @inlinable public func index(after i: Swift.AnyRandomAccessCollection<Element>.Index) -> Swift.AnyRandomAccessCollection<Element>.Index {
    return AnyIndex(_box: _box._index(after: i._box))
  }
  @inlinable public func formIndex(after i: inout Swift.AnyRandomAccessCollection<Element>.Index) {
    if _isUnique(&i._box) {
      _box._formIndex(after: i._box)
    }
    else {
      i = index(after: i)
    }
  }
  @inlinable public func index(_ i: Swift.AnyRandomAccessCollection<Element>.Index, offsetBy n: Swift.Int) -> Swift.AnyRandomAccessCollection<Element>.Index {
    return AnyIndex(_box: _box._index(i._box, offsetBy: n))
  }
  @inlinable public func index(_ i: Swift.AnyRandomAccessCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.AnyRandomAccessCollection<Element>.Index) -> Swift.AnyRandomAccessCollection<Element>.Index? {
    return _box._index(i._box, offsetBy: n, limitedBy: limit._box)
      .map { AnyIndex(_box:$0) }
  }
  @inlinable public func formIndex(_ i: inout Swift.AnyRandomAccessCollection<Element>.Index, offsetBy n: Swift.Int) {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n)
    } else {
      i = index(i, offsetBy: n)
    }
  }
  @inlinable public func formIndex(_ i: inout Swift.AnyRandomAccessCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.AnyRandomAccessCollection<Element>.Index) -> Swift.Bool {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n, limitedBy: limit._box)
    }
    if let advanced = index(i, offsetBy: n, limitedBy: limit) {
      i = advanced
      return true
    }
    i = limit
    return false
  }
  @inlinable public func distance(from start: Swift.AnyRandomAccessCollection<Element>.Index, to end: Swift.AnyRandomAccessCollection<Element>.Index) -> Swift.Int {
    return _box._distance(from: start._box, to: end._box)
  }
  @inlinable public var count: Swift.Int {
    get {
    return _box._count
  }
  }
  @inlinable public func index(before i: Swift.AnyRandomAccessCollection<Element>.Index) -> Swift.AnyRandomAccessCollection<Element>.Index {
    return AnyIndex(_box: _box._index(before: i._box))
  }
  @inlinable public func formIndex(before i: inout Swift.AnyRandomAccessCollection<Element>.Index) {
    if _isUnique(&i._box) {
      _box._formIndex(before: i._box)
    }
    else {
      i = index(before: i)
    }
  }
}
extension Swift.AnyRandomAccessCollection : Swift._AnyCollectionProtocol {
  @inlinable public var _boxID: Swift.ObjectIdentifier {
    get {
    return ObjectIdentifier(_box)
  }
  }
}
@frozen public struct LazyFilterSequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _predicate: (Base.Element) -> Swift.Bool
  @inlinable public init(_base base: Base, _ isIncluded: @escaping (Base.Element) -> Swift.Bool) {
    self._base = base
    self._predicate = isIncluded
  }
}
@available(*, unavailable)
extension Swift.LazyFilterSequence : Swift.Sendable {
}
extension Swift.LazyFilterSequence {
  @frozen public struct Iterator {
    public var base: Base.Iterator {
      get
    }
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal let _predicate: (Base.Element) -> Swift.Bool
    @inlinable internal init(_base: Base.Iterator, _ isIncluded: @escaping (Base.Element) -> Swift.Bool) {
      self._base = _base
      self._predicate = isIncluded
    }
  }
}
@available(*, unavailable)
extension Swift.LazyFilterSequence.Iterator : Swift.Sendable {
}
extension Swift.LazyFilterSequence.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  public typealias Element = Base.Element
  @inlinable public mutating func next() -> Swift.LazyFilterSequence<Base>.Iterator.Element? {
    while let n = _base.next() {
      if _predicate(n) {
        return n
      }
    }
    return nil
  }
  public typealias Iterator = Swift.LazyFilterSequence<Base>.Iterator
}
extension Swift.LazyFilterSequence : Swift.Sequence {
  public typealias Element = Base.Element
  @inlinable public __consuming func makeIterator() -> Swift.LazyFilterSequence<Base>.Iterator {
    return Iterator(_base: _base.makeIterator(), _predicate)
  }
  @inlinable public func _customContainsEquatableElement(_ element: Swift.LazyFilterSequence<Base>.Element) -> Swift.Bool? {
     
    guard _predicate(element) else { return false }
    return _base._customContainsEquatableElement(element)
  }
}
extension Swift.LazyFilterSequence : Swift.LazySequenceProtocol {
  public typealias Elements = Swift.LazyFilterSequence<Base>
}
public typealias LazyFilterCollection<T> = Swift.LazyFilterSequence<T> where T : Swift.Collection
extension Swift.LazyFilterCollection : Swift.Collection where Base : Swift.Collection {
  public typealias SubSequence = Swift.LazyFilterCollection<Base.SubSequence>
  @inlinable public var underestimatedCount: Swift.Int {
    get { return 0 }
  }
  public typealias Index = Base.Index
  @inlinable public var startIndex: Swift.LazyFilterSequence<Base>.Index {
    get {
    var index = _base.startIndex
    while index != _base.endIndex && !_predicate(_base[index]) {
      _base.formIndex(after: &index)
    }
    return index
  }
  }
  @inlinable public var endIndex: Swift.LazyFilterSequence<Base>.Index {
    get {
    return _base.endIndex
  }
  }
  @inlinable public func index(after i: Swift.LazyFilterSequence<Base>.Index) -> Swift.LazyFilterSequence<Base>.Index {
    var i = i
    formIndex(after: &i)
    return i
  }
  @inlinable public func formIndex(after i: inout Swift.LazyFilterSequence<Base>.Index) {
     
    var index = i
    _precondition(index != _base.endIndex, "Can't advance past endIndex")
    repeat {
      _base.formIndex(after: &index)
    } while index != _base.endIndex && !_predicate(_base[index])
    i = index
  }
  @inline(__always) @inlinable internal func _advanceIndex(_ i: inout Swift.LazyFilterSequence<Base>.Index, step: Swift.Int) {
    repeat {
      _base.formIndex(&i, offsetBy: step)
    } while i != _base.endIndex && !_predicate(_base[i])
  }
  @inline(__always) @inlinable internal func _ensureBidirectional(step: Swift.Int) {
     
     
     
     
     
    if step < 0 {
      _ = _base.index(
        _base.endIndex, offsetBy: step, limitedBy: _base.startIndex)
    }
  }
  @inlinable public func distance(from start: Swift.LazyFilterSequence<Base>.Index, to end: Swift.LazyFilterSequence<Base>.Index) -> Swift.Int {
     
     
     
    _ = _base.distance(from: start, to: end)
    var _start: Index
    let _end: Index
    let step: Int
    if start > end {
      _start = end
      _end = start
      step = -1
    }
    else {
      _start = start
      _end = end
      step = 1
    }
    var count = 0
    while _start != _end {
      count += step
      formIndex(after: &_start)
    }
    return count
  }
  @inlinable public func index(_ i: Swift.LazyFilterSequence<Base>.Index, offsetBy n: Swift.Int) -> Swift.LazyFilterSequence<Base>.Index {
    var i = i
    let step = n.signum()
     
     
     
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      _advanceIndex(&i, step: step)
    }
    return i
  }
  @inlinable public func formIndex(_ i: inout Swift.LazyFilterSequence<Base>.Index, offsetBy n: Swift.Int) {
    i = index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.LazyFilterSequence<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.LazyFilterSequence<Base>.Index) -> Swift.LazyFilterSequence<Base>.Index? {
    var i = i
    let step = n.signum()
     
     
     
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      if i == limit {
        return nil
      }
      _advanceIndex(&i, step: step)
    }
    return i
  }
  @inlinable public func formIndex(_ i: inout Swift.LazyFilterSequence<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.LazyFilterSequence<Base>.Index) -> Swift.Bool {
    if let advancedIndex = index(i, offsetBy: n, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
  @inlinable public subscript(position: Swift.LazyFilterSequence<Base>.Index) -> Swift.LazyFilterSequence<Base>.Element {
    get {
    return _base[position]
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.LazyFilterSequence<Base>.Index>) -> Swift.LazyFilterSequence<Base>.SubSequence {
    get {
    return SubSequence(_base: _base[bounds], _predicate)
  }
  }
  @inlinable public func _customLastIndexOfEquatableElement(_ element: Swift.LazyFilterSequence<Base>.Element) -> Swift.LazyFilterSequence<Base>.Index?? {
    guard _predicate(element) else { return .some(nil) }
    return _base._customLastIndexOfEquatableElement(element)
  }
  public typealias Indices = Swift.DefaultIndices<Swift.LazyFilterSequence<Base>>
}
extension Swift.LazyFilterCollection : Swift.LazyCollectionProtocol where Base : Swift.Collection {
}
extension Swift.LazyFilterCollection : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.LazyFilterSequence<Base>.Index) -> Swift.LazyFilterSequence<Base>.Index {
    var i = i
    formIndex(before: &i)
    return i
  }
  @inlinable public func formIndex(before i: inout Swift.LazyFilterSequence<Base>.Index) {
     
    var index = i
    _precondition(index != _base.startIndex, "Can't retreat before startIndex")
    repeat {
      _base.formIndex(before: &index)
    } while !_predicate(_base[index])
    i = index
  }
}
extension Swift.LazySequenceProtocol {
  @inlinable public __consuming func filter(_ isIncluded: @escaping (Self.Elements.Element) -> Swift.Bool) -> Swift.LazyFilterSequence<Self.Elements> {
    return LazyFilterSequence(_base: self.elements, isIncluded)
  }
}
extension Swift.LazyFilterSequence {
  @available(swift 5)
  public __consuming func filter(_ isIncluded: @escaping (Swift.LazyFilterSequence<Base>.Element) -> Swift.Bool) -> Swift.LazyFilterSequence<Base>
}
extension Swift.LazySequenceProtocol {
  @inlinable public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Elements.Element) -> SegmentOfResult) -> Swift.LazySequence<Swift.FlattenSequence<Swift.LazyMapSequence<Self.Elements, SegmentOfResult>>> where SegmentOfResult : Swift.Sequence {
    return self.map(transform).joined()
  }
  @inlinable public func compactMap<ElementOfResult>(_ transform: @escaping (Self.Elements.Element) -> ElementOfResult?) -> Swift.LazyMapSequence<Swift.LazyFilterSequence<Swift.LazyMapSequence<Self.Elements, ElementOfResult?>>, ElementOfResult> {
    return self.map(transform).filter { $0 != nil }.map { $0! }
  }
}
@frozen public struct FlattenSequence<Base> where Base : Swift.Sequence, Base.Element : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @inlinable internal init(_base: Base) {
    self._base = _base
  }
}
extension Swift.FlattenSequence : Swift.Sendable where Base : Swift.Sendable {
}
extension Swift.FlattenSequence {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal var _inner: Base.Element.Iterator?
    @inlinable internal init(_base: Base.Iterator) {
      self._base = _base
    }
  }
}
extension Swift.FlattenSequence.Iterator : Swift.Sendable where Base.Iterator : Swift.Sendable, Base.Element.Iterator : Swift.Sendable {
}
extension Swift.FlattenSequence.Iterator : Swift.IteratorProtocol {
  public typealias Element = Base.Element.Element
  @inlinable public mutating func next() -> Swift.FlattenSequence<Base>.Iterator.Element? {
    repeat {
      if _fastPath(_inner != nil) {
        let ret = _inner!.next()
        if _fastPath(ret != nil) {
          return ret
        }
      }
      let s = _base.next()
      if _slowPath(s == nil) {
        return nil
      }
      _inner = s!.makeIterator()
    }
    while true
  }
}
extension Swift.FlattenSequence.Iterator : Swift.Sequence {
  public typealias Iterator = Swift.FlattenSequence<Base>.Iterator
}
extension Swift.FlattenSequence : Swift.Sequence {
  @inlinable public __consuming func makeIterator() -> Swift.FlattenSequence<Base>.Iterator {
    return Iterator(_base: _base.makeIterator())
  }
  public typealias Element = Swift.FlattenSequence<Base>.Iterator.Element
}
extension Swift.Sequence where Self.Element : Swift.Sequence {
  @inlinable public __consuming func joined() -> Swift.FlattenSequence<Self> {
    return FlattenSequence(_base: self)
  }
}
extension Swift.LazySequenceProtocol where Self.Element : Swift.Sequence {
  @inlinable public __consuming func joined() -> Swift.LazySequence<Swift.FlattenSequence<Self.Elements>> {
    return FlattenSequence(_base: elements).lazy
  }
}
public typealias FlattenCollection<T> = Swift.FlattenSequence<T> where T : Swift.Collection, T.Element : Swift.Collection
extension Swift.FlattenSequence where Base : Swift.Collection, Base.Element : Swift.Collection {
  @frozen public struct Index {
    @usableFromInline
    internal let _outer: Base.Index
    @usableFromInline
    internal let _inner: Base.Element.Index?
    @inlinable internal init(_ _outer: Base.Index, _ inner: Base.Element.Index?) {
      self._outer = _outer
      self._inner = inner
    }
  }
}
extension Swift.FlattenSequence.Index : Swift.Sendable where Base.Index : Swift.Sendable, Base.Element.Index : Swift.Sendable {
}
extension Swift.FlattenSequence.Index : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.FlattenCollection<Base>.Index, rhs: Swift.FlattenCollection<Base>.Index) -> Swift.Bool {
    return lhs._outer == rhs._outer && lhs._inner == rhs._inner
  }
}
extension Swift.FlattenSequence.Index : Swift.Comparable {
  @inlinable public static func < (lhs: Swift.FlattenCollection<Base>.Index, rhs: Swift.FlattenCollection<Base>.Index) -> Swift.Bool {
     
    if lhs._outer != rhs._outer {
      return lhs._outer < rhs._outer
    }

    if let lhsInner = lhs._inner, let rhsInner = rhs._inner {
      return lhsInner < rhsInner
    }

     
     
     
    _precondition(lhs._inner == nil && rhs._inner == nil)

    return false
  }
}
extension Swift.FlattenSequence.Index : Swift.Hashable where Base.Index : Swift.Hashable, Base.Element.Index : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_outer)
    hasher.combine(_inner)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.FlattenCollection : Swift.Collection where Base : Swift.Collection, Base.Element : Swift.Collection {
  @inlinable public var startIndex: Swift.FlattenSequence<Base>.Index {
    get {
    let end = _base.endIndex
    var outer = _base.startIndex
    while outer != end {
      let innerCollection = _base[outer]
      if !innerCollection.isEmpty {
        return Index(outer, innerCollection.startIndex)
      }
      _base.formIndex(after: &outer)
    }

    return endIndex
  }
  }
  @inlinable public var endIndex: Swift.FlattenSequence<Base>.Index {
    get {
    return Index(_base.endIndex, nil)
  }
  }
  @inlinable internal func _index(after i: Swift.FlattenSequence<Base>.Index) -> Swift.FlattenSequence<Base>.Index {
    let innerCollection = _base[i._outer]
    let nextInner = innerCollection.index(after: i._inner!)
    if _fastPath(nextInner != innerCollection.endIndex) {
      return Index(i._outer, nextInner)
    }

    var nextOuter = _base.index(after: i._outer)
    while nextOuter != _base.endIndex {
      let nextInnerCollection = _base[nextOuter]
      if !nextInnerCollection.isEmpty {
        return Index(nextOuter, nextInnerCollection.startIndex)
      }
      _base.formIndex(after: &nextOuter)
    }

    return endIndex
  }
  @inlinable internal func _index(before i: Swift.FlattenSequence<Base>.Index) -> Swift.FlattenSequence<Base>.Index {
    var prevOuter = i._outer
    if prevOuter == _base.endIndex {
      prevOuter = _base.index(prevOuter, offsetBy: -1)
    }
    var prevInnerCollection = _base[prevOuter]
    var prevInner = i._inner ?? prevInnerCollection.endIndex

    while prevInner == prevInnerCollection.startIndex {
      prevOuter = _base.index(prevOuter, offsetBy: -1)
      prevInnerCollection = _base[prevOuter]
      prevInner = prevInnerCollection.endIndex
    }

    return Index(prevOuter, prevInnerCollection.index(prevInner, offsetBy: -1))
  }
  @inlinable public func index(after i: Swift.FlattenSequence<Base>.Index) -> Swift.FlattenSequence<Base>.Index {
    return _index(after: i)
  }
  @inlinable public func formIndex(after i: inout Swift.FlattenSequence<Base>.Index) {
    i = index(after: i)
  }
  @inlinable public func distance(from start: Swift.FlattenSequence<Base>.Index, to end: Swift.FlattenSequence<Base>.Index) -> Swift.Int {
     
     
     
    if start > end {
      _ = _base.distance(from: _base.endIndex, to: _base.startIndex)
    }
    
     
    if start._outer == end._outer {
      guard let i = start._inner, let j = end._inner else { return 0 }
      return _base[start._outer].distance(from: i, to: j)
    }
    
     
    let range = start <= end ? start ..< end : end ..< start
    var outer = range.lowerBound._outer
    var count = 0 as Int  
    
    if let inner = range.lowerBound._inner {
      let collection = _base[outer]
      count += collection.distance(from: inner, to: collection.endIndex)
      _base.formIndex(after: &outer)
    }
    
    while outer < range.upperBound._outer {
      count += _base[outer].count
      _base.formIndex(after: &outer)
    }
    
    if let inner = range.upperBound._inner {
      let collection = _base[outer]
      count += collection.distance(from: collection.startIndex, to: inner)
    }
    
    return start <= end ? count : -count
  }
  @inline(__always) @inlinable internal func _advanceIndex(_ i: inout Swift.FlattenSequence<Base>.Index, step: Swift.Int) {
    _internalInvariant(-1...1 ~= step, "step should be within the -1...1 range")
    i = step < 0 ? _index(before: i) : _index(after: i)
  }
  @inline(__always) @inlinable internal func _ensureBidirectional(step: Swift.Int) {
     
     
     
     
     
    if step < 0 {
      _ = _base.index(
        _base.endIndex, offsetBy: step, limitedBy: _base.startIndex)
    }
  }
  @inlinable public func index(_ i: Swift.FlattenSequence<Base>.Index, offsetBy n: Swift.Int) -> Swift.FlattenSequence<Base>.Index {
    var i = i
    let step = n.signum()
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      _advanceIndex(&i, step: step)
    }
    return i
  }
  @inlinable public func formIndex(_ i: inout Swift.FlattenSequence<Base>.Index, offsetBy n: Swift.Int) {
    i = index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.FlattenSequence<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.FlattenSequence<Base>.Index) -> Swift.FlattenSequence<Base>.Index? {
    var i = i
    let step = n.signum()
     
     
     
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      if i == limit {
        return nil
      }
      _advanceIndex(&i, step: step)
    }
    return i
  }
  @inlinable public func formIndex(_ i: inout Swift.FlattenSequence<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.FlattenSequence<Base>.Index) -> Swift.Bool {
    if let advancedIndex = index(i, offsetBy: n, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
  @inlinable public subscript(position: Swift.FlattenSequence<Base>.Index) -> Base.Element.Element {
    get {
    return _base[position._outer][position._inner!]
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.FlattenSequence<Base>.Index>) -> Swift.Slice<Swift.FlattenCollection<Base>> {
    get {
    return Slice(base: self, bounds: bounds)
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.FlattenSequence<Base>>
  public typealias SubSequence = Swift.Slice<Swift.FlattenCollection<Base>>
}
extension Swift.FlattenCollection : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection, Base.Element : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.FlattenSequence<Base>.Index) -> Swift.FlattenSequence<Base>.Index {
    return _index(before: i)
  }
  @inlinable public func formIndex(before i: inout Swift.FlattenSequence<Base>.Index) {
    i = index(before: i)
  }
}
public protocol FloatingPoint : Swift.Hashable, Swift.SignedNumeric, Swift.Strideable where Self == Self.Magnitude {
  associatedtype Exponent : Swift.SignedInteger
  init(sign: Swift.FloatingPointSign, exponent: Self.Exponent, significand: Self)
  init(signOf: Self, magnitudeOf: Self)
  init(_ value: Swift.Int)
  init<Source>(_ value: Source) where Source : Swift.BinaryInteger
  init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger
  static var radix: Swift.Int { get }
  static var nan: Self { get }
  static var signalingNaN: Self { get }
  static var infinity: Self { get }
  static var greatestFiniteMagnitude: Self { get }
  static var pi: Self { get }
  var ulp: Self { get }
  static var ulpOfOne: Self { get }
  static var leastNormalMagnitude: Self { get }
  static var leastNonzeroMagnitude: Self { get }
  var sign: Swift.FloatingPointSign { get }
  var exponent: Self.Exponent { get }
  var significand: Self { get }
  override static func + (lhs: Self, rhs: Self) -> Self
  override static func += (lhs: inout Self, rhs: Self)
  override prefix static func - (operand: Self) -> Self
  override mutating func negate()
  override static func - (lhs: Self, rhs: Self) -> Self
  override static func -= (lhs: inout Self, rhs: Self)
  override static func * (lhs: Self, rhs: Self) -> Self
  override static func *= (lhs: inout Self, rhs: Self)
  static func / (lhs: Self, rhs: Self) -> Self
  static func /= (lhs: inout Self, rhs: Self)
  func remainder(dividingBy other: Self) -> Self
  mutating func formRemainder(dividingBy other: Self)
  func truncatingRemainder(dividingBy other: Self) -> Self
  mutating func formTruncatingRemainder(dividingBy other: Self)
  func squareRoot() -> Self
  mutating func formSquareRoot()
  func addingProduct(_ lhs: Self, _ rhs: Self) -> Self
  mutating func addProduct(_ lhs: Self, _ rhs: Self)
  static func minimum(_ x: Self, _ y: Self) -> Self
  static func maximum(_ x: Self, _ y: Self) -> Self
  static func minimumMagnitude(_ x: Self, _ y: Self) -> Self
  static func maximumMagnitude(_ x: Self, _ y: Self) -> Self
  func rounded(_ rule: Swift.FloatingPointRoundingRule) -> Self
  mutating func round(_ rule: Swift.FloatingPointRoundingRule)
  var nextUp: Self { get }
  var nextDown: Self { get }
  func isEqual(to other: Self) -> Swift.Bool
  func isLess(than other: Self) -> Swift.Bool
  func isLessThanOrEqualTo(_ other: Self) -> Swift.Bool
  func isTotallyOrdered(belowOrEqualTo other: Self) -> Swift.Bool
  var isNormal: Swift.Bool { get }
  var isFinite: Swift.Bool { get }
  var isZero: Swift.Bool { get }
  var isSubnormal: Swift.Bool { get }
  var isInfinite: Swift.Bool { get }
  var isNaN: Swift.Bool { get }
  var isSignalingNaN: Swift.Bool { get }
  var floatingPointClass: Swift.FloatingPointClassification { get }
  var isCanonical: Swift.Bool { get }
}
@frozen public enum FloatingPointSign : Swift.Int, Swift.Sendable {
  case plus
  case minus
  @inlinable public init?(rawValue: Swift.Int) {
    switch rawValue {
    case 0: self = .plus
    case 1: self = .minus
    default: return nil
    }
  }
  @inlinable public var rawValue: Swift.Int {
    get {
    switch self {
    case .plus: return 0
    case .minus: return 1
    }
  }
  }
  @_transparent @inlinable public static func == (a: Swift.FloatingPointSign, b: Swift.FloatingPointSign) -> Swift.Bool {
    return a.rawValue == b.rawValue
  }
  @inlinable public var hashValue: Swift.Int {
    get { return rawValue.hashValue }
  }
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(rawValue)
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    return rawValue._rawHashValue(seed: seed)
  }
  public typealias RawValue = Swift.Int
}
@frozen public enum FloatingPointClassification : Swift.Sendable {
  case signalingNaN
  case quietNaN
  case negativeInfinity
  case negativeNormal
  case negativeSubnormal
  case negativeZero
  case positiveZero
  case positiveSubnormal
  case positiveNormal
  case positiveInfinity
  public static func == (a: Swift.FloatingPointClassification, b: Swift.FloatingPointClassification) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum FloatingPointRoundingRule : Swift.Sendable {
  case toNearestOrAwayFromZero
  case toNearestOrEven
  case up
  case down
  case towardZero
  case awayFromZero
  public static func == (a: Swift.FloatingPointRoundingRule, b: Swift.FloatingPointRoundingRule) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.FloatingPoint {
  @_transparent public static func == (lhs: Self, rhs: Self) -> Swift.Bool {
    return lhs.isEqual(to: rhs)
  }
  @_transparent public static func < (lhs: Self, rhs: Self) -> Swift.Bool {
    return lhs.isLess(than: rhs)
  }
  @_transparent public static func <= (lhs: Self, rhs: Self) -> Swift.Bool {
    return lhs.isLessThanOrEqualTo(rhs)
  }
  @_transparent public static func > (lhs: Self, rhs: Self) -> Swift.Bool {
    return rhs.isLess(than: lhs)
  }
  @_transparent public static func >= (lhs: Self, rhs: Self) -> Swift.Bool {
    return rhs.isLessThanOrEqualTo(lhs)
  }
}
public protocol BinaryFloatingPoint : Swift.ExpressibleByFloatLiteral, Swift.FloatingPoint {
  associatedtype RawSignificand : Swift.UnsignedInteger
  associatedtype RawExponent : Swift.UnsignedInteger
  init(sign: Swift.FloatingPointSign, exponentBitPattern: Self.RawExponent, significandBitPattern: Self.RawSignificand)
  init(_ value: Swift.Float)
  init(_ value: Swift.Double)
  init<Source>(_ value: Source) where Source : Swift.BinaryFloatingPoint
  init?<Source>(exactly value: Source) where Source : Swift.BinaryFloatingPoint
  static var exponentBitCount: Swift.Int { get }
  static var significandBitCount: Swift.Int { get }
  var exponentBitPattern: Self.RawExponent { get }
  var significandBitPattern: Self.RawSignificand { get }
  var binade: Self { get }
  var significandWidth: Swift.Int { get }
}
extension Swift.FloatingPoint {
  @inlinable public static var ulpOfOne: Self {
    get {
    return (1 as Self).ulp
  }
  }
  @_transparent public func rounded(_ rule: Swift.FloatingPointRoundingRule) -> Self {
    var lhs = self
    lhs.round(rule)
    return lhs
  }
  @_transparent public func rounded() -> Self {
    return rounded(.toNearestOrAwayFromZero)
  }
  @_transparent public mutating func round() {
    round(.toNearestOrAwayFromZero)
  }
  @inlinable public var nextDown: Self {
    @inline(__always) get {
      return -(-self).nextUp
    }
  }
  @inlinable @inline(__always) public func truncatingRemainder(dividingBy other: Self) -> Self {
    var lhs = self
    lhs.formTruncatingRemainder(dividingBy: other)
    return lhs
  }
  @inlinable @inline(__always) public func remainder(dividingBy other: Self) -> Self {
    var lhs = self
    lhs.formRemainder(dividingBy: other)
    return lhs
  }
  @_transparent public func squareRoot() -> Self {
    var lhs = self
    lhs.formSquareRoot( )
    return lhs
  }
  @_transparent public func addingProduct(_ lhs: Self, _ rhs: Self) -> Self {
    var addend = self
    addend.addProduct(lhs, rhs)
    return addend
  }
  @inlinable public static func minimum(_ x: Self, _ y: Self) -> Self {
    if x <= y || y.isNaN { return x }
    return y
  }
  @inlinable public static func maximum(_ x: Self, _ y: Self) -> Self {
    if x > y || y.isNaN { return x }
    return y
  }
  @inlinable public static func minimumMagnitude(_ x: Self, _ y: Self) -> Self {
    if x.magnitude <= y.magnitude || y.isNaN { return x }
    return y
  }
  @inlinable public static func maximumMagnitude(_ x: Self, _ y: Self) -> Self {
    if x.magnitude > y.magnitude || y.isNaN { return x }
    return y
  }
  @inlinable public var floatingPointClass: Swift.FloatingPointClassification {
    get {
    if isSignalingNaN { return .signalingNaN }
    if isNaN { return .quietNaN }
    if isInfinite { return sign == .minus ? .negativeInfinity : .positiveInfinity }
    if isNormal { return sign == .minus ? .negativeNormal : .positiveNormal }
    if isSubnormal { return sign == .minus ? .negativeSubnormal : .positiveSubnormal }
    return sign == .minus ? .negativeZero : .positiveZero
  }
  }
}
extension Swift.BinaryFloatingPoint {
  @inlinable @inline(__always) public static var radix: Swift.Int {
    get { return 2 }
  }
  @inlinable public init(signOf: Self, magnitudeOf: Self) {
    self.init(
      sign: signOf.sign,
      exponentBitPattern: magnitudeOf.exponentBitPattern,
      significandBitPattern: magnitudeOf.significandBitPattern
    )
  }
  public static func _convert<Source>(from source: Source) -> (value: Self, exact: Swift.Bool) where Source : Swift.BinaryFloatingPoint
  @inlinable public init<Source>(_ value: Source) where Source : Swift.BinaryFloatingPoint {
     
     
     
    switch (Source.exponentBitCount, Source.significandBitCount) {
    case (5, 10):
      guard #available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)  
      else {
         
        self = Self._convert(from: value).value * 1
        break
      }
      let value_ = value as? Float16 ?? Float16(
        sign: value.sign,
        exponentBitPattern:
          UInt(truncatingIfNeeded: value.exponentBitPattern),
        significandBitPattern:
          UInt16(truncatingIfNeeded: value.significandBitPattern))
      self = Self(Float(value_))
    case (8, 23):
      let value_ = value as? Float ?? Float(
        sign: value.sign,
        exponentBitPattern:
          UInt(truncatingIfNeeded: value.exponentBitPattern),
        significandBitPattern:
          UInt32(truncatingIfNeeded: value.significandBitPattern))
      self = Self(value_)
    case (11, 52):
      let value_ = value as? Double ?? Double(
        sign: value.sign,
        exponentBitPattern:
          UInt(truncatingIfNeeded: value.exponentBitPattern),
        significandBitPattern:
          UInt64(truncatingIfNeeded: value.significandBitPattern))
      self = Self(value_)
    default:
       
      self = Self._convert(from: value).value * 1
    }
  }
  @inlinable public init?<Source>(exactly value: Source) where Source : Swift.BinaryFloatingPoint {
     
     
    if value.isNaN { return nil }
    
    if (Source.exponentBitCount > Self.exponentBitCount
        || Source.significandBitCount > Self.significandBitCount)
      && value.isFinite && !value.isZero {
      let exponent = value.exponent
      if exponent < Self.leastNormalMagnitude.exponent {
        if exponent < Self.leastNonzeroMagnitude.exponent { return nil }
        if value.significandWidth >
          Int(Self.Exponent(exponent) - Self.leastNonzeroMagnitude.exponent) {
          return nil
        }
      } else {
        if exponent > Self.greatestFiniteMagnitude.exponent { return nil }
        if value.significandWidth >
          Self.greatestFiniteMagnitude.significandWidth {
          return nil
        }
      }
    }
    
    self = Self(value)
  }
  @inlinable public func isTotallyOrdered(belowOrEqualTo other: Self) -> Swift.Bool {
     
    if self < other { return true }
    if other > self { return false }
     
     
     
     
    if sign != other.sign { return sign == .minus }
     
    if exponentBitPattern > other.exponentBitPattern { return sign == .minus }
    if exponentBitPattern < other.exponentBitPattern { return sign == .plus }
     
    if significandBitPattern > other.significandBitPattern {
      return sign == .minus
    }
    if significandBitPattern < other.significandBitPattern {
      return sign == .plus
    }
     
    return true
  }
}
extension Swift.BinaryFloatingPoint where Self.RawSignificand : Swift.FixedWidthInteger {
  public static func _convert<Source>(from source: Source) -> (value: Self, exact: Swift.Bool) where Source : Swift.BinaryInteger
  @inlinable public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
    self = Self._convert(from: value).value
  }
  @inlinable public init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger {
    let (value_, exact) = Self._convert(from: value)
    guard exact else { return nil }
    self = value_
  }
}
public protocol Hashable : Swift.Equatable {
  var hashValue: Swift.Int { get }
  func hash(into hasher: inout Swift.Hasher)
  func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Swift.Hashable {
  @inlinable @inline(__always) public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    var hasher = Hasher(_seed: seed)
    hasher.combine(self)
    return hasher._finalize()
  }
}
@inlinable @inline(__always) public func _hashValue<H>(for value: H) -> Swift.Int where H : Swift.Hashable {
  return value._rawHashValue(seed: 0)
}
public protocol _HasCustomAnyHashableRepresentation {
  __consuming func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@usableFromInline
internal protocol _AnyHashableBox {
  var _canonicalBox: any Swift._AnyHashableBox { get }
  func _isEqual(to box: any Swift._AnyHashableBox) -> Swift.Bool?
  var _hashValue: Swift.Int { get }
  func _hash(into hasher: inout Swift.Hasher)
  func _rawHashValue(_seed: Swift.Int) -> Swift.Int
  var _base: Any { get }
  func _unbox<T>() -> T? where T : Swift.Hashable
  func _downCastConditional<T>(into result: Swift.UnsafeMutablePointer<T>) -> Swift.Bool
}
@frozen public struct AnyHashable {
  internal var _box: any Swift._AnyHashableBox
  @_specialize(exported: false, kind: full, where H == Swift.String)
  public init<H>(_ base: H) where H : Swift.Hashable
  public var base: Any {
    get
  }
}
@available(*, unavailable)
extension Swift.AnyHashable : Swift.Sendable {
}
extension Swift.AnyHashable : Swift.Equatable {
  public static func == (lhs: Swift.AnyHashable, rhs: Swift.AnyHashable) -> Swift.Bool
}
extension Swift.AnyHashable : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Swift.AnyHashable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Swift.AnyHashable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.AnyHashable : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.AnyHashable : Swift._HasCustomAnyHashableRepresentation {
}
extension Swift.AnyHashable {
  @_alwaysEmitIntoClient public __consuming func _toCustomAnyHashable() -> Swift.AnyHashable? {
    return self
  }
}
@inlinable public func _convertToAnyHashable<H>(_ value: H) -> Swift.AnyHashable where H : Swift.Hashable {
  return AnyHashable(value)
}
extension Swift.Hasher {
  @usableFromInline
  @frozen internal struct _TailBuffer {
    internal var value: Swift.UInt64
  }
}
extension Swift.Hasher {
  @usableFromInline
  @frozen internal struct _Core {
    private var _buffer: Swift.Hasher._TailBuffer
    private var _state: Swift.Hasher._State
  }
}
@frozen public struct Hasher {
  internal var _core: Swift.Hasher._Core
  @_effects(releasenone) public init()
  @usableFromInline
  @_effects(releasenone) internal init(_seed: Swift.Int)
  @usableFromInline
  @_effects(releasenone) internal init(_rawSeed: (Swift.UInt64, Swift.UInt64))
  @inlinable internal static var _isDeterministic: Swift.Bool {
    @inline(__always) get {
      return _swift_stdlib_Hashing_parameters.deterministic
    }
  }
  @inlinable internal static var _executionSeed: (Swift.UInt64, Swift.UInt64) {
    @inline(__always) get {
      let params = _swift_stdlib_Hashing_parameters

       
       
       
       
      return (params.seed0, params.seed1)
    }
  }
  @inlinable @inline(__always) public mutating func combine<H>(_ value: H) where H : Swift.Hashable {
    value.hash(into: &self)
  }
  @usableFromInline
  @_effects(releasenone) internal mutating func _combine(_ value: Swift.UInt)
  @usableFromInline
  @_effects(releasenone) internal mutating func _combine(_ value: Swift.UInt64)
  @usableFromInline
  @_effects(releasenone) internal mutating func _combine(_ value: Swift.UInt32)
  @usableFromInline
  @_effects(releasenone) internal mutating func _combine(_ value: Swift.UInt16)
  @usableFromInline
  @_effects(releasenone) internal mutating func _combine(_ value: Swift.UInt8)
  @usableFromInline
  @_effects(releasenone) internal mutating func _combine(bytes value: Swift.UInt64, count: Swift.Int)
  @_effects(releasenone) public mutating func combine(bytes: Swift.UnsafeRawBufferPointer)
  @usableFromInline
  @_effects(releasenone) internal mutating func _finalize() -> Swift.Int
  @_effects(releasenone) public __consuming func finalize() -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func _hash(seed: Swift.Int, _ value: Swift.UInt64) -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func _hash(seed: Swift.Int, _ value: Swift.UInt) -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func _hash(seed: Swift.Int, bytes value: Swift.UInt64, count: Swift.Int) -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func _hash(seed: Swift.Int, bytes: Swift.UnsafeRawBufferPointer) -> Swift.Int
}
@usableFromInline
@_transparent internal var _hashContainerDefaultMaxLoadFactorInverse: Swift.Double {
  @_transparent get {
  return 1.0 / 0.75
}
}
@usableFromInline
internal protocol _HashTableDelegate {
  func hashValue(at bucket: Swift._HashTable.Bucket) -> Swift.Int
  func moveEntry(from source: Swift._HashTable.Bucket, to target: Swift._HashTable.Bucket)
}
@usableFromInline
@frozen internal struct _HashTable {
  @usableFromInline
  internal typealias Word = Swift._UnsafeBitset.Word
  @usableFromInline
  internal var words: Swift.UnsafeMutablePointer<Swift._HashTable.Word>
  @usableFromInline
  internal let bucketMask: Swift.Int
  @inlinable @inline(__always) internal init(words: Swift.UnsafeMutablePointer<Swift._HashTable.Word>, bucketCount: Swift.Int) {
    _internalInvariant(bucketCount > 0 && bucketCount & (bucketCount - 1) == 0,
      "bucketCount must be a power of two")
    self.words = words
     
     
    self.bucketMask = bucketCount &- 1
  }
  @inlinable internal var bucketCount: Swift.Int {
    @inline(__always) get {
      return _assumeNonNegative(bucketMask &+ 1)
    }
  }
  @inlinable internal var wordCount: Swift.Int {
    @inline(__always) get {
      return _UnsafeBitset.wordCount(forCapacity: bucketCount)
    }
  }
  @_alwaysEmitIntoClient internal var bitset: Swift._UnsafeBitset {
    get {
    _UnsafeBitset(words: words, wordCount: wordCount)
  }
  }
}
@available(*, unavailable)
extension Swift._HashTable : Swift.Sendable {
}
extension Swift._HashTable {
  @usableFromInline
  @frozen internal struct Bucket {
    @usableFromInline
    internal var offset: Swift.Int
    @inlinable @inline(__always) internal init(offset: Swift.Int) {
      self.offset = offset
    }
    @inlinable @inline(__always) internal init(word: Swift.Int, bit: Swift.Int) {
      self.offset = _UnsafeBitset.join(word: word, bit: bit)
    }
    @inlinable internal var word: Swift.Int {
      @inline(__always) get {
        return _UnsafeBitset.word(for: offset)
      }
    }
    @inlinable internal var bit: Swift.Int {
      @inline(__always) get {
        return _UnsafeBitset.bit(for: offset)
      }
    }
  }
}
extension Swift._HashTable.Bucket : Swift.Equatable {
  @inlinable @inline(__always) internal static func == (lhs: Swift._HashTable.Bucket, rhs: Swift._HashTable.Bucket) -> Swift.Bool {
    return lhs.offset == rhs.offset
  }
}
extension Swift._HashTable.Bucket : Swift.Comparable {
  @inlinable @inline(__always) internal static func < (lhs: Swift._HashTable.Bucket, rhs: Swift._HashTable.Bucket) -> Swift.Bool {
    return lhs.offset < rhs.offset
  }
}
extension Swift._HashTable {
  @usableFromInline
  @frozen internal struct Index {
    @usableFromInline
    internal let bucket: Swift._HashTable.Bucket
    @usableFromInline
    internal let age: Swift.Int32
    @inlinable @inline(__always) internal init(bucket: Swift._HashTable.Bucket, age: Swift.Int32) {
      self.bucket = bucket
      self.age = age
    }
  }
}
extension Swift._HashTable.Index : Swift.Equatable {
  @inlinable @inline(__always) internal static func == (lhs: Swift._HashTable.Index, rhs: Swift._HashTable.Index) -> Swift.Bool {
    _precondition(lhs.age == rhs.age,
      "Can't compare indices belonging to different collections")
    return lhs.bucket == rhs.bucket
  }
}
extension Swift._HashTable.Index : Swift.Comparable {
  @inlinable @inline(__always) internal static func < (lhs: Swift._HashTable.Index, rhs: Swift._HashTable.Index) -> Swift.Bool {
    _precondition(lhs.age == rhs.age,
      "Can't compare indices belonging to different collections")
    return lhs.bucket < rhs.bucket
  }
}
extension Swift._HashTable : Swift.Sequence {
  @usableFromInline
  @frozen internal struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal let hashTable: Swift._HashTable
    @usableFromInline
    internal var wordIndex: Swift.Int
    @usableFromInline
    internal var word: Swift._HashTable.Word
    @inlinable @inline(__always) internal init(_ hashTable: Swift._HashTable) {
      self.hashTable = hashTable
      self.wordIndex = 0
      self.word = hashTable.words[0]
      if hashTable.bucketCount < Word.capacity {
        self.word = self.word.intersecting(elementsBelow: hashTable.bucketCount)
      }
    }
    @inlinable @inline(__always) internal mutating func next() -> Swift._HashTable.Bucket? {
      if let bit = word.next() {
        return Bucket(word: wordIndex, bit: bit)
      }
      while wordIndex + 1 < hashTable.wordCount {
        wordIndex += 1
        word = hashTable.words[wordIndex]
        if let bit = word.next() {
          return Bucket(word: wordIndex, bit: bit)
        }
      }
      return nil
    }
    @usableFromInline
    internal typealias Element = Swift._HashTable.Bucket
  }
  @inlinable @inline(__always) internal func makeIterator() -> Swift._HashTable.Iterator {
    return Iterator(self)
  }
  @usableFromInline
  internal typealias Element = Swift._HashTable.Bucket
}
@available(*, unavailable)
extension Swift._HashTable.Iterator : Swift.Sendable {
}
extension Swift._HashTable {
  @inlinable @inline(__always) internal func isValid(_ bucket: Swift._HashTable.Bucket) -> Swift.Bool {
    return bucket.offset >= 0 && bucket.offset < bucketCount
  }
  @inlinable @inline(__always) internal func _isOccupied(_ bucket: Swift._HashTable.Bucket) -> Swift.Bool {
    _internalInvariant(isValid(bucket))
    return words[bucket.word].uncheckedContains(bucket.bit)
  }
  @inlinable @inline(__always) internal func isOccupied(_ bucket: Swift._HashTable.Bucket) -> Swift.Bool {
    return isValid(bucket) && _isOccupied(bucket)
  }
  @inlinable @inline(__always) internal func checkOccupied(_ bucket: Swift._HashTable.Bucket) {
    _precondition(isOccupied(bucket),
      "Attempting to access Collection elements using an invalid Index")
  }
  @inlinable @inline(__always) internal func _firstOccupiedBucket(fromWord word: Swift.Int) -> Swift._HashTable.Bucket {
    _internalInvariant(word >= 0 && word <= wordCount)
    var word = word
    while word < wordCount {
      if let bit = words[word].minimum {
        return Bucket(word: word, bit: bit)
      }
      word += 1
    }
    return endBucket
  }
  @inlinable internal func occupiedBucket(after bucket: Swift._HashTable.Bucket) -> Swift._HashTable.Bucket {
    _internalInvariant(isValid(bucket))
    let word = bucket.word
    if let bit = words[word].intersecting(elementsAbove: bucket.bit).minimum {
      return Bucket(word: word, bit: bit)
    }
    return _firstOccupiedBucket(fromWord: word + 1)
  }
  @inlinable internal var startBucket: Swift._HashTable.Bucket {
    get {
    return _firstOccupiedBucket(fromWord: 0)
  }
  }
  @inlinable internal var endBucket: Swift._HashTable.Bucket {
    @inline(__always) get {
      return Bucket(offset: bucketCount)
    }
  }
}
extension Swift._HashTable {
  @inlinable @inline(__always) internal func idealBucket(forHashValue hashValue: Swift.Int) -> Swift._HashTable.Bucket {
    return Bucket(offset: hashValue & bucketMask)
  }
  @inlinable @inline(__always) internal func bucket(wrappedAfter bucket: Swift._HashTable.Bucket) -> Swift._HashTable.Bucket {
     
     
    return Bucket(offset: (bucket.offset &+ 1) & bucketMask)
  }
}
extension Swift._HashTable {
  @inlinable internal func previousHole(before bucket: Swift._HashTable.Bucket) -> Swift._HashTable.Bucket {
    _internalInvariant(isValid(bucket))
     
     
    var word = bucket.word
    if let bit =
      words[word]
        .complement
        .intersecting(elementsBelow: bucket.bit)
        .maximum {
      return Bucket(word: word, bit: bit)
    }
    var wrap = false
    while true {
      word -= 1
      if word < 0 {
        _precondition(!wrap, "Hash table has no holes")
        wrap = true
        word = wordCount - 1
      }
      if let bit = words[word].complement.maximum {
        return Bucket(word: word, bit: bit)
      }
    }
  }
  @inlinable internal func nextHole(atOrAfter bucket: Swift._HashTable.Bucket) -> Swift._HashTable.Bucket {
    _internalInvariant(isValid(bucket))
     
     
    var word = bucket.word
    if let bit =
      words[word]
        .complement
        .subtracting(elementsBelow: bucket.bit)
        .minimum {
      return Bucket(word: word, bit: bit)
    }
    var wrap = false
    while true {
      word &+= 1
      if word == wordCount {
        _precondition(!wrap, "Hash table has no holes")
        wrap = true
        word = 0
      }
      if let bit = words[word].complement.minimum {
        return Bucket(word: word, bit: bit)
      }
    }
  }
}
extension Swift._HashTable {
  @inlinable @inline(__always) @_effects(releasenone) internal func copyContents(of other: Swift._HashTable) {
    _internalInvariant(bucketCount == other.bucketCount)
    self.words.update(from: other.words, count: wordCount)
  }
  @inlinable @inline(__always) internal func insertNew(hashValue: Swift.Int) -> Swift._HashTable.Bucket {
    let hole = nextHole(atOrAfter: idealBucket(forHashValue: hashValue))
    insert(hole)
    return hole
  }
  @inlinable @inline(__always) internal func insert(_ bucket: Swift._HashTable.Bucket) {
    _internalInvariant(!isOccupied(bucket))
    words[bucket.word].uncheckedInsert(bucket.bit)
  }
  @inlinable @inline(__always) internal func clear() {
    if bucketCount < Word.capacity {
       
       
       
      words[0] = Word.allBits.subtracting(elementsBelow: bucketCount)
    } else {
      words.update(repeating: .empty, count: wordCount)
    }
  }
  @inline(__always) @inlinable internal func delete<D>(at bucket: Swift._HashTable.Bucket, with delegate: D) where D : Swift._HashTableDelegate {
    _internalInvariant(isOccupied(bucket))

     
     

    var hole = bucket
    var candidate = self.bucket(wrappedAfter: hole)

    guard _isOccupied(candidate) else {
       
      words[hole.word].uncheckedRemove(hole.bit)
      return
    }

     
     
    let start = self.bucket(wrappedAfter: previousHole(before: bucket))

     
     
    while _isOccupied(candidate) {
      let candidateHash = delegate.hashValue(at: candidate)
      let ideal = idealBucket(forHashValue: candidateHash)

       
       
       
      let c0 = ideal >= start
      let c1 = ideal <= hole
      if start <= hole ? (c0 && c1) : (c0 || c1) {
        delegate.moveEntry(from: candidate, to: hole)
        hole = candidate
      }
      candidate = self.bucket(wrappedAfter: candidate)
    }

    words[hole.word].uncheckedRemove(hole.bit)
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol Identifiable<ID> {
  associatedtype ID : Swift.Hashable
  var id: Self.ID { get }
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol Identifiable {
  associatedtype ID : Swift.Hashable
  var id: Self.ID { get }
}
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.Identifiable where Self : AnyObject {
  public var id: Swift.ObjectIdentifier {
    get
  }
}
@frozen public struct DefaultIndices<Elements> where Elements : Swift.Collection {
  @usableFromInline
  internal var _elements: Elements
  @usableFromInline
  internal var _startIndex: Elements.Index
  @usableFromInline
  internal var _endIndex: Elements.Index
  @inlinable internal init(_elements: Elements, startIndex: Elements.Index, endIndex: Elements.Index) {
    self._elements = _elements
    self._startIndex = startIndex
    self._endIndex = endIndex
  }
}
extension Swift.DefaultIndices : Swift.Collection {
  public typealias Index = Elements.Index
  public typealias Element = Elements.Index
  public typealias Indices = Swift.DefaultIndices<Elements>
  public typealias SubSequence = Swift.DefaultIndices<Elements>
  public typealias Iterator = Swift.IndexingIterator<Swift.DefaultIndices<Elements>>
  @inlinable public var startIndex: Swift.DefaultIndices<Elements>.Index {
    get {
    return _startIndex
  }
  }
  @inlinable public var endIndex: Swift.DefaultIndices<Elements>.Index {
    get {
    return _endIndex
  }
  }
  @inlinable public subscript(i: Swift.DefaultIndices<Elements>.Index) -> Elements.Index {
    get {
     
    return i
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.DefaultIndices<Elements>.Index>) -> Swift.DefaultIndices<Elements> {
    get {
     
    return DefaultIndices(
      _elements: _elements,
      startIndex: bounds.lowerBound,
      endIndex: bounds.upperBound)
  }
  }
  @inlinable public func index(after i: Swift.DefaultIndices<Elements>.Index) -> Swift.DefaultIndices<Elements>.Index {
     
    return _elements.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Swift.DefaultIndices<Elements>.Index) {
     
    _elements.formIndex(after: &i)
  }
  @inlinable public var indices: Swift.DefaultIndices<Elements>.Indices {
    get {
    return self
  }
  }
  @_alwaysEmitIntoClient public func index(_ i: Swift.DefaultIndices<Elements>.Index, offsetBy distance: Swift.Int) -> Swift.DefaultIndices<Elements>.Index {
    return _elements.index(i, offsetBy: distance)
  }
  @_alwaysEmitIntoClient public func index(_ i: Swift.DefaultIndices<Elements>.Index, offsetBy distance: Swift.Int, limitedBy limit: Swift.DefaultIndices<Elements>.Index) -> Swift.DefaultIndices<Elements>.Index? {
    return _elements.index(i, offsetBy: distance, limitedBy: limit)
  }
  @_alwaysEmitIntoClient public func distance(from start: Swift.DefaultIndices<Elements>.Index, to end: Swift.DefaultIndices<Elements>.Index) -> Swift.Int {
    return _elements.distance(from: start, to: end)
  }
}
extension Swift.DefaultIndices : Swift.BidirectionalCollection where Elements : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.DefaultIndices<Elements>.Index) -> Swift.DefaultIndices<Elements>.Index {
     
    return _elements.index(before: i)
  }
  @inlinable public func formIndex(before i: inout Swift.DefaultIndices<Elements>.Index) {
     
    _elements.formIndex(before: &i)
  }
}
extension Swift.DefaultIndices : Swift.RandomAccessCollection where Elements : Swift.RandomAccessCollection {
}
extension Swift.Collection where Self.Indices == Swift.DefaultIndices<Self> {
  @inlinable public var indices: Swift.DefaultIndices<Self> {
    get {
    return DefaultIndices(
      _elements: self,
      startIndex: self.startIndex,
      endIndex: self.endIndex)
  }
  }
}
extension Swift.DefaultIndices : Swift.Sendable where Elements : Swift.Sendable, Elements.Index : Swift.Sendable {
}
public func readLine(strippingNewline: Swift.Bool = true) -> Swift.String?
@_alwaysEmitIntoClient internal func _parseIntegerDigits<Result>(ascii codeUnits: Swift.UnsafeBufferPointer<Swift.UInt8>, radix: Swift.Int, isNegative: Swift.Bool) -> Result? where Result : Swift.FixedWidthInteger {
  _internalInvariant(radix >= 2 && radix <= 36)
  guard _fastPath(!codeUnits.isEmpty) else { return nil }
  
   
  let _0 = 48 as UInt8, _A = 65 as UInt8, _a = 97 as UInt8
  
  let numericalUpperBound: UInt8
  let uppercaseUpperBound: UInt8
  let lowercaseUpperBound: UInt8
  if radix <= 10 {
    numericalUpperBound = _0 &+ UInt8(truncatingIfNeeded: radix)
    uppercaseUpperBound = _A
    lowercaseUpperBound = _a
  } else {
    numericalUpperBound = _0 &+ 10
    uppercaseUpperBound = _A &+ UInt8(truncatingIfNeeded: radix &- 10)
    lowercaseUpperBound = _a &+ UInt8(truncatingIfNeeded: radix &- 10)
  }
  let multiplicand = Result(truncatingIfNeeded: radix)
  var result = 0 as Result
  for digit in codeUnits {
    let digitValue: Result
    if _fastPath(digit >= _0 && digit < numericalUpperBound) {
      digitValue = Result(truncatingIfNeeded: digit &- _0)
    } else if _fastPath(digit >= _A && digit < uppercaseUpperBound) {
      digitValue = Result(truncatingIfNeeded: digit &- _A &+ 10)
    } else if _fastPath(digit >= _a && digit < lowercaseUpperBound) {
      digitValue = Result(truncatingIfNeeded: digit &- _a &+ 10)
    } else {
      return nil
    }
    let overflow1: Bool
    (result, overflow1) = result.multipliedReportingOverflow(by: multiplicand)
    let overflow2: Bool
    (result, overflow2) = isNegative
      ? result.subtractingReportingOverflow(digitValue)
      : result.addingReportingOverflow(digitValue)
    guard _fastPath(!overflow1 && !overflow2) else { return nil }
  }
  return result
}
@_alwaysEmitIntoClient @inline(__always) internal func _parseInteger<Result>(ascii codeUnits: Swift.UnsafeBufferPointer<Swift.UInt8>, radix: Swift.Int) -> Result? where Result : Swift.FixedWidthInteger {
  _internalInvariant(!codeUnits.isEmpty)
  
   
  let _plus = 43 as UInt8, _minus = 45 as UInt8
  
  let first = codeUnits[0]
  if first == _minus {
    return _parseIntegerDigits(
      ascii: UnsafeBufferPointer(rebasing: codeUnits[1...]),
      radix: radix, isNegative: true)
  }
  if first == _plus {
    return _parseIntegerDigits(
      ascii: UnsafeBufferPointer(rebasing: codeUnits[1...]),
      radix: radix, isNegative: false)
  }
  return _parseIntegerDigits(ascii: codeUnits, radix: radix, isNegative: false)
}
@_alwaysEmitIntoClient @inline(never) internal func _parseInteger<S, Result>(ascii text: S, radix: Swift.Int) -> Result? where S : Swift.StringProtocol, Result : Swift.FixedWidthInteger {
  var str = String(text)
  return str.withUTF8 { _parseInteger(ascii: $0, radix: radix) }
}
extension Swift.FixedWidthInteger {
  @inlinable @inline(__always) public init?<S>(_ text: S, radix: Swift.Int = 10) where S : Swift.StringProtocol {
    _precondition(2...36 ~= radix, "Radix not in range 2...36")
    guard _fastPath(!text.isEmpty) else { return nil }
    let result: Self? =
      text.utf8.withContiguousStorageIfAvailable {
        _parseInteger(ascii: $0, radix: radix)
      } ?? _parseInteger(ascii: text, radix: radix)
    guard let result_ = result else { return nil }
    self = result_
  }
  @inlinable @inline(__always) public init?(_ description: Swift.String) {
    self.init(description, radix: 10)
  }
}
@usableFromInline
internal func _ascii16(_ c: Swift.Unicode.Scalar) -> Swift.UTF16.CodeUnit
@usableFromInline
internal func _asciiDigit<CodeUnit, Result>(codeUnit u_: CodeUnit, radix: Result) -> Result? where CodeUnit : Swift.UnsignedInteger, Result : Swift.BinaryInteger
@usableFromInline
internal func _parseUnsignedASCII<Rest, Result>(first: Rest.Element, rest: inout Rest, radix: Result, positive: Swift.Bool) -> Result? where Rest : Swift.IteratorProtocol, Result : Swift.FixedWidthInteger, Rest.Element : Swift.UnsignedInteger
@usableFromInline
internal func _parseASCII<CodeUnits, Result>(codeUnits: inout CodeUnits, radix: Result) -> Result? where CodeUnits : Swift.IteratorProtocol, Result : Swift.FixedWidthInteger, CodeUnits.Element : Swift.UnsignedInteger
extension Swift.FixedWidthInteger {
  @usableFromInline
  @_semantics("optimize.sil.specialize.generic.partial.never") @inline(never) internal static func _parseASCIISlowPath<CodeUnits, Result>(codeUnits: inout CodeUnits, radix: Result) -> Result? where CodeUnits : Swift.IteratorProtocol, Result : Swift.FixedWidthInteger, CodeUnits.Element : Swift.UnsignedInteger
}
extension Swift.ExpressibleByIntegerLiteral where Self : Swift._ExpressibleByBuiltinIntegerLiteral {
  @_transparent public init(integerLiteral value: Self) {
    self = value
  }
}
public protocol AdditiveArithmetic : Swift.Equatable {
  static var zero: Self { get }
  static func + (lhs: Self, rhs: Self) -> Self
  static func += (lhs: inout Self, rhs: Self)
  static func - (lhs: Self, rhs: Self) -> Self
  static func -= (lhs: inout Self, rhs: Self)
}
extension Swift.AdditiveArithmetic {
  @_alwaysEmitIntoClient public static func += (lhs: inout Self, rhs: Self) {
    lhs = lhs + rhs
  }
  @_alwaysEmitIntoClient public static func -= (lhs: inout Self, rhs: Self) {
    lhs = lhs - rhs
  }
}
extension Swift.AdditiveArithmetic where Self : Swift.ExpressibleByIntegerLiteral {
  @inlinable @inline(__always) public static var zero: Self {
    get {
    return 0
  }
  }
}
public protocol Numeric : Swift.AdditiveArithmetic, Swift.ExpressibleByIntegerLiteral {
  init?<T>(exactly source: T) where T : Swift.BinaryInteger
  associatedtype Magnitude : Swift.Comparable, Swift.Numeric
  var magnitude: Self.Magnitude { get }
  static func * (lhs: Self, rhs: Self) -> Self
  static func *= (lhs: inout Self, rhs: Self)
}
public protocol SignedNumeric : Swift.Numeric {
  prefix static func - (operand: Self) -> Self
  mutating func negate()
}
extension Swift.SignedNumeric {
  @_transparent prefix public static func - (operand: Self) -> Self {
    var result = operand
    result.negate()
    return result
  }
  @_transparent public mutating func negate() {
    self = 0 - self
  }
}
@inlinable public func abs<T>(_ x: T) -> T where T : Swift.Comparable, T : Swift.SignedNumeric {
  if T.self == T.Magnitude.self {
    return unsafeBitCast(x.magnitude, to: T.self)
  }

  return x < (0 as T) ? -x : x
}
extension Swift.AdditiveArithmetic {
  @_transparent prefix public static func + (x: Self) -> Self {
    return x
  }
}
public typealias _CustomStringConvertibleOrNone = Swift.CustomStringConvertible
public protocol BinaryInteger : Swift.CustomStringConvertible, Swift.Hashable, Swift.Numeric, Swift.Strideable where Self.Magnitude : Swift.BinaryInteger, Self.Magnitude == Self.Magnitude.Magnitude {
  static var isSigned: Swift.Bool { get }
  init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
  init<T>(_ source: T) where T : Swift.BinaryInteger
  init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  init<T>(clamping source: T) where T : Swift.BinaryInteger
  associatedtype Words : Swift.RandomAccessCollection where Self.Words.Element == Swift.UInt, Self.Words.Index == Swift.Int
  var words: Self.Words { get }
  var _lowWord: Swift.UInt { get }
  var bitWidth: Swift.Int { get }
  func _binaryLogarithm() -> Swift.Int
  var trailingZeroBitCount: Swift.Int { get }
  static func / (lhs: Self, rhs: Self) -> Self
  static func /= (lhs: inout Self, rhs: Self)
  static func % (lhs: Self, rhs: Self) -> Self
  static func %= (lhs: inout Self, rhs: Self)
  override static func + (lhs: Self, rhs: Self) -> Self
  override static func += (lhs: inout Self, rhs: Self)
  override static func - (lhs: Self, rhs: Self) -> Self
  override static func -= (lhs: inout Self, rhs: Self)
  override static func * (lhs: Self, rhs: Self) -> Self
  override static func *= (lhs: inout Self, rhs: Self)
  prefix static func ~ (x: Self) -> Self
  static func & (lhs: Self, rhs: Self) -> Self
  static func &= (lhs: inout Self, rhs: Self)
  static func | (lhs: Self, rhs: Self) -> Self
  static func |= (lhs: inout Self, rhs: Self)
  static func ^ (lhs: Self, rhs: Self) -> Self
  static func ^= (lhs: inout Self, rhs: Self)
  static func >> <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : Swift.BinaryInteger
  static func >>= <RHS>(lhs: inout Self, rhs: RHS) where RHS : Swift.BinaryInteger
  static func << <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : Swift.BinaryInteger
  static func <<= <RHS>(lhs: inout Self, rhs: RHS) where RHS : Swift.BinaryInteger
  func quotientAndRemainder(dividingBy rhs: Self) -> (quotient: Self, remainder: Self)
  func isMultiple(of other: Self) -> Swift.Bool
  func signum() -> Self
}
extension Swift.BinaryInteger {
  @_transparent public init() {
    self = 0
  }
  @inlinable public func signum() -> Self {
    return (self > (0 as Self) ? 1 : 0) - (self < (0 as Self) ? 1 : 0)
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
    var it = words.makeIterator()
    return it.next() ?? 0
  }
  }
  @inlinable public func _binaryLogarithm() -> Swift.Int {
    _precondition(self > (0 as Self))
    var (quotient, remainder) =
      (bitWidth &- 1).quotientAndRemainder(dividingBy: UInt.bitWidth)
    remainder = remainder &+ 1
    var word = UInt(truncatingIfNeeded: self >> (bitWidth &- remainder))
     
     
     
     
     
    while word == 0 {
      quotient = quotient &- 1
      remainder = remainder &+ UInt.bitWidth
      word = UInt(truncatingIfNeeded: self >> (bitWidth &- remainder))
    }
     
     
    return UInt.bitWidth &* quotient &+
        (UInt.bitWidth &- (word.leadingZeroBitCount &+ 1))
  }
  @inlinable public func quotientAndRemainder(dividingBy rhs: Self) -> (quotient: Self, remainder: Self) {
    return (self / rhs, self % rhs)
  }
  @inlinable public func isMultiple(of other: Self) -> Swift.Bool {
     
    if other == 0 { return self == 0 }
     
     
     
    return self.magnitude % other.magnitude == 0
  }
  @_transparent public static func & (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func >> <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : Swift.BinaryInteger {
    var r = lhs
    r >>= rhs
    return r
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func << <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : Swift.BinaryInteger {
    var r = lhs
    r <<= rhs
    return r
  }
}
extension Swift.BinaryInteger {
  @_semantics("binaryInteger.description") public var description: Swift.String {
    get
  }
}
extension Swift.BinaryInteger {
  @inlinable @inline(__always) public func distance(to other: Self) -> Swift.Int {
    if !Self.isSigned {
      if self > other {
        if let result = Int(exactly: self - other) {
          return -result
        }
      } else {
        if let result = Int(exactly: other - self) {
          return result
        }
      }
    } else {
      let isNegative = self < (0 as Self)
      if isNegative == (other < (0 as Self)) {
        if let result = Int(exactly: other - self) {
          return result
        }
      } else {
        if let result = Int(exactly: self.magnitude + other.magnitude) {
          return isNegative ? result : -result
        }
      }
    }
    _preconditionFailure("Distance is not representable in Int")
  }
  @inlinable @inline(__always) public func advanced(by n: Swift.Int) -> Self {
    if Self.isSigned {
      return self.bitWidth < n.bitWidth
        ? Self(Int(truncatingIfNeeded: self) + n)
        : self + Self(truncatingIfNeeded: n)
    } else {
      return n < (0 as Int)
        ? self - Self(UInt(bitPattern: ~n &+ 1))
        : self + Self(UInt(bitPattern: n))
    }
  }
}
extension Swift.BinaryInteger {
  @_transparent public static func == <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift.BinaryInteger {
     
    if Self.isSigned == Other.isSigned {
      return lhs.bitWidth >= rhs.bitWidth ?
        lhs == Self(truncatingIfNeeded: rhs) :
        Other(truncatingIfNeeded: lhs) == rhs
    }
     
     
     
     
     
    if Self.isSigned {    
      return lhs.bitWidth > rhs.bitWidth ?  
        lhs == Self(truncatingIfNeeded: rhs) :
        (lhs >= (0 as Self) && Other(truncatingIfNeeded: lhs) == rhs)  
    }
     
    return lhs.bitWidth < rhs.bitWidth ?
      Other(truncatingIfNeeded: lhs) == rhs :
      (rhs >= (0 as Other) && lhs == Self(truncatingIfNeeded: rhs))
  }
  @_transparent public static func != <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift.BinaryInteger {
    return !(lhs == rhs)
  }
  @_transparent public static func < <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift.BinaryInteger {
     
    if Self.isSigned == Other.isSigned {
      return lhs.bitWidth >= rhs.bitWidth ?
        lhs < Self(truncatingIfNeeded: rhs) :
        Other(truncatingIfNeeded: lhs) < rhs
    }
     
     
     
     
     
    if Self.isSigned {
      return lhs.bitWidth > rhs.bitWidth ?  
        lhs < Self(truncatingIfNeeded: rhs) :
        (lhs < (0 as Self) || Other(truncatingIfNeeded: lhs) < rhs)  
    }
     
    return lhs.bitWidth < rhs.bitWidth ?
      Other(truncatingIfNeeded: lhs) < rhs :
      (rhs > (0 as Other) && lhs < Self(truncatingIfNeeded: rhs))
  }
  @_transparent public static func <= <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift.BinaryInteger {
    return !(rhs < lhs)
  }
  @_transparent public static func >= <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift.BinaryInteger {
    return !(lhs < rhs)
  }
  @_transparent public static func > <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift.BinaryInteger {
    return rhs < lhs
  }
}
extension Swift.BinaryInteger {
  @_transparent public static func != (lhs: Self, rhs: Self) -> Swift.Bool {
    return !(lhs == rhs)
  }
  @_transparent public static func <= (lhs: Self, rhs: Self) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Self, rhs: Self) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Self, rhs: Self) -> Swift.Bool {
    return rhs < lhs
  }
}
public typealias _LosslessStringConvertibleOrNone = Swift.LosslessStringConvertible
public protocol FixedWidthInteger : Swift.BinaryInteger, Swift.LosslessStringConvertible where Self.Magnitude : Swift.FixedWidthInteger, Self.Magnitude : Swift.UnsignedInteger, Self.Stride : Swift.FixedWidthInteger, Self.Stride : Swift.SignedInteger {
  static var bitWidth: Swift.Int { get }
  static var max: Self { get }
  static var min: Self { get }
  func addingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Swift.Bool)
  func subtractingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Swift.Bool)
  func multipliedReportingOverflow(by rhs: Self) -> (partialValue: Self, overflow: Swift.Bool)
  func dividedReportingOverflow(by rhs: Self) -> (partialValue: Self, overflow: Swift.Bool)
  func remainderReportingOverflow(dividingBy rhs: Self) -> (partialValue: Self, overflow: Swift.Bool)
  func multipliedFullWidth(by other: Self) -> (high: Self, low: Self.Magnitude)
  func dividingFullWidth(_ dividend: (high: Self, low: Self.Magnitude)) -> (quotient: Self, remainder: Self)
  init(_truncatingBits bits: Swift.UInt)
  var nonzeroBitCount: Swift.Int { get }
  var leadingZeroBitCount: Swift.Int { get }
  init(bigEndian value: Self)
  init(littleEndian value: Self)
  var bigEndian: Self { get }
  var littleEndian: Self { get }
  var byteSwapped: Self { get }
  static func &>> (lhs: Self, rhs: Self) -> Self
  static func &>>= (lhs: inout Self, rhs: Self)
  static func &<< (lhs: Self, rhs: Self) -> Self
  static func &<<= (lhs: inout Self, rhs: Self)
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  static func &* (lhs: Self, rhs: Self) -> Self
}
extension Swift.FixedWidthInteger {
  @inlinable public var bitWidth: Swift.Int {
    get { return Self.bitWidth }
  }
  @inlinable public func _binaryLogarithm() -> Swift.Int {
    _precondition(self > (0 as Self))
    return Self.bitWidth &- (leadingZeroBitCount &+ 1)
  }
  @inlinable public init(littleEndian value: Self) {
    self = value
  }
  @inlinable public init(bigEndian value: Self) {
    self = value.byteSwapped
  }
  @inlinable public var littleEndian: Self {
    get {
    return self
  }
  }
  @inlinable public var bigEndian: Self {
    get {
    return byteSwapped
  }
  }
  @_alwaysEmitIntoClient public func multipliedFullWidth(by other: Self) -> (high: Self, low: Self.Magnitude) {
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
    func split<T: FixedWidthInteger>(_ x: T) -> (high: T, low: T.Magnitude) {
      let n = T.bitWidth/2
      return (x >> n, T.Magnitude(truncatingIfNeeded: x) & ((1 &<< n) &- 1))
    }
     
     
     
     
     
     
     
     
     
    let (x1, x0) = split(self)
    let (y1, y0) = split(other)
     
     
     
    let p00 = x0 &* y0
     
     
     
    let p01 = x1 &* Self(y0) &+ Self(split(p00).high)
     
     
    let p10 = Self(x0) &* y1 &+ Self(split(p01).low)
     
     
     
    let p11 = x1 &* y1 &+ split(p01).high &+ split(p10).high
     
    return (p11, split(p10).low << (bitWidth/2) | split(p00).low)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &>> (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &>> <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.BinaryInteger {
    return lhs &>> Self(truncatingIfNeeded: rhs)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &>>= <Other>(lhs: inout Self, rhs: Other) where Other : Swift.BinaryInteger {
    lhs = lhs &>> rhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &<< (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &<< <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.BinaryInteger {
    return lhs &<< Self(truncatingIfNeeded: rhs)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &<<= <Other>(lhs: inout Self, rhs: Other) where Other : Swift.BinaryInteger {
    lhs = lhs &<< rhs
  }
}
extension Swift.FixedWidthInteger {
  @inlinable public static func random<T>(in range: Swift.Range<Self>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )

     
     
     
    let delta = Magnitude(truncatingIfNeeded: range.upperBound &- range.lowerBound)
     
     
     
     
     
     
    return Self(truncatingIfNeeded:
      Magnitude(truncatingIfNeeded: range.lowerBound) &+
      generator.next(upperBound: delta)
    )
  }
  @inlinable public static func random(in range: Swift.Range<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
  @inlinable public static func random<T>(in range: Swift.ClosedRange<Self>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
     
     
     
    var delta = Magnitude(truncatingIfNeeded: range.upperBound &- range.lowerBound)
     
     
     
     
    if delta == Magnitude.max {
      return Self(truncatingIfNeeded: generator.next() as Magnitude)
    }
     
    delta += 1
     
     
     
     
     
     
    return Self(truncatingIfNeeded:
      Magnitude(truncatingIfNeeded: range.lowerBound) &+
      generator.next(upperBound: delta)
    )
  }
  @inlinable public static func random(in range: Swift.ClosedRange<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}
extension Swift.FixedWidthInteger {
  @_transparent prefix public static func ~ (x: Self) -> Self {
    return 0 &- x &- 1
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func >> <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.BinaryInteger {
    var lhs = lhs
    _nonMaskingRightShiftGeneric(&lhs, rhs)
    return lhs
  }
  @_transparent @_semantics("optimize.sil.specialize.generic.partial.never") public static func >>= <Other>(lhs: inout Self, rhs: Other) where Other : Swift.BinaryInteger {
    _nonMaskingRightShiftGeneric(&lhs, rhs)
  }
  @_transparent public static func _nonMaskingRightShiftGeneric<Other>(_ lhs: inout Self, _ rhs: Other) where Other : Swift.BinaryInteger {
    let shift = rhs < -Self.bitWidth ? -Self.bitWidth
                : rhs > Self.bitWidth ? Self.bitWidth
                : Int(rhs)
    lhs = _nonMaskingRightShift(lhs, shift)
  }
  @_transparent public static func _nonMaskingRightShift(_ lhs: Self, _ rhs: Swift.Int) -> Self {
    let overshiftR = Self.isSigned ? lhs &>> (Self.bitWidth - 1) : 0
    let overshiftL: Self = 0
    if _fastPath(rhs >= 0) {
      if _fastPath(rhs < Self.bitWidth) {
        return lhs &>> Self(truncatingIfNeeded: rhs)
      }
      return overshiftR
    }

    if _slowPath(rhs <= -Self.bitWidth) {
      return overshiftL
    }
    return lhs &<< -rhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func << <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.BinaryInteger {
    var lhs = lhs
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
    return lhs
  }
  @_transparent @_semantics("optimize.sil.specialize.generic.partial.never") public static func <<= <Other>(lhs: inout Self, rhs: Other) where Other : Swift.BinaryInteger {
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
  }
  @_transparent public static func _nonMaskingLeftShiftGeneric<Other>(_ lhs: inout Self, _ rhs: Other) where Other : Swift.BinaryInteger {
    let shift = rhs < -Self.bitWidth ? -Self.bitWidth
                : rhs > Self.bitWidth ? Self.bitWidth
                : Int(rhs)
    lhs = _nonMaskingLeftShift(lhs, shift)
  }
  @_transparent public static func _nonMaskingLeftShift(_ lhs: Self, _ rhs: Swift.Int) -> Self {
    let overshiftR = Self.isSigned ? lhs &>> (Self.bitWidth - 1) : 0
    let overshiftL: Self = 0
    if _fastPath(rhs >= 0) {
      if _fastPath(rhs < Self.bitWidth) {
        return lhs &<< Self(truncatingIfNeeded: rhs)
      }
      return overshiftL
    }

    if _slowPath(rhs <= -Self.bitWidth) {
      return overshiftR
    }
    return lhs &>> -rhs
  }
}
extension Swift.FixedWidthInteger {
  @inlinable @_semantics("optimize.sil.specialize.generic.partial.never") public static func _convert<Source>(from source: Source) -> (value: Self?, exact: Swift.Bool) where Source : Swift.BinaryFloatingPoint {
    guard _fastPath(!source.isZero) else { return (0, true) }
    guard _fastPath(source.isFinite) else { return (nil, false) }
    guard Self.isSigned || source > -1 else { return (nil, false) }
    let exponent = source.exponent
    if _slowPath(Self.bitWidth <= exponent) { return (nil, false) }
    let minBitWidth = source.significandWidth
    let isExact = (minBitWidth <= exponent)
    let bitPattern = source.significandBitPattern
     
     
     
     
    let bitWidth = minBitWidth &+ bitPattern.trailingZeroBitCount
    let shift = exponent - Source.Exponent(bitWidth)
     
    let shiftedBitPattern = Self.Magnitude.bitWidth > bitWidth
      ? Self.Magnitude(truncatingIfNeeded: bitPattern) << shift
      : Self.Magnitude(truncatingIfNeeded: bitPattern << shift)
    if _slowPath(Self.isSigned && Self.bitWidth &- 1 == exponent) {
      return source < 0 && shiftedBitPattern == 0
        ? (Self.min, isExact)
        : (nil, false)
    }
    let magnitude = ((1 as Self.Magnitude) << exponent) | shiftedBitPattern
    return (
      Self.isSigned && source < 0 ? 0 &- Self(magnitude) : Self(magnitude),
      isExact)
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.partial.never") @inline(__always) public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint {
    guard let value = Self._convert(from: source).value else {
      #if !$Embedded
      fatalError("""
        \(T.self) value cannot be converted to \(Self.self) because it is \
        outside the representable range
        """)
      #else
      fatalError("value not representable")
      #endif
    }
    self = value
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint {
    let (temporary, exact) = Self._convert(from: source)
    guard exact, let value = temporary else {
      return nil
    }
    self = value
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.partial.never") public init<Other>(clamping source: Other) where Other : Swift.BinaryInteger {
    if _slowPath(source < Self.min) {
      self = Self.min
    }
    else if _slowPath(source > Self.max) {
      self = Self.max
    }
    else { self = Self(truncatingIfNeeded: source) }
  }
  @inlinable @inline(__always) public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger {
    if Self.bitWidth <= Int.bitWidth {
      self = Self(_truncatingBits: source._lowWord)
    }
    else {
      self = Self._truncatingInit(source)
    }
  }
  @_alwaysEmitIntoClient internal static func _truncatingInit<T>(_ source: T) -> Self where T : Swift.BinaryInteger {
    let neg = source < (0 as T)
    var result: Self = neg ? ~0 : 0
    var shift: Self = 0
    let width = Self(_truncatingBits: Self.bitWidth._lowWord)
    for word in source.words {
      guard shift < width else { break }
       
       
       
      result ^= Self(_truncatingBits: neg ? ~word : word) &<< shift
      shift += Self(_truncatingBits: Int.bitWidth._lowWord)
    }
    return result
  }
  @_transparent public static var _highBitIndex: Self {
    @_transparent get {
    return Self.init(_truncatingBits: UInt(Self.bitWidth._value) &- 1)
  }
  }
  @_transparent public static func &+ (lhs: Self, rhs: Self) -> Self {
    return lhs.addingReportingOverflow(rhs).partialValue
  }
  @_transparent public static func &+= (lhs: inout Self, rhs: Self) {
    lhs = lhs &+ rhs
  }
  @_transparent public static func &- (lhs: Self, rhs: Self) -> Self {
    return lhs.subtractingReportingOverflow(rhs).partialValue
  }
  @_transparent public static func &-= (lhs: inout Self, rhs: Self) {
    lhs = lhs &- rhs
  }
  @_transparent public static func &* (lhs: Self, rhs: Self) -> Self {
    return rhs.multipliedReportingOverflow(by: lhs).partialValue
  }
  @_transparent public static func &*= (lhs: inout Self, rhs: Self) {
    lhs = lhs &* rhs
  }
}
extension Swift.FixedWidthInteger {
  @inlinable public static func _random<R>(using generator: inout R) -> Self where R : Swift.RandomNumberGenerator {
    if bitWidth <= UInt64.bitWidth {
      return Self(truncatingIfNeeded: generator.next())
    }

    let (quotient, remainder) = bitWidth.quotientAndRemainder(
      dividingBy: UInt64.bitWidth
    )
    var tmp: Self = 0
    for i in 0 ..< quotient + remainder.signum() {
      let next: UInt64 = generator.next()
      tmp += Self(truncatingIfNeeded: next) &<< (UInt64.bitWidth * i)
    }
    return tmp
  }
}
public protocol UnsignedInteger : Swift.BinaryInteger {
}
extension Swift.UnsignedInteger {
  @inlinable public var magnitude: Self {
    @inline(__always) get { return self }
  }
  @inlinable public static var isSigned: Swift.Bool {
    @inline(__always) get { return false }
  }
}
extension Swift.UnsignedInteger where Self : Swift.FixedWidthInteger {
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable @inline(__always) public init<T>(_ source: T) where T : Swift.BinaryInteger {
     
    if T.isSigned {
      _precondition(source >= (0 as T), "Negative value is not representable")
    }
     
    if source.bitWidth >= Self.bitWidth {
      _precondition(source <= Self.max,
        "Not enough bits to represent the passed value")
    }
    self.init(truncatingIfNeeded: source)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable @inline(__always) public init?<T>(exactly source: T) where T : Swift.BinaryInteger {
     
    if T.isSigned && source < (0 as T) {
      return nil
    }
     
    if source.bitWidth >= Self.bitWidth &&
       source > Self.max {
      return nil
    }
    self.init(truncatingIfNeeded: source)
  }
  @_transparent public static var max: Self {
    @_transparent get { return ~0 }
  }
  @_transparent public static var min: Self {
    @_transparent get { return 0 }
  }
  @_alwaysEmitIntoClient public func dividingFullWidth(_ dividend: (high: Self, low: Self.Magnitude)) -> (quotient: Self, remainder: Self) {
     
    precondition(self != .zero, "Division by zero")
    precondition(dividend.high < self,
                 "Dividend.high must be smaller than divisor")
     
     
     
     
     
     
     
    let low = Self(dividend.low)
    
     
     
     
     
     
     
     
     
     
     
     
     
    let lz = leadingZeroBitCount
    
     
     
     
    if (self &- 1) & self == .zero {
      let shift = Self.bitWidth - 1 - lz
      let q = low &>> shift | dividend.high &<< -shift
      let r = low & (self &- 1)
      return (q, r)
    }
    
     
     
     
     
     
    let v = self &<< lz
    let uh = dividend.high &<< lz | low >> (Self.bitWidth - lz)
    let ul = low &<< lz
    
     
     
     
     
    let n_2 = Self.bitWidth/2
    let mask = Self(1) &<< n_2 &- 1
    let vh = v &>> n_2
    let vl = v & mask
    
     
     
    if vl == .zero {
      let qh = uh / vh
      let residual = (uh &- qh &* vh) &<< n_2 | ul &>> n_2
      let ql = residual / vh
      
      return (
         
        quotient: qh &<< n_2 | ql,
         
        remainder: ((residual &- ql &* vh) &<< n_2 | ul & mask) &>> lz
      )
    }
    
     
     
     
     
     
     
     
     
     
     
     
     
     
    func generateHalfDigit(high: Self, low: Self) -> Self {
       
      var (q, r) = high.quotientAndRemainder(dividingBy: vh)
       
       
       
      while q > mask || q &* vl > (r &<< n_2 | low) {
        q &-= 1
        r &+= vh
        if r > mask { break }
      }
      return q
    }
    
     
     
     
    let qh = generateHalfDigit(high: uh, low: ul &>> n_2)
    let residual = (uh &<< n_2 | ul &>> n_2) &- (qh &* v)
    let ql = generateHalfDigit(high: residual, low: ul & mask)
    
    return (
       
      quotient: qh &<< n_2 | ql,
       
      remainder: ((residual &<< n_2 | ul & mask) &- (ql &* v)) &>> lz
    )
  }
}
public protocol SignedInteger : Swift.BinaryInteger, Swift.SignedNumeric {
  @available(*, deprecated, message: "Use &+ instead.")
  static func _maskingAdd(_ lhs: Self, _ rhs: Self) -> Self
  @available(*, deprecated, message: "Use &- instead.")
  static func _maskingSubtract(_ lhs: Self, _ rhs: Self) -> Self
}
extension Swift.SignedInteger {
  @inlinable public static var isSigned: Swift.Bool {
    @inline(__always) get { return true }
  }
}
extension Swift.SignedInteger where Self : Swift.FixedWidthInteger {
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable @inline(__always) public init<T>(_ source: T) where T : Swift.BinaryInteger {
     
    if T.isSigned && source.bitWidth > Self.bitWidth {
      _precondition(source >= Self.min,
        "Not enough bits to represent a signed value")
    }
     
    if (source.bitWidth > Self.bitWidth) ||
       (source.bitWidth == Self.bitWidth && !T.isSigned) {
      _precondition(source <= Self.max,
        "Not enough bits to represent the passed value")
    }
    self.init(truncatingIfNeeded: source)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable @inline(__always) public init?<T>(exactly source: T) where T : Swift.BinaryInteger {
     
    if T.isSigned && source.bitWidth > Self.bitWidth && source < Self.min {
      return nil
    }
     
    if (source.bitWidth > Self.bitWidth ||
        (source.bitWidth == Self.bitWidth && !T.isSigned)) &&
       source > Self.max {
      return nil
    }
    self.init(truncatingIfNeeded: source)
  }
  @_transparent public static var max: Self {
    @_transparent get { return ~min }
  }
  @_transparent public static var min: Self {
    @_transparent get {
    return (-1 as Self) &<< Self._highBitIndex
  }
  }
  @inlinable public func isMultiple(of other: Self) -> Swift.Bool {
     
    if other == 0 { return self == 0 }
     
    if other == -1 { return true }
     
    return self % other == 0
  }
  @_alwaysEmitIntoClient public func dividingFullWidth(_ dividend: (high: Self, low: Self.Magnitude)) -> (quotient: Self, remainder: Self) {
     
    var magnitudeHigh = Magnitude(truncatingIfNeeded: dividend.high)
    var magnitudeLow  = dividend.low
    if dividend.high < .zero {
      let carry: Bool
      (magnitudeLow, carry) = (~magnitudeLow).addingReportingOverflow(1)
      magnitudeHigh = ~magnitudeHigh &+ (carry ? 1 : 0)
    }
     
    let (unsignedQuotient, unsignedRemainder) = magnitude.dividingFullWidth(
      (high: magnitudeHigh, low: magnitudeLow)
    )
     
     
    let quotient: Self
    if self ^ dividend.high < .zero {
       
       
       
      precondition(unsignedQuotient <= Self.min.magnitude,
                   "Quotient is not representable.")
      quotient = Self(truncatingIfNeeded: 0 &- unsignedQuotient)
    } else {
      quotient = Self(unsignedQuotient)
    }
    var remainder = Self(unsignedRemainder)
    if dividend.high < .zero { remainder = 0 &- remainder }
    return (quotient, remainder)
  }
}
@inlinable public func numericCast<T, U>(_ x: T) -> U where T : Swift.BinaryInteger, U : Swift.BinaryInteger {
  return U(x)
}
extension Swift.SignedInteger {
  @available(*, deprecated, message: "Use &+ instead.")
  public static func _maskingAdd(_ lhs: Self, _ rhs: Self) -> Self
  @available(*, deprecated, message: "Use &- instead.")
  public static func _maskingSubtract(_ lhs: Self, _ rhs: Self) -> Self
}
extension Swift.SignedInteger where Self : Swift.FixedWidthInteger {
  @available(*, unavailable)
  public static func &+ (lhs: Self, rhs: Self) -> Self
  @available(*, deprecated, message: "Use &+ instead.")
  public static func _maskingAdd(_ lhs: Self, _ rhs: Self) -> Self
  @available(*, unavailable)
  public static func &- (lhs: Self, rhs: Self) -> Self
  @available(*, deprecated, message: "Use &- instead.")
  public static func _maskingSubtract(_ lhs: Self, _ rhs: Self) -> Self
}
@frozen public struct JoinedSequence<Base> where Base : Swift.Sequence, Base.Element : Swift.Sequence {
  public typealias Element = Base.Element.Element
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal var _separator: Swift.ContiguousArray<Swift.JoinedSequence<Base>.Element>
  @inlinable public init<Separator>(base: Base, separator: Separator) where Separator : Swift.Sequence, Separator.Element == Base.Element.Element {
    self._base = base
    self._separator = ContiguousArray(separator)
  }
}
extension Swift.JoinedSequence : Swift.Sendable where Base : Swift.Sendable, Base.Element.Element : Swift.Sendable {
}
extension Swift.JoinedSequence {
  @frozen public struct Iterator {
    @usableFromInline
    @frozen internal enum _JoinIteratorState {
      case start
      case generatingElements
      case generatingSeparator
      case end
      @usableFromInline
      internal static func == (a: Swift.JoinedSequence<Base>.Iterator._JoinIteratorState, b: Swift.JoinedSequence<Base>.Iterator._JoinIteratorState) -> Swift.Bool
      @usableFromInline
      internal func hash(into hasher: inout Swift.Hasher)
      @usableFromInline
      internal var hashValue: Swift.Int {
        @usableFromInline
        get
      }
    }
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal var _inner: Base.Element.Iterator?
    @usableFromInline
    internal var _separatorData: Swift.ContiguousArray<Swift.JoinedSequence<Base>.Iterator.Element>
    @usableFromInline
    internal var _separator: Swift.ContiguousArray<Swift.JoinedSequence<Base>.Iterator.Element>.Iterator?
    @usableFromInline
    internal var _state: Swift.JoinedSequence<Base>.Iterator._JoinIteratorState = .start
    @inlinable public init<Separator>(base: Base.Iterator, separator: Separator) where Separator : Swift.Sequence, Separator.Element == Base.Element.Element {
      self._base = base
      self._separatorData = ContiguousArray(separator)
    }
  }
}
extension Swift.JoinedSequence.Iterator : Swift.Sendable where Base.Iterator : Swift.Sendable, Base.Element.Element : Swift.Sendable, Base.Element.Iterator : Swift.Sendable {
}
extension Swift.JoinedSequence.Iterator : Swift.IteratorProtocol {
  public typealias Element = Base.Element.Element
  @inlinable public mutating func next() -> Swift.JoinedSequence<Base>.Iterator.Element? {
    while true {
      switch _state {
      case .start:
        if let nextSubSequence = _base.next() {
          _inner = nextSubSequence.makeIterator()
          _state = .generatingElements
        } else {
          _state = .end
          return nil
        }

      case .generatingElements:
        let result = _inner!.next()
        if _fastPath(result != nil) {
          return result
        }
        _inner = _base.next()?.makeIterator()
        if _inner == nil {
          _state = .end
          return nil
        }
        if !_separatorData.isEmpty {
          _separator = _separatorData.makeIterator()
          _state = .generatingSeparator
        }

      case .generatingSeparator:
        let result = _separator!.next()
        if _fastPath(result != nil) {
          return result
        }
        _state = .generatingElements

      case .end:
        return nil
      }
    }
  }
}
extension Swift.JoinedSequence : Swift.Sequence {
  @inlinable public __consuming func makeIterator() -> Swift.JoinedSequence<Base>.Iterator {
    return Iterator(base: _base.makeIterator(), separator: _separator)
  }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Swift.JoinedSequence<Base>.Element> {
    var result = ContiguousArray<Element>()
    let separatorSize = _separator.count

    if separatorSize == 0 {
      for x in _base {
        result.append(contentsOf: x)
      }
      return result
    }

    var iter = _base.makeIterator()
    if let first = iter.next() {
      result.append(contentsOf: first)
      while let next = iter.next() {
        result.append(contentsOf: _separator)
        result.append(contentsOf: next)
      }
    }

    return result
  }
}
extension Swift.Sequence where Self.Element : Swift.Sequence {
  @inlinable public __consuming func joined<Separator>(separator: Separator) -> Swift.JoinedSequence<Self> where Separator : Swift.Sequence, Separator.Element == Self.Element.Element {
    return JoinedSequence(base: self, separator: separator)
  }
}
@_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCs11_AnyKeyPath) public class AnyKeyPath : Swift._AppendKeyPath {
  @inlinable public static var rootType: any Any.Type {
    get {
    return _rootAndValueType.root
  }
  }
  @inlinable public static var valueType: any Any.Type {
    get {
    return _rootAndValueType.value
  }
  }
  public var _kvcKeyPathString: Swift.String? {
    @_semantics("keypath.kvcKeyPathString") get
  }
  @usableFromInline
  internal class var _rootAndValueType: (root: any Any.Type, value: any Any.Type) {
    get
  }
  @usableFromInline
  internal var _storedInlineOffset: Swift.Int? {
    get
  }
  @objc deinit
}
extension Swift.AnyKeyPath : Swift.Hashable {
  final public var hashValue: Swift.Int {
    get
  }
  @_effects(releasenone) final public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Swift.AnyKeyPath, b: Swift.AnyKeyPath) -> Swift.Bool
}
@_inheritsConvenienceInitializers public class PartialKeyPath<Root> : Swift.AnyKeyPath {
  @objc deinit
}
@_inheritsConvenienceInitializers public class KeyPath<Root, Value> : Swift.PartialKeyPath<Root> {
  @usableFromInline
  final override internal class var _rootAndValueType: (root: any Any.Type, value: any Any.Type) {
    get
  }
  @usableFromInline
  final internal func _projectReadOnly(from root: Root) -> Value
  @objc deinit
}
@_inheritsConvenienceInitializers public class WritableKeyPath<Root, Value> : Swift.KeyPath<Root, Value> {
  @usableFromInline
  internal func _projectMutableAddress(from base: Swift.UnsafePointer<Root>) -> (pointer: Swift.UnsafeMutablePointer<Value>, owner: Swift.AnyObject?)
  @objc deinit
}
@_inheritsConvenienceInitializers public class ReferenceWritableKeyPath<Root, Value> : Swift.WritableKeyPath<Root, Value> {
  @usableFromInline
  final internal func _projectMutableAddress(from origBase: Root) -> (pointer: Swift.UnsafeMutablePointer<Value>, owner: Swift.AnyObject?)
  @objc deinit
}
@_silgen_name("swift_getAtPartialKeyPath")
public func _getAtPartialKeyPath<Root>(root: Root, keyPath: Swift.PartialKeyPath<Root>) -> Any
@_silgen_name("swift_getAtAnyKeyPath")
public func _getAtAnyKeyPath<RootValue>(root: RootValue, keyPath: Swift.AnyKeyPath) -> Any?
@_silgen_name("swift_getAtKeyPath")
public func _getAtKeyPath<Root, Value>(root: Root, keyPath: Swift.KeyPath<Root, Value>) -> Value
@_silgen_name("_swift_modifyAtWritableKeyPath_impl")
public func _modifyAtWritableKeyPath_impl<Root, Value>(root: inout Root, keyPath: Swift.WritableKeyPath<Root, Value>) -> (Swift.UnsafeMutablePointer<Value>, Swift.AnyObject?)
@_silgen_name("_swift_modifyAtReferenceWritableKeyPath_impl")
public func _modifyAtReferenceWritableKeyPath_impl<Root, Value>(root: Root, keyPath: Swift.ReferenceWritableKeyPath<Root, Value>) -> (Swift.UnsafeMutablePointer<Value>, Swift.AnyObject?)
@_silgen_name("swift_setAtWritableKeyPath")
public func _setAtWritableKeyPath<Root, Value>(root: inout Root, keyPath: Swift.WritableKeyPath<Root, Value>, value: __owned Value)
@_silgen_name("swift_setAtReferenceWritableKeyPath")
public func _setAtReferenceWritableKeyPath<Root, Value>(root: Root, keyPath: Swift.ReferenceWritableKeyPath<Root, Value>, value: __owned Value)
@_show_in_interface public protocol _AppendKeyPath {
}
extension Swift._AppendKeyPath where Self == Swift.AnyKeyPath {
  @inlinable public func appending(path: Swift.AnyKeyPath) -> Swift.AnyKeyPath? {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}
extension Swift._AppendKeyPath {
  @inlinable public func appending<Root>(path: Swift.AnyKeyPath) -> Swift.PartialKeyPath<Root>? where Self == Swift.PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
  @inlinable public func appending<Root, AppendedRoot, AppendedValue>(path: Swift.KeyPath<AppendedRoot, AppendedValue>) -> Swift.KeyPath<Root, AppendedValue>? where Self == Swift.PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
  @inlinable public func appending<Root, AppendedRoot, AppendedValue>(path: Swift.ReferenceWritableKeyPath<AppendedRoot, AppendedValue>) -> Swift.ReferenceWritableKeyPath<Root, AppendedValue>? where Self == Swift.PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}
extension Swift._AppendKeyPath {
  @inlinable public func appending<Root, Value, AppendedValue>(path: Swift.KeyPath<Value, AppendedValue>) -> Swift.KeyPath<Root, AppendedValue> where Self : Swift.KeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
  @inlinable public func appending<Root, Value, AppendedValue>(path: Swift.ReferenceWritableKeyPath<Value, AppendedValue>) -> Swift.ReferenceWritableKeyPath<Root, AppendedValue> where Self == Swift.KeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}
extension Swift._AppendKeyPath {
  @inlinable public func appending<Root, Value, AppendedValue>(path: Swift.WritableKeyPath<Value, AppendedValue>) -> Swift.WritableKeyPath<Root, AppendedValue> where Self == Swift.WritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
  @inlinable public func appending<Root, Value, AppendedValue>(path: Swift.ReferenceWritableKeyPath<Value, AppendedValue>) -> Swift.ReferenceWritableKeyPath<Root, AppendedValue> where Self == Swift.WritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}
extension Swift._AppendKeyPath {
  @inlinable public func appending<Root, Value, AppendedValue>(path: Swift.WritableKeyPath<Value, AppendedValue>) -> Swift.ReferenceWritableKeyPath<Root, AppendedValue> where Self == Swift.ReferenceWritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}
@usableFromInline
internal func _tryToAppendKeyPaths<Result>(root: Swift.AnyKeyPath, leaf: Swift.AnyKeyPath) -> Result? where Result : Swift.AnyKeyPath
@usableFromInline
internal func _appendingKeyPaths<Root, Value, AppendedValue, Result>(root: Swift.KeyPath<Root, Value>, leaf: Swift.KeyPath<Value, AppendedValue>) -> Result where Result : Swift.KeyPath<Root, AppendedValue>
@_cdecl("swift_getKeyPathImpl")
public func _swift_getKeyPath(pattern: Swift.UnsafeMutableRawPointer, arguments: Swift.UnsafeRawPointer) -> Swift.UnsafeRawPointer
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
public func _createOffsetBasedKeyPath(root: any Any.Type, value: any Any.Type, offset: Swift.Int) -> Swift.AnyKeyPath
@available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
extension Swift.AnyKeyPath : Swift.CustomDebugStringConvertible {
  @available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
  public var debugDescription: Swift.String {
    get
  }
}
@frozen public struct KeyValuePairs<Key, Value> : Swift.ExpressibleByDictionaryLiteral {
  @usableFromInline
  internal let _elements: [(Key, Value)]
  @inlinable public init(dictionaryLiteral elements: (Key, Value)...) {
    self._elements = elements
  }
}
extension Swift.KeyValuePairs : Swift.RandomAccessCollection {
  public typealias Element = (key: Key, value: Value)
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = Swift.Slice<Swift.KeyValuePairs<Key, Value>>
  @inlinable public var startIndex: Swift.KeyValuePairs<Key, Value>.Index {
    get { return 0 }
  }
  @inlinable public var endIndex: Swift.KeyValuePairs<Key, Value>.Index {
    get { return _elements.endIndex }
  }
  @inlinable public subscript(position: Swift.KeyValuePairs<Key, Value>.Index) -> Swift.KeyValuePairs<Key, Value>.Element {
    get {
    return _elements[position]
  }
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.KeyValuePairs<Key, Value>>
}
extension Swift.KeyValuePairs : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Swift.KeyValuePairs : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.KeyValuePairs : Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
public protocol LazyCollectionProtocol : Swift.Collection, Swift.LazySequenceProtocol where Self.Elements : Swift.Collection {
}
extension Swift.LazyCollectionProtocol {
  @inlinable public var lazy: Swift.LazyCollection<Self.Elements> {
    get {
     return elements.lazy
   }
  }
}
extension Swift.LazyCollectionProtocol where Self.Elements : Swift.LazyCollectionProtocol {
  @inlinable public var lazy: Self.Elements {
    get {
     return elements
   }
  }
}
public typealias LazyCollection<T> = Swift.LazySequence<T> where T : Swift.Collection
extension Swift.LazyCollection : Swift.Collection where Base : Swift.Collection {
  public typealias Index = Base.Index
  public typealias Indices = Base.Indices
  public typealias SubSequence = Swift.Slice<Swift.LazySequence<Base>>
  @inlinable public var startIndex: Swift.LazySequence<Base>.Index {
    get { return _base.startIndex }
  }
  @inlinable public var endIndex: Swift.LazySequence<Base>.Index {
    get { return _base.endIndex }
  }
  @inlinable public var indices: Swift.LazySequence<Base>.Indices {
    get { return _base.indices }
  }
  @inlinable public func index(after i: Swift.LazySequence<Base>.Index) -> Swift.LazySequence<Base>.Index {
    return _base.index(after: i)
  }
  @inlinable public subscript(position: Swift.LazySequence<Base>.Index) -> Swift.LazySequence<Base>.Element {
    get {
    return _base[position]
  }
  }
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return _base.isEmpty
  }
  }
  @inlinable public var count: Swift.Int {
    get {
    return _base.count
  }
  }
  @inlinable public func _customIndexOfEquatableElement(_ element: Swift.LazySequence<Base>.Element) -> Swift.LazySequence<Base>.Index?? {
    return _base._customIndexOfEquatableElement(element)
  }
  @inlinable public func _customLastIndexOfEquatableElement(_ element: Swift.LazySequence<Base>.Element) -> Swift.LazySequence<Base>.Index?? {
    return _base._customLastIndexOfEquatableElement(element)
  }
  @inlinable public func index(_ i: Swift.LazySequence<Base>.Index, offsetBy n: Swift.Int) -> Swift.LazySequence<Base>.Index {
    return _base.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.LazySequence<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.LazySequence<Base>.Index) -> Swift.LazySequence<Base>.Index? {
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Swift.LazySequence<Base>.Index, to end: Swift.LazySequence<Base>.Index) -> Swift.Int {
    return _base.distance(from:start, to: end)
  }
}
extension Swift.LazyCollection : Swift.LazyCollectionProtocol where Base : Swift.Collection {
}
extension Swift.LazyCollection : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.LazySequence<Base>.Index) -> Swift.LazySequence<Base>.Index {
    return _base.index(before: i)
  }
}
extension Swift.LazyCollection : Swift.RandomAccessCollection where Base : Swift.RandomAccessCollection {
}
extension Swift.Slice : Swift.LazySequenceProtocol where Base : Swift.LazySequenceProtocol {
  public typealias Elements = Swift.Slice<Base>
}
extension Swift.ReversedCollection : Swift.LazySequenceProtocol where Base : Swift.LazySequenceProtocol {
  public typealias Elements = Swift.ReversedCollection<Base>
}
public protocol LazySequenceProtocol : Swift.Sequence {
  associatedtype Elements : Swift.Sequence = Self where Self.Element == Self.Elements.Element
  var elements: Self.Elements { get }
}
extension Swift.LazySequenceProtocol where Self == Self.Elements {
  @inlinable public var elements: Self {
    get { return self }
  }
}
extension Swift.LazySequenceProtocol {
  @inlinable public var lazy: Swift.LazySequence<Self.Elements> {
    get {
    return elements.lazy
  }
  }
}
extension Swift.LazySequenceProtocol where Self.Elements : Swift.LazySequenceProtocol {
  @inlinable public var lazy: Self.Elements {
    get {
    return elements
  }
  }
}
@frozen public struct LazySequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @inlinable internal init(_base: Base) {
    self._base = _base
  }
}
extension Swift.LazySequence : Swift.Sendable where Base : Swift.Sendable {
}
extension Swift.LazySequence : Swift.Sequence {
  public typealias Element = Base.Element
  public typealias Iterator = Base.Iterator
  @inlinable public __consuming func makeIterator() -> Swift.LazySequence<Base>.Iterator {
    return _base.makeIterator()
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return _base.underestimatedCount
  }
  }
  @discardableResult
  @inlinable public __consuming func _copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Swift.LazySequence<Base>.Element>) -> (Swift.LazySequence<Base>.Iterator, Swift.UnsafeMutableBufferPointer<Swift.LazySequence<Base>.Element>.Index) {
    return _base._copyContents(initializing: buf)
  }
  @inlinable public func _customContainsEquatableElement(_ element: Swift.LazySequence<Base>.Element) -> Swift.Bool? { 
    return _base._customContainsEquatableElement(element)
  }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Swift.LazySequence<Base>.Element> {
    return _base._copyToContiguousArray()
  }
}
extension Swift.LazySequence : Swift.LazySequenceProtocol {
  public typealias Elements = Base
  @inlinable public var elements: Swift.LazySequence<Base>.Elements {
    get { return _base }
  }
}
extension Swift.Sequence {
  @inlinable public var lazy: Swift.LazySequence<Self> {
    get {
    return LazySequence(_base: self)
  }
  }
}
extension Swift.Unicode.UTF16 {
  @available(*, unavailable, renamed: "Unicode.UTF16.isASCII")
  @inlinable public static func _isASCII(_ x: Swift.Unicode.UTF16.CodeUnit) -> Swift.Bool {
    return Unicode.UTF16.isASCII(x)
  }
}
@available(*, unavailable, renamed: "Unicode.UTF8.isASCII")
@inlinable internal func _isASCII(_ x: Swift.UInt8) -> Swift.Bool {
  return Unicode.UTF8.isASCII(x)
}
@available(*, unavailable, renamed: "Unicode.UTF8.isContinuation")
@inlinable internal func _isContinuation(_ x: Swift.UInt8) -> Swift.Bool {
  return UTF8.isContinuation(x)
}
extension Swift.Substring {
  @available(*, unavailable, renamed: "Substring.base")
  @inlinable internal var _wholeString: Swift.String {
    get { return base }
  }
}
extension Swift.String {
  @available(*, unavailable, renamed: "String.withUTF8")
  @inlinable internal func _withUTF8<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R {
    var copy = self
    return try copy.withUTF8(body)
  }
}
extension Swift.Substring {
  @available(*, unavailable, renamed: "Substring.withUTF8")
  @inlinable internal func _withUTF8<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R {
    var copy = self
    return try copy.withUTF8(body)
  }
}
@usableFromInline
internal func _branchHint(_ actual: Swift.Bool, expected: Swift.Bool) -> Swift.Bool
extension Swift.String {
  @usableFromInline
  internal func _nativeCopyUTF16CodeUnits(into buffer: Swift.UnsafeMutableBufferPointer<Swift.UInt16>, range: Swift.Range<Swift.String.Index>)
}
extension Swift.String.UTF16View {
  @inlinable @inline(__always) internal var _shortHeuristic: Swift.Int {
    get { return 32 }
  }
}
#if compiler(>=5.3) && $TypedThrows
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func withExtendedLifetime<T, E, Result>(_ x: borrowing T, _ body: () throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
  defer { _fixLifetime(x) }
  return try body()
}
#else
@_alwaysEmitIntoClient public func withExtendedLifetime<T, E, Result>(_ x: borrowing T, _ body: () throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
  defer { _fixLifetime(x) }
  return try body()
}
#endif
#endif
#if compiler(>=5.3) && $TypedThrows
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func withExtendedLifetime<T, E, Result>(_ x: borrowing T, _ body: (borrowing T) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
  defer { _fixLifetime(x) }
  return try body(x)
}
#else
@_alwaysEmitIntoClient public func withExtendedLifetime<T, E, Result>(_ x: borrowing T, _ body: (borrowing T) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
  defer { _fixLifetime(x) }
  return try body(x)
}
#endif
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_transparent @_preInverseGenerics public func _fixLifetime<T>(_ x: borrowing T) where T : ~Copyable {
  Builtin.fixLifetime(x)
}
#else
@_transparent public func _fixLifetime<T>(_ x: T) {
  Builtin.fixLifetime(x)
}
#endif
#if compiler(>=5.3) && $TypedThrows
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func withUnsafeMutablePointer<T, E, Result>(to value: inout T, _ body: (Swift.UnsafeMutablePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
  try body(UnsafeMutablePointer<T>(Builtin.addressof(&value)))
}
#else
@_alwaysEmitIntoClient public func withUnsafeMutablePointer<T, E, Result>(to value: inout T, _ body: (Swift.UnsafeMutablePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
  try body(UnsafeMutablePointer<T>(Builtin.addressof(&value)))
}
#endif
#endif
@_silgen_name("$ss24withUnsafeMutablePointer2to_q_xz_q_SpyxGKXEtKr0_lF")
@usableFromInline
internal func __abi_se0413_withUnsafeMutablePointer<T, Result>(to value: inout T, _ body: (Swift.UnsafeMutablePointer<T>) throws -> Result) rethrows -> Result
#if compiler(>=5.3) && $TypedThrows
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func _withUnprotectedUnsafeMutablePointer<T, E, Result>(to value: inout T, _ body: (Swift.UnsafeMutablePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
#if $BuiltinUnprotectedAddressOf
  return try body(UnsafeMutablePointer<T>(Builtin.unprotectedAddressOf(&value)))
#else
  return try body(UnsafeMutablePointer<T>(Builtin.addressof(&value)))
#endif
}
#else
@_alwaysEmitIntoClient public func _withUnprotectedUnsafeMutablePointer<T, E, Result>(to value: inout T, _ body: (Swift.UnsafeMutablePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
#if $BuiltinUnprotectedAddressOf
  return try body(UnsafeMutablePointer<T>(Builtin.unprotectedAddressOf(&value)))
#else
  return try body(UnsafeMutablePointer<T>(Builtin.addressof(&value)))
#endif
}
#endif
#endif
#if compiler(>=5.3) && $TypedThrows
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func withUnsafePointer<T, E, Result>(to value: borrowing T, _ body: (Swift.UnsafePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
  return try body(UnsafePointer<T>(Builtin.addressOfBorrow(value)))
}
#else
@_alwaysEmitIntoClient public func withUnsafePointer<T, E, Result>(to value: borrowing T, _ body: (Swift.UnsafePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
  return try body(UnsafePointer<T>(Builtin.addressOfBorrow(value)))
}
#endif
#endif
@_silgen_name("$ss17withUnsafePointer2to_q_x_q_SPyxGKXEtKr0_lF")
@usableFromInline
internal func __abi_withUnsafePointer<T, Result>(to value: T, _ body: (Swift.UnsafePointer<T>) throws -> Result) rethrows -> Result
#if compiler(>=5.3) && $TypedThrows
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func withUnsafePointer<T, E, Result>(to value: inout T, _ body: (Swift.UnsafePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
  try body(UnsafePointer<T>(Builtin.addressof(&value)))
}
#else
@_alwaysEmitIntoClient public func withUnsafePointer<T, E, Result>(to value: inout T, _ body: (Swift.UnsafePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
  try body(UnsafePointer<T>(Builtin.addressof(&value)))
}
#endif
#endif
@_silgen_name("$ss17withUnsafePointer2to_q_xz_q_SPyxGKXEtKr0_lF")
@usableFromInline
internal func __abi_se0413_withUnsafePointer<T, Result>(to value: inout T, _ body: (Swift.UnsafePointer<T>) throws -> Result) rethrows -> Result
#if compiler(>=5.3) && $TypedThrows
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func _withUnprotectedUnsafePointer<T, E, Result>(to value: inout T, _ body: (Swift.UnsafePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
#if $BuiltinUnprotectedAddressOf
  return try body(UnsafePointer<T>(Builtin.unprotectedAddressOf(&value)))
#else
  return try body(UnsafePointer<T>(Builtin.addressof(&value)))
#endif
}
#else
@_alwaysEmitIntoClient public func _withUnprotectedUnsafePointer<T, E, Result>(to value: inout T, _ body: (Swift.UnsafePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
#if $BuiltinUnprotectedAddressOf
  return try body(UnsafePointer<T>(Builtin.unprotectedAddressOf(&value)))
#else
  return try body(UnsafePointer<T>(Builtin.addressof(&value)))
#endif
}
#endif
#endif
extension Swift.String {
  @inlinable public func withCString<Result>(_ body: (Swift.UnsafePointer<Swift.Int8>) throws -> Result) rethrows -> Result {
    return try _guts.withCString(body)
  }
}
@_alwaysEmitIntoClient @inlinable @_transparent @_semantics("lifetimemanagement.copy") public func _copy<T>(_ value: T) -> T {
  #if $BuiltinCopy
    Builtin.copy(value)
  #else
    value
  #endif
}
#if compiler(>=5.3) && $Macros && $FreestandingExpressionMacros
@freestanding(expression) public macro externalMacro<T>(module: Swift.String, type: Swift.String) -> T = Builtin.ExternalMacro
#endif
#if compiler(>=5.3) && $Macros && $FreestandingExpressionMacros
@freestanding(expression) public macro fileID<T>() -> T = Builtin.FileIDMacro where T : Swift.ExpressibleByStringLiteral
#endif
#if compiler(>=5.3) && $Macros && $FreestandingExpressionMacros
@freestanding(expression) public macro filePath<T>() -> T = Builtin.FilePathMacro where T : Swift.ExpressibleByStringLiteral
#endif
#if compiler(>=5.3) && $Macros && $FreestandingExpressionMacros
@freestanding(expression) public macro file<T>() -> T = Builtin.FileMacro where T : Swift.ExpressibleByStringLiteral
#endif
#if compiler(>=5.3) && $Macros && $FreestandingExpressionMacros
@freestanding(expression) public macro function<T>() -> T = Builtin.FunctionMacro where T : Swift.ExpressibleByStringLiteral
#endif
#if compiler(>=5.3) && $Macros && $FreestandingExpressionMacros
@freestanding(expression) public macro line<T>() -> T = Builtin.LineMacro where T : Swift.ExpressibleByIntegerLiteral
#endif
#if compiler(>=5.3) && $Macros && $FreestandingExpressionMacros
@freestanding(expression) public macro column<T>() -> T = Builtin.ColumnMacro where T : Swift.ExpressibleByIntegerLiteral
#endif
#if compiler(>=5.3) && $Macros && $FreestandingExpressionMacros
@freestanding(expression) public macro dsohandle() -> Swift.UnsafeRawPointer = Builtin.DSOHandleMacro
#endif
#if compiler(>=5.3) && $Macros && $FreestandingMacros
@freestanding(declaration) public macro warning(_ message: Swift.String) = Builtin.WarningMacro
#endif
#if compiler(>=5.3) && $Macros && $FreestandingMacros
@freestanding(declaration) public macro error(_ message: Swift.String) = Builtin.ErrorMacro
#endif
@usableFromInline
internal typealias _HeapObject = SwiftShims.HeapObject
@usableFromInline
@_silgen_name("swift_bufferAllocate")
internal func _swift_bufferAllocate(bufferType type: Swift.AnyClass, size: Swift.Int, alignmentMask: Swift.Int) -> Swift.AnyObject
#if compiler(>=5.3) && $NoncopyableGenerics
@_fixed_layout open class ManagedBuffer<Header, Element> where Element : ~Copyable {
  @_preInverseGenerics final public var header: Header
  @usableFromInline
  @_preInverseGenerics internal init(_doNotCallMe: ())
  @objc @_preInverseGenerics @inlinable deinit {}
}
#else
@_fixed_layout open class ManagedBuffer<Header, Element> {
  final public var header: Header
  @usableFromInline
  internal init(_doNotCallMe: ())
  @objc @inlinable deinit {}
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(*, unavailable)
extension Swift.ManagedBuffer : Swift.Sendable where Element : ~Copyable {
}
#else
@available(*, unavailable)
extension Swift.ManagedBuffer : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.ManagedBuffer where Element : ~Copyable {
  @_preInverseGenerics @inlinable final public class func create(minimumCapacity: Swift.Int, makingHeaderWith factory: (Swift.ManagedBuffer<Header, Element>) throws -> Header) rethrows -> Swift.ManagedBuffer<Header, Element> {
    let p = Builtin.allocWithTailElems_1(
         self,
         minimumCapacity._builtinWordValue, Element.self)

    let initHeaderVal = try factory(p)
    p.headerAddress.initialize(to: initHeaderVal)
     
     
     
    _fixLifetime(p)
    return p
  }
  @available(OpenBSD, unavailable, message: "malloc_size is unavailable.")
  @_preInverseGenerics @inlinable final public var capacity: Swift.Int {
    get {
    let storageAddr = UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(self))
    let endAddr = storageAddr + _swift_stdlib_malloc_size(storageAddr)
    let realCapacity = endAddr.assumingMemoryBound(to: Element.self) -
      firstElementAddress
    return realCapacity
  }
  }
  @_preInverseGenerics @inlinable final internal var firstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    return UnsafeMutablePointer(
      Builtin.projectTailElems(self, Element.self))
  }
  }
  @_preInverseGenerics @inlinable final internal var headerAddress: Swift.UnsafeMutablePointer<Header> {
    get {
    return UnsafeMutablePointer<Header>(Builtin.addressof(&header))
  }
  }
}
#else
extension Swift.ManagedBuffer {
  @inlinable final public class func create(minimumCapacity: Swift.Int, makingHeaderWith factory: (Swift.ManagedBuffer<Header, Element>) throws -> Header) rethrows -> Swift.ManagedBuffer<Header, Element> {
    let p = Builtin.allocWithTailElems_1(
         self,
         minimumCapacity._builtinWordValue, Element.self)

    let initHeaderVal = try factory(p)
    p.headerAddress.initialize(to: initHeaderVal)
     
     
     
    _fixLifetime(p)
    return p
  }
  @available(OpenBSD, unavailable, message: "malloc_size is unavailable.")
  @inlinable final public var capacity: Swift.Int {
    get {
    let storageAddr = UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(self))
    let endAddr = storageAddr + _swift_stdlib_malloc_size(storageAddr)
    let realCapacity = endAddr.assumingMemoryBound(to: Element.self) -
      firstElementAddress
    return realCapacity
  }
  }
  @inlinable final internal var firstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    return UnsafeMutablePointer(
      Builtin.projectTailElems(self, Element.self))
  }
  }
  @inlinable final internal var headerAddress: Swift.UnsafeMutablePointer<Header> {
    get {
    return UnsafeMutablePointer<Header>(Builtin.addressof(&header))
  }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.ManagedBuffer where Element : ~Copyable {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient @inline(__always) final public func withUnsafeMutablePointerToHeader<E, R>(_ body: (Swift.UnsafeMutablePointer<Header>) throws(E) -> R) throws(E) -> R where E : Swift.Error, R : ~Copyable {
    try withUnsafeMutablePointers { (v, _) throws(E) in try body(v) }
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient @inline(__always) final public func withUnsafeMutablePointerToElements<E, R>(_ body: (Swift.UnsafeMutablePointer<Element>) throws(E) -> R) throws(E) -> R where E : Swift.Error, R : ~Copyable {
    try withUnsafeMutablePointers { (_, v) throws(E) in try body(v) }
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient @inline(__always) final public func withUnsafeMutablePointers<E, R>(_ body: (Swift.UnsafeMutablePointer<Header>, Swift.UnsafeMutablePointer<Element>) throws(E) -> R) throws(E) -> R where E : Swift.Error, R : ~Copyable {
    defer { _fixLifetime(self) }
    return try body(headerAddress, firstElementAddress)
  }
  #endif
}
#else
extension Swift.ManagedBuffer {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient @inline(__always) final public func withUnsafeMutablePointerToHeader<E, R>(_ body: (Swift.UnsafeMutablePointer<Header>) throws(E) -> R) throws(E) -> R where E : Swift.Error {
    try withUnsafeMutablePointers { (v, _) throws(E) in try body(v) }
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient @inline(__always) final public func withUnsafeMutablePointerToElements<E, R>(_ body: (Swift.UnsafeMutablePointer<Element>) throws(E) -> R) throws(E) -> R where E : Swift.Error {
    try withUnsafeMutablePointers { (_, v) throws(E) in try body(v) }
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient @inline(__always) final public func withUnsafeMutablePointers<E, R>(_ body: (Swift.UnsafeMutablePointer<Header>, Swift.UnsafeMutablePointer<Element>) throws(E) -> R) throws(E) -> R where E : Swift.Error {
    defer { _fixLifetime(self) }
    return try body(headerAddress, firstElementAddress)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@frozen public struct ManagedBufferPointer<Header, Element> : Swift.Copyable where Element : ~Copyable {
  @usableFromInline
  @_preInverseGenerics internal var _nativeBuffer: Builtin.NativeObject
  @available(OpenBSD, unavailable, message: "malloc_size is unavailable.")
  @_preInverseGenerics @inlinable public init(bufferClass: Swift.AnyClass, minimumCapacity: Swift.Int, makingHeaderWith factory: (_ buffer: Swift.AnyObject, _ capacity: (Swift.AnyObject) -> Swift.Int) throws -> Header) rethrows {
    self = ManagedBufferPointer(
      bufferClass: bufferClass, minimumCapacity: minimumCapacity)

     
    try withUnsafeMutablePointerToHeader {
      $0.initialize(to:
        try factory(
          self.buffer,
          {
            ManagedBufferPointer(unsafeBufferObject: $0).capacity
          }))
    }
  }
  @_preInverseGenerics @inlinable public init(unsafeBufferObject buffer: Swift.AnyObject) {
    ManagedBufferPointer._checkValidBufferClass(type(of: buffer))

    self._nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
  @_preInverseGenerics @inlinable internal init(_uncheckedUnsafeBufferObject buffer: Swift.AnyObject) {
    ManagedBufferPointer._internalInvariantValidBufferClass(type(of: buffer))
    self._nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
  @_preInverseGenerics @inlinable internal init(bufferClass: Swift.AnyClass, minimumCapacity: Swift.Int) {
    ManagedBufferPointer._checkValidBufferClass(bufferClass, creating: true)
    _precondition(
      minimumCapacity >= 0,
      "ManagedBufferPointer must have non-negative capacity")

    self.init(
      _uncheckedBufferClass: bufferClass, minimumCapacity: minimumCapacity)
  }
  @_preInverseGenerics @inlinable internal init(_uncheckedBufferClass: Swift.AnyClass, minimumCapacity: Swift.Int) {
    ManagedBufferPointer._internalInvariantValidBufferClass(
      _uncheckedBufferClass, creating: true)
    _internalInvariant(
      minimumCapacity >= 0,
      "ManagedBufferPointer must have non-negative capacity")

    let totalSize = ManagedBufferPointer._elementOffset
      +  minimumCapacity * MemoryLayout<Element>.stride

    let newBuffer: AnyObject = _swift_bufferAllocate(
      bufferType: _uncheckedBufferClass,
      size: totalSize,
      alignmentMask: ManagedBufferPointer._alignmentMask)

    self._nativeBuffer = Builtin.unsafeCastToNativeObject(newBuffer)
  }
  @_preInverseGenerics @inlinable internal init(_ buffer: Swift.ManagedBuffer<Header, Element>) {
    _nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
}
#else
@frozen public struct ManagedBufferPointer<Header, Element> {
  @usableFromInline
  internal var _nativeBuffer: Builtin.NativeObject
  @available(OpenBSD, unavailable, message: "malloc_size is unavailable.")
  @inlinable public init(bufferClass: Swift.AnyClass, minimumCapacity: Swift.Int, makingHeaderWith factory: (_ buffer: Swift.AnyObject, _ capacity: (Swift.AnyObject) -> Swift.Int) throws -> Header) rethrows {
    self = ManagedBufferPointer(
      bufferClass: bufferClass, minimumCapacity: minimumCapacity)

     
    try withUnsafeMutablePointerToHeader {
      $0.initialize(to:
        try factory(
          self.buffer,
          {
            ManagedBufferPointer(unsafeBufferObject: $0).capacity
          }))
    }
  }
  @inlinable public init(unsafeBufferObject buffer: Swift.AnyObject) {
    ManagedBufferPointer._checkValidBufferClass(type(of: buffer))

    self._nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
  @inlinable internal init(_uncheckedUnsafeBufferObject buffer: Swift.AnyObject) {
    ManagedBufferPointer._internalInvariantValidBufferClass(type(of: buffer))
    self._nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
  @inlinable internal init(bufferClass: Swift.AnyClass, minimumCapacity: Swift.Int) {
    ManagedBufferPointer._checkValidBufferClass(bufferClass, creating: true)
    _precondition(
      minimumCapacity >= 0,
      "ManagedBufferPointer must have non-negative capacity")

    self.init(
      _uncheckedBufferClass: bufferClass, minimumCapacity: minimumCapacity)
  }
  @inlinable internal init(_uncheckedBufferClass: Swift.AnyClass, minimumCapacity: Swift.Int) {
    ManagedBufferPointer._internalInvariantValidBufferClass(
      _uncheckedBufferClass, creating: true)
    _internalInvariant(
      minimumCapacity >= 0,
      "ManagedBufferPointer must have non-negative capacity")

    let totalSize = ManagedBufferPointer._elementOffset
      +  minimumCapacity * MemoryLayout<Element>.stride

    let newBuffer: AnyObject = _swift_bufferAllocate(
      bufferType: _uncheckedBufferClass,
      size: totalSize,
      alignmentMask: ManagedBufferPointer._alignmentMask)

    self._nativeBuffer = Builtin.unsafeCastToNativeObject(newBuffer)
  }
  @inlinable internal init(_ buffer: Swift.ManagedBuffer<Header, Element>) {
    _nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.ManagedBufferPointer where Element : ~Copyable {
  @_preInverseGenerics @inlinable public var header: Header {
    _read {
      yield _headerPointer.pointee
    }
    _modify {
      yield &_headerPointer.pointee
    }
  }
}
#else
extension Swift.ManagedBufferPointer {
  @inlinable public var header: Header {
    _read {
      yield _headerPointer.pointee
    }
    _modify {
      yield &_headerPointer.pointee
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.ManagedBufferPointer where Element : ~Copyable {
  @_preInverseGenerics @inlinable public var buffer: Swift.AnyObject {
    get {
    return Builtin.castFromNativeObject(_nativeBuffer)
  }
  }
  @available(OpenBSD, unavailable, message: "malloc_size is unavailable.")
  @_preInverseGenerics @inlinable public var capacity: Swift.Int {
    get {
    return (
      _capacityInBytes &- ManagedBufferPointer._elementOffset
    ) / MemoryLayout<Element>.stride
  }
  }
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withUnsafeMutablePointerToHeader<E, R>(_ body: (Swift.UnsafeMutablePointer<Header>) throws(E) -> R) throws(E) -> R where E : Swift.Error, R : ~Copyable {
    try withUnsafeMutablePointers { (v, _) throws(E) in try body(v) }
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withUnsafeMutablePointerToElements<E, R>(_ body: (Swift.UnsafeMutablePointer<Element>) throws(E) -> R) throws(E) -> R where E : Swift.Error, R : ~Copyable {
    try withUnsafeMutablePointers { (_, v) throws(E) in try body(v) }
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withUnsafeMutablePointers<E, R>(_ body: (Swift.UnsafeMutablePointer<Header>, Swift.UnsafeMutablePointer<Element>) throws(E) -> R) throws(E) -> R where E : Swift.Error, R : ~Copyable {
    defer { _fixLifetime(_nativeBuffer) }
    return try body(_headerPointer, _elementPointer)
  }
  #endif
  @_preInverseGenerics @inlinable public mutating func isUniqueReference() -> Swift.Bool {
    return _isUnique(&_nativeBuffer)
  }
}
#else
extension Swift.ManagedBufferPointer {
  @inlinable public var buffer: Swift.AnyObject {
    get {
    return Builtin.castFromNativeObject(_nativeBuffer)
  }
  }
  @available(OpenBSD, unavailable, message: "malloc_size is unavailable.")
  @inlinable public var capacity: Swift.Int {
    get {
    return (
      _capacityInBytes &- ManagedBufferPointer._elementOffset
    ) / MemoryLayout<Element>.stride
  }
  }
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withUnsafeMutablePointerToHeader<E, R>(_ body: (Swift.UnsafeMutablePointer<Header>) throws(E) -> R) throws(E) -> R where E : Swift.Error {
    try withUnsafeMutablePointers { (v, _) throws(E) in try body(v) }
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withUnsafeMutablePointerToElements<E, R>(_ body: (Swift.UnsafeMutablePointer<Element>) throws(E) -> R) throws(E) -> R where E : Swift.Error {
    try withUnsafeMutablePointers { (_, v) throws(E) in try body(v) }
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withUnsafeMutablePointers<E, R>(_ body: (Swift.UnsafeMutablePointer<Header>, Swift.UnsafeMutablePointer<Element>) throws(E) -> R) throws(E) -> R where E : Swift.Error {
    defer { _fixLifetime(_nativeBuffer) }
    return try body(_headerPointer, _elementPointer)
  }
  #endif
  @inlinable public mutating func isUniqueReference() -> Swift.Bool {
    return _isUnique(&_nativeBuffer)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.ManagedBufferPointer where Element : ~Copyable {
  @_preInverseGenerics @inlinable internal static func _checkValidBufferClass(_ bufferClass: Swift.AnyClass, creating: Swift.Bool = false) {
    _debugPrecondition(
      _class_getInstancePositiveExtentSize(bufferClass) == MemoryLayout<_HeapObject>.size
      || (
        (!creating || bufferClass is ManagedBuffer<Header, Element>.Type)
        && _class_getInstancePositiveExtentSize(bufferClass)
          == _headerOffset + MemoryLayout<Header>.size),
      "ManagedBufferPointer buffer class has illegal stored properties"
    )
    _debugPrecondition(
      _usesNativeSwiftReferenceCounting(bufferClass),
      "ManagedBufferPointer buffer class must be non-@objc"
    )
  }
  @_preInverseGenerics @inlinable internal static func _internalInvariantValidBufferClass(_ bufferClass: Swift.AnyClass, creating: Swift.Bool = false) {
    _internalInvariant(
      _class_getInstancePositiveExtentSize(bufferClass) == MemoryLayout<_HeapObject>.size
      || (
        (!creating || bufferClass is ManagedBuffer<Header, Element>.Type)
        && _class_getInstancePositiveExtentSize(bufferClass)
          == _headerOffset + MemoryLayout<Header>.size),
      "ManagedBufferPointer buffer class has illegal stored properties"
    )
    _internalInvariant(
      _usesNativeSwiftReferenceCounting(bufferClass),
      "ManagedBufferPointer buffer class must be non-@objc"
    )
  }
}
#else
extension Swift.ManagedBufferPointer {
  @inlinable internal static func _checkValidBufferClass(_ bufferClass: Swift.AnyClass, creating: Swift.Bool = false) {
    _debugPrecondition(
      _class_getInstancePositiveExtentSize(bufferClass) == MemoryLayout<_HeapObject>.size
      || (
        (!creating || bufferClass is ManagedBuffer<Header, Element>.Type)
        && _class_getInstancePositiveExtentSize(bufferClass)
          == _headerOffset + MemoryLayout<Header>.size),
      "ManagedBufferPointer buffer class has illegal stored properties"
    )
    _debugPrecondition(
      _usesNativeSwiftReferenceCounting(bufferClass),
      "ManagedBufferPointer buffer class must be non-@objc"
    )
  }
  @inlinable internal static func _internalInvariantValidBufferClass(_ bufferClass: Swift.AnyClass, creating: Swift.Bool = false) {
    _internalInvariant(
      _class_getInstancePositiveExtentSize(bufferClass) == MemoryLayout<_HeapObject>.size
      || (
        (!creating || bufferClass is ManagedBuffer<Header, Element>.Type)
        && _class_getInstancePositiveExtentSize(bufferClass)
          == _headerOffset + MemoryLayout<Header>.size),
      "ManagedBufferPointer buffer class has illegal stored properties"
    )
    _internalInvariant(
      _usesNativeSwiftReferenceCounting(bufferClass),
      "ManagedBufferPointer buffer class must be non-@objc"
    )
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.ManagedBufferPointer where Element : ~Copyable {
  @_preInverseGenerics @inlinable internal static var _alignmentMask: Swift.Int {
    get {
    return max(
      MemoryLayout<_HeapObject>.alignment,
      max(MemoryLayout<Header>.alignment, MemoryLayout<Element>.alignment)) &- 1
  }
  }
  @available(OpenBSD, unavailable, message: "malloc_size is unavailable.")
  @_preInverseGenerics @inlinable internal var _capacityInBytes: Swift.Int {
    get {
    return _swift_stdlib_malloc_size(_address)
  }
  }
  @_preInverseGenerics @inlinable internal var _address: Swift.UnsafeMutableRawPointer {
    get {
    return UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(_nativeBuffer))
  }
  }
  @_preInverseGenerics @inlinable internal static var _headerOffset: Swift.Int {
    get {
    _onFastPath()
    return _roundUp(
      MemoryLayout<_HeapObject>.size,
      toAlignment: MemoryLayout<Header>.alignment)
  }
  }
  @_preInverseGenerics @inlinable internal var _headerPointer: Swift.UnsafeMutablePointer<Header> {
    get {
    _onFastPath()
    return (_address + ManagedBufferPointer._headerOffset).assumingMemoryBound(
      to: Header.self)
  }
  }
  @_preInverseGenerics @inlinable internal var _elementPointer: Swift.UnsafeMutablePointer<Element> {
    get {
    _onFastPath()
    return (_address + ManagedBufferPointer._elementOffset).assumingMemoryBound(
      to: Element.self)
  }
  }
  @_preInverseGenerics @inlinable internal static var _elementOffset: Swift.Int {
    get {
    _onFastPath()
    return _roundUp(
      _headerOffset + MemoryLayout<Header>.size,
      toAlignment: MemoryLayout<Element>.alignment)
  }
  }
}
#else
extension Swift.ManagedBufferPointer {
  @inlinable internal static var _alignmentMask: Swift.Int {
    get {
    return max(
      MemoryLayout<_HeapObject>.alignment,
      max(MemoryLayout<Header>.alignment, MemoryLayout<Element>.alignment)) &- 1
  }
  }
  @available(OpenBSD, unavailable, message: "malloc_size is unavailable.")
  @inlinable internal var _capacityInBytes: Swift.Int {
    get {
    return _swift_stdlib_malloc_size(_address)
  }
  }
  @inlinable internal var _address: Swift.UnsafeMutableRawPointer {
    get {
    return UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(_nativeBuffer))
  }
  }
  @inlinable internal static var _headerOffset: Swift.Int {
    get {
    _onFastPath()
    return _roundUp(
      MemoryLayout<_HeapObject>.size,
      toAlignment: MemoryLayout<Header>.alignment)
  }
  }
  @inlinable internal var _headerPointer: Swift.UnsafeMutablePointer<Header> {
    get {
    _onFastPath()
    return (_address + ManagedBufferPointer._headerOffset).assumingMemoryBound(
      to: Header.self)
  }
  }
  @inlinable internal var _elementPointer: Swift.UnsafeMutablePointer<Element> {
    get {
    _onFastPath()
    return (_address + ManagedBufferPointer._elementOffset).assumingMemoryBound(
      to: Element.self)
  }
  }
  @inlinable internal static var _elementOffset: Swift.Int {
    get {
    _onFastPath()
    return _roundUp(
      _headerOffset + MemoryLayout<Header>.size,
      toAlignment: MemoryLayout<Element>.alignment)
  }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.ManagedBufferPointer : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.ManagedBufferPointer<Header, Element>, rhs: Swift.ManagedBufferPointer<Header, Element>) -> Swift.Bool {
    return lhs._address == rhs._address
  }
}
#else
extension Swift.ManagedBufferPointer : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.ManagedBufferPointer<Header, Element>, rhs: Swift.ManagedBufferPointer<Header, Element>) -> Swift.Bool {
    return lhs._address == rhs._address
  }
}
#endif
@inlinable public func isKnownUniquelyReferenced<T>(_ object: inout T) -> Swift.Bool where T : AnyObject {
  return _isUnique(&object)
}
@inlinable public func isKnownUniquelyReferenced<T>(_ object: inout T?) -> Swift.Bool where T : AnyObject {
  return _isUnique(&object)
}
@frozen public struct LazyMapSequence<Base, Element> where Base : Swift.Sequence {
  public typealias Elements = Swift.LazyMapSequence<Base, Element>
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _transform: (Base.Element) -> Element
  @inlinable internal init(_base: Base, transform: @escaping (Base.Element) -> Element) {
    self._base = _base
    self._transform = transform
  }
}
@available(*, unavailable)
extension Swift.LazyMapSequence : Swift.Sendable {
}
extension Swift.LazyMapSequence {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal let _transform: (Base.Element) -> Swift.LazyMapSequence<Base, Element>.Iterator.Element
    @inlinable public var base: Base.Iterator {
      get { return _base }
    }
    @inlinable internal init(_base: Base.Iterator, _transform: @escaping (Base.Element) -> Swift.LazyMapSequence<Base, Element>.Iterator.Element) {
      self._base = _base
      self._transform = _transform
    }
  }
}
@available(*, unavailable)
extension Swift.LazyMapSequence.Iterator : Swift.Sendable {
}
extension Swift.LazyMapSequence.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  @inlinable public mutating func next() -> Element? {
    return _base.next().map(_transform)
  }
  public typealias Iterator = Swift.LazyMapSequence<Base, Element>.Iterator
}
extension Swift.LazyMapSequence : Swift.LazySequenceProtocol {
  @inlinable public __consuming func makeIterator() -> Swift.LazyMapSequence<Base, Element>.Iterator {
    return Iterator(_base: _base.makeIterator(), _transform: _transform)
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return _base.underestimatedCount
  }
  }
}
public typealias LazyMapCollection<T, U> = Swift.LazyMapSequence<T, U> where T : Swift.Collection
extension Swift.LazyMapCollection : Swift.Collection where Base : Swift.Collection {
  public typealias Index = Base.Index
  public typealias Indices = Base.Indices
  public typealias SubSequence = Swift.LazyMapCollection<Base.SubSequence, Element>
  @inlinable public var startIndex: Base.Index {
    get { return _base.startIndex }
  }
  @inlinable public var endIndex: Base.Index {
    get { return _base.endIndex }
  }
  @inlinable public func index(after i: Swift.LazyMapSequence<Base, Element>.Index) -> Swift.LazyMapSequence<Base, Element>.Index { return _base.index(after: i) }
  @inlinable public func formIndex(after i: inout Swift.LazyMapSequence<Base, Element>.Index) { _base.formIndex(after: &i) }
  @inlinable public subscript(position: Base.Index) -> Element {
    get {
    return _transform(_base[position])
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Base.Index>) -> Swift.LazyMapSequence<Base, Element>.SubSequence {
    get {
    return SubSequence(_base: _base[bounds], transform: _transform)
  }
  }
  @inlinable public var indices: Swift.LazyMapSequence<Base, Element>.Indices {
    get {
    return _base.indices
  }
  }
  @inlinable public var isEmpty: Swift.Bool {
    get { return _base.isEmpty }
  }
  @inlinable public var count: Swift.Int {
    get {
    return _base.count
  }
  }
  @inlinable public func index(_ i: Swift.LazyMapSequence<Base, Element>.Index, offsetBy n: Swift.Int) -> Swift.LazyMapSequence<Base, Element>.Index {
    return _base.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.LazyMapSequence<Base, Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.LazyMapSequence<Base, Element>.Index) -> Swift.LazyMapSequence<Base, Element>.Index? {
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Swift.LazyMapSequence<Base, Element>.Index, to end: Swift.LazyMapSequence<Base, Element>.Index) -> Swift.Int {
    return _base.distance(from: start, to: end)
  }
}
extension Swift.LazyMapCollection : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.LazyMapSequence<Base, Element>.Index) -> Swift.LazyMapSequence<Base, Element>.Index { return _base.index(before: i) }
  @inlinable public func formIndex(before i: inout Swift.LazyMapSequence<Base, Element>.Index) {
    _base.formIndex(before: &i)
  }
}
extension Swift.LazyMapCollection : Swift.LazyCollectionProtocol where Base : Swift.Collection {
}
extension Swift.LazyMapCollection : Swift.RandomAccessCollection where Base : Swift.RandomAccessCollection {
}
extension Swift.LazySequenceProtocol {
  @inlinable public func map<U>(_ transform: @escaping (Self.Element) -> U) -> Swift.LazyMapSequence<Self.Elements, U> {
    return LazyMapSequence(_base: elements, transform: transform)
  }
}
extension Swift.LazyMapSequence {
  @available(swift 5)
  @inlinable public func map<ElementOfResult>(_ transform: @escaping (Element) -> ElementOfResult) -> Swift.LazyMapSequence<Base, ElementOfResult> {
    return LazyMapSequence<Base, ElementOfResult>(
      _base: _base,
      transform: { transform(self._transform($0)) })
  }
}
extension Swift.LazyMapCollection where Base : Swift.Collection {
  @available(swift 5)
  @inlinable public func map<ElementOfResult>(_ transform: @escaping (Element) -> ElementOfResult) -> Swift.LazyMapCollection<Base, ElementOfResult> {
    return LazyMapCollection<Base, ElementOfResult>(
      _base: _base,
      transform: {transform(self._transform($0))})
  }
}
#if compiler(>=5.3) && $ConformanceSuppression
@frozen public enum MemoryLayout<T> : ~Swift.BitwiseCopyable, Swift.Copyable where T : ~Copyable {
}
#elseif compiler(>=5.3) && $NoncopyableGenerics
@frozen public enum MemoryLayout<T> : Swift.Copyable where T : ~Copyable {
}
#else
@frozen public enum MemoryLayout<T> {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.MemoryLayout where T : ~Copyable {
  @_transparent @_preInverseGenerics public static var size: Swift.Int {
    @_transparent get {
    return Int(Builtin.sizeof(T.self))
  }
  }
  @_transparent @_preInverseGenerics public static var stride: Swift.Int {
    @_transparent get {
    return Int(Builtin.strideof(T.self))
  }
  }
  @_transparent @_preInverseGenerics public static var alignment: Swift.Int {
    @_transparent get {
    return Int(Builtin.alignof(T.self))
  }
  }
}
#else
extension Swift.MemoryLayout {
  @_transparent public static var size: Swift.Int {
    @_transparent get {
    return Int(Builtin.sizeof(T.self))
  }
  }
  @_transparent public static var stride: Swift.Int {
    @_transparent get {
    return Int(Builtin.strideof(T.self))
  }
  }
  @_transparent public static var alignment: Swift.Int {
    @_transparent get {
    return Int(Builtin.alignof(T.self))
  }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.MemoryLayout where T : ~Copyable {
  @_transparent @_preInverseGenerics public static func size(ofValue value: borrowing T) -> Swift.Int {
    return MemoryLayout.size
  }
  @_transparent @_preInverseGenerics public static func stride(ofValue value: borrowing T) -> Swift.Int {
    return MemoryLayout.stride
  }
  @_transparent @_preInverseGenerics public static func alignment(ofValue value: borrowing T) -> Swift.Int {
    return MemoryLayout.alignment
  }
}
#else
extension Swift.MemoryLayout {
  @_transparent public static func size(ofValue value: T) -> Swift.Int {
    return MemoryLayout.size
  }
  @_transparent public static func stride(ofValue value: T) -> Swift.Int {
    return MemoryLayout.stride
  }
  @_transparent public static func alignment(ofValue value: T) -> Swift.Int {
    return MemoryLayout.alignment
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.MemoryLayout {
  @_transparent public static func offset(of key: Swift.PartialKeyPath<T>) -> Swift.Int? {
    return key._storedInlineOffset
  }
}
#else
extension Swift.MemoryLayout {
  @_transparent public static func offset(of key: Swift.PartialKeyPath<T>) -> Swift.Int? {
    return key._storedInlineOffset
  }
}
#endif
extension Swift.Unicode {
  @frozen public struct Scalar : Swift.Sendable {
    @usableFromInline
    internal var _value: Swift.UInt32
    @inlinable internal init(_value: Swift.UInt32) {
      self._value = _value
    }
  }
}
extension Swift.Unicode.Scalar : Swift._ExpressibleByBuiltinUnicodeScalarLiteral, Swift.ExpressibleByUnicodeScalarLiteral {
  @inlinable public var value: Swift.UInt32 {
    get { return _value }
  }
  @_transparent public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self._value = UInt32(value)
  }
  @_transparent public init(unicodeScalarLiteral value: Swift.Unicode.Scalar) {
    self = value
  }
  @inlinable public init?(_ v: Swift.UInt32) {
     
     
     
     
     
     
     
     
     
    if (v < 0xD800 || v > 0xDFFF) && v <= 0x10FFFF {
      self._value = v
      return
    }
     
    return nil
  }
  @inlinable public init?(_ v: Swift.UInt16) {
    self.init(UInt32(v))
  }
  @inlinable public init(_ v: Swift.UInt8) {
    self._value = UInt32(v)
  }
  @inlinable public init(_ v: Swift.Unicode.Scalar) {
     
     
    self = v
  }
  public func escaped(asASCII forceASCII: Swift.Bool) -> Swift.String
  @inlinable public var isASCII: Swift.Bool {
    get {
    return value <= 127
  }
  }
  public typealias UnicodeScalarLiteralType = Swift.Unicode.Scalar
}
extension Swift.Unicode.Scalar : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inlinable public var description: Swift.String {
    get {
    return String(self)
  }
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.Unicode.Scalar : Swift.LosslessStringConvertible {
  @inlinable public init?(_ description: Swift.String) {
    let scalars = description.unicodeScalars
    guard let v = scalars.first, scalars.count == 1 else {
      return nil
    }
    self = v
  }
}
extension Swift.Unicode.Scalar : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(self.value)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Unicode.Scalar {
  @inlinable public init?(_ v: Swift.Int) {
    if let exact = UInt32(exactly: v) {
      self.init(exact)
    } else {
      return nil
    }
  }
}
extension Swift.UInt8 {
  @inlinable public init(ascii v: Swift.Unicode.Scalar) {
    _precondition(v.value < 128,
        "Code point value does not fit into ASCII")
    self = UInt8(v.value)
  }
}
extension Swift.UInt32 {
  @inlinable public init(_ v: Swift.Unicode.Scalar) {
    self = v.value
  }
}
extension Swift.UInt64 {
  @inlinable public init(_ v: Swift.Unicode.Scalar) {
    self = UInt64(v.value)
  }
}
extension Swift.Unicode.Scalar : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.Unicode.Scalar, rhs: Swift.Unicode.Scalar) -> Swift.Bool {
    return lhs.value == rhs.value
  }
}
extension Swift.Unicode.Scalar : Swift.Comparable {
  @inlinable public static func < (lhs: Swift.Unicode.Scalar, rhs: Swift.Unicode.Scalar) -> Swift.Bool {
    return lhs.value < rhs.value
  }
}
extension Swift.Unicode.Scalar {
  @frozen public struct UTF16View : Swift.Sendable {
    @usableFromInline
    internal var value: Swift.Unicode.Scalar
    @inlinable internal init(value: Swift.Unicode.Scalar) {
      self.value = value
    }
  }
  @inlinable public var utf16: Swift.Unicode.Scalar.UTF16View {
    get {
    return UTF16View(value: self)
  }
  }
}
extension Swift.Unicode.Scalar.UTF16View : Swift.RandomAccessCollection {
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable public var startIndex: Swift.Int {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.Int {
    get {
    return 0 + UTF16.width(value)
  }
  }
  @inlinable public subscript(position: Swift.Int) -> Swift.UTF16.CodeUnit {
    get {
    if position == 1 { return UTF16.trailSurrogate(value) }
    if endIndex == 1 { return UTF16.CodeUnit(value.value) }
    return UTF16.leadSurrogate(value)
  }
  }
  public typealias Element = Swift.UTF16.CodeUnit
  public typealias Index = Swift.Int
  public typealias Iterator = Swift.IndexingIterator<Swift.Unicode.Scalar.UTF16View>
  public typealias SubSequence = Swift.Slice<Swift.Unicode.Scalar.UTF16View>
}
extension Swift.Unicode.Scalar {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @frozen public struct UTF8View : Swift.Sendable {
    @usableFromInline
    internal var value: Swift.Unicode.Scalar
    @inlinable internal init(value: Swift.Unicode.Scalar) {
      self.value = value
    }
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @inlinable public var utf8: Swift.Unicode.Scalar.UTF8View {
    get { return UTF8View(value: self) }
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.Unicode.Scalar.UTF8View : Swift.RandomAccessCollection {
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable public var startIndex: Swift.Int {
    get { return 0 }
  }
  @inlinable public var endIndex: Swift.Int {
    get { return 0 + UTF8.width(value) }
  }
  @inlinable public subscript(position: Swift.Int) -> Swift.UTF8.CodeUnit {
    get {
    _precondition(position >= startIndex && position < endIndex,
      "Unicode.Scalar.UTF8View index is out of bounds")
    return value.withUTF8CodeUnits { $0[position] }
  }
  }
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Element = Swift.UTF8.CodeUnit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Index = Swift.Int
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Iterator = Swift.IndexingIterator<Swift.Unicode.Scalar.UTF8View>
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias SubSequence = Swift.Slice<Swift.Unicode.Scalar.UTF8View>
}
extension Swift.Unicode.Scalar {
  @available(*, unavailable, message: "use 'Unicode.Scalar(0)'")
  public init()
}
extension Swift.Unicode.Scalar {
  @inlinable internal func withUTF8CodeUnits<Result>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> Result) rethrows -> Result {
    let encodedScalar = UTF8.encode(self)!
    var (codeUnits, utf8Count) = encodedScalar._bytes

     
    codeUnits = codeUnits.littleEndian
#if $TypedThrows
    return try Swift._withUnprotectedUnsafePointer(to: &codeUnits) {
      return try $0.withMemoryRebound(to: UInt8.self, capacity: 4) {
        return try body(UnsafeBufferPointer(start: $0, count: utf8Count))
      }
    }
#else
    return try Swift.__abi_se0413_withUnsafePointer(to: &codeUnits) {
      return try $0.withMemoryRebound(to: UInt8.self, capacity: 4) {
        return try body(UnsafeBufferPointer(start: $0, count: utf8Count))
      }
    }
#endif
  }
}
extension Swift.Float : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Float : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Float.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.Double : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Double : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Double.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.Bool : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Bool : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Bool.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.String : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.String : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "String.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.Character : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Character : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Character.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.Unicode.Scalar : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Unicode.Scalar : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Unicode.Scalar.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.UInt8 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.UInt8 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt8.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.Int8 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Int8 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int8.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.UInt16 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.UInt16 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt16.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.Int16 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Int16 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int16.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.UInt32 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.UInt32 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt32.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.Int32 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Int32 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int32.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.UInt64 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.UInt64 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt64.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.Int64 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Int64 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int64.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.UInt : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.UInt : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.Int : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Int : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@_transparent public func _isPowerOf2(_ x: Swift.UInt) -> Swift.Bool {
  if x == 0 {
    return false
  }
   
   
  return x & (x &- 1) == 0
}
@_transparent public func _isPowerOf2(_ x: Swift.Int) -> Swift.Bool {
  if x <= 0 {
    return false
  }
   
   
  return x & (x &- 1) == 0
}
@_transparent public func _autorelease(_ x: Swift.AnyObject) {
  Builtin.retain(x)
  Builtin.autorelease(x)
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@_silgen_name("swift_getFunctionFullNameFromMangledName")
public func _getFunctionFullNameFromMangledNameImpl(_ mangledName: Swift.UnsafePointer<Swift.UInt8>, _ mangledNameLength: Swift.UInt) -> (Swift.UnsafePointer<Swift.UInt8>, Swift.UInt)
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public func _getFunctionFullNameFromMangledName(mangledName: Swift.String) -> Swift.String?
@_silgen_name("swift_getTypeName")
public func _getTypeName(_ type: any Any.Type, qualified: Swift.Bool) -> (Swift.UnsafePointer<Swift.UInt8>, Swift.Int)
@_semantics("typeName") public func _typeName(_ type: any Any.Type, qualified: Swift.Bool = true) -> Swift.String
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@_silgen_name("swift_getMangledTypeName")
public func _getMangledTypeName(_ type: any Any.Type) -> (Swift.UnsafePointer<Swift.UInt8>, Swift.Int)
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public func _mangledTypeName(_ type: any Any.Type) -> Swift.String?
public func _typeByName(_ name: Swift.String) -> (any Any.Type)?
@_silgen_name("swift_getTypeByMangledNameInEnvironment")
public func _getTypeByMangledNameInEnvironment(_ name: Swift.UnsafePointer<Swift.UInt8>, _ nameLength: Swift.UInt, genericEnvironment: Swift.UnsafeRawPointer?, genericArguments: Swift.UnsafeRawPointer?) -> (any Any.Type)?
@_silgen_name("swift_getTypeByMangledNameInContext")
public func _getTypeByMangledNameInContext(_ name: Swift.UnsafePointer<Swift.UInt8>, _ nameLength: Swift.UInt, genericContext: Swift.UnsafeRawPointer?, genericArguments: Swift.UnsafeRawPointer?) -> (any Any.Type)?
@_alwaysEmitIntoClient @_semantics("no_performance_analysis") public func _unsafePerformance<T>(_ c: () -> T) -> T {
  return c()
}
@usableFromInline
@_alwaysEmitIntoClient @inline(__always) internal func _rethrowsViaClosure(_ fn: () throws -> ()) rethrows {
  try fn()
}
#if compiler(>=5.3) && $NoncopyableGenerics
@_marker public protocol Copyable {
}
#else
@_marker public protocol Copyable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_documentation(visibility: internal) @_marker public protocol Escapable {
}
#else
@_documentation(visibility: internal) @_marker public protocol Escapable {
}
#endif
#if compiler(>=5.3) && $BitwiseCopyable2
@_marker public protocol BitwiseCopyable {
}
#else
@_marker public protocol _BitwiseCopyable {
}
#endif
#if compiler(>=5.3) && $BitwiseCopyable2
@available(*, deprecated, message: "Use BitwiseCopyable")
public typealias _BitwiseCopyable = Swift.BitwiseCopyable
#else
@available(*, deprecated, message: "Use BitwiseCopyable")
public typealias BitwiseCopyable = Swift._BitwiseCopyable
#endif
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol MutableCollection<Element> : Swift.Collection where Self.SubSequence : Swift.MutableCollection {
  override associatedtype Element
  override associatedtype Index
  override associatedtype SubSequence
  @_borrowed override subscript(position: Self.Index) -> Self.Element { get set }
  override subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get set }
  mutating func partition(by belongsInSecondPartition: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index
  mutating func swapAt(_ i: Self.Index, _ j: Self.Index)
  @available(*, deprecated, renamed: "withContiguousMutableStorageIfAvailable")
  mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R?
  mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (_ buffer: inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R?
}
#else
public protocol MutableCollection : Swift.Collection where Self.SubSequence : Swift.MutableCollection {
  override associatedtype Element
  override associatedtype Index
  override associatedtype SubSequence
  @_borrowed override subscript(position: Self.Index) -> Self.Element { get set }
  override subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get set }
  mutating func partition(by belongsInSecondPartition: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index
  mutating func swapAt(_ i: Self.Index, _ j: Self.Index)
  @available(*, deprecated, renamed: "withContiguousMutableStorageIfAvailable")
  mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R?
  mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (_ buffer: inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R?
}
#endif
extension Swift.MutableCollection {
  @available(*, deprecated, renamed: "withContiguousMutableStorageIfAvailable")
  @inlinable public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R? {
    return nil
  }
  @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R? {
    return nil
  }
  @available(*, unavailable)
  @inlinable public subscript(bounds: Swift.Range<Self.Index>) -> Swift.Slice<Self> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: self, bounds: bounds)
    }
    set {
      _writeBackMutableSlice(&self, bounds: bounds, slice: newValue)
    }
  }
  @available(*, unavailable)
  @_alwaysEmitIntoClient public subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence {
    get { fatalError() }
    set { fatalError() }
  }
  @inlinable public mutating func swapAt(_ i: Self.Index, _ j: Self.Index) {
    guard i != j else { return }
    let tmp = self[i]
    self[i] = self[j]
    self[j] = tmp
  }
}
extension Swift.MutableCollection where Self.SubSequence == Swift.Slice<Self> {
  @inlinable @_alwaysEmitIntoClient public subscript(bounds: Swift.Range<Self.Index>) -> Swift.Slice<Self> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: self, bounds: bounds)
    }
    set {
      _writeBackMutableSlice(&self, bounds: bounds, slice: newValue)
    }
  }
}
extension Swift.MutableCollection {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  public mutating func moveSubranges(_ subranges: Swift.RangeSet<Self.Index>, to insertionPoint: Self.Index) -> Swift.Range<Self.Index>
}
#if compiler(>=5.3) && $NoncopyableGenerics
@inlinable @_preInverseGenerics public func swap<T>(_ a: inout T, _ b: inout T) where T : ~Copyable {
  let temp = consume a
  a = consume b
  b = consume temp
}
#else
@inlinable public func swap<T>(_ a: inout T, _ b: inout T) {
  let temp = consume a
  a = consume b
  b = consume temp
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func exchange<T>(_ item: inout T, with newValue: consuming T) -> T where T : ~Copyable {
  let oldValue = consume item
  item = consume newValue
  return oldValue
}
#else
@_alwaysEmitIntoClient public func exchange<T>(_ item: inout T, with newValue: consuming T) -> T {
  let oldValue = consume item
  item = consume newValue
  return oldValue
}
#endif
@usableFromInline
@frozen internal struct _NativeDictionary<Key, Value> where Key : Swift.Hashable {
  @usableFromInline
  internal typealias Element = (key: Key, value: Value)
  @usableFromInline
  internal var _storage: Swift.__RawDictionaryStorage
  @inlinable internal init() {
    self._storage = __RawDictionaryStorage.empty
  }
  @inlinable internal init(_ storage: __owned Swift.__RawDictionaryStorage) {
    self._storage = storage
  }
  @inlinable internal init(capacity: Swift.Int) {
    if capacity == 0 {
      self._storage = __RawDictionaryStorage.empty
    } else {
      self._storage = _DictionaryStorage<Key, Value>.allocate(capacity: capacity)
    }
  }
  @inlinable internal init(_ cocoa: __owned Swift.__CocoaDictionary) {
    self.init(cocoa, capacity: cocoa.count)
  }
  @inlinable internal init(_ cocoa: __owned Swift.__CocoaDictionary, capacity: Swift.Int) {
    if capacity == 0 {
      self._storage = __RawDictionaryStorage.empty
    } else {
      _internalInvariant(cocoa.count <= capacity)
      self._storage =
        _DictionaryStorage<Key, Value>.convert(cocoa, capacity: capacity)
      for (key, value) in cocoa {
        insertNew(
          key: _forceBridgeFromObjectiveC(key, Key.self),
          value: _forceBridgeFromObjectiveC(value, Value.self))
      }
    }
  }
}
@available(*, unavailable)
extension Swift._NativeDictionary : Swift.Sendable {
}
extension Swift._NativeDictionary {
  @usableFromInline
  internal typealias Bucket = Swift._HashTable.Bucket
  @inlinable internal var capacity: Swift.Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._capacity)
    }
  }
  @inlinable internal var hashTable: Swift._HashTable {
    @inline(__always) get {
      return _storage._hashTable
    }
  }
  @inlinable internal var age: Swift.Int32 {
    @inline(__always) get {
      return _storage._age
    }
  }
  @inlinable internal var _keys: Swift.UnsafeMutablePointer<Key> {
    get {
    return _storage._rawKeys.assumingMemoryBound(to: Key.self)
  }
  }
  @inlinable internal var _values: Swift.UnsafeMutablePointer<Value> {
    get {
    return _storage._rawValues.assumingMemoryBound(to: Value.self)
  }
  }
  @inlinable @inline(__always) internal func invalidateIndices() {
    _storage._age &+= 1
  }
}
extension Swift._NativeDictionary {
  @inlinable @inline(__always) internal func uncheckedKey(at bucket: Swift._NativeDictionary<Key, Value>.Bucket) -> Key {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isOccupied(bucket))
    return _keys[bucket.offset]
  }
  @inlinable @inline(__always) internal func uncheckedValue(at bucket: Swift._NativeDictionary<Key, Value>.Bucket) -> Value {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isOccupied(bucket))
    return _values[bucket.offset]
  }
  @inlinable @inline(__always) internal func uncheckedInitialize(at bucket: Swift._NativeDictionary<Key, Value>.Bucket, toKey key: __owned Key, value: __owned Value) {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isValid(bucket))
    (_keys + bucket.offset).initialize(to: key)
    (_values + bucket.offset).initialize(to: value)
  }
  @inlinable @inline(__always) internal func uncheckedDestroy(at bucket: Swift._NativeDictionary<Key, Value>.Bucket) {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isValid(bucket))
    (_keys + bucket.offset).deinitialize(count: 1)
    (_values + bucket.offset).deinitialize(count: 1)
  }
}
extension Swift._NativeDictionary {
  @inlinable @inline(__always) internal func hashValue(for key: Key) -> Swift.Int {
    return key._rawHashValue(seed: _storage._seed)
  }
  @inlinable @inline(__always) internal func find(_ key: Key) -> (bucket: Swift._NativeDictionary<Key, Value>.Bucket, found: Swift.Bool) {
    return _storage.find(key)
  }
  @inlinable @inline(__always) internal func find(_ key: Key, hashValue: Swift.Int) -> (bucket: Swift._NativeDictionary<Key, Value>.Bucket, found: Swift.Bool) {
    return _storage.find(key, hashValue: hashValue)
  }
}
extension Swift._NativeDictionary {
  @_alwaysEmitIntoClient @inline(never) internal mutating func _copyOrMoveAndResize(capacity: Swift.Int, moveElements: Swift.Bool) {
    let capacity = Swift.max(capacity, self.capacity)
    let newStorage = _DictionaryStorage<Key, Value>.resize(
      original: _storage,
      capacity: capacity,
      move: moveElements)
    let result = _NativeDictionary(newStorage)
    if count > 0 {
      for bucket in hashTable {
        let key: Key
        let value: Value
        if moveElements {
          key = (_keys + bucket.offset).move()
          value = (_values + bucket.offset).move()
        } else {
          key = self.uncheckedKey(at: bucket)
          value = self.uncheckedValue(at: bucket)
        }
        result._unsafeInsertNew(key: key, value: value)
      }
      if moveElements {
         
         
        _storage._hashTable.clear()
        _storage._count = 0
      }
    }
    _storage = result._storage
  }
  @inlinable internal mutating func resize(capacity: Swift.Int) {
    _copyOrMoveAndResize(capacity: capacity, moveElements: true)
  }
  @inlinable internal mutating func copyAndResize(capacity: Swift.Int) {
    _copyOrMoveAndResize(capacity: capacity, moveElements: false)
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") internal mutating func copy() {
    let newStorage = _DictionaryStorage<Key, Value>.copy(original: _storage)
    _internalInvariant(newStorage._scale == _storage._scale)
    _internalInvariant(newStorage._age == _storage._age)
    _internalInvariant(newStorage._seed == _storage._seed)
    let result = _NativeDictionary(newStorage)
    if count > 0 {
      result.hashTable.copyContents(of: hashTable)
      result._storage._count = self.count
      for bucket in hashTable {
        let key = uncheckedKey(at: bucket)
        let value = uncheckedValue(at: bucket)
        result.uncheckedInitialize(at: bucket, toKey: key, value: value)
      }
    }
    _storage = result._storage
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") internal mutating func ensureUnique(isUnique: Swift.Bool, capacity: Swift.Int) -> Swift.Bool {
    if _fastPath(capacity <= self.capacity && isUnique) {
      return false
    }
    if isUnique {
      resize(capacity: capacity)
      return true
    }
    if capacity <= self.capacity {
      copy()
      return false
    }
    copyAndResize(capacity: capacity)
    return true
  }
}
extension Swift._NativeDictionary {
  @inlinable @inline(__always) internal func validatedBucket(for index: Swift._HashTable.Index) -> Swift._NativeDictionary<Key, Value>.Bucket {
    _precondition(hashTable.isOccupied(index.bucket) && index.age == age,
      "Attempting to access Dictionary elements using an invalid index")
    return index.bucket
  }
  @inlinable @inline(__always) internal func validatedBucket(for index: Swift.Dictionary<Key, Value>.Index) -> Swift._NativeDictionary<Key, Value>.Bucket {
    guard index._isNative else {
      index._cocoaPath()
       
       
       
      let cocoa = index._asCocoa
      if cocoa.age == self.age {
        let key = _forceBridgeFromObjectiveC(cocoa.key, Key.self)
        let (bucket, found) = find(key)
        if found {
          return bucket
        }
      }
      _preconditionFailure(
        "Attempting to access Dictionary elements using an invalid index")
    }
    return validatedBucket(for: index._asNative)
  }
}
extension Swift._NativeDictionary {
  @usableFromInline
  internal typealias Index = Swift.Dictionary<Key, Value>.Index
  @inlinable internal var startIndex: Swift._NativeDictionary<Key, Value>.Index {
    get {
    let bucket = hashTable.startBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  }
  @inlinable internal var endIndex: Swift._NativeDictionary<Key, Value>.Index {
    get {
    let bucket = hashTable.endBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  }
  @inlinable internal func index(after index: Swift._NativeDictionary<Key, Value>.Index) -> Swift._NativeDictionary<Key, Value>.Index {
    guard _fastPath(index._isNative) else {
      let _ = validatedBucket(for: index)
      let i = index._asCocoa
      return Index(_cocoa: i.dictionary.index(after: i))
    }
    let bucket = validatedBucket(for: index._asNative)
    let next = hashTable.occupiedBucket(after: bucket)
    return Index(_native: _HashTable.Index(bucket: next, age: age))
  }
  @inlinable internal func index(forKey key: Key) -> Swift._NativeDictionary<Key, Value>.Index? {
    if count == 0 {
       
      return nil
    }
    let (bucket, found) = find(key)
    guard found else { return nil }
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  @inlinable internal var count: Swift.Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._count)
    }
  }
  @inlinable @inline(__always) internal func contains(_ key: Key) -> Swift.Bool {
    if count == 0 {
       
      return false
    }
    return find(key).found
  }
  @inlinable @inline(__always) internal func lookup(_ key: Key) -> Value? {
    if count == 0 {
       
      return nil
    }
    let (bucket, found) = self.find(key)
    guard found else { return nil }
    return self.uncheckedValue(at: bucket)
  }
  @inlinable @inline(__always) internal func lookup(_ index: Swift._NativeDictionary<Key, Value>.Index) -> (key: Key, value: Value) {
    let bucket = validatedBucket(for: index)
    let key = self.uncheckedKey(at: bucket)
    let value = self.uncheckedValue(at: bucket)
    return (key, value)
  }
  @inlinable @inline(__always) internal func key(at index: Swift._NativeDictionary<Key, Value>.Index) -> Key {
    let bucket = validatedBucket(for: index)
    return self.uncheckedKey(at: bucket)
  }
  @inlinable @inline(__always) internal func value(at index: Swift._NativeDictionary<Key, Value>.Index) -> Value {
    let bucket = validatedBucket(for: index)
    return self.uncheckedValue(at: bucket)
  }
}
extension Swift._NativeDictionary {
  @inlinable internal subscript(key: Key, isUnique isUnique: Swift.Bool) -> Value? {
    @inline(__always) get {
       
      return lookup(key)
    }
    @inline(__always) _modify {
      let (bucket, found) = mutatingFind(key, isUnique: isUnique)
       
       
      var value: Value? = (found ? (_values + bucket.offset).move() : nil)
      defer {
         
         
        if let value = value {
          if found {
             
            (_values + bucket.offset).initialize(to: value)
          } else {
             
             
            _insert(at: bucket, key: key, value: value)
          }
        } else {
          if found {
             
             
            (_keys + bucket.offset).deinitialize(count: 1)
            _delete(at: bucket)
          } else {
             
          }
        }
      }
      yield &value
    }
  }
}
@usableFromInline
@inline(never) internal func KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_ keyType: any Any.Type) -> Swift.Never
extension Swift._NativeDictionary {
  @inlinable internal func _unsafeInsertNew(key: __owned Key, value: __owned Value) {
    _internalInvariant(count + 1 <= capacity)
    let hashValue = self.hashValue(for: key)
    if _isDebugAssertConfiguration() {
       
       
       
       
      let (bucket, found) = find(key, hashValue: hashValue)
      guard !found else {
        #if !$Embedded
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(Key.self)
        #else
        fatalError("duplicate keys in a Dictionary")
        #endif
      }
      hashTable.insert(bucket)
      uncheckedInitialize(at: bucket, toKey: key, value: value)
    } else {
      let bucket = hashTable.insertNew(hashValue: hashValue)
      uncheckedInitialize(at: bucket, toKey: key, value: value)
    }
    _storage._count &+= 1
  }
  @_alwaysEmitIntoClient @inlinable internal mutating func _unsafeUpdate(key: __owned Key, value: __owned Value) {
    let (bucket, found) = find(key)
    if found {
       
       
       
       
      (_keys + bucket.offset).pointee = key
      (_values + bucket.offset).pointee = value
    } else {
      _precondition(count < capacity)
      _insert(at: bucket, key: key, value: value)
    }
  }
  @inlinable internal mutating func insertNew(key: __owned Key, value: __owned Value) {
    _ = ensureUnique(isUnique: true, capacity: count + 1)
    _unsafeInsertNew(key: key, value: value)
  }
  @inlinable internal mutating func mutatingFind(_ key: Key, isUnique: Swift.Bool) -> (bucket: Swift._NativeDictionary<Key, Value>.Bucket, found: Swift.Bool) {
    let (bucket, found) = find(key)

     
     
     
     
     
    let rehashed = ensureUnique(
      isUnique: isUnique,
      capacity: count + (found ? 0 : 1))
    guard rehashed else { return (bucket, found) }
    let (b, f) = find(key)
    if f != found {
      #if !$Embedded
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(Key.self)
      #else
      fatalError("duplicate keys in a Dictionary")
      #endif
    }
    return (b, found)
  }
  @inlinable internal func _insert(at bucket: Swift._NativeDictionary<Key, Value>.Bucket, key: __owned Key, value: __owned Value) {
    _internalInvariant(count < capacity)
    hashTable.insert(bucket)
    uncheckedInitialize(at: bucket, toKey: key, value: value)
    _storage._count += 1
  }
  @inlinable internal mutating func updateValue(_ value: __owned Value, forKey key: Key, isUnique: Swift.Bool) -> Value? {
    let (bucket, found) = mutatingFind(key, isUnique: isUnique)
    if found {
      let oldValue = (_values + bucket.offset).move()
      (_values + bucket.offset).initialize(to: value)
      return oldValue
    }
    _insert(at: bucket, key: key, value: value)
    return nil
  }
  @inlinable internal mutating func setValue(_ value: __owned Value, forKey key: Key, isUnique: Swift.Bool) {
    let (bucket, found) = mutatingFind(key, isUnique: isUnique)
    if found {
      (_values + bucket.offset).pointee = value
    } else {
      _insert(at: bucket, key: key, value: value)
    }
  }
}
extension Swift._NativeDictionary {
  @inlinable @inline(__always) internal mutating func swapValuesAt(_ a: Swift._NativeDictionary<Key, Value>.Bucket, _ b: Swift._NativeDictionary<Key, Value>.Bucket, isUnique: Swift.Bool) {
    let rehashed = ensureUnique(isUnique: isUnique, capacity: capacity)
    _internalInvariant(!rehashed)
    _internalInvariant(hashTable.isOccupied(a) && hashTable.isOccupied(b))
    let value = (_values + a.offset).move()
    (_values + a.offset).moveInitialize(from: _values + b.offset, count: 1)
    (_values + b.offset).initialize(to: value)
  }
  @_alwaysEmitIntoClient internal func extractDictionary(using bitset: Swift._UnsafeBitset, count: Swift.Int) -> Swift._NativeDictionary<Key, Value> {
    var count = count
    if count == 0 { return _NativeDictionary<Key, Value>() }
    if count == self.count { return self }
    let result = _NativeDictionary<Key, Value>(capacity: count)
    for offset in bitset {
      let key = self.uncheckedKey(at: Bucket(offset: offset))
      let value = self.uncheckedValue(at: Bucket(offset: offset))
      result._unsafeInsertNew(key: key, value: value)
       
       
      count -= 1
      if count == 0 { break }
    }
    return result
  }
}
extension Swift._NativeDictionary where Value : Swift.Equatable {
  @inlinable @inline(__always) internal func isEqual(to other: Swift._NativeDictionary<Key, Value>) -> Swift.Bool {
    if self._storage === other._storage { return true }
    if self.count != other.count { return false }

    for (key, value) in self {
      let (bucket, found) = other.find(key)
      guard found, other.uncheckedValue(at: bucket) == value else {
        return false
      }
    }
    return true
  }
  @inlinable internal func isEqual(to other: Swift.__CocoaDictionary) -> Swift.Bool {
    if self.count != other.count { return false }

    defer { _fixLifetime(self) }
    for bucket in self.hashTable {
      let key = self.uncheckedKey(at: bucket)
      let value = self.uncheckedValue(at: bucket)
      guard
        let cocoaValue = other.lookup(_bridgeAnythingToObjectiveC(key)),
        value == _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      else {
        return false
      }
    }
    return true
  }
}
extension Swift._NativeDictionary : Swift._HashTableDelegate {
  @inlinable @inline(__always) internal func hashValue(at bucket: Swift._NativeDictionary<Key, Value>.Bucket) -> Swift.Int {
    return hashValue(for: uncheckedKey(at: bucket))
  }
  @inlinable @inline(__always) internal func moveEntry(from source: Swift._NativeDictionary<Key, Value>.Bucket, to target: Swift._NativeDictionary<Key, Value>.Bucket) {
    _internalInvariant(hashTable.isValid(source))
    _internalInvariant(hashTable.isValid(target))
    (_keys + target.offset)
      .moveInitialize(from: _keys + source.offset, count: 1)
    (_values + target.offset)
      .moveInitialize(from: _values + source.offset, count: 1)
  }
  @inlinable @inline(__always) internal func swapEntry(_ left: Swift._NativeDictionary<Key, Value>.Bucket, with right: Swift._NativeDictionary<Key, Value>.Bucket) {
    _internalInvariant(hashTable.isValid(left))
    _internalInvariant(hashTable.isValid(right))
    swap(&_keys[left.offset], &_keys[right.offset])
    swap(&_values[left.offset], &_values[right.offset])
  }
}
extension Swift._NativeDictionary {
  @inlinable @_effects(releasenone) @_semantics("optimize.sil.specialize.generic.size.never") internal func _delete(at bucket: Swift._NativeDictionary<Key, Value>.Bucket) {
    hashTable.delete(at: bucket, with: self)
    _storage._count -= 1
    _internalInvariant(_storage._count >= 0)
    invalidateIndices()
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") internal mutating func uncheckedRemove(at bucket: Swift._NativeDictionary<Key, Value>.Bucket, isUnique: Swift.Bool) -> Swift._NativeDictionary<Key, Value>.Element {
    _internalInvariant(hashTable.isOccupied(bucket))
    let rehashed = ensureUnique(isUnique: isUnique, capacity: capacity)
    _internalInvariant(!rehashed)
    let oldKey = (_keys + bucket.offset).move()
    let oldValue = (_values + bucket.offset).move()
    _delete(at: bucket)
    return (oldKey, oldValue)
  }
  @usableFromInline
  internal mutating func removeAll(isUnique: Swift.Bool)
}
extension Swift._NativeDictionary {
  @inlinable internal func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> Swift._NativeDictionary<Key, T> {
    let resultStorage = _DictionaryStorage<Key, T>.copy(original: _storage)
    _internalInvariant(resultStorage._seed == _storage._seed)
    let result = _NativeDictionary<Key, T>(resultStorage)
     
     
     
    for bucket in hashTable {
      let key = self.uncheckedKey(at: bucket)
      let value = self.uncheckedValue(at: bucket)
      try result._insert(at: bucket, key: key, value: transform(value))
    }
    return result
  }
  @inlinable internal mutating func merge<S>(_ keysAndValues: __owned S, isUnique: Swift.Bool, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    var isUnique = isUnique
    for (key, value) in keysAndValues {
      let (bucket, found) = mutatingFind(key, isUnique: isUnique)
      isUnique = true
      if found {
        do {
          let newValue = try combine(uncheckedValue(at: bucket), value)
          _values[bucket.offset] = newValue
        } catch _MergeError.keyCollision {
          #if !$Embedded
          fatalError("Duplicate values for key: '\(key)'")
          #else
          fatalError("Duplicate values for a key in a Dictionary")
          #endif
        }
      } else {
        _insert(at: bucket, key: key, value: value)
      }
    }
  }
  @inlinable @inline(__always) internal init<S>(grouping values: __owned S, by keyForValue: (S.Element) throws -> Key) rethrows where Value == [S.Element], S : Swift.Sequence {
    self.init()
    for value in values {
      let key = try keyForValue(value)
      let (bucket, found) = mutatingFind(key, isUnique: true)
      if found {
        _values[bucket.offset].append(value)
      } else {
        _insert(at: bucket, key: key, value: [value])
      }
    }
  }
  @_alwaysEmitIntoClient internal func filter(_ isIncluded: (Swift._NativeDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows -> Swift._NativeDictionary<Key, Value> {
    try _UnsafeBitset.withTemporaryBitset(
      capacity: _storage._bucketCount
    ) { bitset in
      var count = 0
      for bucket in hashTable {
        if try isIncluded(
          (uncheckedKey(at: bucket), uncheckedValue(at: bucket))
        ) {
          bitset.uncheckedInsert(bucket.offset)
          count += 1
        }
      }
      return extractDictionary(using: bitset, count: count)
    }
  }
}
extension Swift._NativeDictionary : Swift.Sequence {
  @usableFromInline
  @frozen internal struct Iterator {
    @usableFromInline
    internal let base: Swift._NativeDictionary<Key, Value>
    @usableFromInline
    internal var iterator: Swift._HashTable.Iterator
    @inlinable @inline(__always) internal init(_ base: __owned Swift._NativeDictionary<Key, Value>) {
      self.base = base
      self.iterator = base.hashTable.makeIterator()
    }
  }
  @inlinable internal __consuming func makeIterator() -> Swift._NativeDictionary<Key, Value>.Iterator {
    return Iterator(self)
  }
}
@available(*, unavailable)
extension Swift._NativeDictionary.Iterator : Swift.Sendable {
}
extension Swift._NativeDictionary.Iterator : Swift.IteratorProtocol {
  @usableFromInline
  internal typealias Element = (key: Key, value: Value)
  @inlinable @inline(__always) internal mutating func nextKey() -> Key? {
    guard let index = iterator.next() else { return nil }
    return base.uncheckedKey(at: index)
  }
  @inlinable @inline(__always) internal mutating func nextValue() -> Value? {
    guard let index = iterator.next() else { return nil }
    return base.uncheckedValue(at: index)
  }
  @inlinable @inline(__always) internal mutating func next() -> Swift._NativeDictionary<Key, Value>.Iterator.Element? {
    guard let index = iterator.next() else { return nil }
    let key = base.uncheckedKey(at: index)
    let value = base.uncheckedValue(at: index)
    return (key, value)
  }
}
@usableFromInline
@frozen internal struct _NativeSet<Element> where Element : Swift.Hashable {
  @usableFromInline
  internal var _storage: Swift.__RawSetStorage
  @inlinable @inline(__always) internal init() {
    self._storage = __RawSetStorage.empty
  }
  @inlinable @inline(__always) internal init(_ storage: __owned Swift.__RawSetStorage) {
    self._storage = storage
  }
  @inlinable internal init(capacity: Swift.Int) {
    if capacity == 0 {
      self._storage = __RawSetStorage.empty
    } else {
      self._storage = _SetStorage<Element>.allocate(capacity: capacity)
    }
  }
  @inlinable internal init(_ cocoa: __owned Swift.__CocoaSet) {
    self.init(cocoa, capacity: cocoa.count)
  }
  @inlinable internal init(_ cocoa: __owned Swift.__CocoaSet, capacity: Swift.Int) {
    if capacity == 0 {
      self._storage = __RawSetStorage.empty
    } else {
      _internalInvariant(cocoa.count <= capacity)
      self._storage = _SetStorage<Element>.convert(cocoa, capacity: capacity)
      for element in cocoa {
        let nativeElement = _forceBridgeFromObjectiveC(element, Element.self)
        insertNew(nativeElement, isUnique: true)
      }
    }
  }
}
@available(*, unavailable)
extension Swift._NativeSet : Swift.Sendable {
}
extension Swift._NativeSet {
  @usableFromInline
  internal typealias Bucket = Swift._HashTable.Bucket
  @inlinable internal var capacity: Swift.Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._capacity)
    }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var bucketCount: Swift.Int {
    get {
    _assumeNonNegative(_storage._bucketCount)
  }
  }
  @inlinable internal var hashTable: Swift._HashTable {
    @inline(__always) get {
      return _storage._hashTable
    }
  }
  @inlinable internal var age: Swift.Int32 {
    @inline(__always) get {
      return _storage._age
    }
  }
  @inlinable internal var _elements: Swift.UnsafeMutablePointer<Element> {
    get {
    return _storage._rawElements.assumingMemoryBound(to: Element.self)
  }
  }
  @inlinable @inline(__always) internal func invalidateIndices() {
    _storage._age &+= 1
  }
}
extension Swift._NativeSet {
  @inlinable @inline(__always) internal func uncheckedElement(at bucket: Swift._NativeSet<Element>.Bucket) -> Element {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isOccupied(bucket))
    return _elements[bucket.offset]
  }
  @inlinable @inline(__always) internal func uncheckedInitialize(at bucket: Swift._NativeSet<Element>.Bucket, to element: __owned Element) {
    _internalInvariant(hashTable.isValid(bucket))
    (_elements + bucket.offset).initialize(to: element)
  }
  @_alwaysEmitIntoClient @inlinable @inline(__always) internal func uncheckedAssign(at bucket: Swift._NativeSet<Element>.Bucket, to element: __owned Element) {
    _internalInvariant(hashTable.isOccupied(bucket))
    (_elements + bucket.offset).pointee = element
  }
}
extension Swift._NativeSet {
  @inlinable @inline(__always) internal func hashValue(for element: Element) -> Swift.Int {
    return element._rawHashValue(seed: _storage._seed)
  }
  @inlinable @inline(__always) internal func find(_ element: Element) -> (bucket: Swift._NativeSet<Element>.Bucket, found: Swift.Bool) {
    return find(element, hashValue: self.hashValue(for: element))
  }
  @inlinable @inline(__always) internal func find(_ element: Element, hashValue: Swift.Int) -> (bucket: Swift._NativeSet<Element>.Bucket, found: Swift.Bool) {
    let hashTable = self.hashTable
    var bucket = hashTable.idealBucket(forHashValue: hashValue)
    while hashTable._isOccupied(bucket) {
      if uncheckedElement(at: bucket) == element {
        return (bucket, true)
      }
      bucket = hashTable.bucket(wrappedAfter: bucket)
    }
    return (bucket, false)
  }
}
extension Swift._NativeSet {
  @inlinable internal mutating func resize(capacity: Swift.Int) {
    let capacity = Swift.max(capacity, self.capacity)
    let result = _NativeSet(_SetStorage<Element>.resize(
        original: _storage,
        capacity: capacity,
        move: true))
    if count > 0 {
      for bucket in hashTable {
        let element = (self._elements + bucket.offset).move()
        result._unsafeInsertNew(element)
      }
       
       
      _storage._hashTable.clear()
      _storage._count = 0
    }
    _storage = result._storage
  }
  @inlinable internal mutating func copyAndResize(capacity: Swift.Int) {
    let capacity = Swift.max(capacity, self.capacity)
    let result = _NativeSet(_SetStorage<Element>.resize(
        original: _storage,
        capacity: capacity,
        move: false))
    if count > 0 {
      for bucket in hashTable {
        result._unsafeInsertNew(self.uncheckedElement(at: bucket))
      }
    }
    _storage = result._storage
  }
  @inlinable internal mutating func copy() {
    let newStorage = _SetStorage<Element>.copy(original: _storage)
    _internalInvariant(newStorage._scale == _storage._scale)
    _internalInvariant(newStorage._age == _storage._age)
    _internalInvariant(newStorage._seed == _storage._seed)
    let result = _NativeSet(newStorage)
    if count > 0 {
      result.hashTable.copyContents(of: hashTable)
      result._storage._count = self.count
      for bucket in hashTable {
        let element = uncheckedElement(at: bucket)
        result.uncheckedInitialize(at: bucket, to: element)
      }
    }
    _storage = result._storage
  }
  @inlinable @inline(__always) internal mutating func ensureUnique(isUnique: Swift.Bool, capacity: Swift.Int) -> Swift.Bool {
    if _fastPath(capacity <= self.capacity && isUnique) {
      return false
    }
    if isUnique {
      resize(capacity: capacity)
      return true
    }
    if capacity <= self.capacity {
      copy()
      return false
    }
    copyAndResize(capacity: capacity)
    return true
  }
}
extension Swift._NativeSet {
  @inlinable @inline(__always) internal func validatedBucket(for index: Swift._HashTable.Index) -> Swift._NativeSet<Element>.Bucket {
    _precondition(hashTable.isOccupied(index.bucket) && index.age == age,
      "Attempting to access Set elements using an invalid index")
    return index.bucket
  }
  @inlinable @inline(__always) internal func validatedBucket(for index: Swift.Set<Element>.Index) -> Swift._NativeSet<Element>.Bucket {
    guard index._isNative else {
      index._cocoaPath()
      let cocoa = index._asCocoa
       
       
      if cocoa.age == self.age {
        let element = _forceBridgeFromObjectiveC(cocoa.element, Element.self)
        let (bucket, found) = find(element)
        if found {
          return bucket
        }
      }
      _preconditionFailure(
        "Attempting to access Set elements using an invalid index")
    }
    return validatedBucket(for: index._asNative)
  }
}
extension Swift._NativeSet {
  @usableFromInline
  internal typealias Index = Swift.Set<Element>.Index
  @inlinable internal var startIndex: Swift._NativeSet<Element>.Index {
    get {
    let bucket = hashTable.startBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  }
  @inlinable internal var endIndex: Swift._NativeSet<Element>.Index {
    get {
    let bucket = hashTable.endBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  }
  @inlinable internal func index(after index: Swift._NativeSet<Element>.Index) -> Swift._NativeSet<Element>.Index {
     
    let bucket = validatedBucket(for: index._asNative)
    let next = hashTable.occupiedBucket(after: bucket)
    return Index(_native: _HashTable.Index(bucket: next, age: age))
  }
  @inlinable @inline(__always) internal func index(for element: Element) -> Swift._NativeSet<Element>.Index? {
    if count == 0 {
       
      return nil
    }
    let (bucket, found) = find(element)
    guard found else { return nil }
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  @inlinable internal var count: Swift.Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._count)
    }
  }
  @inlinable @inline(__always) internal func contains(_ member: Element) -> Swift.Bool {
     
    if count == 0 { return false }
    return find(member).found
  }
  @inlinable @inline(__always) internal func element(at index: Swift._NativeSet<Element>.Index) -> Element {
    let bucket = validatedBucket(for: index)
    return uncheckedElement(at: bucket)
  }
}
@usableFromInline
@inline(never) internal func ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_ elementType: any Any.Type) -> Swift.Never
extension Swift._NativeSet {
  @inlinable internal func _unsafeInsertNew(_ element: __owned Element) {
    _internalInvariant(count + 1 <= capacity)
    let hashValue = self.hashValue(for: element)
    if _isDebugAssertConfiguration() {
       
       
       
       
      let (bucket, found) = find(element, hashValue: hashValue)
      guard !found else {
        #if !$Embedded
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(Element.self)
        #else
        fatalError("duplicate elements in a Set")
        #endif
      }
      hashTable.insert(bucket)
      uncheckedInitialize(at: bucket, to: element)
    } else {
      let bucket = hashTable.insertNew(hashValue: hashValue)
      uncheckedInitialize(at: bucket, to: element)
    }
    _storage._count &+= 1
  }
  @inlinable internal mutating func insertNew(_ element: __owned Element, isUnique: Swift.Bool) {
    _ = ensureUnique(isUnique: isUnique, capacity: count + 1)
    _unsafeInsertNew(element)
  }
  @inlinable internal func _unsafeInsertNew(_ element: __owned Element, at bucket: Swift._NativeSet<Element>.Bucket) {
    hashTable.insert(bucket)
    uncheckedInitialize(at: bucket, to: element)
    _storage._count += 1
  }
  @inlinable internal mutating func insertNew(_ element: __owned Element, at bucket: Swift._NativeSet<Element>.Bucket, isUnique: Swift.Bool) {
    _internalInvariant(!hashTable.isOccupied(bucket))
    var bucket = bucket
    let rehashed = ensureUnique(isUnique: isUnique, capacity: count + 1)
    if rehashed {
      let (b, f) = find(element)
      if f {
        #if !$Embedded
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(Element.self)
        #else
        fatalError("duplicate elements in a Set")
        #endif
      }
      bucket = b
    }
    _unsafeInsertNew(element, at: bucket)
  }
  @inlinable internal mutating func update(with element: __owned Element, isUnique: Swift.Bool) -> Element? {
    var (bucket, found) = find(element)
    let rehashed = ensureUnique(
      isUnique: isUnique,
      capacity: count + (found ? 0 : 1))
    if rehashed {
      let (b, f) = find(element)
      if f != found {
        #if !$Embedded
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(Element.self)
        #else
        fatalError("duplicate elements in a Set")
        #endif
      }
      bucket = b
    }
    if found {
      let old = (_elements + bucket.offset).move()
      uncheckedInitialize(at: bucket, to: element)
      return old
    }
    _unsafeInsertNew(element, at: bucket)
    return nil
  }
  @_alwaysEmitIntoClient @inlinable internal mutating func _unsafeUpdate(with element: __owned Element) {
    let (bucket, found) = find(element)
    if found {
      uncheckedAssign(at: bucket, to: element)
    } else {
      _precondition(count < capacity)
      _unsafeInsertNew(element, at: bucket)
    }
  }
}
extension Swift._NativeSet {
  @inlinable @inline(__always) internal func isEqual(to other: Swift._NativeSet<Element>) -> Swift.Bool {
    if self._storage === other._storage { return true }
    if self.count != other.count { return false }

    for member in self {
      guard other.find(member).found else { return false }
    }
    return true
  }
  @inlinable internal func isEqual(to other: Swift.__CocoaSet) -> Swift.Bool {
    if self.count != other.count { return false }

    defer { _fixLifetime(self) }
    for bucket in self.hashTable {
      let key = self.uncheckedElement(at: bucket)
      let bridgedKey = _bridgeAnythingToObjectiveC(key)
      guard other.contains(bridgedKey) else { return false }
    }
    return true
  }
}
extension Swift._NativeSet : Swift._HashTableDelegate {
  @inlinable @inline(__always) internal func hashValue(at bucket: Swift._NativeSet<Element>.Bucket) -> Swift.Int {
    return hashValue(for: uncheckedElement(at: bucket))
  }
  @inlinable @inline(__always) internal func moveEntry(from source: Swift._NativeSet<Element>.Bucket, to target: Swift._NativeSet<Element>.Bucket) {
    (_elements + target.offset)
      .moveInitialize(from: _elements + source.offset, count: 1)
  }
}
extension Swift._NativeSet {
  @inlinable @_effects(releasenone) internal mutating func _delete(at bucket: Swift._NativeSet<Element>.Bucket) {
    hashTable.delete(at: bucket, with: self)
    _storage._count -= 1
    _internalInvariant(_storage._count >= 0)
    invalidateIndices()
  }
  @inlinable @inline(__always) internal mutating func uncheckedRemove(at bucket: Swift._NativeSet<Element>.Bucket, isUnique: Swift.Bool) -> Element {
    _internalInvariant(hashTable.isOccupied(bucket))
    let rehashed = ensureUnique(isUnique: isUnique, capacity: capacity)
    _internalInvariant(!rehashed)
    let old = (_elements + bucket.offset).move()
    _delete(at: bucket)
    return old
  }
  @usableFromInline
  internal mutating func removeAll(isUnique: Swift.Bool)
}
extension Swift._NativeSet : Swift.Sequence {
  @usableFromInline
  @frozen internal struct Iterator {
    @usableFromInline
    internal let base: Swift._NativeSet<Element>
    @usableFromInline
    internal var iterator: Swift._HashTable.Iterator
    @inlinable @inline(__always) internal init(_ base: __owned Swift._NativeSet<Element>) {
      self.base = base
      self.iterator = base.hashTable.makeIterator()
    }
  }
  @inlinable @inline(__always) internal __consuming func makeIterator() -> Swift._NativeSet<Element>.Iterator {
    return Iterator(self)
  }
}
@available(*, unavailable)
extension Swift._NativeSet.Iterator : Swift.Sendable {
}
extension Swift._NativeSet.Iterator : Swift.IteratorProtocol {
  @inlinable @inline(__always) internal mutating func next() -> Element? {
    guard let index = iterator.next() else { return nil }
    return base.uncheckedElement(at: index)
  }
}
extension Swift._NativeSet {
  @_alwaysEmitIntoClient internal func isSubset<S>(of possibleSuperset: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    _UnsafeBitset.withTemporaryBitset(capacity: self.bucketCount) { seen in
       
      var seenCount = 0
      for element in possibleSuperset {
        let (bucket, found) = find(element)
        guard found else { continue }
        let inserted = seen.uncheckedInsert(bucket.offset)
        if inserted {
          seenCount += 1
          if seenCount == self.count {
            return true
          }
        }
      }
      return false
    }
  }
  @_alwaysEmitIntoClient internal func isStrictSubset<S>(of possibleSuperset: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    _UnsafeBitset.withTemporaryBitset(capacity: self.bucketCount) { seen in
       
      var seenCount = 0
      var isStrict = false
      for element in possibleSuperset {
        let (bucket, found) = find(element)
        guard found else {
          if !isStrict {
            isStrict = true
            if seenCount == self.count { return true }
          }
          continue
        }
        let inserted = seen.uncheckedInsert(bucket.offset)
        if inserted {
          seenCount += 1
          if seenCount == self.count, isStrict {
            return true
          }
        }
      }
      return false
    }
  }
  @_alwaysEmitIntoClient internal func isStrictSuperset<S>(of possibleSubset: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    _UnsafeBitset.withTemporaryBitset(capacity: self.bucketCount) { seen in
       
      var seenCount = 0
      for element in possibleSubset {
        let (bucket, found) = find(element)
        guard found else { return false }
        let inserted = seen.uncheckedInsert(bucket.offset)
        if inserted {
          seenCount += 1
          if seenCount == self.count {
            return false
          }
        }
      }
      return true
    }
  }
  @_alwaysEmitIntoClient internal __consuming func extractSubset(using bitset: Swift._UnsafeBitset, count: Swift.Int) -> Swift._NativeSet<Element> {
    var count = count
    if count == 0 { return _NativeSet() }
    if count == self.count { return self }
    let result = _NativeSet(capacity: count)
    for offset in bitset {
      result._unsafeInsertNew(self.uncheckedElement(at: Bucket(offset: offset)))
       
       
      count -= 1
      if count == 0 { break }
    }
    return result
  }
  @_alwaysEmitIntoClient internal __consuming func subtracting<S>(_ other: S) -> Swift._NativeSet<Element> where Element == S.Element, S : Swift.Sequence {
    guard count > 0 else { return _NativeSet() }

     
    var it = other.makeIterator()
    var bucket: Bucket? = nil
    while let next = it.next() {
      let (b, found) = find(next)
      if found {
        bucket = b
        break
      }
    }
    guard let bucket = bucket else { return self }

     
     
     
     
    return _UnsafeBitset.withTemporaryCopy(of: hashTable.bitset) { difference in
      var remainingCount = self.count

      let removed = difference.uncheckedRemove(bucket.offset)
      _internalInvariant(removed)
      remainingCount -= 1

      while let element = it.next() {
        let (bucket, found) = find(element)
        if found {
          if difference.uncheckedRemove(bucket.offset) {
            remainingCount -= 1
            if remainingCount == 0 { return _NativeSet() }
          }
        }
      }
      _internalInvariant(difference.count > 0)
      return extractSubset(using: difference, count: remainingCount)
    }
  }
  @_alwaysEmitIntoClient internal __consuming func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> Swift._NativeSet<Element> {
    try _UnsafeBitset.withTemporaryBitset(capacity: bucketCount) { bitset in
      var count = 0
      for bucket in hashTable {
        if try isIncluded(uncheckedElement(at: bucket)) {
          bitset.uncheckedInsert(bucket.offset)
          count += 1
        }
      }
      return extractSubset(using: bitset, count: count)
    }
  }
  @_alwaysEmitIntoClient internal __consuming func intersection(_ other: Swift._NativeSet<Element>) -> Swift._NativeSet<Element> {
     
     
     
     
    _UnsafeBitset.withTemporaryBitset(capacity: bucketCount) { bitset in
      var count = 0
       
       
      if self.count > other.count {
        for element in other {
          let (bucket, found) = find(element)
          if found {
             
            bitset.uncheckedInsert(bucket.offset)
            count += 1
          }
        }
      } else {
        for bucket in hashTable {
          if other.find(uncheckedElement(at: bucket)).found {
            bitset.uncheckedInsert(bucket.offset)
            count += 1
          }
        }
      }
      return extractSubset(using: bitset, count: count)
    }
  }
  @_alwaysEmitIntoClient internal __consuming func genericIntersection<S>(_ other: S) -> Swift._NativeSet<Element> where Element == S.Element, S : Swift.Sequence {
     
     
     
    _UnsafeBitset.withTemporaryBitset(capacity: bucketCount) { bitset in
      var count = 0
      for element in other {
        let (bucket, found) = find(element)
         
         
        if found, bitset.uncheckedInsert(bucket.offset) {
          count += 1
        }
      }
      return extractSubset(using: bitset, count: count)
    }
  }
}
public protocol _SwiftNewtypeWrapper : Swift.RawRepresentable, Swift._HasCustomAnyHashableRepresentation {
}
extension Swift._SwiftNewtypeWrapper where Self : Swift.Hashable, Self.RawValue : Swift.Hashable {
  @inlinable public var hashValue: Swift.Int {
    get {
    return rawValue.hashValue
  }
  }
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(rawValue)
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    return rawValue._rawHashValue(seed: seed)
  }
}
extension Swift._SwiftNewtypeWrapper {
  public __consuming func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift._SwiftNewtypeWrapper where Self : Swift.Hashable, Self.RawValue : Swift.Hashable {
  public __consuming func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift._SwiftNewtypeWrapper where Self.RawValue : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = Self.RawValue._ObjectiveCType
  @inlinable public func _bridgeToObjectiveC() -> Self.RawValue._ObjectiveCType {
    return rawValue._bridgeToObjectiveC()
  }
  @inlinable public static func _forceBridgeFromObjectiveC(_ source: Self.RawValue._ObjectiveCType, result: inout Self?) {
    var innerResult: Self.RawValue?
    Self.RawValue._forceBridgeFromObjectiveC(source, result: &innerResult)
    result = innerResult.flatMap { Self(rawValue: $0) }
  }
  @inlinable public static func _conditionallyBridgeFromObjectiveC(_ source: Self.RawValue._ObjectiveCType, result: inout Self?) -> Swift.Bool {
    var innerResult: Self.RawValue?
    let success = Self.RawValue._conditionallyBridgeFromObjectiveC(
      source,
      result: &innerResult)
    result = innerResult.flatMap { Self(rawValue: $0) }
    return success
  }
  @inlinable @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Self.RawValue._ObjectiveCType?) -> Self {
    return Self(
      rawValue: Self.RawValue._unconditionallyBridgeFromObjectiveC(source))!
  }
}
extension Swift._SwiftNewtypeWrapper where Self.RawValue : AnyObject {
  @inlinable public func _bridgeToObjectiveC() -> Self.RawValue {
    return rawValue
  }
  @inlinable public static func _forceBridgeFromObjectiveC(_ source: Self.RawValue, result: inout Self?) {
    result = Self(rawValue: source)
  }
  @inlinable public static func _conditionallyBridgeFromObjectiveC(_ source: Self.RawValue, result: inout Self?) -> Swift.Bool {
    result = Self(rawValue: source)
    return result != nil
  }
  @inlinable @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Self.RawValue?) -> Self {
    return Self(rawValue: source!)!
  }
}
@frozen public struct ObjectIdentifier : Swift.Sendable {
  @usableFromInline
  internal let _value: Builtin.RawPointer
  @inlinable public init(_ x: Swift.AnyObject) {
    self._value = Builtin.bridgeToRawPointer(x)
  }
  @inlinable public init(_ x: any Any.Type) {
    self._value = unsafeBitCast(x, to: Builtin.RawPointer.self)
  }
}
extension Swift.ObjectIdentifier : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.ObjectIdentifier : Swift.Equatable {
  @inlinable public static func == (x: Swift.ObjectIdentifier, y: Swift.ObjectIdentifier) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_RawPointer(x._value, y._value))
  }
}
extension Swift.ObjectIdentifier : Swift.Comparable {
  @inlinable public static func < (lhs: Swift.ObjectIdentifier, rhs: Swift.ObjectIdentifier) -> Swift.Bool {
    return UInt(bitPattern: lhs) < UInt(bitPattern: rhs)
  }
}
extension Swift.ObjectIdentifier : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(Int(Builtin.ptrtoint_Word(_value)))
  }
  @_alwaysEmitIntoClient public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    Int(Builtin.ptrtoint_Word(_value))._rawHashValue(seed: seed)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.UInt {
  @inlinable public init(bitPattern objectID: Swift.ObjectIdentifier) {
    self.init(Builtin.ptrtoint_Word(objectID._value))
  }
}
extension Swift.Int {
  @inlinable public init(bitPattern objectID: Swift.ObjectIdentifier) {
    self.init(bitPattern: UInt(bitPattern: objectID))
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
@frozen public enum Optional<Wrapped> : ~Swift.Copyable where Wrapped : ~Copyable {
  case none
  case some(Wrapped)
}
#else
@frozen public enum Optional<Wrapped> {
  case none
  case some(Wrapped)
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : Swift.Copyable where Wrapped : Swift.Copyable {
}
#else
extension Swift.Optional {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : Swift.Sendable where Wrapped : Swift.Sendable, Wrapped : ~Copyable {
}
#else
extension Swift.Optional : Swift.Sendable where Wrapped : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : Swift.BitwiseCopyable where Wrapped : Swift.BitwiseCopyable {
}
#else
extension Swift.Optional : Swift.BitwiseCopyable where Wrapped : Swift.BitwiseCopyable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.Optional : Swift.ExpressibleByNilLiteral where Wrapped : ~Copyable {
  @_transparent @_preInverseGenerics public init(nilLiteral: ()) {
    self = .none
  }
}
#else
extension Swift.Optional : Swift.ExpressibleByNilLiteral {
  @_transparent public init(nilLiteral: ()) {
    self = .none
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped : ~Copyable {
  @_transparent @_preInverseGenerics public init(_ some: consuming Wrapped) { self = .some(some) }
}
#else
extension Swift.Optional {
  @_transparent public init(_ some: Wrapped) { self = .some(some) }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func map<E, U>(_ transform: (Wrapped) throws(E) -> U) throws(E) -> U? where E : Swift.Error, U : ~Copyable {
    switch self {
    case .some(let y):
      return .some(try transform(y))
    case .none:
      return .none
    }
  }
  #endif
}
#else
extension Swift.Optional {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func map<E, U>(_ transform: (Wrapped) throws(E) -> U) throws(E) -> U? where E : Swift.Error {
    switch self {
    case .some(let y):
      return .some(try transform(y))
    case .none:
      return .none
    }
  }
  #endif
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped : ~Copyable {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public consuming func _consumingMap<U, E>(_ transform: (consuming Wrapped) throws(E) -> U) throws(E) -> U? where E : Swift.Error, U : ~Copyable {
    switch consume self {
    case .some(let y):
      return .some(try transform(y))
    case .none:
      return .none
    }
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public borrowing func _borrowingMap<U, E>(_ transform: (borrowing Wrapped) throws(E) -> U) throws(E) -> U? where E : Swift.Error, U : ~Copyable {
    #if compiler(>=6.0) && $NoncopyableGenerics
    switch self {
    case .some(let y):
      return .some(try transform(y))
    case .none:
      return .none
    }
    #else
    fatalError("unsupported compiler")
    #endif
  }
  #endif
}
#else
extension Swift.Optional {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public consuming func _consumingMap<U, E>(_ transform: (consuming Wrapped) throws(E) -> U) throws(E) -> U? where E : Swift.Error {
    switch consume self {
    case .some(let y):
      return .some(try transform(y))
    case .none:
      return .none
    }
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public borrowing func _borrowingMap<U, E>(_ transform: (borrowing Wrapped) throws(E) -> U) throws(E) -> U? where E : Swift.Error {
    #if compiler(>=6.0) && $NoncopyableGenerics
    switch self {
    case .some(let y):
      return .some(try transform(y))
    case .none:
      return .none
    }
    #else
    fatalError("unsupported compiler")
    #endif
  }
  #endif
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func flatMap<E, U>(_ transform: (Wrapped) throws(E) -> U?) throws(E) -> U? where E : Swift.Error, U : ~Copyable {
    switch self {
    case .some(let y):
      return try transform(y)
    case .none:
      return .none
    }
  }
  #endif
}
#else
extension Swift.Optional {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func flatMap<E, U>(_ transform: (Wrapped) throws(E) -> U?) throws(E) -> U? where E : Swift.Error {
    switch self {
    case .some(let y):
      return try transform(y)
    case .none:
      return .none
    }
  }
  #endif
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped : ~Copyable {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public consuming func _consumingFlatMap<U, E>(_ transform: (consuming Wrapped) throws(E) -> U?) throws(E) -> U? where E : Swift.Error, U : ~Copyable {
    switch consume self {
    case .some(let y):
      return try transform(consume y)
    case .none:
      return .none
    }
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func _borrowingFlatMap<U, E>(_ transform: (borrowing Wrapped) throws(E) -> U?) throws(E) -> U? where E : Swift.Error, U : ~Copyable {
    #if compiler(>=6.0) && $NoncopyableGenerics
    switch self {
    case .some(let y):
      return try transform(y)
    case .none:
      return .none
    }
    #else
    fatalError("Unsupported compiler")
    #endif
  }
  #endif
}
#else
extension Swift.Optional {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public consuming func _consumingFlatMap<U, E>(_ transform: (consuming Wrapped) throws(E) -> U?) throws(E) -> U? where E : Swift.Error {
    switch consume self {
    case .some(let y):
      return try transform(consume y)
    case .none:
      return .none
    }
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func _borrowingFlatMap<U, E>(_ transform: (borrowing Wrapped) throws(E) -> U?) throws(E) -> U? where E : Swift.Error {
    #if compiler(>=6.0) && $NoncopyableGenerics
    switch self {
    case .some(let y):
      return try transform(y)
    case .none:
      return .none
    }
    #else
    fatalError("Unsupported compiler")
    #endif
  }
  #endif
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional {
  @inlinable public var unsafelyUnwrapped: Wrapped {
    @inline(__always) get {
      if let x = self {
        return x
      }
      _debugPreconditionFailure("unsafelyUnwrapped of nil optional")
    }
  }
}
#else
extension Swift.Optional {
  @inlinable public var unsafelyUnwrapped: Wrapped {
    @inline(__always) get {
      if let x = self {
        return x
      }
      _debugPreconditionFailure("unsafelyUnwrapped of nil optional")
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped : ~Copyable {
  @_alwaysEmitIntoClient public consuming func _consumingUnsafelyUnwrap() -> Wrapped {
    switch consume self {
    case .some(let x):
      return x
    case .none:
      _debugPreconditionFailure("consumingUsafelyUnwrap of nil optional")
    }
  }
}
#else
extension Swift.Optional {
  @_alwaysEmitIntoClient public consuming func _consumingUnsafelyUnwrap() -> Wrapped {
    switch consume self {
    case .some(let x):
      return x
    case .none:
      _debugPreconditionFailure("consumingUsafelyUnwrap of nil optional")
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional {
  @inlinable internal var _unsafelyUnwrappedUnchecked: Wrapped {
    @inline(__always) get {
      if let x = self {
        return x
      }
      _internalInvariantFailure("_unsafelyUnwrappedUnchecked of nil optional")
    }
  }
}
#else
extension Swift.Optional {
  @inlinable internal var _unsafelyUnwrappedUnchecked: Wrapped {
    @inline(__always) get {
      if let x = self {
        return x
      }
      _internalInvariantFailure("_unsafelyUnwrappedUnchecked of nil optional")
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped : ~Copyable {
  @_alwaysEmitIntoClient internal consuming func _consumingUncheckedUnwrapped() -> Wrapped {
    if let x = self {
      return x
    }
    _internalInvariantFailure("_uncheckedUnwrapped of nil optional")
  }
}
#else
extension Swift.Optional {
  @_alwaysEmitIntoClient internal consuming func _consumingUncheckedUnwrapped() -> Wrapped {
    if let x = self {
      return x
    }
    _internalInvariantFailure("_uncheckedUnwrapped of nil optional")
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped : ~Copyable {
  @_alwaysEmitIntoClient public mutating func take() -> Swift.Optional<Wrapped> {
    let result = consume self
    self = nil
    return result
  }
}
#else
extension Swift.Optional {
  @_alwaysEmitIntoClient public mutating func take() -> Swift.Optional<Wrapped> {
    let result = consume self
    self = nil
    return result
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
#else
extension Swift.Optional : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
#else
extension Swift.Optional : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
#endif
@_transparent public func _diagnoseUnexpectedNilOptional(_filenameStart: Builtin.RawPointer, _filenameLength: Builtin.Word, _filenameIsASCII: Builtin.Int1, _line: Builtin.Word, _isImplicitUnwrap: Builtin.Int1) {
   
   
  if Bool(_isImplicitUnwrap) {
    _preconditionFailure(
      "Unexpectedly found nil while implicitly unwrapping an Optional value",
      file: StaticString(_start: _filenameStart,
                         utf8CodeUnitCount: _filenameLength,
                         isASCII: _filenameIsASCII),
      line: UInt(_line))
  } else {
    _preconditionFailure(
      "Unexpectedly found nil while unwrapping an Optional value",
      file: StaticString(_start: _filenameStart,
                         utf8CodeUnitCount: _filenameLength,
                         isASCII: _filenameIsASCII),
      line: UInt(_line))
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : Swift.Equatable where Wrapped : Swift.Equatable {
  @_transparent public static func == (lhs: Wrapped?, rhs: Wrapped?) -> Swift.Bool {
    switch (lhs, rhs) {
    case let (l?, r?):
      return l == r
    case (nil, nil):
      return true
    default:
      return false
    }
  }
}
#else
extension Swift.Optional : Swift.Equatable where Wrapped : Swift.Equatable {
  @_transparent public static func == (lhs: Wrapped?, rhs: Wrapped?) -> Swift.Bool {
    switch (lhs, rhs) {
    case let (l?, r?):
      return l == r
    case (nil, nil):
      return true
    default:
      return false
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : Swift.Hashable where Wrapped : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    switch self {
    case .none:
      hasher.combine(0 as UInt8)
    case .some(let wrapped):
      hasher.combine(1 as UInt8)
      hasher.combine(wrapped)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
#else
extension Swift.Optional : Swift.Hashable where Wrapped : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    switch self {
    case .none:
      hasher.combine(0 as UInt8)
    case .some(let wrapped):
      hasher.combine(1 as UInt8)
      hasher.combine(wrapped)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
#endif
@frozen public struct _OptionalNilComparisonType : Swift.ExpressibleByNilLiteral {
  @_transparent public init(nilLiteral: ()) {
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped : ~Copyable {
  @_transparent @_preInverseGenerics public static func ~= (lhs: Swift._OptionalNilComparisonType, rhs: borrowing Wrapped?) -> Swift.Bool {
    switch rhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
  @_transparent @_preInverseGenerics public static func == (lhs: borrowing Wrapped?, rhs: Swift._OptionalNilComparisonType) -> Swift.Bool {
    switch lhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
  @_transparent @_preInverseGenerics public static func != (lhs: borrowing Wrapped?, rhs: Swift._OptionalNilComparisonType) -> Swift.Bool {
    switch lhs {
    case .some:
      return true
    case .none:
      return false
    }
  }
  @_transparent @_preInverseGenerics public static func == (lhs: Swift._OptionalNilComparisonType, rhs: borrowing Wrapped?) -> Swift.Bool {
    switch rhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
  @_transparent @_preInverseGenerics public static func != (lhs: Swift._OptionalNilComparisonType, rhs: borrowing Wrapped?) -> Swift.Bool {
    switch rhs {
    case .some:
      return true
    case .none:
      return false
    }
  }
}
#else
extension Swift.Optional {
  @_transparent public static func ~= (lhs: Swift._OptionalNilComparisonType, rhs: Wrapped?) -> Swift.Bool {
    switch rhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
  @_transparent public static func == (lhs: Wrapped?, rhs: Swift._OptionalNilComparisonType) -> Swift.Bool {
    switch lhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
  @_transparent public static func != (lhs: Wrapped?, rhs: Swift._OptionalNilComparisonType) -> Swift.Bool {
    switch lhs {
    case .some:
      return true
    case .none:
      return false
    }
  }
  @_transparent public static func == (lhs: Swift._OptionalNilComparisonType, rhs: Wrapped?) -> Swift.Bool {
    switch rhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
  @_transparent public static func != (lhs: Swift._OptionalNilComparisonType, rhs: Wrapped?) -> Swift.Bool {
    switch rhs {
    case .some:
      return true
    case .none:
      return false
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_transparent @_alwaysEmitIntoClient public func ?? <T>(optional: consuming T?, defaultValue: @autoclosure () throws -> T) rethrows -> T where T : ~Copyable {
  switch consume optional {
  case .some(let value):
    return value
  case .none:
    return try defaultValue()
  }
}
#else
@_transparent @_alwaysEmitIntoClient public func ?? <T>(optional: consuming T?, defaultValue: @autoclosure () throws -> T) rethrows -> T {
  switch consume optional {
  case .some(let value):
    return value
  case .none:
    return try defaultValue()
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_transparent @_alwaysEmitIntoClient public func ?? <T>(optional: consuming T?, defaultValue: @autoclosure () throws -> T?) rethrows -> T? where T : ~Copyable {
  switch consume optional {
  case .some(let value):
    return value
  case .none:
    return try defaultValue()
  }
}
#else
@_transparent @_alwaysEmitIntoClient public func ?? <T>(optional: consuming T?, defaultValue: @autoclosure () throws -> T?) rethrows -> T? {
  switch consume optional {
  case .some(let value):
    return value
  case .none:
    return try defaultValue()
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Swift.AnyObject
  public static func _forceBridgeFromObjectiveC(_ source: Swift.AnyObject, result: inout Swift.Optional<Wrapped>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Swift.AnyObject, result: inout Swift.Optional<Wrapped>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Swift.AnyObject?) -> Swift.Optional<Wrapped>
  public typealias _ObjectiveCType = Swift.AnyObject
}
#else
extension Swift.Optional : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Swift.AnyObject
  public static func _forceBridgeFromObjectiveC(_ source: Swift.AnyObject, result: inout Swift.Optional<Wrapped>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Swift.AnyObject, result: inout Swift.Optional<Wrapped>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Swift.AnyObject?) -> Swift.Optional<Wrapped>
  public typealias _ObjectiveCType = Swift.AnyObject
}
#endif
public protocol OptionSet : Swift.RawRepresentable, Swift.SetAlgebra {
  associatedtype Element = Self
  init(rawValue: Self.RawValue)
}
extension Swift.OptionSet {
  @inlinable public func union(_ other: Self) -> Self {
    var r: Self = Self(rawValue: self.rawValue)
    r.formUnion(other)
    return r
  }
  @inlinable public func intersection(_ other: Self) -> Self {
    var r = Self(rawValue: self.rawValue)
    r.formIntersection(other)
    return r
  }
  @inlinable public func symmetricDifference(_ other: Self) -> Self {
    var r = Self(rawValue: self.rawValue)
    r.formSymmetricDifference(other)
    return r
  }
}
extension Swift.OptionSet where Self == Self.Element {
  @inlinable public func contains(_ member: Self) -> Swift.Bool {
    return self.isSuperset(of: member)
  }
  @discardableResult
  @inlinable public mutating func insert(_ newMember: Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element) {
    let oldMember = self.intersection(newMember)
    let shouldInsert = oldMember != newMember
    let result = (
      inserted: shouldInsert,
      memberAfterInsert: shouldInsert ? newMember : oldMember)
    if shouldInsert {
      self.formUnion(newMember)
    }
    return result
  }
  @discardableResult
  @inlinable public mutating func remove(_ member: Self.Element) -> Self.Element? {
    let intersectionElements = intersection(member)
    guard !intersectionElements.isEmpty else {
      return nil
    }
    
    self.subtract(member)
    return intersectionElements
  }
  @discardableResult
  @inlinable public mutating func update(with newMember: Self.Element) -> Self.Element? {
    let r = self.intersection(newMember)
    self.formUnion(newMember)
    return r.isEmpty ? nil : r
  }
}
extension Swift.OptionSet where Self.RawValue : Swift.FixedWidthInteger {
  @inlinable public init() {
    self.init(rawValue: 0)
  }
  @inlinable public mutating func formUnion(_ other: Self) {
    self = Self(rawValue: self.rawValue | other.rawValue)
  }
  @inlinable public mutating func formIntersection(_ other: Self) {
    self = Self(rawValue: self.rawValue & other.rawValue)
  }
  @inlinable public mutating func formSymmetricDifference(_ other: Self) {
    self = Self(rawValue: self.rawValue ^ other.rawValue)
  }
}
public protocol TextOutputStream {
  mutating func _lock()
  mutating func _unlock()
  mutating func write(_ string: Swift.String)
  mutating func _writeASCII(_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>)
}
extension Swift.TextOutputStream {
  public mutating func _lock()
  public mutating func _unlock()
  public mutating func _writeASCII(_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>)
}
public protocol TextOutputStreamable {
  func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
public protocol CustomStringConvertible {
  var description: Swift.String { get }
}
public protocol LosslessStringConvertible : Swift.CustomStringConvertible {
  init?(_ description: Swift.String)
}
public protocol CustomDebugStringConvertible {
  var debugDescription: Swift.String { get }
}
@usableFromInline
@_semantics("optimize.sil.specialize.generic.never") internal func _print_unlocked<T, TargetStream>(_ value: T, _ target: inout TargetStream) where TargetStream : Swift.TextOutputStream
@_semantics("optimize.sil.specialize.generic.never") @inline(never) public func _debugPrint_unlocked<T, TargetStream>(_ value: T, _ target: inout TargetStream) where TargetStream : Swift.TextOutputStream
extension Swift.String : Swift.TextOutputStream {
  public mutating func write(_ other: Swift.String)
  public mutating func _writeASCII(_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>)
}
extension Swift.String : Swift.TextOutputStreamable {
  @inlinable public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream {
    target.write(self)
  }
}
extension Swift.Character : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Swift.Unicode.Scalar : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
public var _playgroundPrintHook: ((Swift.String) -> Swift.Void)?
public typealias _CustomReflectableOrNone = Swift.CustomReflectable
public typealias _CustomDebugStringConvertibleOrNone = Swift.CustomDebugStringConvertible
#if compiler(>=5.3) && $NoncopyableGenerics
public protocol _Pointer : Swift.BitwiseCopyable, Swift.CustomDebugStringConvertible, Swift.CustomReflectable, Swift.Hashable, Swift.Strideable {
  typealias Distance = Swift.Int
  associatedtype Pointee : ~Copyable
  var _rawValue: Builtin.RawPointer { get }
  init(_ _rawValue: Builtin.RawPointer)
}
#else
public protocol _Pointer : Swift.BitwiseCopyable, Swift.CustomDebugStringConvertible, Swift.CustomReflectable, Swift.Hashable, Swift.Strideable {
  typealias Distance = Swift.Int
  associatedtype Pointee
  var _rawValue: Builtin.RawPointer { get }
  init(_ _rawValue: Builtin.RawPointer)
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift._Pointer {
  @_transparent public init(_ from: Swift.OpaquePointer) {
    self.init(from._rawValue)
  }
  @_transparent public init?(_ from: Swift.OpaquePointer?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
  @_transparent public init?(bitPattern: Swift.Int) {
    if bitPattern == 0 { return nil }
    self.init(Builtin.inttoptr_Word(bitPattern._builtinWordValue))
  }
  @_transparent public init?(bitPattern: Swift.UInt) {
    if bitPattern == 0 { return nil }
    self.init(Builtin.inttoptr_Word(bitPattern._builtinWordValue))
  }
  @_transparent public init(@_nonEphemeral _ other: Self) {
    self.init(other._rawValue)
  }
  @_transparent public init?(@_nonEphemeral _ other: Self?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped._rawValue)
  }
}
#else
extension Swift._Pointer {
  @_transparent public init(_ from: Swift.OpaquePointer) {
    self.init(from._rawValue)
  }
  @_transparent public init?(_ from: Swift.OpaquePointer?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
  @_transparent public init?(bitPattern: Swift.Int) {
    if bitPattern == 0 { return nil }
    self.init(Builtin.inttoptr_Word(bitPattern._builtinWordValue))
  }
  @_transparent public init?(bitPattern: Swift.UInt) {
    if bitPattern == 0 { return nil }
    self.init(Builtin.inttoptr_Word(bitPattern._builtinWordValue))
  }
  @_transparent public init(@_nonEphemeral _ other: Self) {
    self.init(other._rawValue)
  }
  @_transparent public init?(@_nonEphemeral _ other: Self?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped._rawValue)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift._Pointer {
  @_transparent public static func == (lhs: Self, rhs: Self) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
  @inlinable @_alwaysEmitIntoClient public static func == <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift._Pointer {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
  @inlinable @_alwaysEmitIntoClient public static func != <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift._Pointer {
    return Bool(Builtin.cmp_ne_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}
#else
extension Swift._Pointer {
  @_transparent public static func == (lhs: Self, rhs: Self) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
  @inlinable @_alwaysEmitIntoClient public static func == <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift._Pointer {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
  @inlinable @_alwaysEmitIntoClient public static func != <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift._Pointer {
    return Bool(Builtin.cmp_ne_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift._Pointer {
  @_transparent public static func < (lhs: Self, rhs: Self) -> Swift.Bool {
    return Bool(Builtin.cmp_ult_RawPointer(lhs._rawValue, rhs._rawValue))
  }
  @inlinable @_alwaysEmitIntoClient public static func < <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift._Pointer {
    return Bool(Builtin.cmp_ult_RawPointer(lhs._rawValue, rhs._rawValue))
  }
  @inlinable @_alwaysEmitIntoClient public static func <= <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift._Pointer {
    return Bool(Builtin.cmp_ule_RawPointer(lhs._rawValue, rhs._rawValue))
  }
  @inlinable @_alwaysEmitIntoClient public static func > <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift._Pointer {
    return Bool(Builtin.cmp_ugt_RawPointer(lhs._rawValue, rhs._rawValue))
  }
  @inlinable @_alwaysEmitIntoClient public static func >= <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift._Pointer {
    return Bool(Builtin.cmp_uge_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}
#else
extension Swift._Pointer {
  @_transparent public static func < (lhs: Self, rhs: Self) -> Swift.Bool {
    return Bool(Builtin.cmp_ult_RawPointer(lhs._rawValue, rhs._rawValue))
  }
  @inlinable @_alwaysEmitIntoClient public static func < <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift._Pointer {
    return Bool(Builtin.cmp_ult_RawPointer(lhs._rawValue, rhs._rawValue))
  }
  @inlinable @_alwaysEmitIntoClient public static func <= <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift._Pointer {
    return Bool(Builtin.cmp_ule_RawPointer(lhs._rawValue, rhs._rawValue))
  }
  @inlinable @_alwaysEmitIntoClient public static func > <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift._Pointer {
    return Bool(Builtin.cmp_ugt_RawPointer(lhs._rawValue, rhs._rawValue))
  }
  @inlinable @_alwaysEmitIntoClient public static func >= <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift._Pointer {
    return Bool(Builtin.cmp_uge_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift._Pointer {
  @_transparent public func successor() -> Self {
    return advanced(by: 1)
  }
  @_transparent public func predecessor() -> Self {
    return advanced(by: -1)
  }
  @_transparent public func distance(to end: Self) -> Swift.Int {
    return
      Int(Builtin.sub_Word(Builtin.ptrtoint_Word(end._rawValue),
                           Builtin.ptrtoint_Word(_rawValue)))
      / MemoryLayout<Pointee>.stride
  }
  @_transparent public func advanced(by n: Swift.Int) -> Self {
    return Self(Builtin.gep_Word(
      self._rawValue, n._builtinWordValue, Pointee.self))
  }
}
#else
extension Swift._Pointer {
  @_transparent public func successor() -> Self {
    return advanced(by: 1)
  }
  @_transparent public func predecessor() -> Self {
    return advanced(by: -1)
  }
  @_transparent public func distance(to end: Self) -> Swift.Int {
    return
      Int(Builtin.sub_Word(Builtin.ptrtoint_Word(end._rawValue),
                           Builtin.ptrtoint_Word(_rawValue)))
      / MemoryLayout<Pointee>.stride
  }
  @_transparent public func advanced(by n: Swift.Int) -> Self {
    return Self(Builtin.gep_Word(
      self._rawValue, n._builtinWordValue, Pointee.self))
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift._Pointer {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(UInt(bitPattern: self))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    return Hasher._hash(seed: seed, UInt(bitPattern: self))
  }
}
#else
extension Swift._Pointer {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(UInt(bitPattern: self))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    return Hasher._hash(seed: seed, UInt(bitPattern: self))
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift._Pointer {
  public var debugDescription: Swift.String {
    get
  }
}
#else
extension Swift._Pointer {
  public var debugDescription: Swift.String {
    get
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift._Pointer {
  public var customMirror: Swift.Mirror {
    get
  }
}
#else
extension Swift._Pointer {
  public var customMirror: Swift.Mirror {
    get
  }
}
#endif
extension Swift.Int {
  @_transparent public init<P>(bitPattern pointer: P?) where P : Swift._Pointer {
    if let pointer = pointer {
      self = Int(Builtin.ptrtoint_Word(pointer._rawValue))
    } else {
      self = 0
    }
  }
}
extension Swift.UInt {
  @_transparent public init<P>(bitPattern pointer: P?) where P : Swift._Pointer {
    if let pointer = pointer {
      self = UInt(Builtin.ptrtoint_Word(pointer._rawValue))
    } else {
      self = 0
    }
  }
}
extension Swift.Strideable where Self : Swift._Pointer {
  @_transparent public static func + (@_nonEphemeral lhs: Self, rhs: Self.Stride) -> Self {
    return lhs.advanced(by: rhs)
  }
  @_transparent public static func + (lhs: Self.Stride, @_nonEphemeral rhs: Self) -> Self {
    return rhs.advanced(by: lhs)
  }
  @_transparent public static func - (@_nonEphemeral lhs: Self, rhs: Self.Stride) -> Self {
    return lhs.advanced(by: -rhs)
  }
  @_transparent public static func - (lhs: Self, rhs: Self) -> Self.Stride {
    return rhs.distance(to: lhs)
  }
  @_transparent public static func += (lhs: inout Self, rhs: Self.Stride) {
    lhs = lhs.advanced(by: rhs)
  }
  @_transparent public static func -= (lhs: inout Self, rhs: Self.Stride) {
    lhs = lhs.advanced(by: -rhs)
  }
}
@_transparent public func _convertPointerToPointerArgument<FromPointer, ToPointer>(_ from: FromPointer) -> ToPointer where FromPointer : Swift._Pointer, ToPointer : Swift._Pointer {
  return ToPointer(from._rawValue)
}
@_transparent public func _convertInOutToPointerArgument<ToPointer>(_ from: Builtin.RawPointer) -> ToPointer where ToPointer : Swift._Pointer {
  return ToPointer(from)
}
@_transparent public func _convertConstArrayToPointerArgument<FromElement, ToPointer>(_ arr: [FromElement]) -> (Swift.AnyObject?, ToPointer) where ToPointer : Swift._Pointer {
  let (owner, opaquePointer) = arr._cPointerArgs()

  let validPointer: ToPointer
  if let addr = opaquePointer {
    validPointer = ToPointer(addr._rawValue)
  } else {
    let lastAlignedValue = ~(MemoryLayout<FromElement>.alignment - 1)
    let lastAlignedPointer = UnsafeRawPointer(bitPattern: lastAlignedValue)!
    validPointer = ToPointer(lastAlignedPointer._rawValue)
  }
  return (owner, validPointer)
}
@_transparent public func _convertMutableArrayToPointerArgument<FromElement, ToPointer>(_ a: inout [FromElement]) -> (Swift.AnyObject?, ToPointer) where ToPointer : Swift._Pointer {
   
   

   
  a.reserveCapacity(0)
  _debugPrecondition(a._baseAddressIfContiguous != nil || a.isEmpty)

  return _convertConstArrayToPointerArgument(a)
}
@_transparent public func _convertConstStringToUTF8PointerArgument<ToPointer>(_ str: Swift.String) -> (Swift.AnyObject?, ToPointer) where ToPointer : Swift._Pointer {
  let utf8 = Array(str.utf8CString)
  return _convertConstArrayToPointerArgument(utf8)
}
@frozen public enum Never {
}
extension Swift.Never : Swift.BitwiseCopyable {
}
extension Swift.Never : Swift.Sendable {
}
extension Swift.Never : Swift.Error {
}
extension Swift.Never : Swift.Equatable, Swift.Comparable, Swift.Hashable {
  public static func == (a: Swift.Never, b: Swift.Never) -> Swift.Bool
  public static func < (a: Swift.Never, b: Swift.Never) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.Never : Swift.Identifiable {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public var id: Swift.Never {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ID = Swift.Never
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension Swift.Never : Swift.Encodable {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension Swift.Never : Swift.Decodable {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public init(from decoder: any Swift.Decoder) throws
}
public typealias Void = ()
public typealias Float32 = Swift.Float
public typealias Float64 = Swift.Double
public typealias IntegerLiteralType = Swift.Int
public typealias FloatLiteralType = Swift.Double
public typealias BooleanLiteralType = Swift.Bool
public typealias UnicodeScalarType = Swift.String
public typealias ExtendedGraphemeClusterType = Swift.String
public typealias StringLiteralType = Swift.String
public typealias _MaxBuiltinFloatType = Builtin.FPIEEE64
public typealias AnyObject = Builtin.AnyObject
public typealias AnyClass = any Swift.AnyObject.Type
@_transparent public func ~= <T>(a: T, b: T) -> Swift.Bool where T : Swift.Equatable {
  return a == b
}
precedencegroup AssignmentPrecedence {
  associativity: right
  assignment: true
}
precedencegroup FunctionArrowPrecedence {
  associativity: right
  higherThan: AssignmentPrecedence
}
precedencegroup TernaryPrecedence {
  associativity: right
  higherThan: FunctionArrowPrecedence
}
precedencegroup DefaultPrecedence {
  higherThan: TernaryPrecedence
}
precedencegroup LogicalDisjunctionPrecedence {
  associativity: left
  higherThan: TernaryPrecedence
}
precedencegroup LogicalConjunctionPrecedence {
  associativity: left
  higherThan: LogicalDisjunctionPrecedence
}
precedencegroup ComparisonPrecedence {
  higherThan: LogicalConjunctionPrecedence
}
precedencegroup NilCoalescingPrecedence {
  associativity: right
  higherThan: ComparisonPrecedence
}
precedencegroup CastingPrecedence {
  higherThan: NilCoalescingPrecedence
}
precedencegroup RangeFormationPrecedence {
  higherThan: CastingPrecedence
}
precedencegroup AdditionPrecedence {
  associativity: left
  higherThan: RangeFormationPrecedence
}
precedencegroup MultiplicationPrecedence {
  associativity: left
  higherThan: AdditionPrecedence
}
precedencegroup BitwiseShiftPrecedence {
  higherThan: MultiplicationPrecedence
}
postfix operator ++
postfix operator --
postfix operator ...
prefix operator ++
prefix operator --
prefix operator !
prefix operator ~
prefix operator +
prefix operator -
prefix operator ...
prefix operator ..<
infix operator << : BitwiseShiftPrecedence
infix operator &<< : BitwiseShiftPrecedence
infix operator >> : BitwiseShiftPrecedence
infix operator &>> : BitwiseShiftPrecedence
infix operator * : MultiplicationPrecedence
infix operator &* : MultiplicationPrecedence
infix operator / : MultiplicationPrecedence
infix operator % : MultiplicationPrecedence
infix operator & : MultiplicationPrecedence
infix operator + : AdditionPrecedence
infix operator &+ : AdditionPrecedence
infix operator - : AdditionPrecedence
infix operator &- : AdditionPrecedence
infix operator | : AdditionPrecedence
infix operator ^ : AdditionPrecedence
infix operator ... : RangeFormationPrecedence
infix operator ..< : RangeFormationPrecedence
infix operator ?? : NilCoalescingPrecedence
infix operator < : ComparisonPrecedence
infix operator <= : ComparisonPrecedence
infix operator > : ComparisonPrecedence
infix operator >= : ComparisonPrecedence
infix operator == : ComparisonPrecedence
infix operator != : ComparisonPrecedence
infix operator === : ComparisonPrecedence
infix operator !== : ComparisonPrecedence
infix operator ~= : ComparisonPrecedence
infix operator && : LogicalConjunctionPrecedence
infix operator || : LogicalDisjunctionPrecedence
infix operator *= : AssignmentPrecedence
infix operator &*= : AssignmentPrecedence
infix operator /= : AssignmentPrecedence
infix operator %= : AssignmentPrecedence
infix operator += : AssignmentPrecedence
infix operator &+= : AssignmentPrecedence
infix operator -= : AssignmentPrecedence
infix operator &-= : AssignmentPrecedence
infix operator <<= : AssignmentPrecedence
infix operator &<<= : AssignmentPrecedence
infix operator >>= : AssignmentPrecedence
infix operator &>>= : AssignmentPrecedence
infix operator &= : AssignmentPrecedence
infix operator ^= : AssignmentPrecedence
infix operator |= : AssignmentPrecedence
infix operator ~> : DefaultPrecedence
@frozen public struct LazyPrefixWhileSequence<Base> where Base : Swift.Sequence {
  public typealias Element = Base.Element
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _predicate: (Swift.LazyPrefixWhileSequence<Base>.Element) -> Swift.Bool
  @inlinable internal init(_base: Base, predicate: @escaping (Swift.LazyPrefixWhileSequence<Base>.Element) -> Swift.Bool) {
    self._base = _base
    self._predicate = predicate
  }
}
@available(*, unavailable)
extension Swift.LazyPrefixWhileSequence : Swift.Sendable {
}
extension Swift.LazyPrefixWhileSequence {
  @frozen public struct Iterator {
    public typealias Element = Base.Element
    @usableFromInline
    internal var _predicateHasFailed: Swift.Bool = false
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal let _predicate: (Swift.LazyPrefixWhileSequence<Base>.Iterator.Element) -> Swift.Bool
    @inlinable internal init(_base: Base.Iterator, predicate: @escaping (Swift.LazyPrefixWhileSequence<Base>.Iterator.Element) -> Swift.Bool) {
      self._base = _base
      self._predicate = predicate
    }
  }
}
@available(*, unavailable)
extension Swift.LazyPrefixWhileSequence.Iterator : Swift.Sendable {
}
extension Swift.LazyPrefixWhileSequence.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  @inlinable public mutating func next() -> Swift.LazyPrefixWhileSequence<Base>.Iterator.Element? {
     
    if !_predicateHasFailed, let nextElement = _base.next() {
      if _predicate(nextElement) {
        return nextElement
      } else {
        _predicateHasFailed = true
      }
    }
    return nil
  }
  public typealias Iterator = Swift.LazyPrefixWhileSequence<Base>.Iterator
}
extension Swift.LazyPrefixWhileSequence : Swift.Sequence {
  @inlinable public __consuming func makeIterator() -> Swift.LazyPrefixWhileSequence<Base>.Iterator {
    return Iterator(_base: _base.makeIterator(), predicate: _predicate)
  }
}
extension Swift.LazyPrefixWhileSequence : Swift.LazySequenceProtocol {
  public typealias Elements = Swift.LazyPrefixWhileSequence<Base>
}
extension Swift.LazySequenceProtocol {
  @inlinable public __consuming func prefix(while predicate: @escaping (Self.Elements.Element) -> Swift.Bool) -> Swift.LazyPrefixWhileSequence<Self.Elements> {
    return LazyPrefixWhileSequence(_base: self.elements, predicate: predicate)
  }
}
public typealias LazyPrefixWhileCollection<T> = Swift.LazyPrefixWhileSequence<T> where T : Swift.Collection
extension Swift.LazyPrefixWhileCollection where Base : Swift.Collection {
  @usableFromInline
  @frozen internal enum _IndexRepresentation {
    case index(Base.Index)
    case pastEnd
  }
  @frozen public struct Index {
    @usableFromInline
    internal let _value: Swift.LazyPrefixWhileSequence<Base>._IndexRepresentation
    @inlinable internal init(_ i: Base.Index) {
      self._value = .index(i)
    }
    @inlinable internal init(endOf: Base) {
      self._value = .pastEnd
    }
  }
}
extension Swift.LazyPrefixWhileSequence._IndexRepresentation : Swift.Sendable where Base.Index : Swift.Sendable {
}
extension Swift.LazyPrefixWhileSequence.Index : Swift.Sendable where Base.Index : Swift.Sendable {
}
extension Swift.LazyPrefixWhileSequence.Index : Swift.Comparable {
  @inlinable public static func == (lhs: Swift.LazyPrefixWhileCollection<Base>.Index, rhs: Swift.LazyPrefixWhileCollection<Base>.Index) -> Swift.Bool {
    switch (lhs._value, rhs._value) {
    case let (.index(l), .index(r)):
      return l == r
    case (.pastEnd, .pastEnd):
      return true
    case (.pastEnd, .index), (.index, .pastEnd):
      return false
    }
  }
  @inlinable public static func < (lhs: Swift.LazyPrefixWhileCollection<Base>.Index, rhs: Swift.LazyPrefixWhileCollection<Base>.Index) -> Swift.Bool {
    switch (lhs._value, rhs._value) {
    case let (.index(l), .index(r)):
      return l < r
    case (.index, .pastEnd):
      return true
    case (.pastEnd, _):
      return false
    }
  }
}
extension Swift.LazyPrefixWhileSequence.Index : Swift.Hashable where Base.Index : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    switch _value {
    case .index(let value):
      hasher.combine(value)
    case .pastEnd:
      hasher.combine(Int.max)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.LazyPrefixWhileCollection : Swift.Collection where Base : Swift.Collection {
  public typealias SubSequence = Swift.Slice<Swift.LazyPrefixWhileCollection<Base>>
  @inlinable public var startIndex: Swift.LazyPrefixWhileSequence<Base>.Index {
    get {
    return Index(_base.startIndex)
  }
  }
  @inlinable public var endIndex: Swift.LazyPrefixWhileSequence<Base>.Index {
    get {
     
     
    if let first = _base.first, _predicate(first) {
      return Index(endOf: _base)
    }

     
     
    return startIndex
  }
  }
  @inlinable public func index(after i: Swift.LazyPrefixWhileSequence<Base>.Index) -> Swift.LazyPrefixWhileSequence<Base>.Index {
    _precondition(i != endIndex, "Can't advance past endIndex")
    guard case .index(let i) = i._value else {
      _preconditionFailure("Invalid index passed to index(after:)")
    }
    let nextIndex = _base.index(after: i)
    guard nextIndex != _base.endIndex && _predicate(_base[nextIndex]) else {
      return Index(endOf: _base)
    }
    return Index(nextIndex)
  }
  @inlinable public subscript(position: Swift.LazyPrefixWhileSequence<Base>.Index) -> Swift.LazyPrefixWhileSequence<Base>.Element {
    get {
    switch position._value {
    case .index(let i):
      return _base[i]
    case .pastEnd:
      _preconditionFailure("Index out of range")
    }
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.LazyPrefixWhileSequence<Base>>
}
extension Swift.LazyPrefixWhileCollection : Swift.LazyCollectionProtocol where Base : Swift.Collection {
}
extension Swift.LazyPrefixWhileCollection : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.LazyPrefixWhileSequence<Base>.Index) -> Swift.LazyPrefixWhileSequence<Base>.Index {
    switch i._value {
    case .index(let i):
      _precondition(i != _base.startIndex, "Can't move before startIndex")
      return Index(_base.index(before: i))
    case .pastEnd:
       
       
       

       
       
       
      _internalInvariant(!_base.isEmpty)
      var result = _base.startIndex
      while true {
        let next = _base.index(after: result)
        if next == _base.endIndex || !_predicate(_base[next]) {
          break
        }
        result = next
      }
      return Index(result)
    }
  }
}
@usableFromInline
internal func _prespecialize()
@_specializeExtension extension Swift.Dictionary._Variant {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_setValue(_: __owned Value, forKey: Key)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_removeValue(forKey: Key) -> Value?
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_isUniquelyReferenced() -> Swift.Bool
}
@_specializeExtension extension Swift._NativeDictionary {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize__copyOrMoveAndResize(capacity: Swift.Int, moveElements: Swift.Bool)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_copy()
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_mutatingFind(_ key: Key, isUnique: Swift.Bool) -> (bucket: Swift._HashTable.Bucket, found: Swift.Bool)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal func __specialize__insert(at: Swift._NativeDictionary<Key, Value>.Bucket, key: __owned Key, value: __owned Value)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_ensureUnique(isUnique: Swift.Bool, capacity: Swift.Int) -> Swift.Bool
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_uncheckedRemove(at: Swift._HashTable.Bucket, isUnique: Swift.Bool) -> (key: Key, value: Value)
}
@_specializeExtension extension Swift.__RawDictionaryStorage {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal func __specialize_find<T>(_: T, hashValue: Swift.Int) -> (bucket: Swift._HashTable.Bucket, found: Swift.Bool) where T : Swift.Hashable
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal func __specialize_find<T>(_: T) -> (bucket: Swift._HashTable.Bucket, found: Swift.Bool) where T : Swift.Hashable
}
@_specializeExtension extension Swift.Array {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal func __specialize__checkSubscript(_: Swift.Int, wasNativeTypeChecked: Swift.Bool) -> Swift._DependenceToken
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize__endMutation()
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _endMutation(), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal mutating func __specialize_class__endMutation()
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal mutating func __specialize_class__endMutation()
  #endif
  #endif
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize__createNewBuffer(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool)
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal mutating func __specialize_class__createNewBuffer(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool)
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal mutating func __specialize_class__createNewBuffer(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool)
  #endif
  #endif
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize__makeUniqueAndReserveCapacityIfNotUnique()
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _makeUniqueAndReserveCapacityIfNotUnique(), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal mutating func __specialize_class__makeUniqueAndReserveCapacityIfNotUnique()
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal mutating func __specialize_class__makeUniqueAndReserveCapacityIfNotUnique()
  #endif
  #endif
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize__appendElementAssumeUniqueAndCapacity(_: Swift.Int, newElement: __owned Element)
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _appendElementAssumeUniqueAndCapacity(_:newElement:), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal mutating func __specialize_class__appendElementAssumeUniqueAndCapacity(_: Swift.Int, newElement: __owned Element)
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal mutating func __specialize_class__appendElementAssumeUniqueAndCapacity(_: Swift.Int, newElement: __owned Element)
  #endif
  #endif
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_append(_: __owned Element)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal static func __specialize__adoptStorage(_: __owned Swift._ContiguousArrayStorage<Element>, count: Swift.Int) -> ([Element], Swift.UnsafeMutablePointer<Element>)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_append<S>(contentsOf: __owned S) where Element == S.Element, S : Swift.Sequence
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize__reserveCapacityImpl(minimumCapacity: Swift.Int, growForAppend: Swift.Bool)
}
@_specializeExtension extension Swift._ArrayBuffer {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal func __specialize__consumeAndCreateNew(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) -> Swift._ArrayBuffer<Element>
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal func __specialize_class__consumeAndCreateNew(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) -> Swift._ArrayBuffer<Element>
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal func __specialize_class__consumeAndCreateNew(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) -> Swift._ArrayBuffer<Element>
  #endif
  #endif
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_isMutableAndUniquelyReferenced() -> Swift.Bool
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_isUniquelyReferenced() -> Swift.Bool
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_beginCOWMutation() -> Swift.Bool
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal var __specialize_firstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal var __specialize__native: Swift._ContiguousArrayBuffer<Element> {
    get
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal var __specialize_immutableCount: Swift.Int {
    get
  }
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _copyContents(initializing:), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal __consuming func __specialize_class__copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift._ArrayBuffer<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index)
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal __consuming func __specialize_class__copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift._ArrayBuffer<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index)
  #endif
  #endif
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _copyContents(subRange:initializing:), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal __consuming func __specialize_class__copyContents(subRange: Swift.Range<Swift.Int>, initializing: Swift.UnsafeMutablePointer<Element>) -> Swift.UnsafeMutablePointer<Element>
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal __consuming func __specialize_class__copyContents(subRange: Swift.Range<Swift.Int>, initializing: Swift.UnsafeMutablePointer<Element>) -> Swift.UnsafeMutablePointer<Element>
  #endif
  #endif
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _getElementSlowPath(_:), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  internal func __specialize_class__getElementSlowPath(_ i: Swift.Int) -> Swift.AnyObject
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  internal func __specialize_class__getElementSlowPath(_ i: Swift.Int) -> Swift.AnyObject
  #endif
  #endif
}
@_specializeExtension extension Swift.ContiguousArray {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize__endMutation()
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _endMutation(), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal mutating func __specialize_class__endMutation()
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal mutating func __specialize_class__endMutation()
  #endif
  #endif
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize__createNewBuffer(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool)
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal mutating func __specialize_class__createNewBuffer(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool)
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal mutating func __specialize_class__createNewBuffer(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool)
  #endif
  #endif
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize__makeUniqueAndReserveCapacityIfNotUnique()
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _makeUniqueAndReserveCapacityIfNotUnique(), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal mutating func __specialize_class__makeUniqueAndReserveCapacityIfNotUnique()
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal mutating func __specialize_class__makeUniqueAndReserveCapacityIfNotUnique()
  #endif
  #endif
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize__appendElementAssumeUniqueAndCapacity(_: Swift.Int, newElement: __owned Element)
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _appendElementAssumeUniqueAndCapacity(_:newElement:), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal mutating func __specialize_class__appendElementAssumeUniqueAndCapacity(_: Swift.Int, newElement: __owned Element)
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal mutating func __specialize_class__appendElementAssumeUniqueAndCapacity(_: Swift.Int, newElement: __owned Element)
  #endif
  #endif
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_append(_: __owned Element)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_append<S>(contentsOf: __owned S) where Element == S.Element, S : Swift.Sequence
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize__reserveCapacityImpl(minimumCapacity: Swift.Int, growForAppend: Swift.Bool)
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _reserveCapacityImpl(minimumCapacity:growForAppend:), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal mutating func __specialize_class__reserveCapacityImpl(minimumCapacity: Swift.Int, growForAppend: Swift.Bool)
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal mutating func __specialize_class__reserveCapacityImpl(minimumCapacity: Swift.Int, growForAppend: Swift.Bool)
  #endif
  #endif
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _reserveCapacityAssumingUniqueBuffer(oldCount:), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal mutating func __specialize_class__reserveCapacityAssumingUniqueBuffer(oldCount: Swift.Int)
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal mutating func __specialize_class__reserveCapacityAssumingUniqueBuffer(oldCount: Swift.Int)
  #endif
  #endif
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: reserveCapacity(_:), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal mutating func __specialize_class__reserveCapacity(_ minimumCapacity: Swift.Int)
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal mutating func __specialize_class__reserveCapacity(_ minimumCapacity: Swift.Int)
  #endif
  #endif
}
@_specializeExtension extension Swift._ContiguousArrayBuffer {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal func __specialize__consumeAndCreateNew(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) -> Swift._ContiguousArrayBuffer<Element>
  #if compiler(>=5.3) && $LayoutPrespecialization
  #if compiler(>=5.3) && $SpecializeAttributeWithAvailability
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_specialize(exported: true, kind: full, target: _consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:), availability: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *; where @_noMetadata Element : _Class)
  @usableFromInline
  internal func __specialize_class__consumeAndCreateNew(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) -> Swift._ContiguousArrayBuffer<Element>
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal func __specialize_class__consumeAndCreateNew(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) -> Swift._ContiguousArrayBuffer<Element>
  #endif
  #endif
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_isMutableAndUniquelyReferenced() -> Swift.Bool
}
@_specializeExtension extension Swift.Set {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal func __specialize_contains(_: Element) -> Swift.Bool
}
@_specializeExtension extension Swift.Set._Variant {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_insert(_: __owned Element) -> (inserted: Swift.Bool, memberAfterInsert: Element)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_remove(_: Element) -> Element?
}
@_specializeExtension extension Swift.Sequence {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal __consuming func __specialize__copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
}
@_specializeExtension extension Swift._NativeSet {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_copyAndResize(capacity: Swift.Int)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_copy()
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal func __specialize_index(after: Swift.Set<Element>.Index) -> Swift.Set<Element>.Index
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_resize(capacity: Swift.Int)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize__delete(at: Swift._HashTable.Bucket)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal mutating func __specialize_insertNew(_: __owned Element, at: Swift._HashTable.Bucket, isUnique: Swift.Bool)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal func __specialize__unsafeInsertNew(_: __owned Element, at: Swift._HashTable.Bucket)
}
#if compiler(>=5.3) && $NoncopyableGenerics
@_specializeExtension extension Swift.Optional {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal static func __specialize_equals(lhs: Wrapped?, rhs: Wrapped?) -> Swift.Bool
}
#else
@_specializeExtension extension Swift.Optional {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal static func __specialize_equals(lhs: Wrapped?, rhs: Wrapped?) -> Swift.Bool
}
#endif
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@usableFromInline
internal func __specialize_dictionaryUpCast<DerivedKey, DerivedValue, BaseKey, BaseValue>(_ source: Swift.Dictionary<DerivedKey, DerivedValue>) -> Swift.Dictionary<BaseKey, BaseValue> where DerivedKey : Swift.Hashable, BaseKey : Swift.Hashable
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@usableFromInline
internal func __specialize_copyCollectionToContiguousArray<C>(_ source: C) -> Swift.ContiguousArray<C.Element> where C : Swift.Collection
public func print(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n")
public func debugPrint(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n")
public func print<Target>(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n", to output: inout Target) where Target : Swift.TextOutputStream
public func debugPrint<Target>(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n", to output: inout Target) where Target : Swift.TextOutputStream
public protocol RandomNumberGenerator {
  mutating func next() -> Swift.UInt64
}
extension Swift.RandomNumberGenerator {
  @available(*, unavailable)
  @_alwaysEmitIntoClient public mutating func next() -> Swift.UInt64 { fatalError() }
  @inlinable public mutating func next<T>() -> T where T : Swift.FixedWidthInteger, T : Swift.UnsignedInteger {
    return T._random(using: &self)
  }
  @inlinable public mutating func next<T>(upperBound: T) -> T where T : Swift.FixedWidthInteger, T : Swift.UnsignedInteger {
    _precondition(upperBound != 0, "upperBound cannot be zero.")
     
     
     
    var random: T = next()
    var m = random.multipliedFullWidth(by: upperBound)
    if m.low < upperBound {
      let t = (0 &- upperBound) % upperBound
      while m.low < t {
        random = next()
        m = random.multipliedFullWidth(by: upperBound)
      }
    }
    return m.high
  }
}
@frozen public struct SystemRandomNumberGenerator : Swift.RandomNumberGenerator, Swift.Sendable {
  @inlinable public init() { }
  @inlinable public mutating func next() -> Swift.UInt64 {
    var random: UInt64 = 0
#if $TypedThrows
    _withUnprotectedUnsafeMutablePointer(to: &random) {
      swift_stdlib_random($0, MemoryLayout<UInt64>.size)
    }
#else
    __abi_se0413_withUnsafeMutablePointer(to: &random) {
      swift_stdlib_random($0, MemoryLayout<UInt64>.size)
    }
#endif
    return random
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol RandomAccessCollection<Element> : Swift.BidirectionalCollection where Self.Indices : Swift.RandomAccessCollection, Self.SubSequence : Swift.RandomAccessCollection {
  override associatedtype Element
  override associatedtype Index
  override associatedtype SubSequence
  override associatedtype Indices
  override var indices: Self.Indices { get }
  override subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get }
  @_borrowed override subscript(position: Self.Index) -> Self.Element { get }
  override var startIndex: Self.Index { get }
  override var endIndex: Self.Index { get }
  override func index(before i: Self.Index) -> Self.Index
  override func formIndex(before i: inout Self.Index)
  override func index(after i: Self.Index) -> Self.Index
  override func formIndex(after i: inout Self.Index)
  @_nonoverride func index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index
  @_nonoverride func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index?
  @_nonoverride func distance(from start: Self.Index, to end: Self.Index) -> Swift.Int
}
#else
public protocol RandomAccessCollection : Swift.BidirectionalCollection where Self.Indices : Swift.RandomAccessCollection, Self.SubSequence : Swift.RandomAccessCollection {
  override associatedtype Element
  override associatedtype Index
  override associatedtype SubSequence
  override associatedtype Indices
  override var indices: Self.Indices { get }
  override subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get }
  @_borrowed override subscript(position: Self.Index) -> Self.Element { get }
  override var startIndex: Self.Index { get }
  override var endIndex: Self.Index { get }
  override func index(before i: Self.Index) -> Self.Index
  override func formIndex(before i: inout Self.Index)
  override func index(after i: Self.Index) -> Self.Index
  override func formIndex(after i: inout Self.Index)
  @_nonoverride func index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index
  @_nonoverride func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index?
  @_nonoverride func distance(from start: Self.Index, to end: Self.Index) -> Swift.Int
}
#endif
extension Swift.RandomAccessCollection {
  @inlinable public func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index? {
     
    let l = self.distance(from: i, to: limit)
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return index(i, offsetBy: distance)
  }
}
extension Swift.RandomAccessCollection where Self.Index : Swift.Strideable, Self.Index.Stride == Swift.Int {
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @_implements(Swift.Collection, Indices) public typealias _Default_Indices = Swift.Range<Self.Index>
  #else
  public typealias _Default_Indices = Swift.Range<Self.Index>
  #endif
}
extension Swift.RandomAccessCollection where Self.Index : Swift.Strideable, Self.Indices == Swift.Range<Self.Index>, Self.Index.Stride == Swift.Int {
  @inlinable public var indices: Swift.Range<Self.Index> {
    get {
    return startIndex..<endIndex
  }
  }
  @inlinable public func index(after i: Self.Index) -> Self.Index {
     
    _failEarlyRangeCheck(
      i, bounds: Range(uncheckedBounds: (startIndex, endIndex)))
    return i.advanced(by: 1)
  }
  @inlinable public func index(before i: Self.Index) -> Self.Index {
    let result = i.advanced(by: -1)
     
    _failEarlyRangeCheck(
      result, bounds: Range(uncheckedBounds: (startIndex, endIndex)))
    return result
  }
  @inlinable public func index(_ i: Self.Index, offsetBy distance: Self.Index.Stride) -> Self.Index {
    let result = i.advanced(by: distance)
     
     
     
     
     
    _failEarlyRangeCheck(
      result, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    return result
  }
  @inlinable public func distance(from start: Self.Index, to end: Self.Index) -> Self.Index.Stride {
     
    _failEarlyRangeCheck(
      start, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    _failEarlyRangeCheck(
      end, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    return start.distance(to: end)
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol RangeExpression<Bound> {
  associatedtype Bound : Swift.Comparable
  func relative<C>(to collection: C) -> Swift.Range<Self.Bound> where C : Swift.Collection, Self.Bound == C.Index
  func contains(_ element: Self.Bound) -> Swift.Bool
}
#else
public protocol RangeExpression {
  associatedtype Bound : Swift.Comparable
  func relative<C>(to collection: C) -> Swift.Range<Self.Bound> where C : Swift.Collection, Self.Bound == C.Index
  func contains(_ element: Self.Bound) -> Swift.Bool
}
#endif
extension Swift.RangeExpression {
  @inlinable public static func ~= (pattern: Self, value: Self.Bound) -> Swift.Bool {
    return pattern.contains(value)
  }
}
@frozen public struct Range<Bound> where Bound : Swift.Comparable {
  public let lowerBound: Bound
  public let upperBound: Bound
  @_alwaysEmitIntoClient @inline(__always) internal init(_uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    self.lowerBound = bounds.lower
    self.upperBound = bounds.upper
  }
  @inlinable public init(uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    _debugPrecondition(bounds.lower <= bounds.upper,
      "Range requires lowerBound <= upperBound")
    self.init(_uncheckedBounds: (lower: bounds.lower, upper: bounds.upper))
  }
  @inlinable public func contains(_ element: Bound) -> Swift.Bool {
    return lowerBound <= element && element < upperBound
  }
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return lowerBound == upperBound
  }
  }
}
extension Swift.Range : Swift.Sequence where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias Element = Bound
  public typealias Iterator = Swift.IndexingIterator<Swift.Range<Bound>>
}
extension Swift.Range : Swift.Collection, Swift.BidirectionalCollection, Swift.RandomAccessCollection where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias Index = Bound
  public typealias Indices = Swift.Range<Bound>
  public typealias SubSequence = Swift.Range<Bound>
  @inlinable public var startIndex: Swift.Range<Bound>.Index {
    get { return lowerBound }
  }
  @inlinable public var endIndex: Swift.Range<Bound>.Index {
    get { return upperBound }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Range<Bound>.Index) -> Swift.Range<Bound>.Index {
    _failEarlyRangeCheck(i, bounds: startIndex..<endIndex)

    return i.advanced(by: 1)
  }
  @inlinable public func index(before i: Swift.Range<Bound>.Index) -> Swift.Range<Bound>.Index {
    _precondition(i > lowerBound)
    _precondition(i <= upperBound)

    return i.advanced(by: -1)
  }
  @inlinable public func index(_ i: Swift.Range<Bound>.Index, offsetBy n: Swift.Int) -> Swift.Range<Bound>.Index {
    let r = i.advanced(by: numericCast(n))
    _precondition(r >= lowerBound)
    _precondition(r <= upperBound)
    return r
  }
  @inlinable public func distance(from start: Swift.Range<Bound>.Index, to end: Swift.Range<Bound>.Index) -> Swift.Int {
    return numericCast(start.distance(to: end))
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Range<Bound>.Index>) -> Swift.Range<Bound> {
    get {
    return bounds
  }
  }
  @inlinable public var indices: Swift.Range<Bound>.Indices {
    get {
    return self
  }
  }
  @inlinable public func _customContainsEquatableElement(_ element: Swift.Range<Bound>.Element) -> Swift.Bool? {
    return lowerBound <= element && element < upperBound
  }
  @inlinable public func _customIndexOfEquatableElement(_ element: Bound) -> Swift.Range<Bound>.Index?? {
    return lowerBound <= element && element < upperBound ? element : nil
  }
  @inlinable public func _customLastIndexOfEquatableElement(_ element: Bound) -> Swift.Range<Bound>.Index?? {
     
    return _customIndexOfEquatableElement(element)
  }
  @inlinable public subscript(position: Swift.Range<Bound>.Index) -> Swift.Range<Bound>.Element {
    get {
     
    _debugPrecondition(self.contains(position), "Index out of range")
    return position
  }
  }
}
extension Swift.Range where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  @inlinable public init(_ other: Swift.ClosedRange<Bound>) {
    let upperBound = other.upperBound.advanced(by: 1)
    self.init(_uncheckedBounds: (lower: other.lowerBound, upper: upperBound))
  }
}
extension Swift.Range : Swift.RangeExpression {
  @inlinable public func relative<C>(to collection: C) -> Swift.Range<Bound> where Bound == C.Index, C : Swift.Collection {
    self
  }
}
extension Swift.Range {
  @inlinable @inline(__always) public func clamped(to limits: Swift.Range<Bound>) -> Swift.Range<Bound> {
    let lower =         
      limits.lowerBound > self.lowerBound ? limits.lowerBound
          : limits.upperBound < self.lowerBound ? limits.upperBound
          : self.lowerBound
    let upper =
      limits.upperBound < self.upperBound ? limits.upperBound
          : limits.lowerBound > self.upperBound ? limits.lowerBound
          : self.upperBound
    return Range(_uncheckedBounds: (lower: lower, upper: upper))
  }
}
extension Swift.Range : Swift.CustomStringConvertible {
  @inlinable public var description: Swift.String {
    get {
    return "\(lowerBound)..<\(upperBound)"
  }
  }
}
extension Swift.Range : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.Range : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Range : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.Range<Bound>, rhs: Swift.Range<Bound>) -> Swift.Bool {
    return
      lhs.lowerBound == rhs.lowerBound &&
      lhs.upperBound == rhs.upperBound
  }
}
extension Swift.Range : Swift.Hashable where Bound : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(lowerBound)
    hasher.combine(upperBound)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Range : Swift.Decodable where Bound : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.Range : Swift.Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@frozen public struct PartialRangeUpTo<Bound> where Bound : Swift.Comparable {
  public let upperBound: Bound
  @inlinable public init(_ upperBound: Bound) { self.upperBound = upperBound }
}
extension Swift.PartialRangeUpTo : Swift.RangeExpression {
  @_transparent public func relative<C>(to collection: C) -> Swift.Range<Bound> where Bound == C.Index, C : Swift.Collection {
    return collection.startIndex..<self.upperBound
  }
  @_transparent public func contains(_ element: Bound) -> Swift.Bool {
    return element < upperBound
  }
}
extension Swift.PartialRangeUpTo : Swift.Decodable where Bound : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.PartialRangeUpTo : Swift.Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@frozen public struct PartialRangeThrough<Bound> where Bound : Swift.Comparable {
  public let upperBound: Bound
  @inlinable public init(_ upperBound: Bound) { self.upperBound = upperBound }
}
extension Swift.PartialRangeThrough : Swift.RangeExpression {
  @_transparent public func relative<C>(to collection: C) -> Swift.Range<Bound> where Bound == C.Index, C : Swift.Collection {
    return collection.startIndex..<collection.index(after: self.upperBound)
  }
  @_transparent public func contains(_ element: Bound) -> Swift.Bool {
    return element <= upperBound
  }
}
extension Swift.PartialRangeThrough : Swift.Decodable where Bound : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.PartialRangeThrough : Swift.Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@frozen public struct PartialRangeFrom<Bound> where Bound : Swift.Comparable {
  public let lowerBound: Bound
  @inlinable public init(_ lowerBound: Bound) { self.lowerBound = lowerBound }
}
extension Swift.PartialRangeFrom : Swift.RangeExpression {
  @_transparent public func relative<C>(to collection: C) -> Swift.Range<Bound> where Bound == C.Index, C : Swift.Collection {
    return self.lowerBound..<collection.endIndex
  }
  @inlinable public func contains(_ element: Bound) -> Swift.Bool {
    return lowerBound <= element
  }
}
extension Swift.PartialRangeFrom : Swift.Sequence where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias Element = Bound
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal var _current: Bound
    @inlinable public init(_current: Bound) { self._current = _current }
    @inlinable public mutating func next() -> Bound? {
      defer { _current = _current.advanced(by: 1) }
      return _current
    }
    public typealias Element = Bound
  }
  @inlinable public __consuming func makeIterator() -> Swift.PartialRangeFrom<Bound>.Iterator { 
    return Iterator(_current: lowerBound) 
  }
}
extension Swift.PartialRangeFrom : Swift.Decodable where Bound : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.PartialRangeFrom : Swift.Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.Comparable {
  @_transparent public static func ..< (minimum: Self, maximum: Self) -> Swift.Range<Self> {
    _precondition(minimum <= maximum,
      "Range requires lowerBound <= upperBound")
    return Range(_uncheckedBounds: (lower: minimum, upper: maximum))
  }
  @_transparent prefix public static func ..< (maximum: Self) -> Swift.PartialRangeUpTo<Self> {
    _precondition(maximum == maximum,
      "Range cannot have an unordered upper bound.")
    return PartialRangeUpTo(maximum)
  }
  @_transparent prefix public static func ... (maximum: Self) -> Swift.PartialRangeThrough<Self> {
    _precondition(maximum == maximum,
      "Range cannot have an unordered upper bound.")
    return PartialRangeThrough(maximum)
  }
  @_transparent postfix public static func ... (minimum: Self) -> Swift.PartialRangeFrom<Self> {
    _precondition(minimum == minimum,
      "Range cannot have an unordered lower bound.")
    return PartialRangeFrom(minimum)
  }
}
@frozen public enum UnboundedRange_ {
  postfix public static func ... (_: Swift.UnboundedRange_)
}
public typealias UnboundedRange = (Swift.UnboundedRange_) -> ()
extension Swift.Collection {
  @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : Swift.RangeExpression, Self.Index == R.Bound {
    get {
    return self[r.relative(to: self)]
  }
  }
  @inlinable public subscript(x: (Swift.UnboundedRange_) -> ()) -> Self.SubSequence {
    get {
    return self[startIndex...]
  }
  }
}
extension Swift.MutableCollection {
  @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : Swift.RangeExpression, Self.Index == R.Bound {
    get {
      return self[r.relative(to: self)]
    }
    set {
      self[r.relative(to: self)] = newValue
    }
  }
  @inlinable public subscript(x: (Swift.UnboundedRange_) -> ()) -> Self.SubSequence {
    get {
      return self[startIndex...]
    }
    set {
      self[startIndex...] = newValue
    }
  }
}
extension Swift.Range {
  @inlinable public func overlaps(_ other: Swift.Range<Bound>) -> Swift.Bool {
     
     
     
     
    let isDisjoint = other.upperBound <= self.lowerBound
      || self.upperBound <= other.lowerBound
      || self.isEmpty || other.isEmpty
    return !isDisjoint
  }
  @inlinable public func overlaps(_ other: Swift.ClosedRange<Bound>) -> Swift.Bool {
     
     
     
     
    let isDisjoint = other.upperBound < self.lowerBound
      || self.upperBound <= other.lowerBound
      || self.isEmpty
    return !isDisjoint
  }
}
public typealias CountableRange<Bound> = Swift.Range<Bound> where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger
public typealias CountablePartialRangeFrom<Bound> = Swift.PartialRangeFrom<Bound> where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger
extension Swift.Range : Swift.Sendable where Bound : Swift.Sendable {
}
extension Swift.PartialRangeUpTo : Swift.Sendable where Bound : Swift.Sendable {
}
extension Swift.PartialRangeThrough : Swift.Sendable where Bound : Swift.Sendable {
}
extension Swift.PartialRangeFrom : Swift.Sendable where Bound : Swift.Sendable {
}
extension Swift.PartialRangeFrom.Iterator : Swift.Sendable where Bound : Swift.Sendable {
}
extension Swift.Range where Bound == Swift.String.Index {
  @_alwaysEmitIntoClient internal var _encodedOffsetRange: Swift.Range<Swift.Int> {
    get {
    _internalInvariant(
      (lowerBound._canBeUTF8 && upperBound._canBeUTF8)
      || (lowerBound._canBeUTF16 && upperBound._canBeUTF16))
    return Range<Int>(
      _uncheckedBounds: (lowerBound._encodedOffset, upperBound._encodedOffset))
  }
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol RangeReplaceableCollection<Element> : Swift.Collection where Self.SubSequence : Swift.RangeReplaceableCollection {
  override associatedtype SubSequence
  init()
  mutating func replaceSubrange<C>(_ subrange: Swift.Range<Self.Index>, with newElements: __owned C) where C : Swift.Collection, Self.Element == C.Element
  mutating func reserveCapacity(_ n: Swift.Int)
  init(repeating repeatedValue: Self.Element, count: Swift.Int)
  init<S>(_ elements: S) where S : Swift.Sequence, Self.Element == S.Element
  mutating func append(_ newElement: __owned Self.Element)
  mutating func append<S>(contentsOf newElements: __owned S) where S : Swift.Sequence, Self.Element == S.Element
  mutating func insert(_ newElement: __owned Self.Element, at i: Self.Index)
  mutating func insert<S>(contentsOf newElements: __owned S, at i: Self.Index) where S : Swift.Collection, Self.Element == S.Element
  @discardableResult
  mutating func remove(at i: Self.Index) -> Self.Element
  mutating func removeSubrange(_ bounds: Swift.Range<Self.Index>)
  mutating func _customRemoveLast() -> Self.Element?
  mutating func _customRemoveLast(_ n: Swift.Int) -> Swift.Bool
  @discardableResult
  mutating func removeFirst() -> Self.Element
  mutating func removeFirst(_ k: Swift.Int)
  mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool)
  mutating func removeAll(where shouldBeRemoved: (Self.Element) throws -> Swift.Bool) rethrows
  @_borrowed override subscript(position: Self.Index) -> Self.Element { get }
  override subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get }
}
#else
public protocol RangeReplaceableCollection : Swift.Collection where Self.SubSequence : Swift.RangeReplaceableCollection {
  override associatedtype SubSequence
  init()
  mutating func replaceSubrange<C>(_ subrange: Swift.Range<Self.Index>, with newElements: __owned C) where C : Swift.Collection, Self.Element == C.Element
  mutating func reserveCapacity(_ n: Swift.Int)
  init(repeating repeatedValue: Self.Element, count: Swift.Int)
  init<S>(_ elements: S) where S : Swift.Sequence, Self.Element == S.Element
  mutating func append(_ newElement: __owned Self.Element)
  mutating func append<S>(contentsOf newElements: __owned S) where S : Swift.Sequence, Self.Element == S.Element
  mutating func insert(_ newElement: __owned Self.Element, at i: Self.Index)
  mutating func insert<S>(contentsOf newElements: __owned S, at i: Self.Index) where S : Swift.Collection, Self.Element == S.Element
  @discardableResult
  mutating func remove(at i: Self.Index) -> Self.Element
  mutating func removeSubrange(_ bounds: Swift.Range<Self.Index>)
  mutating func _customRemoveLast() -> Self.Element?
  mutating func _customRemoveLast(_ n: Swift.Int) -> Swift.Bool
  @discardableResult
  mutating func removeFirst() -> Self.Element
  mutating func removeFirst(_ k: Swift.Int)
  mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool)
  mutating func removeAll(where shouldBeRemoved: (Self.Element) throws -> Swift.Bool) rethrows
  @_borrowed override subscript(position: Self.Index) -> Self.Element { get }
  override subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get }
}
#endif
extension Swift.RangeReplaceableCollection {
  @inlinable public init(repeating repeatedValue: Self.Element, count: Swift.Int) {
    self.init()
    if count != 0 {
      let elements = Repeated(_repeating: repeatedValue, count: count)
      append(contentsOf: elements)
    }
  }
  @inlinable public init<S>(_ elements: S) where S : Swift.Sequence, Self.Element == S.Element {
    self.init()
    append(contentsOf: elements)
  }
  @inlinable public mutating func append(_ newElement: __owned Self.Element) {
    insert(newElement, at: endIndex)
  }
  @inlinable public mutating func append<S>(contentsOf newElements: __owned S) where S : Swift.Sequence, Self.Element == S.Element {
    for element in newElements {
      append(element)
    }
  }
  @inlinable public mutating func insert(_ newElement: __owned Self.Element, at i: Self.Index) {
    replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
  @inlinable public mutating func insert<C>(contentsOf newElements: __owned C, at i: Self.Index) where C : Swift.Collection, Self.Element == C.Element {
    replaceSubrange(i..<i, with: newElements)
  }
  @discardableResult
  @inlinable public mutating func remove(at position: Self.Index) -> Self.Element {
    _precondition(!isEmpty, "Can't remove from an empty collection")
    let result: Element = self[position]
    replaceSubrange(position..<index(after: position), with: EmptyCollection())
    return result
  }
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Self.Index>) {
    replaceSubrange(bounds, with: EmptyCollection())
  }
  @inlinable public mutating func removeFirst(_ k: Swift.Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    guard let end = index(startIndex, offsetBy: k, limitedBy: endIndex) else {
      _preconditionFailure(
        "Can't remove more items from a collection than it has")
    }
    removeSubrange(startIndex..<end)
  }
  @discardableResult
  @inlinable public mutating func removeFirst() -> Self.Element {
    _precondition(!isEmpty,
      "Can't remove first element from an empty collection")
    let firstElement = first!
    removeFirst(1)
    return firstElement
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    if !keepCapacity {
      self = Self()
    }
    else {
      replaceSubrange(startIndex..<endIndex, with: EmptyCollection())
    }
  }
  @inlinable public mutating func reserveCapacity(_ n: Swift.Int) {}
}
extension Swift.RangeReplaceableCollection where Self == Self.SubSequence {
  @discardableResult
  @inlinable public mutating func removeFirst() -> Self.Element {
    _precondition(!isEmpty, "Can't remove items from an empty collection")
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
  @inlinable public mutating func removeFirst(_ k: Swift.Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    guard let idx = index(startIndex, offsetBy: k, limitedBy: endIndex) else {
      _preconditionFailure(
        "Can't remove more items from a collection than it contains")
    }
    self = self[idx..<endIndex]
  }
}
extension Swift.RangeReplaceableCollection {
  @inlinable public mutating func replaceSubrange<C, R>(_ subrange: R, with newElements: __owned C) where C : Swift.Collection, R : Swift.RangeExpression, Self.Element == C.Element, Self.Index == R.Bound {
    self.replaceSubrange(subrange.relative(to: self), with: newElements)
  }
  @available(*, unavailable)
  @_alwaysEmitIntoClient public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Self.Index>, with newElements: C) where C : Swift.Collection, Self.Element == C.Element {
    fatalError()
  }
  @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : Swift.RangeExpression, Self.Index == R.Bound {
    removeSubrange(bounds.relative(to: self))
  }
}
extension Swift.RangeReplaceableCollection {
  @inlinable public mutating func _customRemoveLast() -> Self.Element? {
    return nil
  }
  @inlinable public mutating func _customRemoveLast(_ n: Swift.Int) -> Swift.Bool {
    return false
  }
}
extension Swift.RangeReplaceableCollection where Self : Swift.BidirectionalCollection, Self == Self.SubSequence {
  @inlinable public mutating func _customRemoveLast() -> Self.Element? {
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
  @inlinable public mutating func _customRemoveLast(_ n: Swift.Int) -> Swift.Bool {
    guard let end = index(endIndex, offsetBy: -n, limitedBy: startIndex)
    else {
      _preconditionFailure(
        "Can't remove more items from a collection than it contains")
    }
    self = self[startIndex..<end]
    return true
  }
}
extension Swift.RangeReplaceableCollection where Self : Swift.BidirectionalCollection {
  @inlinable public mutating func popLast() -> Self.Element? {
    if isEmpty { return nil }
     
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
  @discardableResult
  @inlinable public mutating func removeLast() -> Self.Element {
    _precondition(!isEmpty, "Can't remove last element from an empty collection")
     
     
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
  @inlinable public mutating func removeLast(_ k: Swift.Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    if _customRemoveLast(k) {
      return
    }
    let end = endIndex
    guard let start = index(end, offsetBy: -k, limitedBy: startIndex)
    else {
      _preconditionFailure(
        "Can't remove more items from a collection than it contains")
    }

    removeSubrange(start..<end)
  }
}
extension Swift.RangeReplaceableCollection where Self : Swift.BidirectionalCollection, Self == Self.SubSequence {
  @inlinable public mutating func popLast() -> Self.Element? {
    if isEmpty { return nil }
     
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
  @discardableResult
  @inlinable public mutating func removeLast() -> Self.Element {
    _precondition(!isEmpty, "Can't remove last element from an empty collection")
     
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
  @inlinable public mutating func removeLast(_ k: Swift.Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    if _customRemoveLast(k) {
      return
    }
    let end = endIndex
    guard let start = index(end, offsetBy: -k, limitedBy: startIndex)
    else {
      _preconditionFailure(
        "Can't remove more items from a collection than it contains")
    }
    removeSubrange(start..<end)
  }
}
extension Swift.RangeReplaceableCollection {
  @inlinable public static func + <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.Sequence, Self.Element == Other.Element {
    var lhs = lhs
     
    lhs.append(contentsOf: rhs)
    return lhs
  }
  @inlinable public static func + <Other>(lhs: Other, rhs: Self) -> Self where Other : Swift.Sequence, Self.Element == Other.Element {
    var result = Self()
    result.reserveCapacity(rhs.count + lhs.underestimatedCount)
    result.append(contentsOf: lhs)
    result.append(contentsOf: rhs)
    return result
  }
  @inlinable public static func += <Other>(lhs: inout Self, rhs: Other) where Other : Swift.Sequence, Self.Element == Other.Element {
    lhs.append(contentsOf: rhs)
  }
  @inlinable public static func + <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.RangeReplaceableCollection, Self.Element == Other.Element {
    var lhs = lhs
     
    lhs.append(contentsOf: rhs)
    return lhs
  }
}
extension Swift.RangeReplaceableCollection {
  @available(swift 4.0)
  @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Swift.Bool) rethrows -> Self {
    var result = Self()
    for element in self where try isIncluded(element) {
      result.append(element)
    }
    return result
  }
}
extension Swift.RangeReplaceableCollection where Self : Swift.MutableCollection {
  @inlinable public mutating func removeAll(where shouldBeRemoved: (Self.Element) throws -> Swift.Bool) rethrows {
    let suffixStart = try _halfStablePartition(isSuffixElement: shouldBeRemoved)
    removeSubrange(suffixStart...)
  }
}
extension Swift.RangeReplaceableCollection {
  @inlinable public mutating func removeAll(where shouldBeRemoved: (Self.Element) throws -> Swift.Bool) rethrows {
    self = try filter { try !shouldBeRemoved($0) }
  }
}
extension Swift.RangeReplaceableCollection {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public mutating func removeSubranges(_ subranges: Swift.RangeSet<Self.Index>) {
    guard !subranges.isEmpty else {
      return
    }
    
    let inversion = subranges._inverted(within: self)
    var result = Self()
    for range in inversion.ranges {
      result.append(contentsOf: self[range])
    }
    self = result
  }
}
extension Swift.MutableCollection where Self : Swift.RangeReplaceableCollection {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public mutating func removeSubranges(_ subranges: Swift.RangeSet<Self.Index>) {
    guard let firstRange = subranges.ranges.first else {
      return
    }
    
    var endOfElementsToKeep = firstRange.lowerBound
    var firstUnprocessed = firstRange.upperBound
    
     
     
     
     
     
     
     
     
     
     
     
     
     
    for range in subranges.ranges.dropFirst() {
      let nextLow = range.lowerBound
      while firstUnprocessed != nextLow {
        swapAt(endOfElementsToKeep, firstUnprocessed)
        formIndex(after: &endOfElementsToKeep)
        formIndex(after: &firstUnprocessed)
      }
      
      firstUnprocessed = range.upperBound
    }
    
     
     
    while firstUnprocessed != endIndex {
      swapAt(endOfElementsToKeep, firstUnprocessed)
      formIndex(after: &endOfElementsToKeep)
      formIndex(after: &firstUnprocessed)
    }
    
    removeSubrange(endOfElementsToKeep..<endIndex)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public struct RangeSet<Bound> where Bound : Swift.Comparable {
  @usableFromInline
  internal var _ranges: Swift.RangeSet<Bound>.Ranges
  public var ranges: Swift.RangeSet<Bound>.Ranges {
    get
  }
  public init()
  public init(_ range: Swift.Range<Bound>)
  public init(_ ranges: some Sequence<Range<Bound>>)
  @usableFromInline
  internal init(_ranges: Swift.RangeSet<Bound>.Ranges)
  @usableFromInline
  internal func _checkInvariants()
  @usableFromInline
  internal init(_orderedRanges ranges: [Swift.Range<Bound>])
  public var isEmpty: Swift.Bool {
    get
  }
  public func contains(_ value: Bound) -> Swift.Bool
  @inlinable public mutating func insert(contentsOf range: Swift.Range<Bound>) {
    if range.isEmpty { return }
    _ranges._insert(contentsOf: range)
  }
  public mutating func remove(contentsOf range: Swift.Range<Bound>)
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet : Swift.Equatable {
  public static func == (left: Swift.RangeSet<Bound>, right: Swift.RangeSet<Bound>) -> Swift.Bool
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet : Swift.Hashable where Bound : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet : Swift.Sendable where Bound : Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet {
  @inlinable public init<S, C>(_ indices: S, within collection: C) where Bound == S.Element, S : Swift.Sequence, C : Swift.Collection, S.Element == C.Index {
    self.init()
    for i in indices {
      self.insert(i, within: collection)
    }
  }
  @discardableResult
  public mutating func insert<C>(_ index: Bound, within collection: C) -> Swift.Bool where Bound == C.Index, C : Swift.Collection
  public mutating func remove<C>(_ index: Bound, within collection: C) where Bound == C.Index, C : Swift.Collection
  @usableFromInline
  internal func _inverted<C>(within collection: C) -> Swift.RangeSet<Bound> where Bound == C.Index, C : Swift.Collection
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet {
  public mutating func formUnion(_ other: __owned Swift.RangeSet<Bound>)
  public mutating func formIntersection(_ other: Swift.RangeSet<Bound>)
  public mutating func formSymmetricDifference(_ other: __owned Swift.RangeSet<Bound>)
  public mutating func subtract(_ other: Swift.RangeSet<Bound>)
  public __consuming func union(_ other: __owned Swift.RangeSet<Bound>) -> Swift.RangeSet<Bound>
  public __consuming func intersection(_ other: Swift.RangeSet<Bound>) -> Swift.RangeSet<Bound>
  public __consuming func symmetricDifference(_ other: __owned Swift.RangeSet<Bound>) -> Swift.RangeSet<Bound>
  public __consuming func subtracting(_ other: Swift.RangeSet<Bound>) -> Swift.RangeSet<Bound>
  public func isSubset(of other: Swift.RangeSet<Bound>) -> Swift.Bool
  public func isSuperset(of other: Swift.RangeSet<Bound>) -> Swift.Bool
  public func isStrictSubset(of other: Swift.RangeSet<Bound>) -> Swift.Bool
  public func isStrictSuperset(of other: Swift.RangeSet<Bound>) -> Swift.Bool
  public func isDisjoint(_ other: Swift.RangeSet<Bound>) -> Swift.Bool
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet {
  public struct Ranges {
    @usableFromInline
    internal init()
    @usableFromInline
    internal init(_range: Swift.Range<Bound>)
    @usableFromInline
    internal init(_ranges: [Swift.Range<Bound>])
    @usableFromInline
    internal init(_unorderedRanges: [Swift.Range<Bound>])
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet.Ranges {
  @usableFromInline
  internal func _contains(_ bound: Bound) -> Swift.Bool
  @usableFromInline
  internal func _indicesOfRange(_ range: Swift.Range<Bound>, in subranges: Swift.ContiguousArray<Swift.Range<Bound>>, includeAdjacent: Swift.Bool = true) -> Swift.Range<Swift.Int>
  @usableFromInline
  @discardableResult
  internal mutating func _insert(contentsOf range: Swift.Range<Bound>) -> Swift.Bool
  @usableFromInline
  internal mutating func _remove(contentsOf range: Swift.Range<Bound>)
  @usableFromInline
  internal func _gaps(boundedBy bounds: Swift.Range<Bound>) -> Swift.RangeSet<Bound>.Ranges
  @usableFromInline
  internal func _intersection(_ other: Swift.RangeSet<Bound>.Ranges) -> Swift.RangeSet<Bound>.Ranges
  @usableFromInline
  internal func _union(_ other: Swift.RangeSet<Bound>.Ranges) -> Swift.RangeSet<Bound>.Ranges
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet.Ranges : Swift.Sequence {
  public typealias Element = Swift.Range<Bound>
  public typealias Iterator = Swift.IndexingIterator<Swift.RangeSet<Bound>.Ranges>
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet.Ranges : Swift.Collection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.RangeSet<Bound>.Ranges.Index>
  public typealias SubSequence = Swift.Slice<Swift.RangeSet<Bound>.Ranges>
  public var startIndex: Swift.RangeSet<Bound>.Ranges.Index {
    get
  }
  public var endIndex: Swift.RangeSet<Bound>.Ranges.Index {
    get
  }
  public var count: Swift.Int {
    get
  }
  public subscript(i: Swift.RangeSet<Bound>.Ranges.Index) -> Swift.RangeSet<Bound>.Ranges.Element {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet.Ranges : Swift.RandomAccessCollection {
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet.Ranges : Swift.Equatable {
  public static func == (left: Swift.RangeSet<Bound>.Ranges, right: Swift.RangeSet<Bound>.Ranges) -> Swift.Bool
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet.Ranges : Swift.Hashable where Bound : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet.Ranges : Swift.Sendable where Bound : Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RangeSet.Ranges : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@frozen public struct Repeated<Element> {
  public let count: Swift.Int
  public let repeatedValue: Element
  @inlinable internal init(_repeating repeatedValue: Element, count: Swift.Int) {
    _precondition(count >= 0, "Repetition count should be non-negative")
    self.count = count
    self.repeatedValue = repeatedValue
  }
}
extension Swift.Repeated : Swift.RandomAccessCollection {
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Index = Swift.Int
  @inlinable public var startIndex: Swift.Repeated<Element>.Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.Repeated<Element>.Index {
    get {
    return count
  }
  }
  @inlinable public subscript(position: Swift.Int) -> Element {
    get {
    _precondition(position >= 0 && position < count, "Index out of range")
    return repeatedValue
  }
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.Repeated<Element>>
  public typealias SubSequence = Swift.Slice<Swift.Repeated<Element>>
}
@inlinable public func repeatElement<T>(_ element: T, count n: Swift.Int) -> Swift.Repeated<T> {
  return Repeated(_repeating: element, count: n)
}
extension Swift.Repeated : Swift.Sendable where Element : Swift.Sendable {
}
public func _replPrintLiteralString(_ text: Swift.String)
@inline(never) public func _replDebugPrintln<T>(_ value: T)
#if compiler(>=5.3) && $NoncopyableGenerics
@frozen public enum Result<Success, Failure> where Failure : Swift.Error, Success : ~Copyable {
  case success(Success)
  case failure(Failure)
}
#else
@frozen public enum Result<Success, Failure> where Failure : Swift.Error {
  case success(Success)
  case failure(Failure)
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result : Swift.Copyable where Success : Swift.Copyable {
}
#else
extension Swift.Result {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result : Swift.Sendable where Success : Swift.Sendable, Success : ~Copyable {
}
#else
extension Swift.Result : Swift.Sendable where Success : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result : Swift.Equatable where Success : Swift.Equatable, Failure : Swift.Equatable {
  public static func == (a: Swift.Result<Success, Failure>, b: Swift.Result<Success, Failure>) -> Swift.Bool
}
#else
extension Swift.Result : Swift.Equatable where Success : Swift.Equatable, Failure : Swift.Equatable {
  public static func == (a: Swift.Result<Success, Failure>, b: Swift.Result<Success, Failure>) -> Swift.Bool
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result : Swift.Hashable where Success : Swift.Hashable, Failure : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
#else
extension Swift.Result : Swift.Hashable where Success : Swift.Hashable, Failure : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result {
  @_alwaysEmitIntoClient @_disfavoredOverload public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> Swift.Result<NewSuccess, Failure> where NewSuccess : ~Copyable {
    switch self {
    case let .success(success):
      return .success(transform(success))
    case let .failure(failure):
      return .failure(failure)
    }
  }
}
#else
extension Swift.Result {
  @_alwaysEmitIntoClient @_disfavoredOverload public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> Swift.Result<NewSuccess, Failure> {
    switch self {
    case let .success(success):
      return .success(transform(success))
    case let .failure(failure):
      return .failure(failure)
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result where Success : ~Copyable {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public consuming func _consumingMap<NewSuccess>(_ transform: (consuming Success) -> NewSuccess) -> Swift.Result<NewSuccess, Failure> where NewSuccess : ~Copyable {
    switch consume self {
    case let .success(success):
      return .success(transform(consume success))
    case let .failure(failure):
      return .failure(consume failure)
    }
  }
  #else
  @_alwaysEmitIntoClient public consuming func _consumingMap<NewSuccess>(_ transform: (consuming Success) -> NewSuccess) -> Swift.Result<NewSuccess, Failure> {
    switch consume self {
    case let .success(success):
      return .success(transform(consume success))
    case let .failure(failure):
      return .failure(consume failure)
    }
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public borrowing func _borrowingMap<NewSuccess>(_ transform: (borrowing Success) -> NewSuccess) -> Swift.Result<NewSuccess, Failure> where NewSuccess : ~Copyable {
    switch self {
    case .success(let success):
      return .success(transform(success))
    case let .failure(failure):
      return .failure(failure)
    }
  }
  #else
  @_alwaysEmitIntoClient public borrowing func _borrowingMap<NewSuccess>(_ transform: (borrowing Success) -> NewSuccess) -> Swift.Result<NewSuccess, Failure> {
    switch self {
    case .success(let success):
      return .success(transform(success))
    case let .failure(failure):
      return .failure(failure)
    }
  }
  #endif
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result where Success : ~Copyable {
  @_alwaysEmitIntoClient public consuming func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> Swift.Result<Success, NewFailure> where NewFailure : Swift.Error {
    switch consume self {
    case let .success(success):
      return .success(consume success)
    case let .failure(failure):
      return .failure(transform(failure))
    }
  }
}
#else
extension Swift.Result {
  @_alwaysEmitIntoClient public consuming func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> Swift.Result<Success, NewFailure> where NewFailure : Swift.Error {
    switch consume self {
    case let .success(success):
      return .success(consume success)
    case let .failure(failure):
      return .failure(transform(failure))
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result {
  @_alwaysEmitIntoClient @_disfavoredOverload public func flatMap<NewSuccess>(_ transform: (Success) -> Swift.Result<NewSuccess, Failure>) -> Swift.Result<NewSuccess, Failure> where NewSuccess : ~Copyable {
    switch self {
    case let .success(success):
      return transform(success)
    case let .failure(failure):
      return .failure(failure)
    }
  }
}
#else
extension Swift.Result {
  @_alwaysEmitIntoClient @_disfavoredOverload public func flatMap<NewSuccess>(_ transform: (Success) -> Swift.Result<NewSuccess, Failure>) -> Swift.Result<NewSuccess, Failure> {
    switch self {
    case let .success(success):
      return transform(success)
    case let .failure(failure):
      return .failure(failure)
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result where Success : ~Copyable {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public consuming func _consumingFlatMap<NewSuccess>(_ transform: (consuming Success) -> Swift.Result<NewSuccess, Failure>) -> Swift.Result<NewSuccess, Failure> where NewSuccess : ~Copyable {
    switch consume self {
    case let .success(success):
      return transform(consume success)
    case let .failure(failure):
      return .failure(failure)
    }
  }
  #else
  @_alwaysEmitIntoClient public consuming func _consumingFlatMap<NewSuccess>(_ transform: (consuming Success) -> Swift.Result<NewSuccess, Failure>) -> Swift.Result<NewSuccess, Failure> {
    switch consume self {
    case let .success(success):
      return transform(consume success)
    case let .failure(failure):
      return .failure(failure)
    }
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public borrowing func _borrowingFlatMap<NewSuccess>(_ transform: (borrowing Success) -> Swift.Result<NewSuccess, Failure>) -> Swift.Result<NewSuccess, Failure> where NewSuccess : ~Copyable {
    switch self {
    case .success(let success):
      return transform(success)
    case let .failure(failure):
      return .failure(failure)
    }
  }
  #else
  @_alwaysEmitIntoClient public borrowing func _borrowingFlatMap<NewSuccess>(_ transform: (borrowing Success) -> Swift.Result<NewSuccess, Failure>) -> Swift.Result<NewSuccess, Failure> {
    switch self {
    case .success(let success):
      return transform(success)
    case let .failure(failure):
      return .failure(failure)
    }
  }
  #endif
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result where Success : ~Copyable {
  @_alwaysEmitIntoClient public consuming func flatMapError<NewFailure>(_ transform: (Failure) -> Swift.Result<Success, NewFailure>) -> Swift.Result<Success, NewFailure> where NewFailure : Swift.Error {
    switch consume self {
    case let .success(success):
      return .success(success)
    case let .failure(failure):
      return transform(failure)
    }
  }
}
#else
extension Swift.Result {
  @_alwaysEmitIntoClient public consuming func flatMapError<NewFailure>(_ transform: (Failure) -> Swift.Result<Success, NewFailure>) -> Swift.Result<Success, NewFailure> where NewFailure : Swift.Error {
    switch consume self {
    case let .success(success):
      return .success(success)
    case let .failure(failure):
      return transform(failure)
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result where Success : ~Copyable {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public consuming func get() throws(Failure) -> Success {
    switch consume self {
    case let .success(success):
      return success
    case let .failure(failure):
      throw failure
    }
  }
  #endif
}
#else
extension Swift.Result {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public consuming func get() throws(Failure) -> Success {
    switch consume self {
    case let .success(success):
      return success
    case let .failure(failure):
      throw failure
    }
  }
  #endif
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result where Success : ~Copyable {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public init(catching body: () throws(Failure) -> Success) {
    do {
      self = .success(try body())
    } catch {
      self = .failure(error)
    }
  }
  #endif
}
#else
extension Swift.Result {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public init(catching body: () throws(Failure) -> Success) {
    do {
      self = .success(try body())
    } catch {
      self = .failure(error)
    }
  }
  #endif
}
#endif
extension Swift.MutableCollection where Self : Swift.BidirectionalCollection {
  @inlinable public mutating func reverse() {
    if isEmpty { return }
    var f = startIndex
    var l = index(before: endIndex)
    while f < l {
      swapAt(f, l)
      formIndex(after: &f)
      formIndex(before: &l)
    }
  }
}
@frozen public struct ReversedCollection<Base> where Base : Swift.BidirectionalCollection {
  public let _base: Base
  @inlinable internal init(_base: Base) {
    self._base = _base
  }
}
extension Swift.ReversedCollection : Swift.Sendable where Base : Swift.Sendable {
}
extension Swift.ReversedCollection {
  @frozen public struct Iterator {
    @usableFromInline
    internal let _base: Base
    @usableFromInline
    internal var _position: Base.Index
    @inlinable @inline(__always) public init(_base: Base) {
      self._base = _base
      self._position = _base.endIndex
    }
  }
}
extension Swift.ReversedCollection.Iterator : Swift.Sendable where Base : Swift.Sendable, Base.Index : Swift.Sendable {
}
extension Swift.ReversedCollection.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  public typealias Element = Base.Element
  @inlinable @inline(__always) public mutating func next() -> Swift.ReversedCollection<Base>.Iterator.Element? {
    guard _fastPath(_position != _base.startIndex) else { return nil }
    _base.formIndex(before: &_position)
    return _base[_position]
  }
  public typealias Iterator = Swift.ReversedCollection<Base>.Iterator
}
extension Swift.ReversedCollection : Swift.Sequence {
  public typealias Element = Base.Element
  @inlinable @inline(__always) public __consuming func makeIterator() -> Swift.ReversedCollection<Base>.Iterator {
    return Iterator(_base: _base)
  }
}
extension Swift.ReversedCollection {
  @frozen public struct Index {
    public let base: Base.Index
    @inlinable public init(_ base: Base.Index) {
      self.base = base
    }
  }
}
extension Swift.ReversedCollection.Index : Swift.Sendable where Base.Index : Swift.Sendable {
}
extension Swift.ReversedCollection.Index : Swift.Comparable {
  @inlinable public static func == (lhs: Swift.ReversedCollection<Base>.Index, rhs: Swift.ReversedCollection<Base>.Index) -> Swift.Bool {
     
    return lhs.base == rhs.base
  }
  @inlinable public static func < (lhs: Swift.ReversedCollection<Base>.Index, rhs: Swift.ReversedCollection<Base>.Index) -> Swift.Bool {
     
    return lhs.base > rhs.base
  }
}
extension Swift.ReversedCollection.Index : Swift.Hashable where Base.Index : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(base)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.ReversedCollection : Swift.BidirectionalCollection {
  @inlinable public var startIndex: Swift.ReversedCollection<Base>.Index {
    get {
    return Index(_base.endIndex)
  }
  }
  @inlinable public var endIndex: Swift.ReversedCollection<Base>.Index {
    get {
    return Index(_base.startIndex)
  }
  }
  @inlinable public func index(after i: Swift.ReversedCollection<Base>.Index) -> Swift.ReversedCollection<Base>.Index {
    return Index(_base.index(before: i.base))
  }
  @inlinable public func index(before i: Swift.ReversedCollection<Base>.Index) -> Swift.ReversedCollection<Base>.Index {
    return Index(_base.index(after: i.base))
  }
  @inlinable public func index(_ i: Swift.ReversedCollection<Base>.Index, offsetBy n: Swift.Int) -> Swift.ReversedCollection<Base>.Index {
     
    return Index(_base.index(i.base, offsetBy: -n))
  }
  @inlinable public func index(_ i: Swift.ReversedCollection<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.ReversedCollection<Base>.Index) -> Swift.ReversedCollection<Base>.Index? {
     
    return _base.index(i.base, offsetBy: -n, limitedBy: limit.base)
                .map(Index.init)
  }
  @inlinable public func distance(from start: Swift.ReversedCollection<Base>.Index, to end: Swift.ReversedCollection<Base>.Index) -> Swift.Int {
    return _base.distance(from: end.base, to: start.base)
  }
  @inlinable public subscript(position: Swift.ReversedCollection<Base>.Index) -> Swift.ReversedCollection<Base>.Element {
    get {
    return _base[_base.index(before: position.base)]
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.ReversedCollection<Base>>
  public typealias SubSequence = Swift.Slice<Swift.ReversedCollection<Base>>
}
extension Swift.ReversedCollection : Swift.RandomAccessCollection where Base : Swift.RandomAccessCollection {
}
extension Swift.ReversedCollection {
  @available(swift 4.2)
  @inlinable public __consuming func reversed() -> Base {
    return _base
  }
}
extension Swift.BidirectionalCollection {
  @inlinable public __consuming func reversed() -> Swift.ReversedCollection<Self> {
    return ReversedCollection(_base: self)
  }
}
@_transparent public func _stdlib_atomicCompareExchangeStrongPtr(object target: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer?>, expected: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer?>, desired: Swift.UnsafeRawPointer?) -> Swift.Bool {
   
  let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Word(
    target._rawValue,
    UInt(bitPattern: expected.pointee)._builtinWordValue,
    UInt(bitPattern: desired)._builtinWordValue)
  expected.pointee = UnsafeRawPointer(bitPattern: Int(oldValue))
  return Bool(won)
}
@_transparent public func _stdlib_atomicCompareExchangeStrongPtr<T>(object target: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<T>>, expected: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<T>>, desired: Swift.UnsafeMutablePointer<T>) -> Swift.Bool {
  let rawTarget = UnsafeMutableRawPointer(target).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  let rawExpected = UnsafeMutableRawPointer(expected).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  return _stdlib_atomicCompareExchangeStrongPtr(
    object: rawTarget,
    expected: rawExpected,
    desired: UnsafeRawPointer(desired))
}
@_transparent public func _stdlib_atomicCompareExchangeStrongPtr<T>(object target: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<T>?>, expected: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<T>?>, desired: Swift.UnsafeMutablePointer<T>?) -> Swift.Bool {
  let rawTarget = UnsafeMutableRawPointer(target).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  let rawExpected = UnsafeMutableRawPointer(expected).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  return _stdlib_atomicCompareExchangeStrongPtr(
    object: rawTarget,
    expected: rawExpected,
    desired: UnsafeRawPointer(desired))
}
@discardableResult
@_transparent public func _stdlib_atomicInitializeARCRef(object target: Swift.UnsafeMutablePointer<Swift.AnyObject?>, desired: Swift.AnyObject) -> Swift.Bool {
   
   
  var expected: UnsafeRawPointer? = nil
  let unmanaged = Unmanaged.passRetained(desired)
  let desiredPtr = unmanaged.toOpaque()
  let rawTarget = UnsafeMutableRawPointer(target).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
#if $TypedThrows
  let wonRace = withUnsafeMutablePointer(to: &expected) {
    _stdlib_atomicCompareExchangeStrongPtr(
      object: rawTarget, expected: $0, desired: desiredPtr
    )
  }
#else
  let wonRace = __abi_se0413_withUnsafeMutablePointer(to: &expected) {
    _stdlib_atomicCompareExchangeStrongPtr(
      object: rawTarget, expected: $0, desired: desiredPtr
    )
  }
#endif
  if !wonRace {
     
     
    unmanaged.release()
  }
  return wonRace
}
@_transparent public func _stdlib_atomicLoadARCRef(object target: Swift.UnsafeMutablePointer<Swift.AnyObject?>) -> Swift.AnyObject? {
  let value = Builtin.atomicload_seqcst_Word(target._rawValue)
  if let unwrapped = UnsafeRawPointer(bitPattern: Int(value)) {
    return Unmanaged<AnyObject>.fromOpaque(unwrapped).takeUnretainedValue()
  }
  return nil
}
@discardableResult
@_transparent @_alwaysEmitIntoClient public func _stdlib_atomicAcquiringInitializeARCRef<T>(object target: Swift.UnsafeMutablePointer<T?>, desired: __owned T) -> Swift.Unmanaged<T> where T : AnyObject {
   
   
   
  let unmanaged = Unmanaged.passRetained(desired)
  let desiredPtr = unmanaged.toOpaque()

  let (value, won) = Builtin.cmpxchg_acqrel_acquire_Word(
    target._rawValue,
    0._builtinWordValue,
    Builtin.ptrtoint_Word(desiredPtr._rawValue))

  if Bool(won) { return unmanaged }

   
   
  unmanaged.release()
  let ptr = UnsafeRawPointer(Builtin.inttoptr_Word(value))
  return Unmanaged<T>.fromOpaque(ptr)
}
@_alwaysEmitIntoClient @_transparent public func _stdlib_atomicAcquiringLoadARCRef<T>(object target: Swift.UnsafeMutablePointer<T?>) -> Swift.Unmanaged<T>? where T : AnyObject {
  let value = Builtin.atomicload_acquire_Word(target._rawValue)
  if Int(value) == 0 { return nil }
  let opaque = UnsafeRawPointer(Builtin.inttoptr_Word(value))
  return Unmanaged<T>.fromOpaque(opaque)
}
public func _uint64ToString(_ value: Swift.UInt64, radix: Swift.Int64 = 10, uppercase: Swift.Bool = false) -> Swift.String
@inlinable internal func _rawPointerToString(_ value: Builtin.RawPointer) -> Swift.String {
  var result = _uint64ToString(
    UInt64(
      UInt(bitPattern: UnsafeRawPointer(value))),
      radix: 16,
      uppercase: false
    )
  for _ in 0..<(2 * MemoryLayout<UnsafeRawPointer>.size - result.utf16.count) {
    result = "0" + result
  }
  return "0x" + result
}
@usableFromInline
@_fixed_layout @objc @_swift_native_objc_runtime_base(__SwiftNativeNSArrayBase) internal class __SwiftNativeNSArray {
  @inlinable @nonobjc internal init() {}
  @objc @inlinable deinit {}
}
@available(*, unavailable)
extension Swift.__SwiftNativeNSArray : Swift.Sendable {
}
@usableFromInline
@_fixed_layout @objc @_swift_native_objc_runtime_base(__SwiftNativeNSMutableArrayBase) internal class _SwiftNativeNSMutableArray {
  @inlinable @nonobjc internal init() {}
  @objc @inlinable deinit {}
}
@available(*, unavailable)
extension Swift._SwiftNativeNSMutableArray : Swift.Sendable {
}
@_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @objc @_swift_native_objc_runtime_base(__SwiftNativeNSDictionaryBase) internal class __SwiftNativeNSDictionary {
  @objc public init(coder: Swift.AnyObject)
  @objc deinit
}
@available(*, unavailable)
extension Swift.__SwiftNativeNSDictionary : Swift.Sendable {
}
@_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @objc @_swift_native_objc_runtime_base(__SwiftNativeNSSetBase) internal class __SwiftNativeNSSet {
  @objc public init(coder: Swift.AnyObject)
  @objc deinit
}
@available(*, unavailable)
extension Swift.__SwiftNativeNSSet : Swift.Sendable {
}
public func _stdlib_initializeReturnAutoreleased()
extension Swift.Hasher {
  @usableFromInline
  @frozen internal struct _State {
    private var v0: Swift.UInt64 = 0x736f6d6570736575
    private var v1: Swift.UInt64 = 0x646f72616e646f6d
    private var v2: Swift.UInt64 = 0x6c7967656e657261
    private var v3: Swift.UInt64 = 0x7465646279746573
    private var v4: Swift.UInt64 = 0
    private var v5: Swift.UInt64 = 0
    private var v6: Swift.UInt64 = 0
    private var v7: Swift.UInt64 = 0
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol IteratorProtocol<Element> {
  associatedtype Element
  mutating func next() -> Self.Element?
}
#else
public protocol IteratorProtocol {
  associatedtype Element
  mutating func next() -> Self.Element?
}
#endif
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol Sequence<Element> {
  associatedtype Element where Self.Element == Self.Iterator.Element
  associatedtype Iterator : Swift.IteratorProtocol
  @available(*, unavailable, renamed: "Iterator")
  typealias Generator = Self.Iterator
  __consuming func makeIterator() -> Self.Iterator
  var underestimatedCount: Swift.Int { get }
  func _customContainsEquatableElement(_ element: Self.Element) -> Swift.Bool?
  __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
  __consuming func _copyContents(initializing ptr: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.UnsafeMutableBufferPointer<Self.Element>.Index)
  func withContiguousStorageIfAvailable<R>(_ body: (_ buffer: Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R?
}
#else
public protocol Sequence {
  associatedtype Element where Self.Element == Self.Iterator.Element
  associatedtype Iterator : Swift.IteratorProtocol
  @available(*, unavailable, renamed: "Iterator")
  typealias Generator = Self.Iterator
  __consuming func makeIterator() -> Self.Iterator
  var underestimatedCount: Swift.Int { get }
  func _customContainsEquatableElement(_ element: Self.Element) -> Swift.Bool?
  __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
  __consuming func _copyContents(initializing ptr: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.UnsafeMutableBufferPointer<Self.Element>.Index)
  func withContiguousStorageIfAvailable<R>(_ body: (_ buffer: Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R?
}
#endif
extension Swift.Sequence where Self : Swift.IteratorProtocol {
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @_implements(Swift.Sequence, Iterator) public typealias _Default_Iterator = Self
  #else
  public typealias _Default_Iterator = Self
  #endif
}
extension Swift.Sequence where Self == Self.Iterator {
  @inlinable public __consuming func makeIterator() -> Self {
    return self
  }
}
@frozen public struct DropFirstSequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal let _base: Base
  @usableFromInline
  internal let _limit: Swift.Int
  @inlinable public init(_ base: Base, dropping limit: Swift.Int) {
    _precondition(limit >= 0, 
      "Can't drop a negative number of elements from a sequence")
    _base = base
    _limit = limit
  }
}
extension Swift.DropFirstSequence : Swift.Sendable where Base : Swift.Sendable {
}
extension Swift.DropFirstSequence : Swift.Sequence {
  public typealias Element = Base.Element
  public typealias Iterator = Base.Iterator
  public typealias SubSequence = Swift.AnySequence<Swift.DropFirstSequence<Base>.Element>
  @inlinable public __consuming func makeIterator() -> Swift.DropFirstSequence<Base>.Iterator {
    var it = _base.makeIterator()
    var dropped = 0
    while dropped < _limit, it.next() != nil { dropped &+= 1 }
    return it
  }
  @inlinable public __consuming func dropFirst(_ k: Swift.Int) -> Swift.DropFirstSequence<Base> {
     
     
     
     
     
    return DropFirstSequence(_base, dropping: _limit + k)
  }
}
@frozen public struct PrefixSequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _maxLength: Swift.Int
  @inlinable public init(_ base: Base, maxLength: Swift.Int) {
    _precondition(maxLength >= 0, "Can't take a prefix of negative length")
    _base = base
    _maxLength = maxLength
  }
}
extension Swift.PrefixSequence : Swift.Sendable where Base : Swift.Sendable {
}
extension Swift.PrefixSequence {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal var _remaining: Swift.Int
    @inlinable internal init(_ base: Base.Iterator, maxLength: Swift.Int) {
      _base = base
      _remaining = maxLength
    }
  }
}
extension Swift.PrefixSequence.Iterator : Swift.Sendable where Base.Iterator : Swift.Sendable {
}
extension Swift.PrefixSequence.Iterator : Swift.IteratorProtocol {
  public typealias Element = Base.Element
  @inlinable public mutating func next() -> Swift.PrefixSequence<Base>.Iterator.Element? {
    if _remaining != 0 {
      _remaining &-= 1
      return _base.next()
    } else {
      return nil
    }
  }
}
extension Swift.PrefixSequence : Swift.Sequence {
  @inlinable public __consuming func makeIterator() -> Swift.PrefixSequence<Base>.Iterator {
    return Iterator(_base.makeIterator(), maxLength: _maxLength)
  }
  @inlinable public __consuming func prefix(_ maxLength: Swift.Int) -> Swift.PrefixSequence<Base> {
    let length = Swift.min(maxLength, self._maxLength)
    return PrefixSequence(_base, maxLength: length)
  }
  public typealias Element = Swift.PrefixSequence<Base>.Iterator.Element
}
@frozen public struct DropWhileSequence<Base> where Base : Swift.Sequence {
  public typealias Element = Base.Element
  @usableFromInline
  internal var _iterator: Base.Iterator
  @usableFromInline
  internal var _nextElement: Swift.DropWhileSequence<Base>.Element?
  @inlinable internal init(iterator: Base.Iterator, predicate: (Swift.DropWhileSequence<Base>.Element) throws -> Swift.Bool) rethrows {
    _iterator = iterator
    _nextElement = _iterator.next()
    
    while let x = _nextElement, try predicate(x) {
      _nextElement = _iterator.next()
    }
  }
  @inlinable internal init(_ base: Base, predicate: (Swift.DropWhileSequence<Base>.Element) throws -> Swift.Bool) rethrows {
    self = try DropWhileSequence(iterator: base.makeIterator(), predicate: predicate)
  }
}
extension Swift.DropWhileSequence : Swift.Sendable where Base.Element : Swift.Sendable, Base.Iterator : Swift.Sendable {
}
extension Swift.DropWhileSequence {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _iterator: Base.Iterator
    @usableFromInline
    internal var _nextElement: Swift.DropWhileSequence<Base>.Iterator.Element?
    @inlinable internal init(_ iterator: Base.Iterator, nextElement: Swift.DropWhileSequence<Base>.Iterator.Element?) {
      _iterator = iterator
      _nextElement = nextElement
    }
  }
}
extension Swift.DropWhileSequence.Iterator : Swift.Sendable where Base.Element : Swift.Sendable, Base.Iterator : Swift.Sendable {
}
extension Swift.DropWhileSequence.Iterator : Swift.IteratorProtocol {
  public typealias Element = Base.Element
  @inlinable public mutating func next() -> Swift.DropWhileSequence<Base>.Iterator.Element? {
    guard let next = _nextElement else { return nil }
    _nextElement = _iterator.next()
    return next
  }
}
extension Swift.DropWhileSequence : Swift.Sequence {
  @inlinable public func makeIterator() -> Swift.DropWhileSequence<Base>.Iterator {
    return Iterator(_iterator, nextElement: _nextElement)
  }
  @inlinable public __consuming func drop(while predicate: (Swift.DropWhileSequence<Base>.Element) throws -> Swift.Bool) rethrows -> Swift.DropWhileSequence<Base> {
    guard let x = _nextElement, try predicate(x) else { return self }
    return try DropWhileSequence(iterator: _iterator, predicate: predicate)
  }
}
extension Swift.Sequence {
  #if compiler(>=5.3) && $TypedThrows
  @inlinable @_alwaysEmitIntoClient public func map<T, E>(_ transform: (Self.Element) throws(E) -> T) throws(E) -> [T] where E : Swift.Error {
    let initialCapacity = underestimatedCount
    var result = ContiguousArray<T>()
    result.reserveCapacity(initialCapacity)

    var iterator = self.makeIterator()

     
    for _ in 0..<initialCapacity {
      result.append(try transform(iterator.next()!))
    }
     
    while let element = iterator.next() {
      result.append(try transform(element))
    }
    return Array(result)
  }
  #endif
  @usableFromInline
  @_silgen_name("$sSTsE3mapySayqd__Gqd__7ElementQzKXEKlF")
  internal func __rethrows_map<T>(_ transform: (Self.Element) throws -> T) throws -> [T]
  @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Swift.Bool) rethrows -> [Self.Element] {
    return try _filter(isIncluded)
  }
  @_transparent public func _filter(_ isIncluded: (Self.Element) throws -> Swift.Bool) rethrows -> [Self.Element] {

    var result = ContiguousArray<Element>()

    var iterator = self.makeIterator()

    while let element = iterator.next() {
      if try isIncluded(element) {
        result.append(element)
      }
    }

    return Array(result)
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return 0
  }
  }
  @inlinable @inline(__always) public func _customContainsEquatableElement(_ element: Self.Iterator.Element) -> Swift.Bool? {
    return nil
  }
  @_semantics("sequence.forEach") @inlinable public func forEach(_ body: (Self.Element) throws -> Swift.Void) rethrows {
    for element in self {
      try body(element)
    }
  }
}
extension Swift.Sequence {
  @inlinable public func first(where predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Element? {
    for element in self {
      if try predicate(element) {
        return element
      }
    }
    return nil
  }
}
extension Swift.Sequence where Self.Element : Swift.Equatable {
  @inlinable public __consuming func split(separator: Self.Element, maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true) -> [Swift.ArraySlice<Self.Element>] {
    return split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      whereSeparator: { $0 == separator })
  }
}
extension Swift.Sequence {
  @inlinable public __consuming func split(maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true, whereSeparator isSeparator: (Self.Element) throws -> Swift.Bool) rethrows -> [Swift.ArraySlice<Self.Element>] {
    _precondition(maxSplits >= 0, "Must take zero or more splits")
    let whole = Array(self)
    return try whole.split(
                  maxSplits: maxSplits, 
                  omittingEmptySubsequences: omittingEmptySubsequences, 
                  whereSeparator: isSeparator)
  }
  @inlinable public __consuming func suffix(_ maxLength: Swift.Int) -> [Self.Element] {
    _precondition(maxLength >= 0, "Can't take a suffix of negative length from a sequence")
    guard maxLength != 0 else { return [] }

     
     
     
     
    var ringBuffer = ContiguousArray<Element>()
    ringBuffer.reserveCapacity(Swift.min(maxLength, underestimatedCount))

    var i = 0

    for element in self {
      if ringBuffer.count < maxLength {
        ringBuffer.append(element)
      } else {
        ringBuffer[i] = element
        i += 1
        if i >= maxLength {
          i = 0
        }
      }
    }

    if i != ringBuffer.startIndex {
      var rotated = ContiguousArray<Element>()
      rotated.reserveCapacity(ringBuffer.count)
      rotated += ringBuffer[i..<ringBuffer.endIndex]
      rotated += ringBuffer[0..<i]
      return Array(rotated)
    } else {
      return Array(ringBuffer)
    }
  }
  @inlinable public __consuming func dropFirst(_ k: Swift.Int = 1) -> Swift.DropFirstSequence<Self> {
    return DropFirstSequence(self, dropping: k)
  }
  @inlinable public __consuming func dropLast(_ k: Swift.Int = 1) -> [Self.Element] {
    _precondition(k >= 0, "Can't drop a negative number of elements from a sequence")
    guard k != 0 else { return Array(self) }

     
     
     
     
     
     
    var result = ContiguousArray<Element>()
    var ringBuffer = ContiguousArray<Element>()
    var i = ringBuffer.startIndex

    for element in self {
      if ringBuffer.count < k {
        ringBuffer.append(element)
      } else {
        result.append(ringBuffer[i])
        ringBuffer[i] = element
        i += 1
        if i >= k {
          i = 0
        }
      }
    }
    return Array(result)
  }
  @inlinable public __consuming func drop(while predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Swift.DropWhileSequence<Self> {
    return try DropWhileSequence(self, predicate: predicate)
  }
  @inlinable public __consuming func prefix(_ maxLength: Swift.Int) -> Swift.PrefixSequence<Self> {
    return PrefixSequence(self, maxLength: maxLength)
  }
  @inlinable public __consuming func prefix(while predicate: (Self.Element) throws -> Swift.Bool) rethrows -> [Self.Element] {
    var result = ContiguousArray<Element>()

    for element in self {
      guard try predicate(element) else {
        break
      }
      result.append(element)
    }
    return Array(result)
  }
}
extension Swift.Sequence {
  @inlinable public __consuming func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.UnsafeMutableBufferPointer<Self.Element>.Index) {
    return _copySequenceContents(initializing: buffer)
  }
  @_alwaysEmitIntoClient internal __consuming func _copySequenceContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.UnsafeMutableBufferPointer<Self.Element>.Index) {
    var it = self.makeIterator()
    guard var ptr = buffer.baseAddress else { return (it, buffer.startIndex) }
    for idx in buffer.indices {
      guard let x = it.next() else {
        return (it, idx)
      }
      ptr.initialize(to: x)
      ptr += 1
    }
    return (it, buffer.endIndex)
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R? {
    return nil
  }
}
@frozen public struct IteratorSequence<Base> where Base : Swift.IteratorProtocol {
  @usableFromInline
  internal var _base: Base
  @inlinable public init(_ base: Base) {
    _base = base
  }
}
extension Swift.IteratorSequence : Swift.IteratorProtocol, Swift.Sequence {
  public typealias Element = Base.Element
  @inlinable public mutating func next() -> Base.Element? {
    return _base.next()
  }
  public typealias Iterator = Swift.IteratorSequence<Base>
}
extension Swift.IteratorSequence : Swift.Sendable where Base : Swift.Sendable {
}
extension Swift.Sequence {
  @inlinable public func enumerated() -> Swift.EnumeratedSequence<Self> {
    return EnumeratedSequence(_base: self)
  }
}
extension Swift.Sequence {
  @warn_unqualified_access
  @inlinable public func min(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows -> Self.Element? {
    var it = makeIterator()
    guard var result = it.next() else { return nil }
    while let e = it.next() {
      if try areInIncreasingOrder(e, result) { result = e }
    }
    return result
  }
  @warn_unqualified_access
  @inlinable public func max(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows -> Self.Element? {
    var it = makeIterator()
    guard var result = it.next() else { return nil }
    while let e = it.next() {
      if try areInIncreasingOrder(result, e) { result = e }
    }
    return result
  }
}
extension Swift.Sequence where Self.Element : Swift.Comparable {
  @warn_unqualified_access
  @inlinable public func min() -> Self.Element? {
    return self.min(by: <)
  }
  @warn_unqualified_access
  @inlinable public func max() -> Self.Element? {
    return self.max(by: <)
  }
}
extension Swift.Sequence {
  @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (Self.Element, PossiblePrefix.Element) throws -> Swift.Bool) rethrows -> Swift.Bool where PossiblePrefix : Swift.Sequence {
    var possiblePrefixIterator = possiblePrefix.makeIterator()
    for e0 in self {
      if let e1 = possiblePrefixIterator.next() {
        if try !areEquivalent(e0, e1) {
          return false
        }
      }
      else {
        return true
      }
    }
    return possiblePrefixIterator.next() == nil
  }
}
extension Swift.Sequence where Self.Element : Swift.Equatable {
  @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Swift.Bool where PossiblePrefix : Swift.Sequence, Self.Element == PossiblePrefix.Element {
    return self.starts(with: possiblePrefix, by: ==)
  }
}
extension Swift.Sequence {
  @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (Self.Element, OtherSequence.Element) throws -> Swift.Bool) rethrows -> Swift.Bool where OtherSequence : Swift.Sequence {
    var iter1 = self.makeIterator()
    var iter2 = other.makeIterator()
    while true {
      switch (iter1.next(), iter2.next()) {
      case let (e1?, e2?):
        if try !areEquivalent(e1, e2) {
          return false
        }
      case (_?, nil), (nil, _?): return false
      case (nil, nil):           return true
      }
    }
  }
}
extension Swift.Sequence where Self.Element : Swift.Equatable {
  @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Swift.Bool where OtherSequence : Swift.Sequence, Self.Element == OtherSequence.Element {
    return self.elementsEqual(other, by: ==)
  }
}
extension Swift.Sequence {
  @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows -> Swift.Bool where OtherSequence : Swift.Sequence, Self.Element == OtherSequence.Element {
    var iter1 = self.makeIterator()
    var iter2 = other.makeIterator()
    while true {
      guard let e1 = iter1.next() else {
        return iter2.next() != nil
      }
      guard let e2 = iter2.next() else {
        return false
      }
      if try areInIncreasingOrder(e1, e2) {
        return true
      }
      if try areInIncreasingOrder(e2, e1) {
        return false
      }
    }
  }
}
extension Swift.Sequence where Self.Element : Swift.Comparable {
  @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Swift.Bool where OtherSequence : Swift.Sequence, Self.Element == OtherSequence.Element {
    return self.lexicographicallyPrecedes(other, by: <)
  }
}
extension Swift.Sequence {
  @inlinable public func contains(where predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
    for e in self {
      if try predicate(e) {
        return true
      }
    }
    return false
  }
  @inlinable public func allSatisfy(_ predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
    return try !contains { try !predicate($0) }
  }
}
extension Swift.Sequence where Self.Element : Swift.Equatable {
  @inlinable public func contains(_ element: Self.Element) -> Swift.Bool {
    if let result = _customContainsEquatableElement(element) {
      return result
    } else {
      return self.contains { $0 == element }
    }
  }
}
extension Swift.Sequence {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func count<E>(where predicate: (Self.Element) throws(E) -> Swift.Bool) throws(E) -> Swift.Int where E : Swift.Error {
    var count = 0
    for e in self {
      count += try predicate(e) ? 1 : 0
    }
    return count
  }
  #endif
}
extension Swift.Sequence {
  @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result {
    var accumulator = initialResult
    for element in self {
      accumulator = try nextPartialResult(accumulator, element)
    }
    return accumulator
  }
  @inlinable public func reduce<Result>(into initialResult: __owned Result, _ updateAccumulatingResult: (_ partialResult: inout Result, Self.Element) throws -> ()) rethrows -> Result {
    var accumulator = initialResult
    for element in self {
      try updateAccumulatingResult(&accumulator, element)
    }
    return accumulator
  }
}
extension Swift.Sequence {
  @inlinable public __consuming func reversed() -> [Self.Element] {
     
     
     
    var result = Array(self)
    let count = result.count
    for i in 0..<count/2 {
      result.swapAt(i, count - ((i + 1) as Int))
    }
    return result
  }
}
extension Swift.Sequence {
  @inlinable public func flatMap<SegmentOfResult>(_ transform: (Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Swift.Sequence {
    var result: [SegmentOfResult.Element] = []
    for element in self {
      result.append(contentsOf: try transform(element))
    }
    return result
  }
}
extension Swift.Sequence {
  @inlinable public func compactMap<ElementOfResult>(_ transform: (Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult] {
    return try _compactMap(transform)
  }
  @inlinable @inline(__always) public func _compactMap<ElementOfResult>(_ transform: (Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult] {
    var result: [ElementOfResult] = []
    for element in self {
      if let newElement = try transform(element) {
        result.append(newElement)
      }
    }
    return result
  }
}
#if compiler(>=5.3) && $LexicalLifetimes
@frozen @_eagerMove public struct Set<Element> where Element : Swift.Hashable {
  @usableFromInline
  internal var _variant: Swift.Set<Element>._Variant
  public init(minimumCapacity: Swift.Int)
  @inlinable internal init(_native: __owned Swift._NativeSet<Element>) {
    _variant = _Variant(native: _native)
  }
  @inlinable internal init(_cocoa: __owned Swift.__CocoaSet) {
    _variant = _Variant(cocoa: _cocoa)
  }
  @inlinable public init(_immutableCocoaSet: __owned Swift.AnyObject) {
    _internalInvariant(_isBridgedVerbatimToObjectiveC(Element.self),
      "Set can be backed by NSSet _variant only when the member type can be bridged verbatim to Objective-C")
    self.init(_cocoa: __CocoaSet(_immutableCocoaSet))
  }
}
#else
@frozen public struct Set<Element> where Element : Swift.Hashable {
  @usableFromInline
  internal var _variant: Swift.Set<Element>._Variant
  public init(minimumCapacity: Swift.Int)
  @inlinable internal init(_native: __owned Swift._NativeSet<Element>) {
    _variant = _Variant(native: _native)
  }
  @inlinable internal init(_cocoa: __owned Swift.__CocoaSet) {
    _variant = _Variant(cocoa: _cocoa)
  }
  @inlinable public init(_immutableCocoaSet: __owned Swift.AnyObject) {
    _internalInvariant(_isBridgedVerbatimToObjectiveC(Element.self),
      "Set can be backed by NSSet _variant only when the member type can be bridged verbatim to Objective-C")
    self.init(_cocoa: __CocoaSet(_immutableCocoaSet))
  }
}
#endif
extension Swift.Set : Swift.ExpressibleByArrayLiteral {
  @inlinable @inline(__always) public init(arrayLiteral elements: Element...) {
    if elements.isEmpty {
      self.init()
      return
    }
    self.init(_nonEmptyArrayLiteral: elements)
  }
  @_alwaysEmitIntoClient internal init(_nonEmptyArrayLiteral elements: [Element]) {
    let native = _NativeSet<Element>(capacity: elements.count)
    for element in elements {
      let (bucket, found) = native.find(element)
      if found {
         
        continue
      }
      native._unsafeInsertNew(element, at: bucket)
    }
    self.init(_native: native)
  }
  public typealias ArrayLiteralElement = Element
}
extension Swift.Set : Swift.Sequence {
  @inlinable @inline(__always) public __consuming func makeIterator() -> Swift.Set<Element>.Iterator {
    return _variant.makeIterator()
  }
  @inlinable public func contains(_ member: Element) -> Swift.Bool {
    return _variant.contains(member)
  }
  @inlinable @inline(__always) public func _customContainsEquatableElement(_ member: Element) -> Swift.Bool? {
    return contains(member)
  }
}
extension Swift.Set {
  @available(swift 4.0)
  @inlinable public __consuming func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> Swift.Set<Element> {
    return try Set(_native: _variant.filter(isIncluded))
  }
}
extension Swift.Set : Swift.Collection {
  @inlinable public var startIndex: Swift.Set<Element>.Index {
    get {
    return _variant.startIndex
  }
  }
  @inlinable public var endIndex: Swift.Set<Element>.Index {
    get {
    return _variant.endIndex
  }
  }
  @inlinable public subscript(position: Swift.Set<Element>.Index) -> Element {
    get {
      return _variant.element(at: position)
    }
  }
  @inlinable public func index(after i: Swift.Set<Element>.Index) -> Swift.Set<Element>.Index {
    return _variant.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Swift.Set<Element>.Index) {
    _variant.formIndex(after: &i)
  }
  @inlinable public func firstIndex(of member: Element) -> Swift.Set<Element>.Index? {
    return _variant.index(for: member)
  }
  @inlinable @inline(__always) public func _customIndexOfEquatableElement(_ member: Element) -> Swift.Set<Element>.Index?? {
    return Optional(firstIndex(of: member))
  }
  @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ member: Element) -> Swift.Set<Element>.Index?? {
     
    return _customIndexOfEquatableElement(member)
  }
  @inlinable public var count: Swift.Int {
    get {
    return _variant.count
  }
  }
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return count == 0
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.Set<Element>>
  public typealias SubSequence = Swift.Slice<Swift.Set<Element>>
}
extension Swift.Set : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.Set<Element>, rhs: Swift.Set<Element>) -> Swift.Bool {
    switch (lhs._variant.isNative, rhs._variant.isNative) {
    case (true, true):
      return lhs._variant.asNative.isEqual(to: rhs._variant.asNative)
    case (false, false):
      return lhs._variant.asCocoa.isEqual(to: rhs._variant.asCocoa)
    case (true, false):
      return lhs._variant.asNative.isEqual(to: rhs._variant.asCocoa)
    case (false, true):
      return rhs._variant.asNative.isEqual(to: lhs._variant.asCocoa)
    }
  }
}
extension Swift.Set : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
     

     
     
     
     
    var copy = hasher
    let seed = copy._finalize()

    var hash = 0
    for member in self {
      hash ^= member._rawHashValue(seed: seed)
    }
    hasher.combine(hash)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Set : Swift._HasCustomAnyHashableRepresentation {
  public __consuming func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.Set : Swift.SetAlgebra {
  @discardableResult
  @inlinable public mutating func insert(_ newMember: __owned Element) -> (inserted: Swift.Bool, memberAfterInsert: Element) {
    return _variant.insert(newMember)
  }
  @discardableResult
  @inlinable public mutating func update(with newMember: __owned Element) -> Element? {
    return _variant.update(with: newMember)
  }
  @discardableResult
  @inlinable public mutating func remove(_ member: Element) -> Element? {
    return _variant.remove(member)
  }
  @discardableResult
  @inlinable public mutating func remove(at position: Swift.Set<Element>.Index) -> Element {
    return _variant.remove(at: position)
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    _variant.removeAll(keepingCapacity: keepCapacity)
  }
  @discardableResult
  @inlinable public mutating func removeFirst() -> Element {
    _precondition(!isEmpty, "Can't removeFirst from an empty Set")
    return remove(at: startIndex)
  }
  @inlinable public init() {
    self = Set<Element>(_native: _NativeSet())
  }
  @inlinable public init<Source>(_ sequence: __owned Source) where Element == Source.Element, Source : Swift.Sequence {
    if let s = sequence as? Set<Element> {
       
       
      self = s
    } else {
      self.init(minimumCapacity: sequence.underestimatedCount)
      for item in sequence {
        insert(item)
      }
    }
  }
  @inlinable public func isSubset<S>(of possibleSuperset: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    guard !isEmpty else { return true }
    if self.count == 1 { return possibleSuperset.contains(self.first!) }
    if let s = possibleSuperset as? Set<Element> {
      return isSubset(of: s)
    }
    return _variant.convertedToNative.isSubset(of: possibleSuperset)
  }
  @inlinable public func isStrictSubset<S>(of possibleStrictSuperset: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    if let s = possibleStrictSuperset as? Set<Element> {
      return isStrictSubset(of: s)
    }
    return _variant.convertedToNative.isStrictSubset(of: possibleStrictSuperset)
  }
  @inlinable public func isSuperset<S>(of possibleSubset: __owned S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    if let s = possibleSubset as? Set<Element> {
      return isSuperset(of: s)
    }
    for member in possibleSubset {
      if !contains(member) {
        return false
      }
    }
    return true
  }
  @inlinable public func isStrictSuperset<S>(of possibleStrictSubset: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    if isEmpty { return false }
    if let s = possibleStrictSubset as? Set<Element> {
      return isStrictSuperset(of: s)
    }
    return _variant.convertedToNative.isStrictSuperset(of: possibleStrictSubset)
  }
  @inlinable public func isDisjoint<S>(with other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    if let s = other as? Set<Element> {
      return isDisjoint(with: s)
    }
    return _isDisjoint(with: other)
  }
  @inlinable public __consuming func union<S>(_ other: __owned S) -> Swift.Set<Element> where Element == S.Element, S : Swift.Sequence {
    var newSet = self
    newSet.formUnion(other)
    return newSet
  }
  @inlinable public mutating func formUnion<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
    for item in other {
      insert(item)
    }
  }
  @inlinable public __consuming func subtracting<S>(_ other: S) -> Swift.Set<Element> where Element == S.Element, S : Swift.Sequence {
    return self._subtracting(other)
  }
  @inlinable internal __consuming func _subtracting<S>(_ other: S) -> Swift.Set<Element> where Element == S.Element, S : Swift.Sequence {
    return Set(_native: _variant.convertedToNative.subtracting(other))
  }
  @inlinable public mutating func subtract<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
    _subtract(other)
  }
  @inlinable internal mutating func _subtract<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
     
     
    guard !isEmpty else { return }

    for item in other {
      remove(item)
    }
  }
  @inlinable public __consuming func intersection<S>(_ other: S) -> Swift.Set<Element> where Element == S.Element, S : Swift.Sequence {
    if let other = other as? Set<Element> {
      return self.intersection(other)
    }
    return Set(_native: _variant.convertedToNative.genericIntersection(other))
  }
  @inlinable public mutating func formIntersection<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
     
     
     
    self = self.intersection(other)
  }
  @inlinable public __consuming func symmetricDifference<S>(_ other: __owned S) -> Swift.Set<Element> where Element == S.Element, S : Swift.Sequence {
    var newSet = self
    newSet.formSymmetricDifference(other)
    return newSet
  }
  @inlinable public mutating func formSymmetricDifference<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
    let otherSet = Set(other)
    formSymmetricDifference(otherSet)
  }
}
extension Swift.Set : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.Set {
  @inlinable public mutating func subtract(_ other: Swift.Set<Element>) {
    _subtract(other)
  }
  @inlinable public func isSubset(of other: Swift.Set<Element>) -> Swift.Bool {
    guard self.count <= other.count else { return false }
    for member in self {
      guard other.contains(member) else {
        return false
      }
    }
    return true
  }
  @inlinable public func isSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
    return other.isSubset(of: self)
  }
  @inlinable public func isDisjoint(with other: Swift.Set<Element>) -> Swift.Bool {
    guard !isEmpty && !other.isEmpty else { return true }
    let (smaller, larger) =
      count < other.count ? (self, other) : (other, self)
    for member in smaller {
      if larger.contains(member) {
        return false
      }
    }
    return true
  }
  @inlinable internal func _isDisjoint<S>(with other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    guard !isEmpty else { return true }

    for member in other {
      if contains(member) {
        return false
      }
    }
    return true
  }
  @inlinable public __consuming func subtracting(_ other: Swift.Set<Element>) -> Swift.Set<Element> {
     
     
     
     
    if other.count <= self.count / 8 {
      var copy = self
      copy._subtract(other)
      return copy
    }
     
    return self._subtracting(other)
  }
  @inlinable public func isStrictSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
    return self.count > other.count && other.isSubset(of: self)
  }
  @inlinable public func isStrictSubset(of other: Swift.Set<Element>) -> Swift.Bool {
    return self.count < other.count && self.isSubset(of: other)
  }
  @inlinable public __consuming func intersection(_ other: Swift.Set<Element>) -> Swift.Set<Element> {
    Set(_native: _variant.intersection(other))
  }
  @inlinable public mutating func formSymmetricDifference(_ other: __owned Swift.Set<Element>) {
    for member in other {
      if contains(member) {
        remove(member)
      } else {
        insert(member)
      }
    }
  }
}
extension Swift.Set {
  @frozen public struct Index {
    @usableFromInline
    @frozen internal enum _Variant {
      case native(Swift._HashTable.Index)
      case cocoa(Swift.__CocoaSet.Index)
    }
    @usableFromInline
    internal var _variant: Swift.Set<Element>.Index._Variant
    @inlinable @inline(__always) internal init(_variant: __owned Swift.Set<Element>.Index._Variant) {
      self._variant = _variant
    }
    @inlinable @inline(__always) internal init(_native index: Swift._HashTable.Index) {
      self.init(_variant: .native(index))
    }
    @inlinable @inline(__always) internal init(_cocoa index: __owned Swift.__CocoaSet.Index) {
      self.init(_variant: .cocoa(index))
    }
  }
}
extension Swift.Set.Index {
  @usableFromInline
  @_transparent internal var _guaranteedNative: Swift.Bool {
    @_transparent get {
    return _canBeClass(Element.self) == 0
  }
  }
  @usableFromInline
  @_transparent internal func _cocoaPath() {
    if _guaranteedNative {
      _conditionallyUnreachable()
    }
  }
  @inlinable @inline(__always) internal mutating func _isUniquelyReferenced() -> Swift.Bool {
    defer { _fixLifetime(self) }
    var handle = _asCocoa.handleBitPattern
    return handle == 0 || _isUnique_native(&handle)
  }
  @usableFromInline
  @_transparent internal var _isNative: Swift.Bool {
    @_transparent get {
    switch _variant {
    case .native:
      return true
    case .cocoa:
      _cocoaPath()
      return false
    }
  }
  }
  @usableFromInline
  @_transparent internal var _asNative: Swift._HashTable.Index {
    @_transparent get {
    switch _variant {
    case .native(let nativeIndex):
      return nativeIndex
    case .cocoa:
      _preconditionFailure(
        "Attempting to access Set elements using an invalid index")
    }
  }
  }
  @usableFromInline
  internal var _asCocoa: Swift.__CocoaSet.Index {
    @_transparent get {
      switch _variant {
      case .native:
        _preconditionFailure(
          "Attempting to access Set elements using an invalid index")
      case .cocoa(let cocoaIndex):
        return cocoaIndex
      }
    }
    _modify
  }
}
extension Swift.Set.Index : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.Set<Element>.Index, rhs: Swift.Set<Element>.Index) -> Swift.Bool {
    switch (lhs._variant, rhs._variant) {
    case (.native(let lhsNative), .native(let rhsNative)):
      return lhsNative == rhsNative
    case (.cocoa(let lhsCocoa), .cocoa(let rhsCocoa)):
      lhs._cocoaPath()
      return lhsCocoa == rhsCocoa
    default:
      _preconditionFailure("Comparing indexes from different sets")
    }
  }
}
extension Swift.Set.Index : Swift.Comparable {
  @inlinable public static func < (lhs: Swift.Set<Element>.Index, rhs: Swift.Set<Element>.Index) -> Swift.Bool {
    switch (lhs._variant, rhs._variant) {
    case (.native(let lhsNative), .native(let rhsNative)):
      return lhsNative < rhsNative
    case (.cocoa(let lhsCocoa), .cocoa(let rhsCocoa)):
      lhs._cocoaPath()
      return lhsCocoa < rhsCocoa
    default:
      _preconditionFailure("Comparing indexes from different sets")
    }
  }
}
extension Swift.Set.Index : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Set {
  @frozen public struct Iterator {
    @usableFromInline
    @frozen internal enum _Variant {
      case native(Swift._NativeSet<Swift.Set<Element>.Iterator.Element>.Iterator)
      case cocoa(Swift.__CocoaSet.Iterator)
    }
    @usableFromInline
    internal var _variant: Swift.Set<Element>.Iterator._Variant
    @inlinable internal init(_variant: __owned Swift.Set<Element>.Iterator._Variant) {
      self._variant = _variant
    }
    @inlinable internal init(_native: __owned Swift._NativeSet<Swift.Set<Element>.Iterator.Element>.Iterator) {
      self.init(_variant: .native(_native))
    }
    @usableFromInline
    internal init(_cocoa: __owned Swift.__CocoaSet.Iterator)
  }
}
@available(*, unavailable)
extension Swift.Set.Iterator._Variant : Swift.Sendable {
}
extension Swift.Set.Iterator {
  @usableFromInline
  @_transparent internal var _guaranteedNative: Swift.Bool {
    @_transparent get {
    return _canBeClass(Element.self) == 0
  }
  }
  @usableFromInline
  @_transparent internal func _cocoaPath() {
    if _guaranteedNative {
      _conditionallyUnreachable()
    }
  }
  @usableFromInline
  @_transparent internal var _isNative: Swift.Bool {
    @_transparent get {
    switch _variant {
    case .native:
      return true
    case .cocoa:
      _cocoaPath()
      return false
    }
  }
  }
  @usableFromInline
  @_transparent internal var _asNative: Swift._NativeSet<Element>.Iterator {
    @_transparent get {
      switch _variant {
      case .native(let nativeIterator):
        return nativeIterator
      case .cocoa:
        _internalInvariantFailure("internal error: does not contain a native index")
      }
    }
    @_transparent set {
      self._variant = .native(newValue)
    }
  }
  @usableFromInline
  @_transparent internal var _asCocoa: Swift.__CocoaSet.Iterator {
    @_transparent get {
      switch _variant {
      case .native:
        _internalInvariantFailure("internal error: does not contain a Cocoa index")
      case .cocoa(let cocoa):
        return cocoa
      }
    }
  }
}
extension Swift.Set.Iterator : Swift.IteratorProtocol {
  @inlinable @inline(__always) public mutating func next() -> Element? {
    guard _isNative else {
      guard let cocoaElement = _asCocoa.next() else { return nil }
      return _forceBridgeFromObjectiveC(cocoaElement, Element.self)
    }
    return _asNative.next()
  }
}
extension Swift.Set.Iterator : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Set : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Set {
  @inlinable public mutating func popFirst() -> Element? {
    guard !isEmpty else { return nil }
    return remove(at: startIndex)
  }
  @inlinable public var capacity: Swift.Int {
    get {
    return _variant.capacity
  }
  }
  public mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
}
public typealias SetIndex<Element> = Swift.Set<Element>.Index where Element : Swift.Hashable
public typealias SetIterator<Element> = Swift.Set<Element>.Iterator where Element : Swift.Hashable
extension Swift.Set : @unchecked Swift.Sendable where Element : Swift.Sendable {
}
extension Swift.Set.Index : @unchecked Swift.Sendable where Element : Swift.Sendable {
}
extension Swift.Set.Iterator : @unchecked Swift.Sendable where Element : Swift.Sendable {
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol SetAlgebra<Element> : Swift.Equatable, Swift.ExpressibleByArrayLiteral {
  associatedtype Element
  init()
  func contains(_ member: Self.Element) -> Swift.Bool
  __consuming func union(_ other: __owned Self) -> Self
  __consuming func intersection(_ other: Self) -> Self
  __consuming func symmetricDifference(_ other: __owned Self) -> Self
  @discardableResult
  mutating func insert(_ newMember: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
  @discardableResult
  mutating func remove(_ member: Self.Element) -> Self.Element?
  @discardableResult
  mutating func update(with newMember: __owned Self.Element) -> Self.Element?
  mutating func formUnion(_ other: __owned Self)
  mutating func formIntersection(_ other: Self)
  mutating func formSymmetricDifference(_ other: __owned Self)
  __consuming func subtracting(_ other: Self) -> Self
  func isSubset(of other: Self) -> Swift.Bool
  func isDisjoint(with other: Self) -> Swift.Bool
  func isSuperset(of other: Self) -> Swift.Bool
  var isEmpty: Swift.Bool { get }
  init<S>(_ sequence: __owned S) where S : Swift.Sequence, Self.Element == S.Element
  mutating func subtract(_ other: Self)
}
#else
public protocol SetAlgebra : Swift.Equatable, Swift.ExpressibleByArrayLiteral {
  associatedtype Element
  init()
  func contains(_ member: Self.Element) -> Swift.Bool
  __consuming func union(_ other: __owned Self) -> Self
  __consuming func intersection(_ other: Self) -> Self
  __consuming func symmetricDifference(_ other: __owned Self) -> Self
  @discardableResult
  mutating func insert(_ newMember: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
  @discardableResult
  mutating func remove(_ member: Self.Element) -> Self.Element?
  @discardableResult
  mutating func update(with newMember: __owned Self.Element) -> Self.Element?
  mutating func formUnion(_ other: __owned Self)
  mutating func formIntersection(_ other: Self)
  mutating func formSymmetricDifference(_ other: __owned Self)
  __consuming func subtracting(_ other: Self) -> Self
  func isSubset(of other: Self) -> Swift.Bool
  func isDisjoint(with other: Self) -> Swift.Bool
  func isSuperset(of other: Self) -> Swift.Bool
  var isEmpty: Swift.Bool { get }
  init<S>(_ sequence: __owned S) where S : Swift.Sequence, Self.Element == S.Element
  mutating func subtract(_ other: Self)
}
#endif
extension Swift.SetAlgebra {
  @inlinable public init<S>(_ sequence: __owned S) where S : Swift.Sequence, Self.Element == S.Element {
    self.init()
     
    _onFastPath()
    for e in sequence { insert(e) }
  }
  @inlinable public mutating func subtract(_ other: Self) {
    self.formIntersection(self.symmetricDifference(other))
  }
  @inlinable public func isSubset(of other: Self) -> Swift.Bool {
    return self.intersection(other) == self
  }
  @inlinable public func isSuperset(of other: Self) -> Swift.Bool {
    return other.isSubset(of: self)
  }
  @inlinable public func isDisjoint(with other: Self) -> Swift.Bool {
    return self.intersection(other).isEmpty
  }
  @inlinable public func subtracting(_ other: Self) -> Self {
    return self.intersection(self.symmetricDifference(other))
  }
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return self == Self()
  }
  }
  @inlinable public func isStrictSuperset(of other: Self) -> Swift.Bool {
    return self.isSuperset(of: other) && self != other
  }
  @inlinable public func isStrictSubset(of other: Self) -> Swift.Bool {
    return other.isStrictSuperset(of: self)
  }
}
extension Swift.SetAlgebra where Self.ArrayLiteralElement == Self.Element {
  @inlinable public init(arrayLiteral: Self.Element...) {
    self.init(arrayLiteral)
  }
}
extension Swift.Set where Element == Swift.AnyHashable {
  @discardableResult
  @inlinable public mutating func insert<ConcreteElement>(_ newMember: __owned ConcreteElement) -> (inserted: Swift.Bool, memberAfterInsert: ConcreteElement) where ConcreteElement : Swift.Hashable {
    let (inserted, memberAfterInsert) =
      insert(AnyHashable(newMember))
    return (
      inserted: inserted,
      memberAfterInsert: memberAfterInsert.base as! ConcreteElement)
  }
  @discardableResult
  @inlinable public mutating func update<ConcreteElement>(with newMember: __owned ConcreteElement) -> ConcreteElement? where ConcreteElement : Swift.Hashable {
    return update(with: AnyHashable(newMember))
      .map { $0.base as! ConcreteElement }
  }
  @discardableResult
  @inlinable public mutating func remove<ConcreteElement>(_ member: ConcreteElement) -> ConcreteElement? where ConcreteElement : Swift.Hashable {
    return remove(AnyHashable(member))
      .map { $0.base as! ConcreteElement }
  }
}
extension Swift._NativeSet {
  @usableFromInline
  internal __consuming func bridged() -> Swift.AnyObject
}
@usableFromInline
@frozen internal struct __CocoaSet {
  @usableFromInline
  internal let object: Swift.AnyObject
  @inlinable internal init(_ object: __owned Swift.AnyObject) {
    self.object = object
  }
}
@available(*, unavailable)
extension Swift.__CocoaSet : Swift.Sendable {
}
extension Swift.__CocoaSet {
  @usableFromInline
  @_effects(releasenone) internal func member(for index: Swift.__CocoaSet.Index) -> Swift.AnyObject
  @usableFromInline
  internal func member(for element: Swift.AnyObject) -> Swift.AnyObject?
}
extension Swift.__CocoaSet {
  @usableFromInline
  internal func isEqual(to other: Swift.__CocoaSet) -> Swift.Bool
}
extension Swift.__CocoaSet {
  @usableFromInline
  internal typealias Element = Swift.AnyObject
  @usableFromInline
  internal var startIndex: Swift.__CocoaSet.Index {
    @_effects(releasenone) get
  }
  @usableFromInline
  internal var endIndex: Swift.__CocoaSet.Index {
    @_effects(releasenone) get
  }
  @usableFromInline
  @_effects(releasenone) internal func index(after index: Swift.__CocoaSet.Index) -> Swift.__CocoaSet.Index
  @usableFromInline
  internal func formIndex(after index: inout Swift.__CocoaSet.Index, isUnique: Swift.Bool)
  @usableFromInline
  @_effects(releasenone) internal func index(for element: Swift.AnyObject) -> Swift.__CocoaSet.Index?
  @usableFromInline
  internal var count: Swift.Int {
    get
  }
  @usableFromInline
  internal func contains(_ element: Swift.AnyObject) -> Swift.Bool
  @usableFromInline
  @_effects(releasenone) internal func element(at i: Swift.__CocoaSet.Index) -> Swift.AnyObject
}
extension Swift.__CocoaSet {
  @usableFromInline
  @frozen internal struct Index {
    internal var _storage: Builtin.BridgeObject
    internal var _offset: Swift.Int
  }
}
extension Swift.__CocoaSet.Index {
  @usableFromInline
  internal var handleBitPattern: Swift.UInt {
    @_effects(readonly) get
  }
}
extension Swift.__CocoaSet.Index {
  @usableFromInline
  @nonobjc internal var element: Swift.AnyObject {
    @_effects(readonly) get
  }
  @usableFromInline
  @nonobjc internal var age: Swift.Int32 {
    @_effects(releasenone) get
  }
}
extension Swift.__CocoaSet.Index : Swift.Equatable {
  @usableFromInline
  @_effects(readonly) internal static func == (lhs: Swift.__CocoaSet.Index, rhs: Swift.__CocoaSet.Index) -> Swift.Bool
}
extension Swift.__CocoaSet.Index : Swift.Comparable {
  @usableFromInline
  @_effects(readonly) internal static func < (lhs: Swift.__CocoaSet.Index, rhs: Swift.__CocoaSet.Index) -> Swift.Bool
}
extension Swift.__CocoaSet : Swift.Sequence {
  @_hasMissingDesignatedInitializers @usableFromInline
  final internal class Iterator {
    @objc @usableFromInline
    deinit
  }
  @usableFromInline
  internal __consuming func makeIterator() -> Swift.__CocoaSet.Iterator
}
@available(*, unavailable)
extension Swift.__CocoaSet.Iterator : Swift.Sendable {
}
extension Swift.__CocoaSet.Iterator : Swift.IteratorProtocol {
  @usableFromInline
  internal typealias Element = Swift.AnyObject
  @usableFromInline
  final internal func next() -> Swift.__CocoaSet.Iterator.Element?
}
extension Swift.Set {
  @inlinable public __consuming func _bridgeToObjectiveCImpl() -> Swift.AnyObject {
    guard _variant.isNative else {
      return _variant.asCocoa.object
    }
    return _variant.asNative.bridged()
  }
  public static func _bridgeFromObjectiveCAdoptingNativeStorageOf(_ s: __owned Swift.AnyObject) -> Swift.Set<Element>?
}
@frozen public struct _SetBuilder<Element> where Element : Swift.Hashable {
  @usableFromInline
  internal var _target: Swift._NativeSet<Element>
  @usableFromInline
  internal let _requestedCount: Swift.Int
  @inlinable public init(count: Swift.Int) {
    _target = _NativeSet(capacity: count)
    _requestedCount = count
  }
  @inlinable @inline(__always) public mutating func add(member: Element) {
    _precondition(_target.count < _requestedCount,
      "Can't add more members than promised")
    _target._unsafeInsertNew(member)
  }
  @inlinable public __consuming func take() -> Swift.Set<Element> {
    _precondition(_target.count == _requestedCount,
      "The number of members added does not match the promised count")
    return Set(_native: _target)
  }
}
@available(*, unavailable)
extension Swift._SetBuilder : Swift.Sendable {
}
extension Swift.Set {
  @_alwaysEmitIntoClient @inlinable @inline(__always) internal init?<C>(_mapping source: C, allowingDuplicates: Swift.Bool, transform: (C.Element) -> Element?) where C : Swift.Collection {
    var target = _NativeSet<Element>(capacity: source.count)
    if allowingDuplicates {
      for m in source {
        guard let member = transform(m) else { return nil }
        target._unsafeUpdate(with: member)
      }
    } else {
      for m in source {
        guard let member = transform(m) else { return nil }
        target._unsafeInsertNew(member)
      }
    }
    self.init(_native: target)
  }
}
@inlinable public func _setUpCast<DerivedValue, BaseValue>(_ source: Swift.Set<DerivedValue>) -> Swift.Set<BaseValue> where DerivedValue : Swift.Hashable, BaseValue : Swift.Hashable {
  return Set(
    _mapping: source,
     
     
     
    allowingDuplicates: (BaseValue.self == String.self)
  ) { member in
    (member as! BaseValue)
  }!
}
@inlinable public func _setDownCast<BaseValue, DerivedValue>(_ source: Swift.Set<BaseValue>) -> Swift.Set<DerivedValue> where BaseValue : Swift.Hashable, DerivedValue : Swift.Hashable {

  if _isClassOrObjCExistential(BaseValue.self)
  && _isClassOrObjCExistential(DerivedValue.self) {
    guard source._variant.isNative else {
      return Set(_immutableCocoaSet: source._variant.asCocoa.object)
    }
    return Set(_immutableCocoaSet: source._variant.asNative.bridged())
  }
   
   

  return Set(
    _mapping: source,
     
     
     
    allowingDuplicates: (DerivedValue.self == String.self)
  ) { member in
    (member as! DerivedValue)
  }!
}
@inlinable public func _setDownCastConditional<BaseValue, DerivedValue>(_ source: Swift.Set<BaseValue>) -> Swift.Set<DerivedValue>? where BaseValue : Swift.Hashable, DerivedValue : Swift.Hashable {
  return Set(
    _mapping: source,
     
     
     
    allowingDuplicates: (DerivedValue.self == String.self)
  ) { member in
    member as? DerivedValue
  }
}
@objc @_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @_objc_non_lazy_realization internal class __RawSetStorage : Swift.__SwiftNativeNSSet {
  @usableFromInline
  @nonobjc final internal var _count: Swift.Int
  @usableFromInline
  @nonobjc final internal var _capacity: Swift.Int
  @usableFromInline
  @nonobjc final internal var _scale: Swift.Int8
  @usableFromInline
  @nonobjc final internal var _reservedScale: Swift.Int8
  @nonobjc final internal var _extra: Swift.Int16
  @usableFromInline
  @nonobjc final internal var _age: Swift.Int32
  @usableFromInline
  final internal var _seed: Swift.Int
  @usableFromInline
  @nonobjc final internal var _rawElements: Swift.UnsafeMutableRawPointer
  @inlinable @nonobjc final internal var _bucketCount: Swift.Int {
    @inline(__always) get { return 1 &<< _scale }
  }
  @inlinable @nonobjc final internal var _metadata: Swift.UnsafeMutablePointer<Swift._HashTable.Word> {
    @inline(__always) get {
      let address = Builtin.projectTailElems(self, _HashTable.Word.self)
      return UnsafeMutablePointer(address)
    }
  }
  @inlinable @nonobjc final internal var _hashTable: Swift._HashTable {
    @inline(__always) get {
      return _HashTable(words: _metadata, bucketCount: _bucketCount)
    }
  }
  @objc @usableFromInline
  deinit
}
@available(*, unavailable)
extension Swift.__RawSetStorage : Swift.Sendable {
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @_objc_non_lazy_realization internal class __EmptySetSingleton : Swift.__RawSetStorage {
  @objc @usableFromInline
  deinit
}
@available(*, unavailable)
extension Swift.__EmptySetSingleton : Swift.Sendable {
}
extension Swift.__RawSetStorage {
  @inlinable @nonobjc internal static var empty: Swift.__EmptySetSingleton {
    get {
    return Builtin.bridgeFromRawPointer(
      Builtin.addressof(&_swiftEmptySetSingleton))
  }
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @usableFromInline
final internal class _SetStorage<Element> : Swift.__RawSetStorage where Element : Swift.Hashable {
  @objc deinit
  @inlinable final internal var _elements: Swift.UnsafeMutablePointer<Element> {
    @inline(__always) get {
      return self._rawElements.assumingMemoryBound(to: Element.self)
    }
  }
}
@available(*, unavailable)
extension Swift._SetStorage : Swift.Sendable {
}
extension Swift._SetStorage {
  @usableFromInline
  @_effects(releasenone) internal static func copy(original: Swift.__RawSetStorage) -> Swift._SetStorage<Element>
  @usableFromInline
  @_effects(releasenone) internal static func resize(original: Swift.__RawSetStorage, capacity: Swift.Int, move: Swift.Bool) -> Swift._SetStorage<Element>
  @usableFromInline
  @_effects(releasenone) internal static func allocate(capacity: Swift.Int) -> Swift._SetStorage<Element>
  @usableFromInline
  @_effects(releasenone) internal static func convert(_ cocoa: Swift.__CocoaSet, capacity: Swift.Int) -> Swift._SetStorage<Element>
}
extension Swift.Set {
  @usableFromInline
  @frozen internal struct _Variant {
    @usableFromInline
    internal var object: Swift._BridgeStorage<Swift.__RawSetStorage>
    @inlinable @inline(__always) internal init(dummy: ()) {
#if _pointerBitWidth(_64) && !$Embedded
      self.object = _BridgeStorage(taggedPayload: 0)
#elseif _pointerBitWidth(_32) || $Embedded
      self.init(native: _NativeSet())
#else
#error("Unknown platform")
#endif
    }
    @inlinable @inline(__always) internal init(native: __owned Swift._NativeSet<Element>) {
      self.object = _BridgeStorage(native: native._storage)
    }
    @inlinable @inline(__always) internal init(cocoa: __owned Swift.__CocoaSet) {
      self.object = _BridgeStorage(objC: cocoa.object)
    }
  }
}
extension Swift.Set._Variant {
  @usableFromInline
  @_transparent internal var guaranteedNative: Swift.Bool {
    @_transparent get {
    return _canBeClass(Element.self) == 0
  }
  }
  @inlinable internal mutating func isUniquelyReferenced() -> Swift.Bool {
    return object.isUniquelyReferencedUnflaggedNative()
  }
  @usableFromInline
  @_transparent internal var isNative: Swift.Bool {
    @_transparent get {
    if guaranteedNative { return true }
    return object.isUnflaggedNative
  }
  }
  @usableFromInline
  @_transparent internal var asNative: Swift._NativeSet<Element> {
    @_transparent get {
      return _NativeSet(object.unflaggedNativeInstance)
    }
    @_transparent set {
      self = .init(native: newValue)
    }
    @_transparent _modify {
      var native = _NativeSet<Element>(object.unflaggedNativeInstance)
      self = .init(dummy: ())
      defer {
         
         
        object = .init(native: native._storage)
      }
      yield &native
    }
  }
  @inlinable internal var asCocoa: Swift.__CocoaSet {
    get {
    return __CocoaSet(object.objCInstance)
  }
  }
  @_alwaysEmitIntoClient internal var convertedToNative: Swift._NativeSet<Element> {
    get {
    guard isNative else {  return _NativeSet<Element>(asCocoa) }
    return asNative
  }
  }
  @inlinable internal var capacity: Swift.Int {
    get {
    guard isNative else {
      return asCocoa.count
    }
    return asNative.capacity
  }
  }
}
extension Swift.Set._Variant {
  @usableFromInline
  internal typealias Index = Swift.Set<Element>.Index
  @inlinable internal var startIndex: Swift.Set<Element>._Variant.Index {
    get {
    guard isNative else {
      return Index(_cocoa: asCocoa.startIndex)
    }
    return asNative.startIndex
  }
  }
  @inlinable internal var endIndex: Swift.Set<Element>._Variant.Index {
    get {
    guard isNative else {
      return Index(_cocoa: asCocoa.endIndex)
    }
    return asNative.endIndex
  }
  }
  @inlinable internal func index(after index: Swift.Set<Element>._Variant.Index) -> Swift.Set<Element>._Variant.Index {
    guard isNative else {
      return Index(_cocoa: asCocoa.index(after: index._asCocoa))
    }
    return asNative.index(after: index)
  }
  @inlinable internal func formIndex(after index: inout Swift.Set<Element>._Variant.Index) {
    guard isNative else {
      let isUnique = index._isUniquelyReferenced()
      asCocoa.formIndex(after: &index._asCocoa, isUnique: isUnique)
      return
    }
    index = asNative.index(after: index)
  }
  @inlinable @inline(__always) internal func index(for element: Element) -> Swift.Set<Element>._Variant.Index? {
    guard isNative else {
      let cocoaElement = _bridgeAnythingToObjectiveC(element)
      guard let index = asCocoa.index(for: cocoaElement) else { return nil }
      return Index(_cocoa: index)
    }
    return asNative.index(for: element)
  }
  @inlinable internal var count: Swift.Int {
    @inline(__always) get {
      guard isNative else {
        return asCocoa.count
      }
      return asNative.count
    }
  }
  @inlinable @inline(__always) internal func contains(_ member: Element) -> Swift.Bool {
    guard isNative else {
      return asCocoa.contains(_bridgeAnythingToObjectiveC(member))
    }
    return asNative.contains(member)
  }
  @inlinable @inline(__always) internal func element(at index: Swift.Set<Element>._Variant.Index) -> Element {
    guard isNative else {
      let cocoaMember = asCocoa.element(at: index._asCocoa)
      return _forceBridgeFromObjectiveC(cocoaMember, Element.self)
    }
    return asNative.element(at: index)
  }
}
extension Swift.Set._Variant {
  @inlinable internal mutating func update(with value: __owned Element) -> Element? {
    guard isNative else {
       
      var native = _NativeSet<Element>(asCocoa, capacity: asCocoa.count + 1)
      let old = native.update(with: value, isUnique: true)
      self = .init(native: native)
      return old
    }
    let isUnique = self.isUniquelyReferenced()
    return asNative.update(with: value, isUnique: isUnique)
  }
  @inlinable internal mutating func insert(_ element: __owned Element) -> (inserted: Swift.Bool, memberAfterInsert: Element) {
    guard isNative else {
       
      let cocoaMember = _bridgeAnythingToObjectiveC(element)
      let cocoa = asCocoa
      if let m = cocoa.member(for: cocoaMember) {
        return (false, _forceBridgeFromObjectiveC(m, Element.self))
      }
      var native = _NativeSet<Element>(cocoa, capacity: cocoa.count + 1)
      native.insertNew(element, isUnique: true)
      self = .init(native: native)
      return (true, element)
    }
    let (bucket, found) = asNative.find(element)
    if found {
      return (false, asNative.uncheckedElement(at: bucket))
    }
    let isUnique = self.isUniquelyReferenced()
    asNative.insertNew(element, at: bucket, isUnique: isUnique)
    return (true, element)
  }
  @discardableResult
  @inlinable internal mutating func remove(at index: Swift.Set<Element>._Variant.Index) -> Element {
    guard isNative else {
       
       
      let cocoa = asCocoa
      let cocoaMember = cocoa.member(for: index._asCocoa)
      let nativeMember = _forceBridgeFromObjectiveC(cocoaMember, Element.self)
      return _migrateToNative(cocoa, removing: nativeMember)
    }
    let isUnique = isUniquelyReferenced()
    let bucket = asNative.validatedBucket(for: index)
    return asNative.uncheckedRemove(at: bucket, isUnique: isUnique)
  }
  @discardableResult
  @inlinable internal mutating func remove(_ member: Element) -> Element? {
    guard isNative else {
      let cocoa = asCocoa
      let cocoaMember = _bridgeAnythingToObjectiveC(member)
      guard cocoa.contains(cocoaMember) else { return nil }
      return _migrateToNative(cocoa, removing: member)
    }
    let (bucket, found) = asNative.find(member)
    guard found else { return nil }
    let isUnique = isUniquelyReferenced()
    return asNative.uncheckedRemove(at: bucket, isUnique: isUnique)
  }
  @inlinable internal mutating func _migrateToNative(_ cocoa: Swift.__CocoaSet, removing member: Element) -> Element {
     
     
    var native = _NativeSet<Element>(cocoa)
    let (bucket, found) = native.find(member)
    _precondition(found, "Bridging did not preserve equality")
    let old = native.uncheckedRemove(at: bucket, isUnique: true)
    _precondition(member == old, "Bridging did not preserve equality")
    self = .init(native: native)
    return old
  }
  @inlinable internal mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool) {
    if !keepCapacity {
      self = .init(native: _NativeSet<Element>())
      return
    }
    guard count > 0 else { return }

    guard isNative else {
      self = .init(native: _NativeSet(capacity: asCocoa.count))
      return
    }
    let isUnique = isUniquelyReferenced()
    asNative.removeAll(isUnique: isUnique)
  }
}
extension Swift.Set._Variant {
  @inlinable @inline(__always) internal __consuming func makeIterator() -> Swift.Set<Element>.Iterator {
    guard isNative else {
      return Set.Iterator(_cocoa: asCocoa.makeIterator())
    }
    return Set.Iterator(_native: asNative.makeIterator())
  }
}
extension Swift.Set._Variant {
  @_alwaysEmitIntoClient internal __consuming func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> Swift._NativeSet<Element> {
    guard isNative else {
      var result = _NativeSet<Element>()
      for cocoaElement in asCocoa {
        let nativeElement = _forceBridgeFromObjectiveC(
          cocoaElement, Element.self)
        if try isIncluded(nativeElement) {
          result.insertNew(nativeElement, isUnique: true)
        }
      }
      return result
    }
    return try asNative.filter(isIncluded)
  }
  @_alwaysEmitIntoClient internal __consuming func intersection(_ other: Swift.Set<Element>) -> Swift._NativeSet<Element> {
    switch (self.isNative, other._variant.isNative) {
    case (true, true):
      return asNative.intersection(other._variant.asNative)
    case (true, false):
      return asNative.genericIntersection(other)
    case (false, false):
      return _NativeSet(asCocoa).genericIntersection(other)
    case (false, true):
       
       
       
      let that = other._variant.asNative
      var result = _NativeSet<Element>()
      for cocoaElement in asCocoa {
        let nativeElement = _forceBridgeFromObjectiveC(
          cocoaElement, Element.self)
        if that.contains(nativeElement) {
          result.insertNew(nativeElement, isUnique: true)
        }
      }
      return result
    }
  }
}
@inlinable internal func _makeSwiftNSFastEnumerationState() -> SwiftShims._SwiftNSFastEnumerationState {
  return _SwiftNSFastEnumerationState(
    state: 0, itemsPtr: nil, mutationsPtr: nil,
    extra: (0, 0, 0, 0, 0))
}
@usableFromInline
internal var _fastEnumerationStorageMutationsTarget: Swift.CUnsignedLong
@usableFromInline
internal let _fastEnumerationStorageMutationsPtr: Swift.UnsafeMutablePointer<Swift.CUnsignedLong>
@usableFromInline
@_alwaysEmitIntoClient internal func _mallocSize(ofAllocation ptr: Swift.UnsafeRawPointer) -> Swift.Int? {
  return _swift_stdlib_has_malloc_size() ? _swift_stdlib_malloc_size(ptr) : nil
}
@frozen public struct Slice<Base> where Base : Swift.Collection {
  public var _startIndex: Base.Index
  public var _endIndex: Base.Index
  @usableFromInline
  internal var _base: Base
  @inlinable public init(base: Base, bounds: Swift.Range<Base.Index>) {
    self._base = base
    self._startIndex = bounds.lowerBound
    self._endIndex = bounds.upperBound
  }
  @inlinable public var base: Base {
    get {
    return _base
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var _bounds: Swift.Range<Base.Index> {
    get {
    Range(_uncheckedBounds: (_startIndex, _endIndex))
  }
  }
}
extension Swift.Slice : Swift.Collection {
  public typealias Index = Base.Index
  public typealias Indices = Base.Indices
  public typealias Element = Base.Element
  public typealias SubSequence = Swift.Slice<Base>
  public typealias Iterator = Swift.IndexingIterator<Swift.Slice<Base>>
  @inlinable public var startIndex: Swift.Slice<Base>.Index {
    get {
    return _startIndex
  }
  }
  @inlinable public var endIndex: Swift.Slice<Base>.Index {
    get {
    return _endIndex
  }
  }
  @inlinable public subscript(index: Swift.Slice<Base>.Index) -> Base.Element {
    get {
      _failEarlyRangeCheck(index, bounds: _bounds)
      return _base[index]
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Slice<Base>.Index>) -> Swift.Slice<Base> {
    get {
      _failEarlyRangeCheck(bounds, bounds: _bounds)
      return Slice(base: _base, bounds: bounds)
    }
  }
  public var indices: Swift.Slice<Base>.Indices {
    get
  }
  @inlinable public func index(after i: Swift.Slice<Base>.Index) -> Swift.Slice<Base>.Index {
     
    return _base.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Swift.Slice<Base>.Index) {
     
    _base.formIndex(after: &i)
  }
  @inlinable public func index(_ i: Swift.Slice<Base>.Index, offsetBy n: Swift.Int) -> Swift.Slice<Base>.Index {
     
    return _base.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.Slice<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.Slice<Base>.Index) -> Swift.Slice<Base>.Index? {
     
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Swift.Slice<Base>.Index, to end: Swift.Slice<Base>.Index) -> Swift.Int {
     
    return _base.distance(from: start, to: end)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Slice<Base>.Index, bounds: Swift.Range<Swift.Slice<Base>.Index>) {
    _base._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Slice<Base>.Index>, bounds: Swift.Range<Swift.Slice<Base>.Index>) {
    _base._failEarlyRangeCheck(range, bounds: bounds)
  }
  @_alwaysEmitIntoClient @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Swift.Slice<Base>.Element>) throws -> R) rethrows -> R? {
    try _base.withContiguousStorageIfAvailable { buffer in
      let start = _base.distance(from: _base.startIndex, to: _startIndex)
      let count = _base.distance(from: _startIndex, to: _endIndex)
      let slice = UnsafeBufferPointer(rebasing: buffer[start ..< start + count])
      return try body(slice)
    }
  }
}
extension Swift.Slice {
  @_alwaysEmitIntoClient public __consuming func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Swift.Slice<Base>.Element>) -> (Swift.Slice<Base>.Iterator, Swift.UnsafeMutableBufferPointer<Swift.Slice<Base>.Element>.Index) {
    if let (_, copied) = self.withContiguousStorageIfAvailable({
      $0._copyContents(initializing: buffer)
    }) {
      let position = index(startIndex, offsetBy: copied)
      return (Iterator(_elements: self, _position: position), copied)
    }

    return _copySequenceContents(initializing: buffer)
  }
}
extension Swift.Slice : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.Slice<Base>.Index) -> Swift.Slice<Base>.Index {
     
    return _base.index(before: i)
  }
  @inlinable public func formIndex(before i: inout Swift.Slice<Base>.Index) {
     
    _base.formIndex(before: &i)
  }
}
extension Swift.Slice : Swift.MutableCollection where Base : Swift.MutableCollection {
  @inlinable public subscript(index: Swift.Slice<Base>.Index) -> Base.Element {
    get {
      _failEarlyRangeCheck(index, bounds: _bounds)
      return _base[index]
    }
    set {
      _failEarlyRangeCheck(index, bounds: _bounds)
      _base[index] = newValue
       
       
       
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Slice<Base>.Index>) -> Swift.Slice<Base> {
    get {
      _failEarlyRangeCheck(bounds, bounds: _bounds)
      return Slice(base: _base, bounds: bounds)
    }
    set {
      _writeBackMutableSlice(&self, bounds: bounds, slice: newValue)
    }
  }
  @_alwaysEmitIntoClient @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Swift.Slice<Base>.Element>) throws -> R) rethrows -> R? {
     
     
     
     
    guard _base.withContiguousMutableStorageIfAvailable({ _ in }) != nil
    else {
      return nil
    }
    let start = _base.distance(from: _base.startIndex, to: _startIndex)
    let count = _base.distance(from: _startIndex, to: _endIndex)
    return try _base.withContiguousMutableStorageIfAvailable { buffer in
      var slice = UnsafeMutableBufferPointer(
        rebasing: buffer[start ..< start + count])
      let copy = slice
      defer {
        _precondition(
          slice.baseAddress == copy.baseAddress &&
          slice.count == copy.count,
          "Slice.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed")
      }
      return try body(&slice)
    }
  }
}
extension Swift.Slice : Swift.RandomAccessCollection where Base : Swift.RandomAccessCollection {
}
extension Swift.Slice : Swift.RangeReplaceableCollection where Base : Swift.RangeReplaceableCollection {
  @inlinable public init() {
    self._base = Base()
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
  @inlinable public init(repeating repeatedValue: Base.Element, count: Swift.Int) {
    self._base = Base(repeating: repeatedValue, count: count)
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
  @inlinable public init<S>(_ elements: S) where S : Swift.Sequence, Base.Element == S.Element {
    self._base = Base(elements)
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
  @inlinable public mutating func replaceSubrange<C>(_ subRange: Swift.Range<Swift.Slice<Base>.Index>, with newElements: C) where C : Swift.Collection, Base.Element == C.Element {

     
    let sliceOffset =
      _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount =
      _base.distance(from: _startIndex, to: subRange.lowerBound)
      + _base.distance(from: subRange.upperBound, to: _endIndex)
      + newElements.count
    _base.replaceSubrange(subRange, with: newElements)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
  @inlinable public mutating func insert(_ newElement: Base.Element, at i: Swift.Slice<Base>.Index) {
     
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count + 1
    _base.insert(newElement, at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
  @inlinable public mutating func insert<S>(contentsOf newElements: S, at i: Swift.Slice<Base>.Index) where S : Swift.Collection, Base.Element == S.Element {

     
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count + newElements.count
    _base.insert(contentsOf: newElements, at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
  @inlinable public mutating func remove(at i: Swift.Slice<Base>.Index) -> Base.Element {
     
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count - 1
    let result = _base.remove(at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    return result
  }
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Slice<Base>.Index>) {
     
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount =
      count - distance(from: bounds.lowerBound, to: bounds.upperBound)
    _base.removeSubrange(bounds)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}
extension Swift.Slice where Base : Swift.BidirectionalCollection, Base : Swift.RangeReplaceableCollection {
  @inlinable public mutating func replaceSubrange<C>(_ subRange: Swift.Range<Swift.Slice<Base>.Index>, with newElements: C) where C : Swift.Collection, Base.Element == C.Element {
     
    if subRange.lowerBound == _base.startIndex {
      let newSliceCount =
        _base.distance(from: _startIndex, to: subRange.lowerBound)
        + _base.distance(from: subRange.upperBound, to: _endIndex)
        + newElements.count
      _base.replaceSubrange(subRange, with: newElements)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = subRange.lowerBound == _startIndex
      let lastValidIndex = _base.index(before: subRange.lowerBound)
      let newEndIndexOffset =
        _base.distance(from: subRange.upperBound, to: _endIndex)
        + newElements.count + 1
      _base.replaceSubrange(subRange, with: newElements)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
  @inlinable public mutating func insert(_ newElement: Base.Element, at i: Swift.Slice<Base>.Index) {
     
    if i == _base.startIndex {
      let newSliceCount = count + 1
      _base.insert(newElement, at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset = _base.distance(from: i, to: _endIndex) + 2
      _base.insert(newElement, at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
  @inlinable public mutating func insert<S>(contentsOf newElements: S, at i: Swift.Slice<Base>.Index) where S : Swift.Collection, Base.Element == S.Element {
     
    if i == _base.startIndex {
      let newSliceCount = count + newElements.count
      _base.insert(contentsOf: newElements, at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset =
        _base.distance(from: i, to: _endIndex)
        + newElements.count + 1
      _base.insert(contentsOf: newElements, at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
  @inlinable public mutating func remove(at i: Swift.Slice<Base>.Index) -> Base.Element {
     
    if i == _base.startIndex {
      let newSliceCount = count - 1
      let result = _base.remove(at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
      return result
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset = _base.distance(from: i, to: _endIndex)
      let result = _base.remove(at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
      return result
    }
  }
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Slice<Base>.Index>) {
     
    if bounds.lowerBound == _base.startIndex {
      let newSliceCount =
        count - _base.distance(from: bounds.lowerBound, to: bounds.upperBound)
      _base.removeSubrange(bounds)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = bounds.lowerBound == _startIndex
      let lastValidIndex = _base.index(before: bounds.lowerBound)
      let newEndIndexOffset =
          _base.distance(from: bounds.lowerBound, to: _endIndex)
        - _base.distance(from: bounds.lowerBound, to: bounds.upperBound)
        + 1
      _base.removeSubrange(bounds)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}
extension Swift.Slice : Swift.Sendable where Base : Swift.Sendable, Base.Index : Swift.Sendable {
}
@usableFromInline
@frozen internal struct _SmallString {
  @usableFromInline
  internal typealias RawBitPattern = (Swift.UInt64, Swift.UInt64)
  @usableFromInline
  internal var _storage: Swift._SmallString.RawBitPattern
  @inlinable @inline(__always) internal var rawBits: Swift._SmallString.RawBitPattern {
    get { return _storage }
  }
  @inlinable internal var leadingRawBits: Swift.UInt64 {
    @inline(__always) get { return _storage.0 }
    @inline(__always) set { _storage.0 = newValue }
  }
  @inlinable internal var trailingRawBits: Swift.UInt64 {
    @inline(__always) get { return _storage.1 }
    @inline(__always) set { _storage.1 = newValue }
  }
  @inlinable @inline(__always) internal init(rawUnchecked bits: Swift._SmallString.RawBitPattern) {
    self._storage = bits
  }
  @inlinable @inline(__always) internal init(raw bits: Swift._SmallString.RawBitPattern) {
    self.init(rawUnchecked: bits)
    _invariantCheck()
  }
  @inlinable @inline(__always) internal init(_ object: Swift._StringObject) {
    _internalInvariant(object.isSmall)
     
    let leading = object.rawBits.0.littleEndian
    let trailing = object.rawBits.1.littleEndian
    self.init(raw: (leading, trailing))
  }
  @inlinable @inline(__always) internal init() {
    self.init(_StringObject(empty:()))
  }
}
extension Swift._SmallString {
  @inlinable @inline(__always) internal static var capacity: Swift.Int {
    get {
    return 15
  }
  }
  @inlinable @inline(__always) internal var rawDiscriminatedObject: Swift.UInt64 {
    get {
     
    return _storage.1.littleEndian
  }
  }
  @inlinable @inline(__always) internal var capacity: Swift.Int {
    get { return _SmallString.capacity }
  }
  @inlinable @inline(__always) internal var count: Swift.Int {
    get {
    return _StringObject.getSmallCount(fromRaw: rawDiscriminatedObject)
  }
  }
  @inlinable @inline(__always) internal var unusedCapacity: Swift.Int {
    get { return capacity &- count }
  }
  @inlinable @inline(__always) internal var isASCII: Swift.Bool {
    get {
    return _StringObject.getSmallIsASCII(fromRaw: rawDiscriminatedObject)
  }
  }
  @inlinable @inline(__always) internal var zeroTerminatedRawCodeUnits: Swift._SmallString.RawBitPattern {
    get {
    let smallStringCodeUnitMask = ~UInt64(0xFF).bigEndian  
    return (self._storage.0, self._storage.1 & smallStringCodeUnitMask)
  }
  }
}
extension Swift._SmallString {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension Swift._SmallString : Swift.RandomAccessCollection, Swift.MutableCollection {
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias Element = Swift.UInt8
  @usableFromInline
  internal typealias SubSequence = Swift._SmallString
  @inlinable @inline(__always) internal var startIndex: Swift.Int {
    get { return 0 }
  }
  @inlinable @inline(__always) internal var endIndex: Swift.Int {
    get { return count }
  }
  @inlinable internal subscript(idx: Swift.Int) -> Swift.UInt8 {
    @inline(__always) get {
      _internalInvariant(idx >= 0 && idx <= 15)
      if idx < 8 {
        return leadingRawBits._uncheckedGetByte(at: idx)
      } else {
        return trailingRawBits._uncheckedGetByte(at: idx &- 8)
      }
    }
    @inline(__always) set {
      _internalInvariant(idx >= 0 && idx <= 15)
      if idx < 8 {
        leadingRawBits._uncheckedSetByte(at: idx, to: newValue)
      } else {
        trailingRawBits._uncheckedSetByte(at: idx &- 8, to: newValue)
      }
    }
  }
  @inlinable @inline(__always) internal subscript(bounds: Swift.Range<Swift._SmallString.Index>) -> Swift._SmallString.SubSequence {
    get {
       
      return self.withUTF8 { utf8 in
        let rebased = UnsafeBufferPointer(rebasing: utf8[bounds])
        return _SmallString(rebased)._unsafelyUnwrappedUnchecked
      }
    }
    @_alwaysEmitIntoClient set { fatalError() }
    @_alwaysEmitIntoClient _modify { fatalError() }
  }
  @usableFromInline
  internal typealias Indices = Swift.Range<Swift._SmallString.Index>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._SmallString>
}
extension Swift._SmallString {
  @inlinable @inline(__always) internal func withUTF8<Result>(_ f: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> Result) rethrows -> Result {
    let count = self.count
    var raw = self.zeroTerminatedRawCodeUnits
#if $TypedThrows
    return try Swift._withUnprotectedUnsafeBytes(of: &raw) {
      let rawPtr = $0.baseAddress._unsafelyUnwrappedUnchecked
       
       
      let ptr = rawPtr.bindMemory(to: UInt8.self, capacity: count)
      defer {
         
        _ = rawPtr.bindMemory(to: RawBitPattern.self, capacity: 1)
      }
      return try f(UnsafeBufferPointer(_uncheckedStart: ptr, count: count))
    }
#else
    return try Swift.__abi_se0413_withUnsafeBytes(of: &raw) {
      let rawPtr = $0.baseAddress._unsafelyUnwrappedUnchecked
       
       
      let ptr = rawPtr.bindMemory(to: UInt8.self, capacity: count)
      defer {
         
        _ = rawPtr.bindMemory(to: RawBitPattern.self, capacity: 1)
      }
      return try f(UnsafeBufferPointer(_uncheckedStart: ptr, count: count))
    }
#endif
  }
  @inlinable @_alwaysEmitIntoClient internal static func zeroTrailingBytes(of storage: inout Swift._SmallString.RawBitPattern, from index: Swift.Int) {
    _internalInvariant(index > 0)
    _internalInvariant(index <= _SmallString.capacity)
     
    let mask0 = (UInt64(bitPattern: ~0) &>> (8 &* ( 8 &- Swift.min(index, 8))))
    let mask1 = (UInt64(bitPattern: ~0) &>> (8 &* (16 &- Swift.max(index, 8))))
    storage.0 &= (index <= 0) ? 0 : mask0.littleEndian
    storage.1 &= (index <= 8) ? 0 : mask1.littleEndian
  }
}
extension Swift._SmallString {
  @inlinable @inline(__always) internal init(leading: Swift.UInt64, trailing: Swift.UInt64, count: Swift.Int) {
    _internalInvariant(count <= _SmallString.capacity)

    let isASCII = (leading | trailing) & 0x8080_8080_8080_8080 == 0
    let discriminator = _StringObject.Nibbles
      .small(withCount: count, isASCII: isASCII)
      .littleEndian  
    _internalInvariant(trailing & discriminator == 0)

    self.init(raw: (leading, trailing | discriminator))
    _internalInvariant(self.count == count)
  }
  @inlinable @inline(__always) internal init?(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>) {
    if input.isEmpty {
      self.init()
      return
    }

    let count = input.count
    guard count <= _SmallString.capacity else { return nil }

     
     
    let ptr = input.baseAddress._unsafelyUnwrappedUnchecked
    let leading = _bytesToUInt64(ptr, Swift.min(input.count, 8))
    let trailing = count > 8 ? _bytesToUInt64(ptr + 8, count &- 8) : 0

    self.init(leading: leading, trailing: trailing, count: count)
  }
  @usableFromInline
  internal init?(_ base: Swift._SmallString, appending other: Swift._SmallString)
}
extension Swift._SmallString {
  @usableFromInline
  @_effects(readonly) internal init?(taggedCocoa cocoa: Swift.AnyObject)
}
extension Swift.UInt64 {
  @inlinable @inline(__always) internal func _uncheckedGetByte(at i: Swift.Int) -> Swift.UInt8 {
    _internalInvariant(i >= 0 && i < MemoryLayout<UInt64>.stride)
    let shift = UInt64(truncatingIfNeeded: i) &* 8
    return UInt8(truncatingIfNeeded: (self &>> shift))
  }
  @inlinable @inline(__always) internal mutating func _uncheckedSetByte(at i: Swift.Int, to value: Swift.UInt8) {
    _internalInvariant(i >= 0 && i < MemoryLayout<UInt64>.stride)
    let shift = UInt64(truncatingIfNeeded: i) &* 8
    let valueMask: UInt64 = 0xFF &<< shift
    self = (self & ~valueMask) | (UInt64(truncatingIfNeeded: value) &<< shift)
  }
}
@inlinable @inline(__always) internal func _bytesToUInt64(_ input: Swift.UnsafePointer<Swift.UInt8>, _ c: Swift.Int) -> Swift.UInt64 {
   
   
   
  var r: UInt64 = 0
  var shift: Int = 0
  for idx in 0..<c {
    r = r | (UInt64(input[idx]) &<< shift)
    shift = shift &+ 8
  }
   
  return r.littleEndian
}
extension Swift.Sequence where Self.Element : Swift.Comparable {
  @inlinable public func sorted() -> [Self.Element] {
    return sorted(by: <)
  }
}
extension Swift.Sequence {
  @inlinable public func sorted(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows -> [Self.Element] {
    var result = ContiguousArray(self)
    try result.sort(by: areInIncreasingOrder)
    return Array(result)
  }
}
extension Swift.MutableCollection where Self : Swift.RandomAccessCollection, Self.Element : Swift.Comparable {
  @inlinable public mutating func sort() {
    sort(by: <)
  }
}
extension Swift.MutableCollection where Self : Swift.RandomAccessCollection {
  @inlinable public mutating func sort(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows {
    let didSortUnsafeBuffer: Void? =
      try withContiguousMutableStorageIfAvailable { buffer in
        try buffer._stableSortImpl(by: areInIncreasingOrder)
      }
    if didSortUnsafeBuffer == nil {
       
       
      let sortedElements = try sorted(by: areInIncreasingOrder)
      for (i, j) in zip(indices, sortedElements.indices) {
        self[i] = sortedElements[j]
      }
    }
  }
}
extension Swift.MutableCollection where Self : Swift.BidirectionalCollection {
  @inlinable internal mutating func _insertionSort(within range: Swift.Range<Self.Index>, sortedEnd: Self.Index, by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows {
    var sortedEnd = sortedEnd
    
     
    while sortedEnd != range.upperBound {
      var i = sortedEnd
       
       
      repeat {
        let j = index(before: i)
        
         
         
        if try !areInIncreasingOrder(self[i], self[j]) {
          break
        }
        
        swapAt(i, j)
        i = j
      } while i != range.lowerBound
      
      formIndex(after: &sortedEnd)
    }
  }
  @inlinable public mutating func _insertionSort(within range: Swift.Range<Self.Index>, by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows {
    if range.isEmpty {
      return
    }
    
     
     
    let sortedEnd = index(after: range.lowerBound)
    try _insertionSort(
      within: range, sortedEnd: sortedEnd, by: areInIncreasingOrder)
  }
  @inlinable internal mutating func _reverse(within range: Swift.Range<Self.Index>) {
    var f = range.lowerBound
    var l = range.upperBound
    while f < l {
      formIndex(before: &l)
      swapAt(f, l)
      formIndex(after: &f)
    }
  }
}
@discardableResult
@inlinable internal func _merge<Element>(low: Swift.UnsafeMutablePointer<Element>, mid: Swift.UnsafeMutablePointer<Element>, high: Swift.UnsafeMutablePointer<Element>, buffer: Swift.UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
  let lowCount = mid - low
  let highCount = high - mid
  
  var destLow = low          
  var bufferLow = buffer     
  var bufferHigh = buffer    

   
   
   
   
  defer {
    destLow.moveInitialize(from: bufferLow, count: bufferHigh - bufferLow)
  }
  
  if lowCount < highCount {
     
     
     
     
     
     
     
     
     
     
     
     
     
    buffer.moveInitialize(from: low, count: lowCount)
    bufferHigh = bufferLow + lowCount
    
    var srcLow = mid

     
     
     
     
    while bufferLow < bufferHigh && srcLow < high {
      if try areInIncreasingOrder(srcLow.pointee, bufferLow.pointee) {
        destLow.moveInitialize(from: srcLow, count: 1)
        srcLow += 1
      } else {
        destLow.moveInitialize(from: bufferLow, count: 1)
        bufferLow += 1
      }
      destLow += 1
    }
  } else {
     
     
     
     
     
     
     
     
     
     
     
     
     
    buffer.moveInitialize(from: mid, count: highCount)
    bufferHigh = bufferLow + highCount
    
    var destHigh = high
    var srcHigh = mid
    destLow = mid

     
     
     
     
     
     
     
    while bufferHigh > bufferLow && srcHigh > low {
      destHigh -= 1
      if try areInIncreasingOrder(
        (bufferHigh - 1).pointee, (srcHigh - 1).pointee
      ) {
        srcHigh -= 1
        destHigh.moveInitialize(from: srcHigh, count: 1)
        
         
         
        destLow -= 1
      } else {
        bufferHigh -= 1
        destHigh.moveInitialize(from: bufferHigh, count: 1)
      }
    }
  }

  return true
}
@inlinable internal func _minimumMergeRunLength(_ c: Swift.Int) -> Swift.Int {
   
  let bitsToUse = 6
  
  if c < 1 << bitsToUse {
    return c
  }
  let offset = (Int.bitWidth - bitsToUse) - c.leadingZeroBitCount
  let mask = (1 << offset) - 1
  return c >> offset + (c & mask == 0 ? 0 : 1)
}
@inlinable internal func _findNextRun<C>(in elements: C, from start: C.Index, by areInIncreasingOrder: (C.Element, C.Element) throws -> Swift.Bool) rethrows -> (end: C.Index, descending: Swift.Bool) where C : Swift.RandomAccessCollection {
  _internalInvariant(start < elements.endIndex)

  var previous = start
  var current = elements.index(after: start)
  guard current < elements.endIndex else {
     
     
    return (current, false)
  }

   
   
   
  let isDescending =
    try areInIncreasingOrder(elements[current], elements[previous])
  
   
   
  repeat {
    previous = current
    elements.formIndex(after: &current)
  } while try current < elements.endIndex &&
    isDescending == areInIncreasingOrder(elements[current], elements[previous])
    
  return(current, isDescending)
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer {
  @discardableResult
  @inlinable internal mutating func _mergeRuns(_ runs: inout [Swift.Range<Swift.UnsafeMutableBufferPointer<Element>.Index>], at i: Swift.Int, buffer: Swift.UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
    _internalInvariant(runs[i - 1].upperBound == runs[i].lowerBound)
    let low = runs[i - 1].lowerBound
    let middle = runs[i].lowerBound
    let high = runs[i].upperBound
    
    try _merge(
      low: baseAddress! + low,
      mid: baseAddress! + middle,
      high: baseAddress! + high,
      buffer: buffer,
      by: areInIncreasingOrder)
    
    runs[i - 1] = low..<high
    runs.remove(at: i)

    return true
  }
  @discardableResult
  @inlinable internal mutating func _mergeTopRuns(_ runs: inout [Swift.Range<Swift.UnsafeMutableBufferPointer<Element>.Index>], buffer: Swift.UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
    
     
    while runs.count > 1 {
      var lastIndex = runs.count - 1
      
       
       
      if lastIndex >= 3 &&
        (runs[lastIndex - 3].count <=
          runs[lastIndex - 2].count + runs[lastIndex - 1].count)
      {
         
         
        if runs[lastIndex - 2].count < runs[lastIndex].count {
          lastIndex -= 1
        }
      } else if lastIndex >= 2 &&
        (runs[lastIndex - 2].count <=
          runs[lastIndex - 1].count + runs[lastIndex].count)
      {
         
         
        if runs[lastIndex - 2].count < runs[lastIndex].count {
          lastIndex -= 1
        }
      } else if runs[lastIndex - 1].count <= runs[lastIndex].count {
         
         
      } else {
         
        break
      }
      
       
      try _mergeRuns(
        &runs, at: lastIndex, buffer: buffer, by: areInIncreasingOrder)
    }

    return true
  }
  @discardableResult
  @inlinable internal mutating func _finalizeRuns(_ runs: inout [Swift.Range<Swift.UnsafeMutableBufferPointer<Element>.Index>], buffer: Swift.UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
    while runs.count > 1 {
      try _mergeRuns(
        &runs, at: runs.count - 1, buffer: buffer, by: areInIncreasingOrder)
    }

    return true
  }
  @inlinable public mutating func _stableSortImpl(by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows {
    let minimumRunLength = _minimumMergeRunLength(count)
    if count <= minimumRunLength {
      try _insertionSort(
        within: startIndex..<endIndex, by: areInIncreasingOrder)
      return
    }

     
     
     
     
     
     
    _ = try Array<Element>(_unsafeUninitializedCapacity: count / 2) {
      buffer, _ in
      var runs: [Range<Index>] = []
      
      var start = startIndex
      while start < endIndex {
         
        var (end, descending) =
          try _findNextRun(in: self, from: start, by: areInIncreasingOrder)
        if descending {
          _reverse(within: start..<end)
        }
        
         
         
        if end < endIndex && end - start < minimumRunLength {
          let newEnd = Swift.min(endIndex, start + minimumRunLength)
          try _insertionSort(
            within: start..<newEnd, sortedEnd: end, by: areInIncreasingOrder)
          end = newEnd
        }
        
         
         
        runs.append(start..<end)
        try _mergeTopRuns(
          &runs, buffer: buffer.baseAddress!, by: areInIncreasingOrder)
        start = end
      }
      
      try _finalizeRuns(
        &runs, buffer: buffer.baseAddress!, by: areInIncreasingOrder)
      _internalInvariant(runs.count == 1, "Didn't complete final merge")
    }
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @discardableResult
  @inlinable internal mutating func _mergeRuns(_ runs: inout [Swift.Range<Swift.UnsafeMutableBufferPointer<Element>.Index>], at i: Swift.Int, buffer: Swift.UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
    _internalInvariant(runs[i - 1].upperBound == runs[i].lowerBound)
    let low = runs[i - 1].lowerBound
    let middle = runs[i].lowerBound
    let high = runs[i].upperBound
    
    try _merge(
      low: baseAddress! + low,
      mid: baseAddress! + middle,
      high: baseAddress! + high,
      buffer: buffer,
      by: areInIncreasingOrder)
    
    runs[i - 1] = low..<high
    runs.remove(at: i)

    return true
  }
  @discardableResult
  @inlinable internal mutating func _mergeTopRuns(_ runs: inout [Swift.Range<Swift.UnsafeMutableBufferPointer<Element>.Index>], buffer: Swift.UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
    
     
    while runs.count > 1 {
      var lastIndex = runs.count - 1
      
       
       
      if lastIndex >= 3 &&
        (runs[lastIndex - 3].count <=
          runs[lastIndex - 2].count + runs[lastIndex - 1].count)
      {
         
         
        if runs[lastIndex - 2].count < runs[lastIndex].count {
          lastIndex -= 1
        }
      } else if lastIndex >= 2 &&
        (runs[lastIndex - 2].count <=
          runs[lastIndex - 1].count + runs[lastIndex].count)
      {
         
         
        if runs[lastIndex - 2].count < runs[lastIndex].count {
          lastIndex -= 1
        }
      } else if runs[lastIndex - 1].count <= runs[lastIndex].count {
         
         
      } else {
         
        break
      }
      
       
      try _mergeRuns(
        &runs, at: lastIndex, buffer: buffer, by: areInIncreasingOrder)
    }

    return true
  }
  @discardableResult
  @inlinable internal mutating func _finalizeRuns(_ runs: inout [Swift.Range<Swift.UnsafeMutableBufferPointer<Element>.Index>], buffer: Swift.UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
    while runs.count > 1 {
      try _mergeRuns(
        &runs, at: runs.count - 1, buffer: buffer, by: areInIncreasingOrder)
    }

    return true
  }
  @inlinable public mutating func _stableSortImpl(by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows {
    let minimumRunLength = _minimumMergeRunLength(count)
    if count <= minimumRunLength {
      try _insertionSort(
        within: startIndex..<endIndex, by: areInIncreasingOrder)
      return
    }

     
     
     
     
     
     
    _ = try Array<Element>(_unsafeUninitializedCapacity: count / 2) {
      buffer, _ in
      var runs: [Range<Index>] = []
      
      var start = startIndex
      while start < endIndex {
         
        var (end, descending) =
          try _findNextRun(in: self, from: start, by: areInIncreasingOrder)
        if descending {
          _reverse(within: start..<end)
        }
        
         
         
        if end < endIndex && end - start < minimumRunLength {
          let newEnd = Swift.min(endIndex, start + minimumRunLength)
          try _insertionSort(
            within: start..<newEnd, sortedEnd: end, by: areInIncreasingOrder)
          end = newEnd
        }
        
         
         
        runs.append(start..<end)
        try _mergeTopRuns(
          &runs, buffer: buffer.baseAddress!, by: areInIncreasingOrder)
        start = end
      }
      
      try _finalizeRuns(
        &runs, buffer: buffer.baseAddress!, by: areInIncreasingOrder)
      _internalInvariant(runs.count == 1, "Didn't complete final merge")
    }
  }
}
#endif
@frozen public struct StaticString : Swift.Sendable {
  @usableFromInline
  internal var _startPtrOrData: Builtin.Word
  @usableFromInline
  internal var _utf8CodeUnitCount: Builtin.Word
  @usableFromInline
  internal var _flags: Builtin.Int8
  @_transparent public init() {
    self = ""
  }
  @usableFromInline
  @_transparent internal init(_start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
     
     
     
    self._startPtrOrData = Builtin.ptrtoint_Word(_start)
    self._utf8CodeUnitCount = utf8CodeUnitCount
    self._flags = Bool(isASCII)
      ? (0x2 as UInt8)._value
      : (0x0 as UInt8)._value
  }
  @usableFromInline
  @_transparent internal init(unicodeScalar: Builtin.Int32) {
    self._startPtrOrData = UInt(UInt32(unicodeScalar))._builtinWordValue
    self._utf8CodeUnitCount = 0._builtinWordValue
    self._flags = Unicode.Scalar(_builtinUnicodeScalarLiteral: unicodeScalar).isASCII
      ? (0x3 as UInt8)._value
      : (0x1 as UInt8)._value
  }
  @_transparent public var utf8Start: Swift.UnsafePointer<Swift.UInt8> {
    @_transparent get {
    _precondition(
      hasPointerRepresentation,
      "StaticString should have pointer representation")
    return UnsafePointer(bitPattern: UInt(_startPtrOrData))!
  }
  }
  @_transparent public var unicodeScalar: Swift.Unicode.Scalar {
    @_transparent get {
    _precondition(
      !hasPointerRepresentation,
      "StaticString should have Unicode scalar representation")
    return Unicode.Scalar(UInt32(UInt(_startPtrOrData)))!
  }
  }
  @_transparent public var utf8CodeUnitCount: Swift.Int {
    @_transparent get {
    _precondition(
      hasPointerRepresentation,
      "StaticString should have pointer representation")
    return Int(_utf8CodeUnitCount)
  }
  }
  @_alwaysEmitIntoClient @_transparent internal var unsafeRawPointer: Builtin.RawPointer {
    @_transparent get {
    return Builtin.inttoptr_Word(_startPtrOrData)
  }
  }
  @_transparent public var hasPointerRepresentation: Swift.Bool {
    @_transparent get {
    return (UInt8(_flags) & 0x1) == 0
  }
  }
  @_transparent public var isASCII: Swift.Bool {
    @_transparent get {
    return (UInt8(_flags) & 0x2) != 0
  }
  }
  @_transparent public func withUTF8Buffer<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) -> R) -> R {
    if hasPointerRepresentation {
      return body(UnsafeBufferPointer(
        start: utf8Start, count: utf8CodeUnitCount))
    } else {
      #if $Embedded
      fatalError("non-pointer representation not supported in embedded Swift")
      #else
      return unicodeScalar.withUTF8CodeUnits { body($0) }
      #endif
    }
  }
}
extension Swift.StaticString : Swift._ExpressibleByBuiltinUnicodeScalarLiteral {
  @_effects(readonly) @_transparent public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self = StaticString(unicodeScalar: value)
  }
}
extension Swift.StaticString : Swift.ExpressibleByUnicodeScalarLiteral {
  @_effects(readonly) @_transparent public init(unicodeScalarLiteral value: Swift.StaticString) {
    self = value
  }
  public typealias UnicodeScalarLiteralType = Swift.StaticString
}
extension Swift.StaticString : Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral {
  @_effects(readonly) @_transparent public init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    self = StaticString(
      _builtinStringLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII
    )
  }
}
extension Swift.StaticString : Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  @_effects(readonly) @_transparent public init(extendedGraphemeClusterLiteral value: Swift.StaticString) {
    self = value
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StaticString
}
extension Swift.StaticString : Swift._ExpressibleByBuiltinStringLiteral {
  @_effects(readonly) @_transparent public init(_builtinStringLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    self = StaticString(
      _start: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII)
  }
}
extension Swift.StaticString : Swift.ExpressibleByStringLiteral {
  @_effects(readonly) @_transparent public init(stringLiteral value: Swift.StaticString) {
    self = value
  }
  public typealias StringLiteralType = Swift.StaticString
}
extension Swift.StaticString : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Swift.StaticString : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.StaticString : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol Strideable<Stride> : Swift.Comparable {
  associatedtype Stride : Swift.Comparable, Swift.SignedNumeric
  func distance(to other: Self) -> Self.Stride
  func advanced(by n: Self.Stride) -> Self
  static func _step(after current: (index: Swift.Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Swift.Int?, value: Self)
}
#else
public protocol Strideable : Swift.Comparable {
  associatedtype Stride : Swift.Comparable, Swift.SignedNumeric
  func distance(to other: Self) -> Self.Stride
  func advanced(by n: Self.Stride) -> Self
  static func _step(after current: (index: Swift.Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Swift.Int?, value: Self)
}
#endif
extension Swift.Strideable {
  @inlinable public static func < (x: Self, y: Self) -> Swift.Bool {
    return x.distance(to: y) > 0
  }
  @inlinable public static func == (x: Self, y: Self) -> Swift.Bool {
    return x.distance(to: y) == 0
  }
}
extension Swift.Strideable {
  @inlinable public static func _step(after current: (index: Swift.Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Swift.Int?, value: Self) {
    return (nil, current.value.advanced(by: distance))
  }
}
extension Swift.Strideable where Self : Swift.FixedWidthInteger, Self : Swift.SignedInteger {
  @_alwaysEmitIntoClient public static func _step(after current: (index: Swift.Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Swift.Int?, value: Self) {
    let value = current.value
    let (partialValue, overflow) =
      Self.bitWidth >= Self.Stride.bitWidth ||
        (value < (0 as Self)) == (distance < (0 as Self.Stride))
          ? value.addingReportingOverflow(Self(distance))
          : (Self(Self.Stride(value) + distance), false)
    return overflow
      ? (.min, distance < (0 as Self.Stride) ? .min : .max)
      : (nil, partialValue)
  }
}
extension Swift.Strideable where Self : Swift.FixedWidthInteger, Self : Swift.UnsignedInteger {
  @_alwaysEmitIntoClient public static func _step(after current: (index: Swift.Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Swift.Int?, value: Self) {
    let (partialValue, overflow) = distance < (0 as Self.Stride)
      ? current.value.subtractingReportingOverflow(Self(-distance))
      : current.value.addingReportingOverflow(Self(distance))
    return overflow
      ? (.min, distance < (0 as Self.Stride) ? .min : .max)
      : (nil, partialValue)
  }
}
extension Swift.Strideable where Self.Stride : Swift.FloatingPoint {
  @inlinable public static func _step(after current: (index: Swift.Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Swift.Int?, value: Self) {
    if let i = current.index {
       
       
      return (i + 1, start.advanced(by: Stride(i + 1) * distance))
    }
    return (nil, current.value.advanced(by: distance))
  }
}
extension Swift.Strideable where Self : Swift.FloatingPoint, Self == Self.Stride {
  @inlinable public static func _step(after current: (index: Swift.Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Swift.Int?, value: Self) {
    if let i = current.index {
       
       
       
      return (i + 1, start.addingProduct(Stride(i + 1), distance))
    }
    return (nil, current.value.advanced(by: distance))
  }
}
@frozen public struct StrideToIterator<Element> where Element : Swift.Strideable {
  @usableFromInline
  internal let _start: Element
  @usableFromInline
  internal let _end: Element
  @usableFromInline
  internal let _stride: Element.Stride
  @usableFromInline
  internal var _current: (index: Swift.Int?, value: Element)
  @inlinable internal init(_start: Element, end: Element, stride: Element.Stride) {
    self._start = _start
    _end = end
    _stride = stride
    _current = (0, _start)
  }
}
extension Swift.StrideToIterator : Swift.IteratorProtocol {
  @inlinable public mutating func next() -> Element? {
    let result = _current.value
    if _stride > 0 ? result >= _end : result <= _end {
      return nil
    }
    _current = Element._step(after: _current, from: _start, by: _stride)
    return result
  }
}
@frozen public struct StrideTo<Element> where Element : Swift.Strideable {
  @usableFromInline
  internal let _start: Element
  @usableFromInline
  internal let _end: Element
  @usableFromInline
  internal let _stride: Element.Stride
  @inlinable internal init(_start: Element, end: Element, stride: Element.Stride) {
    _precondition(stride != 0, "Stride size must not be zero")
     
     
    self._start = _start
    self._end = end
    self._stride = stride
  }
}
extension Swift.StrideTo : Swift.Sequence {
  @inlinable public __consuming func makeIterator() -> Swift.StrideToIterator<Element> {
    return StrideToIterator(_start: _start, end: _end, stride: _stride)
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    var it = self.makeIterator()
    var count = 0
    while it.next() != nil {
      count += 1
    }
    return count
  }
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    if _stride < 0 {
      if element <= _end || _start < element { return false }
    } else {
      if element < _start || _end <= element { return false }
    }
     
     
    return nil
  }
  public typealias Iterator = Swift.StrideToIterator<Element>
}
extension Swift.StrideTo : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@inlinable public func stride<T>(from start: T, to end: T, by stride: T.Stride) -> Swift.StrideTo<T> where T : Swift.Strideable {
  return StrideTo(_start: start, end: end, stride: stride)
}
@frozen public struct StrideThroughIterator<Element> where Element : Swift.Strideable {
  @usableFromInline
  internal let _start: Element
  @usableFromInline
  internal let _end: Element
  @usableFromInline
  internal let _stride: Element.Stride
  @usableFromInline
  internal var _current: (index: Swift.Int?, value: Element)
  @usableFromInline
  internal var _didReturnEnd: Swift.Bool = false
  @inlinable internal init(_start: Element, end: Element, stride: Element.Stride) {
    self._start = _start
    _end = end
    _stride = stride
    _current = (0, _start)
  }
}
extension Swift.StrideThroughIterator : Swift.IteratorProtocol {
  @inlinable public mutating func next() -> Element? {
    let result = _current.value
    if _stride > 0 ? result >= _end : result <= _end {
       
       
       
       
       
       
      if result == _end && !_didReturnEnd && _current.index != .min {
        _didReturnEnd = true
        return result
      }
      return nil
    }
    _current = Element._step(after: _current, from: _start, by: _stride)
    return result
  }
}
@frozen public struct StrideThrough<Element> where Element : Swift.Strideable {
  @usableFromInline
  internal let _start: Element
  @usableFromInline
  internal let _end: Element
  @usableFromInline
  internal let _stride: Element.Stride
  @inlinable internal init(_start: Element, end: Element, stride: Element.Stride) {
    _precondition(stride != 0, "Stride size must not be zero")
    self._start = _start
    self._end = end
    self._stride = stride
  }
}
extension Swift.StrideThrough : Swift.Sequence {
  @inlinable public __consuming func makeIterator() -> Swift.StrideThroughIterator<Element> {
    return StrideThroughIterator(_start: _start, end: _end, stride: _stride)
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    var it = self.makeIterator()
    var count = 0
    while it.next() != nil {
      count += 1
    }
    return count
  }
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    if _stride < 0 {
      if element < _end || _start < element { return false }
    } else {
      if element < _start || _end < element { return false }
    }
     
     
    return nil
  }
  public typealias Iterator = Swift.StrideThroughIterator<Element>
}
extension Swift.StrideThrough : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@inlinable public func stride<T>(from start: T, through end: T, by stride: T.Stride) -> Swift.StrideThrough<T> where T : Swift.Strideable {
  return StrideThrough(_start: start, end: end, stride: stride)
}
extension Swift.StrideToIterator : Swift.Sendable where Element : Swift.Sendable, Element.Stride : Swift.Sendable {
}
extension Swift.StrideTo : Swift.Sendable where Element : Swift.Sendable, Element.Stride : Swift.Sendable {
}
extension Swift.StrideThroughIterator : Swift.Sendable where Element : Swift.Sendable, Element.Stride : Swift.Sendable {
}
extension Swift.StrideThrough : Swift.Sendable where Element : Swift.Sendable, Element.Stride : Swift.Sendable {
}
extension Swift.String : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.StringProtocol {
  @_specialize(exported: false, kind: full, where Self == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring)
  public func hash(into hasher: inout Swift.Hasher)
}
@inlinable @_transparent internal func unimplemented_utf8_32bit(_ message: Swift.String = "", file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never {
  fatalError("32-bit: Unimplemented for UTF-8 support", file: file, line: line)
}
#if compiler(>=5.3) && $LexicalLifetimes
@frozen @_eagerMove public struct String {
  public var _guts: Swift._StringGuts
  @inlinable @inline(__always) internal init(_ _guts: Swift._StringGuts) {
    self._guts = _guts
    _invariantCheck()
  }
  @_alwaysEmitIntoClient @_semantics("string.init_empty_with_capacity") @_semantics("inline_late") @inlinable internal static func _createEmpty(withInitialCapacity: Swift.Int) -> Swift.String {
    return String(_StringGuts(_initialCapacity: withInitialCapacity))
  }
  @inlinable @inline(__always) @_semantics("string.init_empty") public init() { self.init(_StringGuts()) }
}
#else
@frozen public struct String {
  public var _guts: Swift._StringGuts
  @inlinable @inline(__always) internal init(_ _guts: Swift._StringGuts) {
    self._guts = _guts
    _invariantCheck()
  }
  @_alwaysEmitIntoClient @_semantics("string.init_empty_with_capacity") @_semantics("inline_late") @inlinable internal static func _createEmpty(withInitialCapacity: Swift.Int) -> Swift.String {
    return String(_StringGuts(_initialCapacity: withInitialCapacity))
  }
  @inlinable @inline(__always) @_semantics("string.init_empty") public init() { self.init(_StringGuts()) }
}
#endif
extension Swift.String : Swift.Sendable {
}
extension Swift.String {
  @inlinable @inline(__always) internal func _invariantCheck() {}
  public func _dump()
}
extension Swift.String {
  @_alwaysEmitIntoClient public func _isIdentical(to other: Swift.String) -> Swift.Bool {
    self._guts.rawBits == other._guts.rawBits
  }
}
extension Swift.String {
  @_alwaysEmitIntoClient @inline(never) private static func _fromNonContiguousUnsafeBitcastUTF8Repairing<C>(_ input: C) -> (result: Swift.String, repairsMade: Swift.Bool) where C : Swift.Collection {
    _internalInvariant(C.Element.self == UInt8.self)
    return Array(input).withUnsafeBufferPointer {
      let raw = UnsafeRawBufferPointer($0)
      return String._fromUTF8Repairing(raw.bindMemory(to: UInt8.self))
    }
  }
  @inlinable @inline(__always) public init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Swift.Collection, Encoding : Swift._UnicodeEncoding, C.Element == Encoding.CodeUnit {
    guard _fastPath(sourceEncoding == UTF8.self) else {
      self = String._fromCodeUnits(
        codeUnits, encoding: sourceEncoding, repair: true)!.0
      return
    }

     
     
     
     
     
    if let str = codeUnits.withContiguousStorageIfAvailable({
      (buffer: UnsafeBufferPointer<C.Element>) -> String in
      Builtin.onFastPath()  
      let rawBufPtr = UnsafeRawBufferPointer(buffer)
      return String._fromUTF8Repairing(
        UnsafeBufferPointer(
          start: rawBufPtr.baseAddress?.assumingMemoryBound(to: UInt8.self),
          count: rawBufPtr.count)).0
    }) {
      self = str
      return
    }

     
    if let contigBytes = codeUnits as? _HasContiguousBytes,
      contigBytes._providesContiguousBytesNoCopy
    {
      self = contigBytes.withUnsafeBytes { rawBufPtr in
        Builtin.onFastPath()  
        return String._fromUTF8Repairing(
          UnsafeBufferPointer(
            start: rawBufPtr.baseAddress?.assumingMemoryBound(to: UInt8.self),
            count: rawBufPtr.count)).0
      }
      return
    }

    self = String._fromNonContiguousUnsafeBitcastUTF8Repairing(codeUnits).0
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init?<Encoding>(validating codeUnits: some Sequence<Encoding.CodeUnit>, as encoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding {
    let contiguousResult = codeUnits.withContiguousStorageIfAvailable {
      String._validate($0, as: Encoding.self)
    }
    if let validationResult = contiguousResult {
      guard let validatedString = validationResult else {
        return nil
      }
      self = validatedString
      return
    }

     
    var transcoded: [UTF8.CodeUnit] = []
    transcoded.reserveCapacity(codeUnits.underestimatedCount)
    var isASCII = true
    let error = transcode(
      codeUnits.makeIterator(),
      from: Encoding.self,
      to: UTF8.self,
      stoppingOnError: true,
      into: {
        uint8 in
        transcoded.append(uint8)
        if isASCII && (uint8 & 0x80) == 0x80 { isASCII = false }
      }
    )
    if error { return nil }
    self = transcoded.withUnsafeBufferPointer{
      String._uncheckedFromUTF8($0, asciiPreScanResult: isASCII)
    }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init?<Encoding>(validating codeUnits: some Sequence<Int8>, as encoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding, Encoding.CodeUnit == Swift.UInt8 {
    let contiguousResult = codeUnits.withContiguousStorageIfAvailable {
      $0.withMemoryRebound(to: UInt8.self) {
        String._validate($0, as: Encoding.self)
      }
    }
    if let validationResult = contiguousResult {
      guard let validatedString = validationResult else {
        return nil
      }
      self = validatedString
      return
    }

     
    let uint8s = codeUnits.lazy.map(UInt8.init(bitPattern:))
    self.init(validating: uint8s, as: Encoding.self)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @inline(__always) public init(unsafeUninitializedCapacity capacity: Swift.Int, initializingUTF8With initializer: (_ buffer: Swift.UnsafeMutableBufferPointer<Swift.UInt8>) throws -> Swift.Int) rethrows
  @inlinable @inline(__always) public func withCString<Result, TargetEncoding>(encodedAs targetEncoding: TargetEncoding.Type, _ body: (Swift.UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result where TargetEncoding : Swift._UnicodeEncoding {
    if targetEncoding == UTF8.self {
      return try self.withCString {
        (cPtr: UnsafePointer<CChar>) -> Result  in
        _internalInvariant(UInt8.self == TargetEncoding.CodeUnit.self)
        let ptr = UnsafeRawPointer(cPtr).assumingMemoryBound(
          to: TargetEncoding.CodeUnit.self)
        return try body(ptr)
      }
    }
    return try _slowWithCString(encodedAs: targetEncoding, body)
  }
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _slowWithCString<Result, TargetEncoding>(encodedAs targetEncoding: TargetEncoding.Type, _ body: (Swift.UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result where TargetEncoding : Swift._UnicodeEncoding
}
extension Swift.String : Swift._ExpressibleByBuiltinUnicodeScalarLiteral {
  @_effects(readonly) @inlinable @inline(__always) public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self.init(Unicode.Scalar(_unchecked: UInt32(value)))
  }
  @inlinable @inline(__always) public init(_ scalar: Swift.Unicode.Scalar) {
    self = scalar.withUTF8CodeUnits { String._uncheckedFromUTF8($0) }
  }
}
extension Swift.String : Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral {
  @inlinable @inline(__always) @_effects(readonly) @_semantics("string.makeUTF8") public init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    self.init(
      _builtinStringLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII)
  }
}
extension Swift.String : Swift._ExpressibleByBuiltinStringLiteral {
  @inlinable @inline(__always) @_effects(readonly) @_semantics("string.makeUTF8") public init(_builtinStringLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    let bufPtr = UnsafeBufferPointer(
      start: UnsafeRawPointer(start).assumingMemoryBound(to: UInt8.self),
      count: Int(utf8CodeUnitCount))
    if let smol = _SmallString(bufPtr) {
      self = String(_StringGuts(smol))
      return
    }
    self.init(_StringGuts(bufPtr, isASCII: Bool(isASCII)))
  }
}
extension Swift.String : Swift.ExpressibleByStringLiteral {
  @inlinable @inline(__always) public init(stringLiteral value: Swift.String) {
    self = value
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Swift.String : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.String {
  @inlinable @_effects(readonly) @_semantics("string.concat") public static func + (lhs: Swift.String, rhs: Swift.String) -> Swift.String {
    var result = lhs
    result.append(rhs)
    return result
  }
  @inlinable @_semantics("string.plusequals") public static func += (lhs: inout Swift.String, rhs: Swift.String) {
    lhs.append(rhs)
  }
}
extension Swift.Sequence where Self.Element : Swift.StringProtocol {
  @_specialize(exported: false, kind: full, where Self == [Swift.Substring])
  @_specialize(exported: false, kind: full, where Self == [Swift.String])
  public func joined(separator: Swift.String = "") -> Swift.String
}
extension Swift.BidirectionalCollection where Self.Element == Swift.String {
  @_specialize(exported: false, kind: full, where Self == [Swift.String])
  public func joined(separator: Swift.String = "") -> Swift.String
}
extension Swift.String {
  @_effects(releasenone) public func lowercased() -> Swift.String
  @_effects(releasenone) public func uppercased() -> Swift.String
  @inlinable @inline(__always) public init<T>(_ value: T) where T : Swift.LosslessStringConvertible {
    self = value.description
  }
}
extension Swift.String : Swift.CustomStringConvertible {
  @inlinable public var description: Swift.String {
    get { return self }
  }
}
extension Swift.String {
  public var _nfcCodeUnits: [Swift.UInt8] {
    get
  }
  public func _withNFCCodeUnits(_ f: (Swift.UInt8) throws -> Swift.Void) rethrows
}
@usableFromInline
internal typealias _CocoaString = Swift.AnyObject
@usableFromInline
@_effects(releasenone) internal func _stdlib_binary_CFStringCreateCopy(_ source: Swift._CocoaString) -> Swift._CocoaString
@usableFromInline
@_effects(readonly) internal func _stdlib_binary_CFStringGetLength(_ source: Swift._CocoaString) -> Swift.Int
@usableFromInline
@_effects(readonly) internal func _stdlib_binary_CFStringGetCharactersPtr(_ source: Swift._CocoaString) -> Swift.UnsafeMutablePointer<Swift.UTF16.CodeUnit>?
@usableFromInline
@_effects(releasenone) internal func _bridgeCocoaString(_ cocoaString: Swift._CocoaString) -> Swift._StringGuts
extension Swift.String {
  @_effects(releasenone) public func _bridgeToObjectiveCImpl() -> Swift.AnyObject
}
@available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
@_cdecl("_SwiftCreateBridgedString")
@usableFromInline
internal func _SwiftCreateBridgedString_DoNotCall(bytes: Swift.UnsafePointer<Swift.UInt8>, length: Swift.Int, encoding: SwiftShims._swift_shims_CFStringEncoding) -> Swift.Unmanaged<Swift.AnyObject>
@_silgen_name("swift_stdlib_getDescription")
public func _getDescription<T>(_ x: T) -> Swift.AnyObject
@available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
@_silgen_name("swift_stdlib_NSStringFromUTF8")
@usableFromInline
internal func _NSStringFromUTF8(_ s: Swift.UnsafePointer<Swift.UInt8>, _ len: Swift.Int) -> Swift.AnyObject
extension Swift.StringProtocol {
  @_specialize(exported: false, kind: full, where Self == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring)
  public func _toUTF16Offset(_ idx: Self.Index) -> Swift.Int
  @_specialize(exported: false, kind: full, where Self == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring)
  public func _toUTF16Index(_ offset: Swift.Int) -> Self.Index
  public func _toUTF16Offsets(_ indices: Swift.Range<Self.Index>) -> Swift.Range<Swift.Int>
  public func _toUTF16Indices(_ range: Swift.Range<Swift.Int>) -> Swift.Range<Self.Index>
}
extension Swift.String {
  public func _copyUTF16CodeUnits(into buffer: Swift.UnsafeMutableBufferPointer<Swift.UInt16>, range: Swift.Range<Swift.Int>)
}
extension Swift.String : Swift.BidirectionalCollection {
  public typealias SubSequence = Swift.Substring
  public typealias Element = Swift.Character
  @inlinable @inline(__always) public var startIndex: Swift.String.Index {
    get { return _guts.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.String.Index {
    get { return _guts.endIndex }
  }
  @inline(__always) public var count: Swift.Int {
    get
  }
  public func index(after i: Swift.String.Index) -> Swift.String.Index
  public func index(before i: Swift.String.Index) -> Swift.String.Index
  public func index(_ i: Swift.String.Index, offsetBy distance: Swift.Int) -> Swift.String.Index
  public func index(_ i: Swift.String.Index, offsetBy distance: Swift.Int, limitedBy limit: Swift.String.Index) -> Swift.String.Index?
  public func distance(from start: Swift.String.Index, to end: Swift.String.Index) -> Swift.Int
  public subscript(i: Swift.String.Index) -> Swift.Character {
    get
  }
  @usableFromInline
  @inline(__always) internal func _characterStride(startingAt i: Swift.String.Index) -> Swift.Int
  @usableFromInline
  @inline(__always) internal func _characterStride(endingAt i: Swift.String.Index) -> Swift.Int
  public typealias Indices = Swift.DefaultIndices<Swift.String>
}
extension Swift.String {
  @frozen public struct Iterator : Swift.IteratorProtocol, Swift.Sendable {
    @usableFromInline
    internal var _guts: Swift._StringGuts
    @usableFromInline
    internal var _position: Swift.Int = 0
    @usableFromInline
    internal var _end: Swift.Int
    @inlinable internal init(_ guts: Swift._StringGuts) {
      self._end = guts.count
      self._guts = guts
    }
    public mutating func next() -> Swift.Character?
    public typealias Element = Swift.Character
  }
  @inlinable public __consuming func makeIterator() -> Swift.String.Iterator {
    return Iterator(_guts)
  }
}
extension Swift.StringProtocol {
  @_specialize(exported: false, kind: full, where Self == Swift.String, RHS == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.String, RHS == Swift.Substring)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring, RHS == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring, RHS == Swift.Substring)
  @inlinable @_effects(readonly) public static func == <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Swift.StringProtocol {
    return _stringCompare(
      lhs._wholeGuts, lhs._offsetRange,
      rhs._wholeGuts, rhs._offsetRange,
      expecting: .equal)
  }
  @inlinable @inline(__always) @_effects(readonly) public static func != <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Swift.StringProtocol {
    return !(lhs == rhs)
  }
  @_specialize(exported: false, kind: full, where Self == Swift.String, RHS == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.String, RHS == Swift.Substring)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring, RHS == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring, RHS == Swift.Substring)
  @inlinable @_effects(readonly) public static func < <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Swift.StringProtocol {
    return _stringCompare(
      lhs._wholeGuts, lhs._offsetRange,
      rhs._wholeGuts, rhs._offsetRange,
      expecting: .less)
  }
  @inlinable @inline(__always) @_effects(readonly) public static func > <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Swift.StringProtocol {
    return rhs < lhs
  }
  @inlinable @inline(__always) @_effects(readonly) public static func <= <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Swift.StringProtocol {
    return !(rhs < lhs)
  }
  @inlinable @inline(__always) @_effects(readonly) public static func >= <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Swift.StringProtocol {
    return !(lhs < rhs)
  }
}
extension Swift.String : Swift.Equatable {
  @inlinable @inline(__always) @_effects(readonly) @_semantics("string.equals") public static func == (lhs: Swift.String, rhs: Swift.String) -> Swift.Bool {
    return _stringCompare(lhs._guts, rhs._guts, expecting: .equal)
  }
}
extension Swift.String : Swift.Comparable {
  @inlinable @inline(__always) @_effects(readonly) public static func < (lhs: Swift.String, rhs: Swift.String) -> Swift.Bool {
    return _stringCompare(lhs._guts, rhs._guts, expecting: .less)
  }
}
extension Swift.Substring : Swift.Equatable {
}
extension Swift.String {
  @_alwaysEmitIntoClient @inline(__always) @_effects(readonly) public static func ~= (lhs: Swift.String, rhs: Swift.Substring) -> Swift.Bool {
    return lhs == rhs
  }
}
extension Swift.Substring {
  @_alwaysEmitIntoClient @inline(__always) @_effects(readonly) public static func ~= (lhs: Swift.Substring, rhs: Swift.String) -> Swift.Bool {
    return lhs == rhs
  }
}
@inlinable @inline(__always) @_effects(readonly) internal func _stringCompare(_ lhs: Swift._StringGuts, _ rhs: Swift._StringGuts, expecting: Swift._StringComparisonResult) -> Swift.Bool {
  if lhs.rawBits == rhs.rawBits { return expecting == .equal }
  return _stringCompareWithSmolCheck(lhs, rhs, expecting: expecting)
}
@usableFromInline
@_effects(readonly) internal func _stringCompareWithSmolCheck(_ lhs: Swift._StringGuts, _ rhs: Swift._StringGuts, expecting: Swift._StringComparisonResult) -> Swift.Bool
@usableFromInline
@inline(never) @_effects(readonly) internal func _stringCompareInternal(_ lhs: Swift._StringGuts, _ rhs: Swift._StringGuts, expecting: Swift._StringComparisonResult) -> Swift.Bool
@inlinable @inline(__always) @_effects(readonly) internal func _stringCompare(_ lhs: Swift._StringGuts, _ lhsRange: Swift.Range<Swift.Int>, _ rhs: Swift._StringGuts, _ rhsRange: Swift.Range<Swift.Int>, expecting: Swift._StringComparisonResult) -> Swift.Bool {
  if lhs.rawBits == rhs.rawBits && lhsRange == rhsRange {
    return expecting == .equal
  }
  return _stringCompareInternal(
    lhs, lhsRange, rhs, rhsRange, expecting: expecting)
}
@usableFromInline
@_effects(readonly) internal func _stringCompareInternal(_ lhs: Swift._StringGuts, _ lhsRange: Swift.Range<Swift.Int>, _ rhs: Swift._StringGuts, _ rhsRange: Swift.Range<Swift.Int>, expecting: Swift._StringComparisonResult) -> Swift.Bool
@usableFromInline
@frozen internal enum _StringComparisonResult {
  case equal
  case less
  @inlinable @inline(__always) internal init(signedNotation int: Swift.Int) {
    _internalInvariant(int <= 0)
    self = int == 0 ? .equal : .less
  }
  @inlinable @inline(__always) internal static func == (lhs: Swift._StringComparisonResult, rhs: Swift._StringComparisonResult) -> Swift.Bool {
    switch (lhs, rhs) {
      case (.equal, .equal): return true
      case (.less, .less): return true
      default: return false
    }
  }
  @usableFromInline
  internal func hash(into hasher: inout Swift.Hasher)
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
}
extension Swift.String {
  @usableFromInline
  internal static func _fromASCII(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>) -> Swift.String
  public static func _tryFromUTF8(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>) -> Swift.String?
  @usableFromInline
  internal static func _fromUTF8Repairing(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>) -> (result: Swift.String, repairsMade: Swift.Bool)
  @usableFromInline
  internal static func _uncheckedFromUTF8(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>) -> Swift.String
  @usableFromInline
  internal static func _uncheckedFromUTF8(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>, isASCII: Swift.Bool) -> Swift.String
  @usableFromInline
  internal static func _uncheckedFromUTF8(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>, asciiPreScanResult: Swift.Bool) -> Swift.String
  @usableFromInline
  internal static func _uncheckedFromUTF16(_ input: Swift.UnsafeBufferPointer<Swift.UInt16>) -> Swift.String
  @usableFromInline
  @_specialize(exported: false, kind: full, where Input == Swift.UnsafeBufferPointer<Swift.UInt8>, Encoding == Swift.Unicode.ASCII)
  @_specialize(exported: false, kind: full, where Input == [Swift.UInt8], Encoding == Swift.Unicode.ASCII)
  @inline(never) internal static func _fromCodeUnits<Input, Encoding>(_ input: Input, encoding: Encoding.Type, repair: Swift.Bool) -> (Swift.String, repairsMade: Swift.Bool)? where Input : Swift.Collection, Encoding : Swift._UnicodeEncoding, Input.Element == Encoding.CodeUnit
  public static func _fromInvalidUTF16(_ utf16: Swift.UnsafeBufferPointer<Swift.UInt16>) -> Swift.String
  @usableFromInline
  internal static func _fromSubstring(_ substring: __shared Swift.Substring) -> Swift.String
  @_alwaysEmitIntoClient @inline(never) internal static func _copying(_ str: Swift.String) -> Swift.String {
    return String._copying(str[...])
  }
  @_alwaysEmitIntoClient @inline(never) internal static func _copying(_ str: Swift.Substring) -> Swift.String {
    if _fastPath(str._wholeGuts.isFastUTF8) {
      return str._wholeGuts.withFastUTF8(range: str._offsetRange) {
        String._uncheckedFromUTF8($0)
      }
    }
    return Array(str.utf8).withUnsafeBufferPointer {
      String._uncheckedFromUTF8($0)
    }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @usableFromInline
  internal static func _validate<Encoding>(_ input: Swift.UnsafeBufferPointer<Encoding.CodeUnit>, as encoding: Encoding.Type) -> Swift.String? where Encoding : Swift._UnicodeEncoding
}
@frozen public struct _StringGuts : @unchecked Swift.Sendable {
  @usableFromInline
  internal var _object: Swift._StringObject
  @inlinable @inline(__always) internal init(_ object: Swift._StringObject) {
    self._object = object
    _invariantCheck()
  }
  @inlinable @inline(__always) internal init() {
    self.init(_StringObject(empty: ()))
  }
}
extension Swift._StringGuts {
  @inlinable @inline(__always) internal var rawBits: Swift._StringObject.RawBitPattern {
    get {
    return _object.rawBits
  }
  }
}
extension Swift._StringGuts {
  @inlinable @inline(__always) internal init(_ smol: Swift._SmallString) {
    self.init(_StringObject(smol))
  }
  @inlinable @inline(__always) internal init(_ bufPtr: Swift.UnsafeBufferPointer<Swift.UInt8>, isASCII: Swift.Bool) {
    self.init(_StringObject(immortal: bufPtr, isASCII: isASCII))
  }
}
extension Swift._StringGuts {
  @inlinable @inline(__always) internal var count: Swift.Int {
    get { return _object.count }
  }
  @inlinable @inline(__always) internal var isEmpty: Swift.Bool {
    get { return count == 0 }
  }
  @inlinable @inline(__always) internal var isSmall: Swift.Bool {
    get { return _object.isSmall }
  }
  @inlinable @inline(__always) internal var asSmall: Swift._SmallString {
    get {
    return _SmallString(_object)
  }
  }
  @inlinable @inline(__always) internal var isASCII: Swift.Bool {
    get {
    return _object.isASCII
  }
  }
  @inlinable @inline(__always) internal var isFastASCII: Swift.Bool {
    get {
    return isFastUTF8 && _object.isASCII
  }
  }
}
extension Swift._StringGuts {
  @_transparent @inlinable internal var isFastUTF8: Swift.Bool {
    @_transparent get { return _fastPath(_object.providesFastUTF8) }
  }
  @inlinable @inline(__always) internal var isForeign: Swift.Bool {
    get {
     return _slowPath(_object.isForeign)
  }
  }
  @inlinable @inline(__always) internal func withFastUTF8<R>(_ f: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R {
    _internalInvariant(isFastUTF8)

    if self.isSmall { return try _SmallString(_object).withUTF8(f) }

    defer { _fixLifetime(self) }
    return try f(_object.fastUTF8)
  }
  @inlinable @inline(__always) internal func withFastUTF8<R>(range: Swift.Range<Swift.Int>, _ f: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R {
    return try self.withFastUTF8 { wholeUTF8 in
      return try f(UnsafeBufferPointer(rebasing: wholeUTF8[range]))
    }
  }
  @inlinable @inline(__always) internal func withFastCChar<R>(_ f: (Swift.UnsafeBufferPointer<Swift.CChar>) throws -> R) rethrows -> R {
    return try self.withFastUTF8 { utf8 in
      return try utf8.withMemoryRebound(to: CChar.self, f)
    }
  }
}
extension Swift._StringGuts {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension Swift._StringGuts {
  @inlinable @inline(__always) internal func withCString<Result>(_ body: (Swift.UnsafePointer<Swift.Int8>) throws -> Result) rethrows -> Result {
    if _slowPath(!_object.isFastZeroTerminated) {
      return try _slowWithCString(body)
    }

    return try self.withFastCChar {
      return try body($0.baseAddress._unsafelyUnwrappedUnchecked)
    }
  }
  @usableFromInline
  @inline(never) internal func _slowWithCString<Result>(_ body: (Swift.UnsafePointer<Swift.Int8>) throws -> Result) rethrows -> Result
}
extension Swift._StringGuts {
  @inlinable internal func copyUTF8(into mbp: Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> Swift.Int? {
    let ptr = mbp.baseAddress._unsafelyUnwrappedUnchecked
    if _fastPath(self.isFastUTF8) {
      return self.withFastUTF8 { utf8 in
        guard utf8.count <= mbp.count else { return nil }

        let utf8Start = utf8.baseAddress._unsafelyUnwrappedUnchecked
        ptr.initialize(from: utf8Start, count: utf8.count)
        return utf8.count
      }
    }

    return _foreignCopyUTF8(into: mbp)
  }
  @usableFromInline
  @_effects(releasenone) @inline(never) internal func _foreignCopyUTF8(into mbp: Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> Swift.Int?
}
extension Swift._StringGuts {
  @usableFromInline
  internal typealias Index = Swift.String.Index
  @inlinable @inline(__always) internal var startIndex: Swift.String.Index {
    get {
     
    Index(_encodedOffset: 0)._characterAligned._encodingIndependent
  }
  }
  @inlinable @inline(__always) internal var endIndex: Swift.String.Index {
    get {
     
    markEncoding(Index(_encodedOffset: self.count)._characterAligned)
  }
  }
}
extension Swift._StringGuts {
  @_alwaysEmitIntoClient @inline(__always) internal var isUTF8: Swift.Bool {
    get { _object.isUTF8 }
  }
  @_alwaysEmitIntoClient @inline(__always) internal func markEncoding(_ i: Swift.String.Index) -> Swift.String.Index {
    isUTF8 ? i._knownUTF8 : i._knownUTF16
  }
  @_alwaysEmitIntoClient @inline(__always) internal func hasMatchingEncoding(_ i: Swift.String.Index) -> Swift.Bool {
    i._hasMatchingEncoding(isUTF8: isUTF8)
  }
  @_alwaysEmitIntoClient @inline(__always) internal func ensureMatchingEncoding(_ i: Swift._StringGuts.Index) -> Swift._StringGuts.Index {
    if _fastPath(hasMatchingEncoding(i)) { return i }
    return _slowEnsureMatchingEncoding(i)
  }
  @_alwaysEmitIntoClient @inline(never) @_effects(releasenone) internal func _slowEnsureMatchingEncoding(_ i: Swift._StringGuts.Index) -> Swift._StringGuts.Index {
     
     

    if isUTF8 {
       
       
       
       
       
       
       
       
       
       

       
       
       
      let utf16 = String.UTF16View(self)
      var r = utf16.index(utf16.startIndex, offsetBy: i._encodedOffset)
      if i.transcodedOffset != 0 {
        r = r.encoded(offsetBy: i.transcodedOffset)
      } else {
         
        r = r._copyingAlignment(from: i)
      }
      return r._knownUTF8
    }

     
     
     
     
    let utf8 = String.UTF8View(self)
    var r = utf8.index(utf8.startIndex, offsetBy: i._encodedOffset)
    if i.transcodedOffset != 0 {
      r = r.encoded(offsetBy: i.transcodedOffset)
    } else {
       
      r = r._copyingAlignment(from: i)
    }
    return r._knownUTF16
  }
}
extension Swift._StringGuts {
  public var _isContiguousASCII: Swift.Bool {
    get
  }
  @available(*, unavailable)
  public var _isContiguousUTF16: Swift.Bool {
    get
  }
  @available(*, deprecated)
  public var startASCII: Swift.UnsafeMutablePointer<Swift.UInt8> {
    get
  }
  @available(*, unavailable)
  public var startUTF16: Swift.UnsafeMutablePointer<Swift.UTF16.CodeUnit> {
    get
  }
}
extension Swift._StringGuts {
  @inlinable public var _isSmall: Swift.Bool {
    get { return isSmall }
  }
  @inlinable public var _smallCodeUnits: (Swift.UInt64, Swift.UInt64) {
    get {
    return asSmall.zeroTerminatedRawCodeUnits
  }
  }
  @inlinable public var _isLargeZeroTerminatedContiguousUTF8: Swift.Bool {
    get {
    return !isSmall && _object.isFastZeroTerminated
  }
  }
  @inlinable public var _largeContiguousUTF8CodeUnits: Swift.UnsafeBufferPointer<Swift.UInt8> {
    get {
    return _object.fastUTF8
  }
  }
}
@available(*, unavailable)
public func _persistCString(_ p: Swift.UnsafePointer<Swift.CChar>?) -> [Swift.CChar]?
extension Swift._StringGuts {
  @usableFromInline
  internal var isUniqueNative: Swift.Bool {
    @inline(__always) mutating get
  }
}
extension Swift._StringGuts {
  @inlinable internal init(_initialCapacity capacity: Swift.Int) {
    self.init()
    if _slowPath(capacity > _SmallString.capacity) {
      self.grow(capacity)  
    }
  }
  @usableFromInline
  internal mutating func grow(_ n: Swift.Int)
}
@usableFromInline
@frozen internal struct _StringObject {
  @usableFromInline
  @frozen internal enum Nibbles {
  }
  @usableFromInline
  @frozen internal struct CountAndFlags {
    @usableFromInline
    internal var _storage: Swift.UInt64
    @inlinable @inline(__always) internal init(zero: ()) { self._storage = 0 }
  }
  @usableFromInline
  internal var _countAndFlagsBits: Swift.UInt64
  @usableFromInline
  internal var _object: Builtin.BridgeObject
  @inlinable @inline(__always) internal init(zero: ()) {
    self._countAndFlagsBits = 0
    self._object = Builtin.valueToBridgeObject(UInt64(0)._value)
  }
  @inlinable @inline(__always) internal var _countAndFlags: Swift._StringObject.CountAndFlags {
    get {
    _internalInvariant(!isSmall)
    return CountAndFlags(rawUnchecked: _countAndFlagsBits)
  }
  }
  @_alwaysEmitIntoClient internal mutating func _setCountAndFlags(to value: Swift._StringObject.CountAndFlags) {
    self._countAndFlagsBits = value._storage
  }
}
extension Swift._StringObject {
  @usableFromInline
  internal typealias RawBitPattern = (Swift.UInt64, Swift.UInt64)
  @inlinable @inline(__always) internal var rawBits: Swift._StringObject.RawBitPattern {
    get {
    return (_countAndFlagsBits, discriminatedObjectRawBits)
  }
  }
  @inlinable @inline(__always) internal init(bridgeObject: Builtin.BridgeObject, countAndFlags: Swift._StringObject.CountAndFlags) {
    self._object = bridgeObject
    self._countAndFlagsBits = countAndFlags._storage
    _invariantCheck()
  }
  @inlinable @inline(__always) internal init(object: Swift.AnyObject, discriminator: Swift.UInt64, countAndFlags: Swift._StringObject.CountAndFlags) {
    defer { _fixLifetime(object) }
    let builtinRawObject: Builtin.Int64 = Builtin.reinterpretCast(object)
    let builtinDiscrim: Builtin.Int64 = discriminator._value
    self.init(
      bridgeObject: Builtin.reinterpretCast(
        Builtin.stringObjectOr_Int64(builtinRawObject, builtinDiscrim)),
      countAndFlags: countAndFlags)
  }
  @inlinable @inline(__always) internal init(pointerBits: Swift.UInt64, discriminator: Swift.UInt64, countAndFlags: Swift._StringObject.CountAndFlags) {
    let builtinValueBits: Builtin.Int64 = pointerBits._value
    let builtinDiscrim: Builtin.Int64 = discriminator._value
    self.init(
      bridgeObject: Builtin.valueToBridgeObject(Builtin.stringObjectOr_Int64(
        builtinValueBits, builtinDiscrim)),
      countAndFlags: countAndFlags)
  }
  @inlinable @inline(__always) internal init(rawUncheckedValue bits: Swift._StringObject.RawBitPattern) {
    self.init(zero:())
    self._countAndFlagsBits = bits.0
    self._object = Builtin.valueToBridgeObject(bits.1._value)
    _internalInvariant(self.rawBits == bits)
  }
  @inlinable @inline(__always) internal init(rawValue bits: Swift._StringObject.RawBitPattern) {
    self.init(rawUncheckedValue: bits)
    _invariantCheck()
  }
  @inlinable @_transparent internal var discriminatedObjectRawBits: Swift.UInt64 {
    @_transparent get {
    return Builtin.reinterpretCast(_object)
  }
  }
}
extension Swift._StringObject.CountAndFlags {
  @usableFromInline
  internal typealias RawBitPattern = Swift.UInt64
  @inlinable @inline(__always) internal var rawBits: Swift._StringObject.CountAndFlags.RawBitPattern {
    get {
   return _storage
  }
  }
  @inlinable @inline(__always) internal init(rawUnchecked bits: Swift._StringObject.CountAndFlags.RawBitPattern) {
    self._storage = bits
  }
  @inlinable @inline(__always) internal init(raw bits: Swift._StringObject.CountAndFlags.RawBitPattern) {
    self.init(rawUnchecked: bits)
    _invariantCheck()
  }
}
extension Swift._StringObject.Nibbles {
  @inlinable @inline(__always) internal static var emptyString: Swift.UInt64 {
    get {
    return _StringObject.Nibbles.small(isASCII: true)
  }
  }
}
extension Swift._StringObject.Nibbles {
  @inlinable @inline(__always) internal static var largeAddressMask: Swift.UInt64 {
    get {
    return 0x0FFF_FFFF_FFFF_FFFF
  }
  }
  @inlinable @inline(__always) internal static var discriminatorMask: Swift.UInt64 {
    get { return ~largeAddressMask }
  }
}
extension Swift._StringObject.Nibbles {
  @inlinable @inline(__always) internal static func small(isASCII: Swift.Bool) -> Swift.UInt64 {
    return isASCII ? 0xE000_0000_0000_0000 : 0xA000_0000_0000_0000
  }
  @inlinable @inline(__always) internal static func small(withCount count: Swift.Int, isASCII: Swift.Bool) -> Swift.UInt64 {
    _internalInvariant(count <= _SmallString.capacity)
    return small(isASCII: isASCII) | UInt64(truncatingIfNeeded: count) &<< 56
  }
  @inlinable @inline(__always) internal static func largeImmortal() -> Swift.UInt64 {
    return 0x8000_0000_0000_0000
  }
  @inlinable @inline(__always) internal static func largeMortal() -> Swift.UInt64 { return 0x0000_0000_0000_0000 }
}
extension Swift._StringObject {
  @inlinable @inline(__always) internal static var nativeBias: Swift.UInt {
    get {
    return 32
  }
  }
  @inlinable @inline(__always) internal var isImmortal: Swift.Bool {
    get {
    return (discriminatedObjectRawBits & 0x8000_0000_0000_0000) != 0
  }
  }
  @inlinable @inline(__always) internal var isMortal: Swift.Bool {
    get { return !isImmortal }
  }
  @inlinable @inline(__always) internal var isSmall: Swift.Bool {
    get {
    return (discriminatedObjectRawBits & 0x2000_0000_0000_0000) != 0
  }
  }
  @inlinable @inline(__always) internal var isLarge: Swift.Bool {
    get { return !isSmall }
  }
  @inlinable @inline(__always) internal var providesFastUTF8: Swift.Bool {
    get {
    return (discriminatedObjectRawBits & 0x1000_0000_0000_0000) == 0
  }
  }
  @inlinable @inline(__always) internal var isForeign: Swift.Bool {
    get { return !providesFastUTF8 }
  }
}
extension Swift._StringObject {
  @inlinable @inline(__always) internal var largeFastIsTailAllocated: Swift.Bool {
    get {
    _internalInvariant(isLarge && providesFastUTF8)
    return _countAndFlags.isTailAllocated
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var isPreferredRepresentation: Swift.Bool {
    get {
    return _fastPath(isSmall || _countAndFlags.isTailAllocated)
  }
  }
}
extension Swift._StringObject {
  @inlinable @inline(__always) internal init(_ small: Swift._SmallString) {
     
     
     
    let word1 = small.rawBits.0.littleEndian
    let word2 = small.rawBits.1.littleEndian
     
    self.init(rawValue: (word1, word2))
    _internalInvariant(isSmall)
  }
  @inlinable internal static func getSmallCount(fromRaw x: Swift.UInt64) -> Swift.Int {
    return Int(truncatingIfNeeded: (x & 0x0F00_0000_0000_0000) &>> 56)
  }
  @inlinable @inline(__always) internal var smallCount: Swift.Int {
    get {
    _internalInvariant(isSmall)
    return _StringObject.getSmallCount(fromRaw: discriminatedObjectRawBits)
  }
  }
  @inlinable internal static func getSmallIsASCII(fromRaw x: Swift.UInt64) -> Swift.Bool {
    return x & 0x4000_0000_0000_0000 != 0
  }
  @inlinable @inline(__always) internal var smallIsASCII: Swift.Bool {
    get {
    _internalInvariant(isSmall)
    return _StringObject.getSmallIsASCII(fromRaw: discriminatedObjectRawBits)
  }
  }
  @inlinable @inline(__always) internal init(empty: ()) {
     
    self._countAndFlagsBits = 0
    self._object = Builtin.valueToBridgeObject(Nibbles.emptyString._value)
    _internalInvariant(self.smallCount == 0)
    _invariantCheck()
  }
}
extension Swift._StringObject.CountAndFlags {
  @inlinable @inline(__always) internal static var countMask: Swift.UInt64 {
    get { return 0x0000_FFFF_FFFF_FFFF }
  }
  @inlinable @inline(__always) internal static var flagsMask: Swift.UInt64 {
    get { return ~countMask }
  }
  @inlinable @inline(__always) internal static var isASCIIMask: Swift.UInt64 {
    get { return 0x8000_0000_0000_0000 }
  }
  @inlinable @inline(__always) internal static var isNFCMask: Swift.UInt64 {
    get { return 0x4000_0000_0000_0000 }
  }
  @inlinable @inline(__always) internal static var isNativelyStoredMask: Swift.UInt64 {
    get {
    return 0x2000_0000_0000_0000
  }
  }
  @inlinable @inline(__always) internal static var isTailAllocatedMask: Swift.UInt64 {
    get {
    return 0x1000_0000_0000_0000
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal static var isForeignUTF8Mask: Swift.UInt64 {
    get {
    return 0x0800_0000_0000_0000
  }
  }
  @inlinable @inline(__always) internal init(count: Swift.Int, isASCII: Swift.Bool, isNFC: Swift.Bool, isNativelyStored: Swift.Bool, isTailAllocated: Swift.Bool) {
    var rawBits = UInt64(truncatingIfNeeded: count)
    _internalInvariant(rawBits <= _StringObject.CountAndFlags.countMask)

    if isASCII {
      _internalInvariant(isNFC)
      rawBits |= _StringObject.CountAndFlags.isASCIIMask
    }

    if isNFC {
      rawBits |= _StringObject.CountAndFlags.isNFCMask
    }

    if isNativelyStored {
      _internalInvariant(isTailAllocated)
      rawBits |= _StringObject.CountAndFlags.isNativelyStoredMask
    }

    if isTailAllocated {
      rawBits |= _StringObject.CountAndFlags.isTailAllocatedMask
    }

    self.init(raw: rawBits)
    _internalInvariant(count == self.count)
    _internalInvariant(isASCII == self.isASCII)
    _internalInvariant(isNFC == self.isNFC)
    _internalInvariant(isNativelyStored == self.isNativelyStored)
    _internalInvariant(isTailAllocated == self.isTailAllocated)
  }
  @inlinable @inline(__always) internal init(count: Swift.Int, flags: Swift.UInt16) {
     
    _internalInvariant(flags & 0xF800 == flags)

    let rawBits = UInt64(truncatingIfNeeded: flags) &<< 48
                | UInt64(truncatingIfNeeded: count)
    self.init(raw: rawBits)
    _internalInvariant(self.count == count && self.flags == flags)
  }
  @inlinable @inline(__always) internal init(immortalCount: Swift.Int, isASCII: Swift.Bool) {
    self.init(
      count: immortalCount,
      isASCII: isASCII,
      isNFC: isASCII,
      isNativelyStored: false,
      isTailAllocated: true)
  }
  @inlinable @inline(__always) internal var count: Swift.Int {
    get {
    return Int(
      truncatingIfNeeded: _storage & _StringObject.CountAndFlags.countMask)
  }
  }
  @inlinable @inline(__always) internal var flags: Swift.UInt16 {
    get {
    return UInt16(truncatingIfNeeded: _storage &>> 48)
  }
  }
  @inlinable @inline(__always) internal var isASCII: Swift.Bool {
    get {
    return 0 != _storage & _StringObject.CountAndFlags.isASCIIMask
  }
  }
  @inlinable @inline(__always) internal var isNFC: Swift.Bool {
    get {
    return 0 != _storage & _StringObject.CountAndFlags.isNFCMask
  }
  }
  @inlinable @inline(__always) internal var isNativelyStored: Swift.Bool {
    get {
    return 0 != _storage & _StringObject.CountAndFlags.isNativelyStoredMask
  }
  }
  @inlinable @inline(__always) internal var isTailAllocated: Swift.Bool {
    get {
    return 0 != _storage & _StringObject.CountAndFlags.isTailAllocatedMask
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var isForeignUTF8: Swift.Bool {
    get {
    (_storage & Self.isForeignUTF8Mask) != 0
  }
  }
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension Swift._StringObject {
  @inlinable @inline(__always) internal var largeCount: Swift.Int {
    get {
    _internalInvariant(isLarge)
    return _countAndFlags.count
  }
  }
  @inlinable @inline(__always) internal var largeAddressBits: Swift.UInt {
    get {
    _internalInvariant(isLarge)
    return UInt(truncatingIfNeeded:
      discriminatedObjectRawBits & Nibbles.largeAddressMask)
  }
  }
  @inline(__always) @_alwaysEmitIntoClient internal var largeAddress: Swift.UnsafeRawPointer {
    get {
    UnsafeRawPointer(bitPattern: largeAddressBits)
      ._unsafelyUnwrappedUnchecked
  }
  }
  @inlinable @inline(__always) internal var nativeUTF8Start: Swift.UnsafePointer<Swift.UInt8> {
    get {
    _internalInvariant(largeFastIsTailAllocated)
    return UnsafePointer(
      bitPattern: largeAddressBits &+ _StringObject.nativeBias
    )._unsafelyUnwrappedUnchecked
  }
  }
  @inlinable @inline(__always) internal var nativeUTF8: Swift.UnsafeBufferPointer<Swift.UInt8> {
    get {
    _internalInvariant(largeFastIsTailAllocated)
    return UnsafeBufferPointer(start: nativeUTF8Start, count: largeCount)
  }
  }
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func getSharedUTF8Start() -> Swift.UnsafePointer<Swift.UInt8>
  @usableFromInline
  internal var sharedUTF8: Swift.UnsafeBufferPointer<Swift.UInt8> {
    @_effects(releasenone) @inline(never) get
  }
  @_alwaysEmitIntoClient @inlinable @inline(__always) internal var owner: Swift.AnyObject? {
    get {
    guard self.isMortal else { return nil }
    let unmanaged = Unmanaged<AnyObject>.fromOpaque(largeAddress)
    return unmanaged.takeUnretainedValue()
  }
  }
}
extension Swift._StringObject {
  @inlinable @inline(__always) internal var count: Swift.Int {
    get { return isSmall ? smallCount : largeCount }
  }
  @inlinable @inline(__always) internal var isASCII: Swift.Bool {
    get {
    if isSmall { return smallIsASCII }
    return _countAndFlags.isASCII
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var isUTF8: Swift.Bool {
    get {
     
     
     
     
     
     
     
     
     
     
     
     
     
    providesFastUTF8 || _countAndFlags.isForeignUTF8
  }
  }
  @inlinable @inline(__always) internal var fastUTF8: Swift.UnsafeBufferPointer<Swift.UInt8> {
    get {
    _internalInvariant(self.isLarge && self.providesFastUTF8)
    guard _fastPath(self.largeFastIsTailAllocated) else {
      return sharedUTF8
    }
    return UnsafeBufferPointer(
      _uncheckedStart: self.nativeUTF8Start, count: self.largeCount)
  }
  }
  @usableFromInline
  internal var hasObjCBridgeableObject: Swift.Bool {
    @_effects(releasenone) get
  }
  @inlinable internal var isFastZeroTerminated: Swift.Bool {
    get {
    if _slowPath(!providesFastUTF8) { return false }

     
    if isSmall { return true }

     
     
     

    return largeFastIsTailAllocated
  }
  }
}
extension Swift._StringObject {
  @inlinable @inline(__always) internal init(immortal bufPtr: Swift.UnsafeBufferPointer<Swift.UInt8>, isASCII: Swift.Bool) {
    let countAndFlags = CountAndFlags(
      immortalCount: bufPtr.count, isASCII: isASCII)
     
    let biasedAddress = UInt(
      bitPattern: bufPtr.baseAddress._unsafelyUnwrappedUnchecked
    ) &- _StringObject.nativeBias

    self.init(
      pointerBits: UInt64(truncatingIfNeeded: biasedAddress),
      discriminator: Nibbles.largeImmortal(),
      countAndFlags: countAndFlags)
  }
}
extension Swift._StringObject {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
public protocol StringProtocol : Swift.BidirectionalCollection, Swift.Comparable, Swift.ExpressibleByStringInterpolation, Swift.Hashable, Swift.LosslessStringConvertible, Swift.TextOutputStream, Swift.TextOutputStreamable where Self.Element == Swift.Character, Self.Index == Swift.String.Index, Self.StringInterpolation == Swift.DefaultStringInterpolation, Self.SubSequence : Swift.StringProtocol {
  associatedtype UTF8View : Swift.Collection where Self.UTF8View.Element == Swift.UInt8, Self.UTF8View.Index == Swift.String.Index
  associatedtype UTF16View : Swift.BidirectionalCollection where Self.UTF16View.Element == Swift.UInt16, Self.UTF16View.Index == Swift.String.Index
  associatedtype UnicodeScalarView : Swift.BidirectionalCollection where Self.UnicodeScalarView.Element == Swift.Unicode.Scalar, Self.UnicodeScalarView.Index == Swift.String.Index
  associatedtype SubSequence = Swift.Substring
  var utf8: Self.UTF8View { get }
  var utf16: Self.UTF16View { get }
  var unicodeScalars: Self.UnicodeScalarView { get }
  func hasPrefix(_ prefix: Swift.String) -> Swift.Bool
  func hasSuffix(_ suffix: Swift.String) -> Swift.Bool
  func lowercased() -> Swift.String
  func uppercased() -> Swift.String
  init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Swift.Collection, Encoding : Swift._UnicodeEncoding, C.Element == Encoding.CodeUnit
  init(cString nullTerminatedUTF8: Swift.UnsafePointer<Swift.CChar>)
  init<Encoding>(decodingCString nullTerminatedCodeUnits: Swift.UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding
  func withCString<Result>(_ body: (Swift.UnsafePointer<Swift.CChar>) throws -> Result) rethrows -> Result
  func withCString<Result, Encoding>(encodedAs targetEncoding: Encoding.Type, _ body: (Swift.UnsafePointer<Encoding.CodeUnit>) throws -> Result) rethrows -> Result where Encoding : Swift._UnicodeEncoding
}
extension Swift.StringProtocol {
  public var _ephemeralString: Swift.String {
    @_specialize(exported: false, kind: full, where Self == Swift.String)
    @_specialize(exported: false, kind: full, where Self == Swift.Substring)
    get
  }
  @inlinable internal var _offsetRange: Swift.Range<Swift.Int> {
    @inline(__always) get {
      let start = startIndex
      let end = endIndex
      _internalInvariant(
        start.transcodedOffset == 0 && end.transcodedOffset == 0)
      return Range(_uncheckedBounds: (start._encodedOffset, end._encodedOffset))
    }
  }
  @inlinable internal var _wholeGuts: Swift._StringGuts {
    @_specialize(exported: false, kind: full, where Self == Swift.String)
    @_specialize(exported: false, kind: full, where Self == Swift.Substring)
    @inline(__always) get {
      if let str = self as? String {
        return str._guts
      }
      if let subStr = self as? Substring {
        return subStr._wholeGuts
      }
      return String(self)._guts
    }
  }
}
extension Swift.String {
  @_alwaysEmitIntoClient public var isContiguousUTF8: Swift.Bool {
    get { return _guts.isFastUTF8 }
  }
  @_alwaysEmitIntoClient public mutating func makeContiguousUTF8() {
    if _fastPath(isContiguousUTF8) { return }
    self = String._copying(self)
  }
  @_alwaysEmitIntoClient public mutating func withUTF8<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R {
    makeContiguousUTF8()
    return try _guts.withFastUTF8(body)
  }
}
extension Swift.Substring {
  @_alwaysEmitIntoClient public var isContiguousUTF8: Swift.Bool {
    get { return self.base.isContiguousUTF8 }
  }
  @_alwaysEmitIntoClient @inline(__always) public mutating func makeContiguousUTF8() {
    if isContiguousUTF8 { return }
    return _slowMakeContiguousUTF8()
  }
  @_alwaysEmitIntoClient @inline(never) internal mutating func _slowMakeContiguousUTF8() {
    _internalInvariant(!isContiguousUTF8)

    let scalarOffset = base.unicodeScalars.distance(
      from: base.startIndex, to: startIndex)
    let scalarCount = base.unicodeScalars.distance(
      from: startIndex, to: endIndex)

    let scalars = String._copying(base).unicodeScalars

    var newStart = scalars.index(scalars.startIndex, offsetBy: scalarOffset)
    var newEnd = scalars.index(newStart, offsetBy: scalarCount)

    if startIndex._isCharacterAligned { newStart = newStart._characterAligned }
    if endIndex._isCharacterAligned { newEnd = newEnd._characterAligned }

    self = Substring(_unchecked: scalars._guts, bounds: newStart ..< newEnd)
  }
  @_alwaysEmitIntoClient public mutating func withUTF8<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R {
    makeContiguousUTF8()
    return try _wholeGuts.withFastUTF8(range: _offsetRange, body)
  }
}
extension Swift.String {
  @frozen public struct Index : Swift.Sendable {
    @usableFromInline
    internal var _rawBits: Swift.UInt64
    @inlinable @inline(__always) internal init(_ raw: Swift.UInt64) {
      self._rawBits = raw
      self._invariantCheck()
    }
  }
}
extension Swift.String.Index {
  @inlinable @inline(__always) internal var orderingValue: Swift.UInt64 {
    get { return _rawBits &>> 14 }
  }
  @inlinable @inline(__always) internal var isZeroPosition: Swift.Bool {
    get { return orderingValue == 0 }
  }
  public func utf16Offset<S>(in s: S) -> Swift.Int where S : Swift.StringProtocol
  @available(swift, deprecated: 4.2, message: "encodedOffset has been deprecated as most common usage is incorrect. Use utf16Offset(in:) to achieve the same behavior.")
  @inlinable public var encodedOffset: Swift.Int {
    get { return _encodedOffset }
  }
  @inlinable @inline(__always) internal var _encodedOffset: Swift.Int {
    get {
    return Int(truncatingIfNeeded: _rawBits &>> 16)
  }
  }
  @inlinable @inline(__always) internal var transcodedOffset: Swift.Int {
    get {
    return Int(truncatingIfNeeded: orderingValue & 0x3)
  }
  }
  @usableFromInline
  internal var characterStride: Swift.Int? {
    get
  }
  @inlinable @inline(__always) internal init(encodedOffset: Swift.Int, transcodedOffset: Swift.Int) {
    let pos = UInt64(truncatingIfNeeded: encodedOffset)
    let trans = UInt64(truncatingIfNeeded: transcodedOffset)
    _internalInvariant(pos == pos & 0x0000_FFFF_FFFF_FFFF)
    _internalInvariant(trans <= 3)

    self.init((pos &<< 16) | (trans &<< 14))
  }
  public init<S>(utf16Offset offset: Swift.Int, in s: S) where S : Swift.StringProtocol
  @available(swift, deprecated: 4.2, message: "encodedOffset has been deprecated as most common usage is incorrect. Use String.Index(utf16Offset:in:) to achieve the same behavior.")
  @inlinable public init(encodedOffset offset: Swift.Int) {
    self.init(_encodedOffset: offset)
  }
  @inlinable @inline(__always) internal init(_encodedOffset offset: Swift.Int) {
    self.init(encodedOffset: offset, transcodedOffset: 0)
  }
  @usableFromInline
  internal init(encodedOffset: Swift.Int, transcodedOffset: Swift.Int, characterStride: Swift.Int)
  @usableFromInline
  internal init(encodedOffset pos: Swift.Int, characterStride char: Swift.Int)
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension Swift.String.Index {
  @inlinable @inline(__always) internal var strippingTranscoding: Swift.String.Index {
    get {
    return String.Index(_encodedOffset: self._encodedOffset)
  }
  }
  @inlinable @inline(__always) internal var nextEncoded: Swift.String.Index {
    get {
    _internalInvariant(self.transcodedOffset == 0)
    return String.Index(_encodedOffset: self._encodedOffset &+ 1)
  }
  }
  @inlinable @inline(__always) internal var priorEncoded: Swift.String.Index {
    get {
    _internalInvariant(self.transcodedOffset == 0)
    return String.Index(_encodedOffset: self._encodedOffset &- 1)
  }
  }
  @inlinable @inline(__always) internal var nextTranscoded: Swift.String.Index {
    get {
    return String.Index(
      encodedOffset: self._encodedOffset,
      transcodedOffset: self.transcodedOffset &+ 1)
  }
  }
  @inlinable @inline(__always) internal var priorTranscoded: Swift.String.Index {
    get {
    return String.Index(
      encodedOffset: self._encodedOffset,
      transcodedOffset: self.transcodedOffset &- 1)
  }
  }
  @inlinable @inline(__always) internal func encoded(offsetBy n: Swift.Int) -> Swift.String.Index {
    return String.Index(_encodedOffset: self._encodedOffset &+ n)
  }
  @inlinable @inline(__always) internal func transcoded(withOffset n: Swift.Int) -> Swift.String.Index {
    _internalInvariant(self.transcodedOffset == 0)
    return String.Index(encodedOffset: self._encodedOffset, transcodedOffset: n)
  }
}
extension Swift.String.Index {
  @_alwaysEmitIntoClient @inline(__always) internal static var __scalarAlignmentBit: Swift.UInt64 {
    get { 0x1 }
  }
  @_alwaysEmitIntoClient @inline(__always) internal static var __characterAlignmentBit: Swift.UInt64 {
    get { 0x2 }
  }
  @_alwaysEmitIntoClient @inline(__always) internal static var __utf8Bit: Swift.UInt64 {
    get { 0x4 }
  }
  @_alwaysEmitIntoClient @inline(__always) internal static var __utf16Bit: Swift.UInt64 {
    get { 0x8 }
  }
  @_alwaysEmitIntoClient @inline(__always) internal static func __encodingBit(utf16: Swift.Bool) -> Swift.UInt64 {
    let utf16 = Int8(Builtin.zext_Int1_Int8(utf16._value))
    return __utf8Bit &<< utf16
  }
}
extension Swift.String.Index {
  @_alwaysEmitIntoClient @inline(__always) internal var _isScalarAligned: Swift.Bool {
    get {
    0 != _rawBits & Self.__scalarAlignmentBit
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var _scalarAligned: Swift.String.Index {
    get {
    var idx = self
    idx._rawBits |= Self.__scalarAlignmentBit
    idx._invariantCheck()
    return idx
  }
  }
}
extension Swift.String.Index {
  @_alwaysEmitIntoClient @inline(__always) internal var _isCharacterAligned: Swift.Bool {
    get {
    0 != _rawBits & Self.__characterAlignmentBit
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var _characterAligned: Swift.String.Index {
    get {
    let r = _rawBits | Self.__characterAlignmentBit | Self.__scalarAlignmentBit
    let idx = Self(r)
    idx._invariantCheck()
    return idx
  }
  }
}
extension Swift.String.Index {
  @_alwaysEmitIntoClient internal func _copyingAlignment(from index: Swift.String.Index) -> Swift.String.Index {
    let mask = Self.__scalarAlignmentBit | Self.__characterAlignmentBit
    return Self((_rawBits & ~mask) | (index._rawBits & mask))
  }
}
extension Swift.String.Index {
  @_alwaysEmitIntoClient @inline(__always) internal var _encodingBits: Swift.UInt64 {
    get {
    _rawBits & (Self.__utf8Bit | Self.__utf16Bit)
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var _canBeUTF8: Swift.Bool {
    get {
     
    _encodingBits != Self.__utf16Bit
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var _canBeUTF16: Swift.Bool {
    get {
     
    _encodingBits != Self.__utf8Bit
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal func _hasMatchingEncoding(isUTF8 utf8: Swift.Bool) -> Swift.Bool {
    _encodingBits != Self.__encodingBit(utf16: utf8)
  }
  @_alwaysEmitIntoClient @inline(__always) internal var _knownUTF8: Swift.String.Index {
    get { Self(_rawBits | Self.__utf8Bit) }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var _knownUTF16: Swift.String.Index {
    get { Self(_rawBits | Self.__utf16Bit) }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var _encodingIndependent: Swift.String.Index {
    get {
    Self(_rawBits | Self.__utf8Bit | Self.__utf16Bit)
  }
  }
  @_alwaysEmitIntoClient internal func _copyingEncoding(from index: Swift.String.Index) -> Swift.String.Index {
    let mask = Self.__utf8Bit | Self.__utf16Bit
    return Self((_rawBits & ~mask) | (index._rawBits & mask))
  }
}
extension Swift.String.Index : Swift.Equatable {
  @inlinable @inline(__always) public static func == (lhs: Swift.String.Index, rhs: Swift.String.Index) -> Swift.Bool {
    return lhs.orderingValue == rhs.orderingValue
  }
}
extension Swift.String.Index : Swift.Comparable {
  @inlinable @inline(__always) public static func < (lhs: Swift.String.Index, rhs: Swift.String.Index) -> Swift.Bool {
    return lhs.orderingValue < rhs.orderingValue
  }
}
extension Swift.String.Index : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(orderingValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.String.Index {
  @_alwaysEmitIntoClient internal var _encodingDescription: Swift.String {
    get {
    switch (_rawBits & Self.__utf8Bit != 0, _rawBits & Self.__utf16Bit != 0) {
    case (false, false): return "unknown"
    case (true, false): return "utf8"
    case (false, true): return "utf16"
    case (true, true): return "any"
    }
  }
  }
  @_alwaysEmitIntoClient @inline(never) public var _description: Swift.String {
    get {
     
    var d = "\(_encodedOffset)[\(_encodingDescription)]"
    if transcodedOffset != 0 {
      d += "+\(transcodedOffset)"
    }
    return d
  }
  }
  @_alwaysEmitIntoClient @inline(never) public var _debugDescription: Swift.String {
    get {
    var d = "String.Index("
    d += "offset: \(_encodedOffset)[\(_encodingDescription)]"
    if transcodedOffset != 0 {
      d += "+\(transcodedOffset)"
    }
    if _isCharacterAligned {
      d += ", aligned: character"
    } else if _isScalarAligned {
      d += ", aligned: scalar"
    }
    if let stride = characterStride {
      d += ", stride: \(stride)"
    }
    d += ")"
    return d
  }
  }
}
extension Swift.String.Index {
  public init?(_ sourcePosition: Swift.String.Index, within target: Swift.String)
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public init?<S>(_ sourcePosition: Swift.String.Index, within target: S) where S : Swift.StringProtocol
  public func samePosition(in utf8: Swift.String.UTF8View) -> Swift.String.UTF8View.Index?
  public func samePosition(in utf16: Swift.String.UTF16View) -> Swift.String.UTF16View.Index?
}
extension Swift.String {
  @available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
  public func _index(roundingDown i: Swift.String.Index) -> Swift.String.Index
}
extension Swift.Substring {
  @available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
  public func _index(roundingDown i: Swift.Substring.Index) -> Swift.Substring.Index
}
extension Swift.String.UnicodeScalarView {
  @_alwaysEmitIntoClient public func _index(roundingDown i: Swift.String.UnicodeScalarView.Index) -> Swift.String.UnicodeScalarView.Index {
    _guts.validateInclusiveScalarIndex(i)
  }
}
extension Swift.Substring.UnicodeScalarView {
  @_alwaysEmitIntoClient public func _index(roundingDown i: Swift.Substring.UnicodeScalarView.Index) -> Swift.Substring.UnicodeScalarView.Index {
    _wholeGuts.validateInclusiveScalarIndex(i, in: _bounds)
  }
}
extension Swift.String.UTF8View {
  @_alwaysEmitIntoClient public func _index(roundingDown i: Swift.String.UTF8View.Index) -> Swift.String.UTF8View.Index {
    let i = _guts.validateInclusiveSubscalarIndex(i)
    guard _guts.isForeign else { return i.strippingTranscoding._knownUTF8 }
    return _utf8AlignForeignIndex(i)
  }
}
extension Swift.Substring.UTF8View {
  @_alwaysEmitIntoClient public func _index(roundingDown i: Swift.Substring.UTF8View.Index) -> Swift.Substring.UTF8View.Index {
    let i = _wholeGuts.validateInclusiveSubscalarIndex(i, in: _bounds)
    guard _wholeGuts.isForeign else { return i.strippingTranscoding._knownUTF8 }
    return _slice._base._utf8AlignForeignIndex(i)
  }
}
extension Swift.String.UTF16View {
  @_alwaysEmitIntoClient public func _index(roundingDown i: Swift.String.UTF16View.Index) -> Swift.String.UTF16View.Index {
    let i = _guts.validateInclusiveSubscalarIndex(i)
    if _guts.isForeign { return i.strippingTranscoding._knownUTF16 }
    return _utf16AlignNativeIndex(i)
  }
}
extension Swift.Substring.UTF16View {
  @_alwaysEmitIntoClient public func _index(roundingDown i: Swift.Substring.UTF16View.Index) -> Swift.Substring.UTF16View.Index {
    let i = _wholeGuts.validateInclusiveSubscalarIndex(i, in: _bounds)
    if _wholeGuts.isForeign { return i.strippingTranscoding._knownUTF16 }
    return _slice._base._utf16AlignNativeIndex(i)
  }
}
extension Swift._StringGuts {
  @_alwaysEmitIntoClient @inline(__always) internal func isFastScalarIndex(_ i: Swift.String.Index) -> Swift.Bool {
    hasMatchingEncoding(i) && i._isScalarAligned
  }
  @_alwaysEmitIntoClient @inline(__always) internal func isFastCharacterIndex(_ i: Swift.String.Index) -> Swift.Bool {
    hasMatchingEncoding(i) && i._isCharacterAligned
  }
}
extension Swift._StringGuts {
  @_alwaysEmitIntoClient internal func validateSubscalarIndex(_ i: Swift.String.Index) -> Swift.String.Index {
    let i = ensureMatchingEncoding(i)
    _precondition(i._encodedOffset < count, "String index is out of bounds")
    return i
  }
  @_alwaysEmitIntoClient internal func validateSubscalarIndex(_ i: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) -> Swift.String.Index {
    _internalInvariant(bounds.upperBound <= endIndex)

    let i = ensureMatchingEncoding(i)
    _precondition(i >= bounds.lowerBound && i < bounds.upperBound,
      "Substring index is out of bounds")
    return i
  }
  @_alwaysEmitIntoClient internal func validateInclusiveSubscalarIndex(_ i: Swift.String.Index) -> Swift.String.Index {
    let i = ensureMatchingEncoding(i)
    _precondition(i._encodedOffset <= count, "String index is out of bounds")
    return i
  }
  @_alwaysEmitIntoClient internal func validateInclusiveSubscalarIndex(_ i: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) -> Swift.String.Index {
    _internalInvariant(bounds.upperBound <= endIndex)

    let i = ensureMatchingEncoding(i)
    _precondition(i >= bounds.lowerBound && i <= bounds.upperBound,
      "Substring index is out of bounds")
    return i
  }
  @_alwaysEmitIntoClient internal func validateSubscalarRange(_ range: Swift.Range<Swift.String.Index>) -> Swift.Range<Swift.String.Index> {
    let upper = ensureMatchingEncoding(range.upperBound)
    let lower = ensureMatchingEncoding(range.lowerBound)

     
     
     
    _precondition(upper <= endIndex && lower <= upper,
      "String index range is out of bounds")

    return Range(_uncheckedBounds: (lower, upper))
  }
  @_alwaysEmitIntoClient internal func validateSubscalarRange(_ range: Swift.Range<Swift.String.Index>, in bounds: Swift.Range<Swift.String.Index>) -> Swift.Range<Swift.String.Index> {
    _internalInvariant(bounds.upperBound <= endIndex)

    let upper = ensureMatchingEncoding(range.upperBound)
    let lower = ensureMatchingEncoding(range.lowerBound)

     
     
     
    _precondition(
      lower >= bounds.lowerBound
      && lower <= upper
      && upper <= bounds.upperBound,
      "Substring index range is out of bounds")

    return Range(_uncheckedBounds: (lower, upper))
  }
}
extension Swift._StringGuts {
  @_alwaysEmitIntoClient internal func validateScalarIndex(_ i: Swift.String.Index) -> Swift.String.Index {
    if isFastScalarIndex(i) {
      _precondition(i._encodedOffset < count, "String index is out of bounds")
      return i
    }

    return scalarAlign(validateSubscalarIndex(i))
  }
  @_alwaysEmitIntoClient internal func validateScalarIndex(_ i: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) -> Swift.String.Index {
    _internalInvariant(bounds.upperBound <= endIndex)

    if isFastScalarIndex(i) {
      _precondition(i >= bounds.lowerBound && i < bounds.upperBound,
        "Substring index is out of bounds")
      return i
    }

    return scalarAlign(validateSubscalarIndex(i, in: bounds))
  }
}
extension Swift._StringGuts {
  @_alwaysEmitIntoClient internal func validateInclusiveScalarIndex(_ i: Swift.String.Index) -> Swift.String.Index {
    if isFastScalarIndex(i) {
      _precondition(i._encodedOffset <= count, "String index is out of bounds")
      return i
    }

    return scalarAlign(validateInclusiveSubscalarIndex(i))
  }
  @_alwaysEmitIntoClient internal func validateInclusiveScalarIndex(_ i: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) -> Swift.String.Index {
    _internalInvariant(bounds.upperBound <= endIndex)

    if isFastScalarIndex(i) {
      _precondition(i >= bounds.lowerBound && i <= bounds.upperBound,
        "Substring index is out of bounds")
      return i
    }

    return scalarAlign(validateInclusiveSubscalarIndex(i, in: bounds))
  }
}
@frozen public struct DefaultStringInterpolation : Swift.StringInterpolationProtocol, Swift.Sendable {
  @usableFromInline
  internal var _storage: Swift.String
  @inlinable public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int) {
    let capacityPerInterpolation = 2
    let initialCapacity = literalCapacity +
      interpolationCount * capacityPerInterpolation
    _storage = String._createEmpty(withInitialCapacity: initialCapacity)
  }
  @inlinable public mutating func appendLiteral(_ literal: Swift.String) {
    literal.write(to: &self)
  }
  @inlinable public mutating func appendInterpolation<T>(_ value: T) where T : Swift.CustomStringConvertible, T : Swift.TextOutputStreamable {
    value.write(to: &self)
  }
  @inlinable public mutating func appendInterpolation<T>(_ value: T) where T : Swift.TextOutputStreamable {
    value.write(to: &self)
  }
  @inlinable public mutating func appendInterpolation<T>(_ value: T) where T : Swift.CustomStringConvertible {
    value.description.write(to: &self)
  }
  @inlinable public mutating func appendInterpolation<T>(_ value: T) {
    _print_unlocked(value, &self)
  }
  @_alwaysEmitIntoClient public mutating func appendInterpolation(_ value: any Any.Type) {
	  _typeName(value, qualified: false).write(to: &self)
  }
  @inlinable internal __consuming func make() -> Swift.String {
    return _storage
  }
  public typealias StringLiteralType = Swift.String
}
extension Swift.DefaultStringInterpolation : Swift.CustomStringConvertible {
  @inlinable public var description: Swift.String {
    get {
    return _storage
  }
  }
}
extension Swift.DefaultStringInterpolation : Swift.TextOutputStream {
  @inlinable public mutating func write(_ string: Swift.String) {
    _storage.append(string)
  }
  public mutating func _writeASCII(_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>)
}
extension Swift.String {
  @inlinable @_effects(readonly) public init(stringInterpolation: Swift.DefaultStringInterpolation) {
    self = stringInterpolation.make()
  }
}
extension Swift.Substring {
  @inlinable @_effects(readonly) public init(stringInterpolation: Swift.DefaultStringInterpolation) {
    self.init(stringInterpolation.make())
  }
}
extension Swift.String {
  public init(repeating repeatedValue: Swift.String, count: Swift.Int)
  @inlinable public var isEmpty: Swift.Bool {
    @inline(__always) get { return _guts.isEmpty }
  }
}
extension Swift.StringProtocol {
  @inlinable public func hasPrefix<Prefix>(_ prefix: Prefix) -> Swift.Bool where Prefix : Swift.StringProtocol {
    return self.starts(with: prefix)
  }
  @inlinable public func hasSuffix<Suffix>(_ suffix: Suffix) -> Swift.Bool where Suffix : Swift.StringProtocol {
    return self.reversed().starts(with: suffix.reversed())
  }
}
extension Swift.String {
  public func hasPrefix(_ prefix: Swift.String) -> Swift.Bool
  public func hasSuffix(_ suffix: Swift.String) -> Swift.Bool
}
extension Swift.String {
  public init<T>(_ value: T, radix: Swift.Int = 10, uppercase: Swift.Bool = false) where T : Swift.BinaryInteger
}
extension Swift.String : Swift.StringProtocol {
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
}
extension Swift.String : Swift.RangeReplaceableCollection {
  public init(repeating repeatedValue: Swift.Character, count: Swift.Int)
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  public init<S>(_ other: S) where S : Swift.LosslessStringConvertible, S : Swift.Sequence, S.Element == Swift.Character
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  @_specialize(exported: false, kind: full, where S == [Swift.Character])
  public init<S>(_ characters: S) where S : Swift.Sequence, S.Element == Swift.Character
  public mutating func reserveCapacity(_ n: Swift.Int)
  @_semantics("string.append") public mutating func append(_ other: Swift.String)
  public mutating func append(_ c: Swift.Character)
  public mutating func append(contentsOf newElements: Swift.String)
  public mutating func append(contentsOf newElements: Swift.Substring)
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  @_specialize(exported: false, kind: full, where S == [Swift.Character])
  public mutating func append<S>(contentsOf newElements: S) where S : Swift.Sequence, S.Element == Swift.Character
  @_specialize(exported: false, kind: full, where C == Swift.String)
  @_specialize(exported: false, kind: full, where C == Swift.Substring)
  @_specialize(exported: false, kind: full, where C == [Swift.Character])
  public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.String.Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.Character
  public mutating func insert(_ newElement: Swift.Character, at i: Swift.String.Index)
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  @_specialize(exported: false, kind: full, where S == [Swift.Character])
  public mutating func insert<S>(contentsOf newElements: S, at i: Swift.String.Index) where S : Swift.Collection, S.Element == Swift.Character
  @discardableResult
  public mutating func remove(at i: Swift.String.Index) -> Swift.Character
  public mutating func removeSubrange(_ bounds: Swift.Range<Swift.String.Index>)
  public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false)
}
extension Swift.String {
  @available(*, deprecated, message: "Use one of the _StringGuts.validateScalarIndex methods")
  @usableFromInline
  internal func _boundsCheck(_ index: Swift.String.Index)
  @available(*, deprecated, message: "Use one of the _StringGuts.validateScalarIndexRange methods")
  @usableFromInline
  internal func _boundsCheck(_ range: Swift.Range<Swift.String.Index>)
  @available(*, deprecated, message: "Use one of the _StringGuts.validateScalarIndex methods")
  @usableFromInline
  internal func _boundsCheck(_ range: Swift.ClosedRange<Swift.String.Index>)
}
extension Swift.String {
  @_transparent public func max<T>(_ x: T, _ y: T) -> T where T : Swift.Comparable {
    return Swift.max(x,y)
  }
  @_transparent public func min<T>(_ x: T, _ y: T) -> T where T : Swift.Comparable {
    return Swift.min(x,y)
  }
}
extension Swift.Sequence where Self.Element == Swift.String {
  @available(*, unavailable, message: "Operator '+' cannot be used to append a String to a sequence of strings")
  public static func + (lhs: Self, rhs: Swift.String) -> Swift.Never
  @available(*, unavailable, message: "Operator '+' cannot be used to append a String to a sequence of strings")
  public static func + (lhs: Swift.String, rhs: Self) -> Swift.Never
}
@_semantics("findStringSwitchCase") public func _findStringSwitchCase(cases: [Swift.StaticString], string: Swift.String) -> Swift.Int
@frozen public struct _OpaqueStringSwitchCache {
  internal var a: Builtin.Word
  internal var b: Builtin.Word
}
@_semantics("findStringSwitchCaseWithCache") public func _findStringSwitchCaseWithCache(cases: [Swift.StaticString], string: Swift.String, cache: inout Swift._OpaqueStringSwitchCache) -> Swift.Int
public struct _StringRepresentation {
  public var _isASCII: Swift.Bool
  public var _count: Swift.Int
  public var _capacity: Swift.Int
  public enum _Form {
    case _small
    case _cocoa(object: Swift.AnyObject)
    case _native(object: Swift.AnyObject)
    case _immortal(address: Swift.UInt)
  }
  public var _form: Swift._StringRepresentation._Form
  public var _objectIdentifier: Swift.ObjectIdentifier? {
    get
  }
}
@available(*, unavailable)
extension Swift._StringRepresentation : Swift.Sendable {
}
@available(*, unavailable)
extension Swift._StringRepresentation._Form : Swift.Sendable {
}
extension Swift.String {
  public func _classify() -> Swift._StringRepresentation
  @_alwaysEmitIntoClient public func _deconstructUTF8<ToPointer>(scratch: Swift.UnsafeMutableRawBufferPointer?) -> (owner: Swift.AnyObject?, ToPointer, length: Swift.Int, usesScratch: Swift.Bool, allocatedMemory: Swift.Bool) where ToPointer : Swift._Pointer {
    _guts._deconstructUTF8(scratch: scratch)
  }
}
extension Swift._StringGuts {
  @_alwaysEmitIntoClient internal func _deconstructUTF8<ToPointer>(scratch: Swift.UnsafeMutableRawBufferPointer?) -> (owner: Swift.AnyObject?, ToPointer, length: Swift.Int, usesScratch: Swift.Bool, allocatedMemory: Swift.Bool) where ToPointer : Swift._Pointer {

     
    if self.isSmall {
      let smol = self.asSmall
      if let scratch = scratch, scratch.count > smol.count {
        let scratchStart =
          scratch.baseAddress!
        smol.withUTF8 { smolUTF8 -> () in
          scratchStart.initializeMemory(
            as: UInt8.self, from: smolUTF8.baseAddress!, count: smolUTF8.count)
        }
        scratch[smol.count] = 0
        return (
          owner: nil,
          _convertPointerToPointerArgument(scratchStart),
          length: smol.count,
          usesScratch: true, allocatedMemory: false)
      }
    } else if _fastPath(self.isFastUTF8) {
      let ptr: ToPointer =
        _convertPointerToPointerArgument(self._object.fastUTF8.baseAddress!)
      return (
        owner: self._object.owner,
        ptr,
        length: self._object.count,
        usesScratch: false, allocatedMemory: false)
    }

    let (object, ptr, len) = self._allocateForDeconstruct()
    return (
      owner: object,
      _convertPointerToPointerArgument(ptr),
      length: len,
      usesScratch: false,
      allocatedMemory: true)
  }
  @_alwaysEmitIntoClient @inline(never) internal func _allocateForDeconstruct() -> (owner: Swift.AnyObject, Swift.UnsafeRawPointer, length: Swift.Int) {
    let utf8 = Array(String(self).utf8) + [0]
    let (owner, ptr): (AnyObject?, UnsafeRawPointer) =
      _convertConstArrayToPointerArgument(utf8)

     
    return (owner: owner!, ptr, length: utf8.count - 1)
  }
}
extension Swift.String {
  @frozen public struct UnicodeScalarView : Swift.Sendable {
    @usableFromInline
    internal var _guts: Swift._StringGuts
    @inlinable @inline(__always) internal init(_ _guts: Swift._StringGuts) {
      self._guts = _guts
      _invariantCheck()
    }
  }
}
extension Swift.String.UnicodeScalarView {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension Swift.String.UnicodeScalarView : Swift.BidirectionalCollection {
  public typealias Index = Swift.String.Index
  @inlinable @inline(__always) public var startIndex: Swift.String.UnicodeScalarView.Index {
    get { return _guts.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.String.UnicodeScalarView.Index {
    get { return _guts.endIndex }
  }
  @inlinable @inline(__always) public func index(after i: Swift.String.UnicodeScalarView.Index) -> Swift.String.UnicodeScalarView.Index {
    let i = _guts.validateScalarIndex(i)
    return _uncheckedIndex(after: i)
  }
  @_alwaysEmitIntoClient @inline(__always) internal func _uncheckedIndex(after i: Swift.String.UnicodeScalarView.Index) -> Swift.String.UnicodeScalarView.Index {
     
    if _fastPath(_guts.isFastUTF8) {
      let len = _guts.fastUTF8ScalarLength(startingAt: i._encodedOffset)
      return i.encoded(offsetBy: len)._scalarAligned._knownUTF8
    }
    return _foreignIndex(after: i)
  }
  @inlinable @inline(__always) public func index(before i: Swift.String.UnicodeScalarView.Index) -> Swift.String.UnicodeScalarView.Index {
    let i = _guts.validateInclusiveScalarIndex(i)
     
     
    _precondition(i > startIndex, "String index is out of bounds")

    return _uncheckedIndex(before: i)
  }
  @_alwaysEmitIntoClient @inline(__always) internal func _uncheckedIndex(before i: Swift.String.UnicodeScalarView.Index) -> Swift.String.UnicodeScalarView.Index {
     
    if _fastPath(_guts.isFastUTF8) {
      let len = _guts.withFastUTF8 { utf8 in
        _utf8ScalarLength(utf8, endingAt: i._encodedOffset)
      }
      _internalInvariant(len <= 4, "invalid UTF8")
      return i.encoded(offsetBy: 0 &- len)._scalarAligned._knownUTF8
    }

    return _foreignIndex(before: i)
  }
  @inlinable @inline(__always) public subscript(position: Swift.String.UnicodeScalarView.Index) -> Swift.Unicode.Scalar {
    get {
    let i = _guts.validateScalarIndex(position)
    return _guts.errorCorrectedScalar(startingAt: i._encodedOffset).0
  }
  }
  @_alwaysEmitIntoClient public func distance(from start: Swift.String.UnicodeScalarView.Index, to end: Swift.String.UnicodeScalarView.Index) -> Swift.Int {
    let start = _guts.validateInclusiveScalarIndex(start)
    let end = _guts.validateInclusiveScalarIndex(end)

    var i = start
    var count = 0
    if i < end {
      while i < end {
        count += 1
        i = _uncheckedIndex(after: i)
      }
    } else if i > end {
      while i > end {
        count -= 1
        i = _uncheckedIndex(before: i)
      }
    }
    return count
  }
  @_alwaysEmitIntoClient public func index(_ i: Swift.String.UnicodeScalarView.Index, offsetBy distance: Swift.Int) -> Swift.String.UnicodeScalarView.Index {
    var i = _guts.validateInclusiveScalarIndex(i)

    if distance >= 0 {
      for _ in stride(from: 0, to: distance, by: 1) {
        _precondition(i._encodedOffset < _guts.count, "String index is out of bounds")
        i = _uncheckedIndex(after: i)
      }
    } else {
      for _ in stride(from: 0, to: distance, by: -1) {
        _precondition(i._encodedOffset > 0, "String index is out of bounds")
        i = _uncheckedIndex(before: i)
      }
    }
    return i
  }
  @_alwaysEmitIntoClient public func index(_ i: Swift.String.UnicodeScalarView.Index, offsetBy distance: Swift.Int, limitedBy limit: Swift.String.UnicodeScalarView.Index) -> Swift.String.UnicodeScalarView.Index? {
     
     
     
     
    let limit = _guts.ensureMatchingEncoding(limit)
    let start = _guts.ensureMatchingEncoding(i)

    var i = _guts.validateInclusiveScalarIndex(i)

    if distance >= 0 {
      for _ in stride(from: 0, to: distance, by: 1) {
        guard limit < start || i < limit else { return nil }
        _precondition(i._encodedOffset < _guts.count, "String index is out of bounds")
        i = _uncheckedIndex(after: i)
      }
      guard limit < start || i <= limit else { return nil }
    } else {
      for _ in stride(from: 0, to: distance, by: -1) {
        guard limit > start || i > limit else { return nil }
        _precondition(i._encodedOffset > 0, "String index is out of bounds")
        i = _uncheckedIndex(before: i)
      }
      guard limit > start || i >= limit else { return nil }
    }
    return i
  }
  public typealias Element = Swift.Unicode.Scalar
  public typealias Indices = Swift.DefaultIndices<Swift.String.UnicodeScalarView>
}
extension Swift.String.UnicodeScalarView {
  @frozen public struct Iterator : Swift.IteratorProtocol, Swift.Sendable {
    @usableFromInline
    internal var _guts: Swift._StringGuts
    @usableFromInline
    internal var _position: Swift.Int = 0
    @usableFromInline
    internal var _end: Swift.Int
    @inlinable internal init(_ guts: Swift._StringGuts) {
      self._end = guts.count
      self._guts = guts
    }
    @inlinable @inline(__always) public mutating func next() -> Swift.Unicode.Scalar? {
      guard _fastPath(_position < _end) else { return nil }

      let (result, len) = _guts.errorCorrectedScalar(startingAt: _position)
      _position &+= len
      return result
    }
    public typealias Element = Swift.Unicode.Scalar
  }
  @inlinable public __consuming func makeIterator() -> Swift.String.UnicodeScalarView.Iterator {
    return Iterator(_guts)
  }
}
extension Swift.String.UnicodeScalarView : Swift.CustomStringConvertible {
  @inlinable @inline(__always) public var description: Swift.String {
    get { return String(_guts) }
  }
}
extension Swift.String.UnicodeScalarView : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.String {
  @inlinable @inline(__always) public init(_ unicodeScalars: Swift.String.UnicodeScalarView) {
    self.init(unicodeScalars._guts)
  }
  public typealias UnicodeScalarIndex = Swift.String.UnicodeScalarView.Index
  @inlinable public var unicodeScalars: Swift.String.UnicodeScalarView {
    @inline(__always) get { return UnicodeScalarView(_guts) }
    @inline(__always) set { _guts = newValue._guts }
    @inlinable @inline(__always) _modify {
      var view = self.unicodeScalars
      self = ""
      defer { self._guts = view._guts }
      yield &view
    }
  }
}
extension Swift.String.UnicodeScalarView : Swift.RangeReplaceableCollection {
  @inlinable @inline(__always) public init() {
    self.init(_StringGuts())
  }
  public mutating func reserveCapacity(_ n: Swift.Int)
  public mutating func append(_ c: Swift.Unicode.Scalar)
  public mutating func append<S>(contentsOf newElements: S) where S : Swift.Sequence, S.Element == Swift.Unicode.Scalar
  public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.String.UnicodeScalarView.Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.Unicode.Scalar
}
extension Swift.String.Index {
  public init?(_ sourcePosition: Swift.String.Index, within unicodeScalars: Swift.String.UnicodeScalarView)
  public func samePosition(in characters: Swift.String) -> Swift.String.Index?
}
extension Swift.String.UnicodeScalarView : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.String.UnicodeScalarView {
  public typealias SubSequence = Swift.Substring.UnicodeScalarView
  @available(swift 4)
  public subscript(r: Swift.Range<Swift.String.UnicodeScalarView.Index>) -> Swift.String.UnicodeScalarView.SubSequence {
    get
  }
}
extension Swift.String.UnicodeScalarView {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(after i: Swift.String.UnicodeScalarView.Index) -> Swift.String.UnicodeScalarView.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(before i: Swift.String.UnicodeScalarView.Index) -> Swift.String.UnicodeScalarView.Index
}
extension Swift.String {
  @frozen public struct UTF16View : Swift.Sendable {
    @usableFromInline
    internal var _guts: Swift._StringGuts
    @inlinable internal init(_ guts: Swift._StringGuts) {
      self._guts = guts
      _invariantCheck()
    }
  }
}
extension Swift.String.UTF16View {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension Swift.String.UTF16View : Swift.BidirectionalCollection {
  public typealias Index = Swift.String.Index
  @inlinable @inline(__always) public var startIndex: Swift.String.UTF16View.Index {
    get { return _guts.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.String.UTF16View.Index {
    get { return _guts.endIndex }
  }
  @inlinable @inline(__always) public func index(after idx: Swift.String.UTF16View.Index) -> Swift.String.UTF16View.Index {
    var idx = _guts.ensureMatchingEncoding(idx)
    _precondition(idx._encodedOffset < _guts.count,
      "String index is out of bounds")
    if _slowPath(_guts.isForeign) { return _foreignIndex(after: idx) }
    if _guts.isASCII {
      return idx.nextEncoded._scalarAligned._encodingIndependent
    }

     
     

     

    idx = _utf16AlignNativeIndex(idx)

    let len = _guts.fastUTF8ScalarLength(startingAt: idx._encodedOffset)
    if len == 4 && idx.transcodedOffset == 0 {
      return idx.nextTranscoded._knownUTF8
    }
    return idx
      .strippingTranscoding
      .encoded(offsetBy: len)
      ._scalarAligned
      ._knownUTF8
  }
  @inlinable @inline(__always) public func index(before idx: Swift.String.UTF16View.Index) -> Swift.String.UTF16View.Index {
    var idx = _guts.ensureMatchingEncoding(idx)
    _precondition(!idx.isZeroPosition && idx <= endIndex,
      "String index is out of bounds")
    if _slowPath(_guts.isForeign) { return _foreignIndex(before: idx) }
    if _guts.isASCII {
      return idx.priorEncoded._scalarAligned._encodingIndependent
    }

    if idx.transcodedOffset != 0 {
      _internalInvariant(idx.transcodedOffset == 1)
      return idx.strippingTranscoding._scalarAligned._knownUTF8
    }

    idx = _utf16AlignNativeIndex(idx)
    let len = _guts.fastUTF8ScalarLength(endingAt: idx._encodedOffset)
    if len == 4 {
       
       
      return idx.encoded(offsetBy: -len).nextTranscoded._knownUTF8
    }

     
    _internalInvariant((1...3) ~= len)
    return idx.encoded(offsetBy: -len)._scalarAligned._knownUTF8
  }
  @_effects(releasenone) public func index(_ i: Swift.String.UTF16View.Index, offsetBy n: Swift.Int) -> Swift.String.UTF16View.Index
  @_effects(releasenone) public func index(_ i: Swift.String.UTF16View.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.String.UTF16View.Index) -> Swift.String.UTF16View.Index?
  @_effects(releasenone) public func distance(from start: Swift.String.UTF16View.Index, to end: Swift.String.UTF16View.Index) -> Swift.Int
  @inlinable public var count: Swift.Int {
    get {
    if _slowPath(_guts.isForeign) {
      return _foreignCount()
    }
    return _nativeGetOffset(for: endIndex)
  }
  }
  @inlinable @inline(__always) public subscript(idx: Swift.String.UTF16View.Index) -> Swift.UTF16.CodeUnit {
    get {
    let idx = _guts.ensureMatchingEncoding(idx)
    _precondition(idx._encodedOffset < _guts.count,
      "String index is out of bounds")
    return self[_unchecked: idx]
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal subscript(_unchecked idx: Swift.String.UTF16View.Index) -> Swift.UTF16.CodeUnit {
    get {
    if _fastPath(_guts.isFastUTF8) {
      let scalar = _guts.fastUTF8Scalar(
        startingAt: _guts.scalarAlign(idx)._encodedOffset)
      return scalar.utf16[idx.transcodedOffset]
    }

    return _foreignSubscript(position: idx)
  }
  }
  public typealias Element = Swift.UTF16.CodeUnit
  public typealias Indices = Swift.DefaultIndices<Swift.String.UTF16View>
}
extension Swift.String.UTF16View {
  @frozen public struct Iterator : Swift.IteratorProtocol, Swift.Sendable {
    @usableFromInline
    internal var _guts: Swift._StringGuts
    @usableFromInline
    internal var _position: Swift.Int = 0
    @usableFromInline
    internal var _end: Swift.Int
    @usableFromInline
    internal var _nextIsTrailingSurrogate: Swift.UInt16? = nil
    @inlinable internal init(_ guts: Swift._StringGuts) {
      self._end = guts.count
      self._guts = guts
    }
    @inlinable public mutating func next() -> Swift.UInt16? {
      if _slowPath(_nextIsTrailingSurrogate != nil) {
        let trailing = self._nextIsTrailingSurrogate._unsafelyUnwrappedUnchecked
        self._nextIsTrailingSurrogate = nil
        return trailing
      }
      guard _fastPath(_position < _end) else { return nil }

      let (scalar, len) = _guts.errorCorrectedScalar(startingAt: _position)
      _position &+= len

      if _slowPath(scalar.value > UInt16.max) {
        self._nextIsTrailingSurrogate = scalar.utf16[1]
        return scalar.utf16[0]
      }
      return UInt16(truncatingIfNeeded: scalar.value)
    }
    public typealias Element = Swift.UInt16
  }
  @inlinable public __consuming func makeIterator() -> Swift.String.UTF16View.Iterator {
    return Iterator(_guts)
  }
}
extension Swift.String.UTF16View : Swift.CustomStringConvertible {
  @inlinable @inline(__always) public var description: Swift.String {
    get { return String(_guts) }
  }
}
extension Swift.String.UTF16View : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.String {
  @inlinable public var utf16: Swift.String.UTF16View {
    @inline(__always) get { return UTF16View(_guts) }
    @inline(__always) set { self = String(newValue._guts) }
  }
  @available(swift 4.0)
  @inlinable @inline(__always) public init(_ utf16: Swift.String.UTF16View) {
    self.init(utf16._guts)
  }
}
extension Swift.String.Index {
  public init?(_ idx: Swift.String.Index, within target: Swift.String.UTF16View)
  public func samePosition(in unicodeScalars: Swift.String.UnicodeScalarView) -> Swift.String.UnicodeScalarIndex?
}
extension Swift.String.UTF16View : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.String.UTF16View {
  public typealias SubSequence = Swift.Substring.UTF16View
  public subscript(r: Swift.Range<Swift.String.UTF16View.Index>) -> Swift.Substring.UTF16View {
    get
  }
}
extension Swift.String.UTF16View {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(after i: Swift.String.UTF16View.Index) -> Swift.String.UTF16View.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(before i: Swift.String.UTF16View.Index) -> Swift.String.UTF16View.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignSubscript(position i: Swift.String.UTF16View.Index) -> Swift.UTF16.CodeUnit
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignDistance(from start: Swift.String.UTF16View.Index, to end: Swift.String.UTF16View.Index) -> Swift.Int
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(_ i: Swift.String.UTF16View.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.String.UTF16View.Index) -> Swift.String.UTF16View.Index?
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(_ i: Swift.String.UTF16View.Index, offsetBy n: Swift.Int) -> Swift.String.UTF16View.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignCount() -> Swift.Int
  @_alwaysEmitIntoClient @inline(__always) internal func _utf16AlignNativeIndex(_ idx: Swift.String.Index) -> Swift.String.Index {
    _internalInvariant(!_guts.isForeign)
    guard idx.transcodedOffset == 0 else { return idx }
    return _guts.scalarAlign(idx)
  }
}
extension Swift.String.Index {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIsWithin(_ target: Swift.String.UTF16View) -> Swift.Bool
}
extension Swift.String.UTF16View {
  @usableFromInline
  @_effects(releasenone) internal func _nativeGetOffset(for idx: Swift.String.UTF16View.Index) -> Swift.Int
  @usableFromInline
  @_effects(releasenone) internal func _nativeGetIndex(for offset: Swift.Int) -> Swift.String.UTF16View.Index
}
extension Swift.String {
  @frozen public struct UTF8View : Swift.Sendable {
    @usableFromInline
    internal var _guts: Swift._StringGuts
    @inlinable @inline(__always) internal init(_ guts: Swift._StringGuts) {
      self._guts = guts
      _invariantCheck()
    }
  }
}
extension Swift.String.UTF8View {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension Swift.String.UTF8View : Swift.BidirectionalCollection {
  public typealias Index = Swift.String.Index
  public typealias Element = Swift.UTF8.CodeUnit
  @inlinable @inline(__always) public var startIndex: Swift.String.UTF8View.Index {
    get { return _guts.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.String.UTF8View.Index {
    get { return _guts.endIndex }
  }
  @inlinable @inline(__always) public func index(after i: Swift.String.UTF8View.Index) -> Swift.String.UTF8View.Index {
    let i = _guts.ensureMatchingEncoding(i)
    if _fastPath(_guts.isFastUTF8) {
       
      return i.strippingTranscoding.nextEncoded._knownUTF8
    }
    _precondition(i._encodedOffset < _guts.count,
      "String index is out of bounds")
    return _foreignIndex(after: i)
  }
  @inlinable @inline(__always) public func index(before i: Swift.String.UTF8View.Index) -> Swift.String.UTF8View.Index {
    let i = _guts.ensureMatchingEncoding(i)
    _precondition(!i.isZeroPosition, "String index is out of bounds")
    if _fastPath(_guts.isFastUTF8) {
      return i.strippingTranscoding.priorEncoded._knownUTF8
    }

    _precondition(i._encodedOffset <= _guts.count,
      "String index is out of bounds")
    return _foreignIndex(before: i)
  }
  @inlinable @inline(__always) public func index(_ i: Swift.String.UTF8View.Index, offsetBy n: Swift.Int) -> Swift.String.UTF8View.Index {
    let i = _guts.ensureMatchingEncoding(i)
    if _fastPath(_guts.isFastUTF8) {
      let offset = n + i._encodedOffset
      _precondition(offset >= 0 && offset <= _guts.count,
        "String index is out of bounds")
      return Index(_encodedOffset: offset)._knownUTF8
    }

    return _foreignIndex(i, offsetBy: n)
  }
  @inlinable @inline(__always) public func index(_ i: Swift.String.UTF8View.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.String.UTF8View.Index) -> Swift.String.UTF8View.Index? {
    let i = _guts.ensureMatchingEncoding(i)
    if _fastPath(_guts.isFastUTF8) {
       
       
       
      let iOffset = i._encodedOffset
      let result = iOffset + n
      let limitOffset = limit._encodedOffset
      if n >= 0 {
        guard limitOffset < iOffset || result <= limitOffset else { return nil }
      } else {
        guard limitOffset > iOffset || result >= limitOffset else { return nil }
      }
      _precondition(result >= 0 && result <= _guts.count,
        "String index is out of bounds")
      return Index(_encodedOffset: result)._knownUTF8
    }

    return _foreignIndex(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable @inline(__always) public func distance(from i: Swift.String.UTF8View.Index, to j: Swift.String.UTF8View.Index) -> Swift.Int {
    let i = _guts.ensureMatchingEncoding(i)
    let j = _guts.ensureMatchingEncoding(j)
    if _fastPath(_guts.isFastUTF8) {
      return j._encodedOffset &- i._encodedOffset
    }
    _precondition(
      i._encodedOffset <= _guts.count && j._encodedOffset <= _guts.count,
      "String index is out of bounds")
    return _foreignDistance(from: i, to: j)
  }
  @inlinable @inline(__always) public subscript(i: Swift.String.UTF8View.Index) -> Swift.UTF8.CodeUnit {
    get {
    let i = _guts.ensureMatchingEncoding(i)
    _precondition(i._encodedOffset < _guts.count,
      "String index is out of bounds")
    return self[_unchecked: i]
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal subscript(_unchecked i: Swift.String.UTF8View.Index) -> Swift.UTF8.CodeUnit {
    get {
    if _fastPath(_guts.isFastUTF8) {
      return _guts.withFastUTF8 { utf8 in utf8[_unchecked: i._encodedOffset] }
    }

    return _foreignSubscript(position: i)
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.String.UTF8View>
  public typealias Iterator = Swift.IndexingIterator<Swift.String.UTF8View>
}
extension Swift.String.UTF8View : Swift.CustomStringConvertible {
  @inlinable @inline(__always) public var description: Swift.String {
    get { return String(_guts) }
  }
}
extension Swift.String.UTF8View : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.String {
  @inlinable public var utf8: Swift.String.UTF8View {
    @inline(__always) get { return UTF8View(self._guts) }
    set { self = String(newValue._guts) }
  }
  public var utf8CString: Swift.ContiguousArray<Swift.CChar> {
    @_effects(readonly) @_semantics("string.getUTF8CString") get
  }
  @usableFromInline
  @inline(never) internal func _slowUTF8CString() -> Swift.ContiguousArray<Swift.CChar>
  @available(swift, introduced: 4.0, message: "Please use failable String.init?(_:UTF8View) when in Swift 3.2 mode")
  @inlinable @inline(__always) public init(_ utf8: Swift.String.UTF8View) {
    self = String(utf8._guts)
  }
}
extension Swift.String.UTF8View {
  @inlinable @inline(__always) public var count: Swift.Int {
    get {
    if _fastPath(_guts.isFastUTF8) {
      return _guts.count
    }
    return _foreignCount()
  }
  }
}
extension Swift.String.Index {
  public init?(_ idx: Swift.String.Index, within target: Swift.String.UTF8View)
}
extension Swift.String.UTF8View : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.String.UTF8View {
  public typealias SubSequence = Swift.Substring.UTF8View
  @available(swift 4)
  @inlinable public subscript(r: Swift.Range<Swift.String.UTF8View.Index>) -> Swift.String.UTF8View.SubSequence {
    get {
    let r = _guts.validateSubscalarRange(r)
    return Substring.UTF8View(self, _bounds: r)
  }
  }
}
extension Swift.String.UTF8View {
  @inlinable @inline(__always) public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Swift.String.UTF8View.Iterator.Element>) -> (Swift.String.UTF8View.Iterator, Swift.UnsafeMutableBufferPointer<Swift.String.UTF8View.Iterator.Element>.Index) {
    guard buffer.baseAddress != nil else {
        _preconditionFailure(
          "Attempt to copy string contents into nil buffer pointer")
    }
    guard let written = _guts.copyUTF8(into: buffer) else {
      _preconditionFailure(
        "Insufficient space allocated to copy string contents")
    }

    let it = String().utf8.makeIterator()
    return (it, buffer.index(buffer.startIndex, offsetBy: written))
  }
}
extension Swift.String.UTF8View {
  @_alwaysEmitIntoClient @inline(__always) internal func _utf8AlignForeignIndex(_ idx: Swift.String.Index) -> Swift.String.Index {
    _internalInvariant(_guts.isForeign)
    guard idx.transcodedOffset == 0 else { return idx }
    return _guts.scalarAlign(idx)
  }
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(after idx: Swift.String.UTF8View.Index) -> Swift.String.UTF8View.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(before idx: Swift.String.UTF8View.Index) -> Swift.String.UTF8View.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignSubscript(position idx: Swift.String.UTF8View.Index) -> Swift.UTF8.CodeUnit
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(_ i: Swift.String.UTF8View.Index, offsetBy n: Swift.Int) -> Swift.String.UTF8View.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(_ i: Swift.String.UTF8View.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.String.UTF8View.Index) -> Swift.String.UTF8View.Index?
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignDistance(from i: Swift.String.UTF8View.Index, to j: Swift.String.UTF8View.Index) -> Swift.Int
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignCount() -> Swift.Int
}
extension Swift.String.Index {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIsWithin(_ target: Swift.String.UTF8View) -> Swift.Bool
}
extension Swift.String.UTF8View {
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Swift.String.UTF8View.Element>) throws -> R) rethrows -> R? {
    guard _guts.isFastUTF8 else { return nil }
    return try _guts.withFastUTF8(body)
  }
}
extension Swift.String {
  @inlinable public init(_ substring: __shared Swift.Substring) {
    self = String._fromSubstring(substring)
  }
}
@frozen public struct Substring : Swift.Sendable {
  @usableFromInline
  internal var _slice: Swift.Slice<Swift.String>
  @_alwaysEmitIntoClient @inline(__always) internal init(_unchecked slice: Swift.Slice<Swift.String>) {
    self._slice = slice
    _invariantCheck()
  }
  @_alwaysEmitIntoClient @inline(__always) internal init(_unchecked guts: Swift._StringGuts, bounds: Swift.Range<Swift.Substring.Index>) {
    self.init(_unchecked: Slice(base: String(guts), bounds: bounds))
  }
  @usableFromInline
  @available(*, deprecated)
  internal init(_ slice: Swift.Slice<Swift.String>)
  @inlinable @inline(__always) public init() {
    self._slice = Slice()
  }
}
extension Swift.Substring {
  @_alwaysEmitIntoClient public var base: Swift.String {
    get { return _slice._base }
  }
  @inlinable @inline(__always) internal var _wholeGuts: Swift._StringGuts {
    get { _slice._base._guts }
  }
  @inlinable @inline(__always) internal var _offsetRange: Swift.Range<Swift.Int> {
    get { _slice._bounds._encodedOffsetRange }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var _bounds: Swift.Range<Swift.Substring.Index> {
    get { _slice._bounds }
  }
}
extension Swift.Substring {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension Swift.Substring : Swift.StringProtocol {
  public typealias Index = Swift.String.Index
  public typealias SubSequence = Swift.Substring
  @inlinable @inline(__always) public var startIndex: Swift.Substring.Index {
    get { _slice._startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Substring.Index {
    get { _slice._endIndex }
  }
  public func index(after i: Swift.Substring.Index) -> Swift.Substring.Index
  public func index(before i: Swift.Substring.Index) -> Swift.Substring.Index
  public func index(_ i: Swift.Substring.Index, offsetBy distance: Swift.Int) -> Swift.Substring.Index
  public func index(_ i: Swift.Substring.Index, offsetBy distance: Swift.Int, limitedBy limit: Swift.Substring.Index) -> Swift.Substring.Index?
  public func distance(from start: Swift.Substring.Index, to end: Swift.Substring.Index) -> Swift.Int
  public subscript(i: Swift.Substring.Index) -> Swift.Character {
    get
  }
  public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Substring.Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.Character
  public mutating func replaceSubrange(_ subrange: Swift.Range<Swift.Substring.Index>, with newElements: Swift.Substring)
  @inlinable public init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Swift.Collection, Encoding : Swift._UnicodeEncoding, C.Element == Encoding.CodeUnit {
    self.init(String(decoding: codeUnits, as: sourceEncoding))
  }
  public init(cString nullTerminatedUTF8: Swift.UnsafePointer<Swift.CChar>)
  @inlinable public init<Encoding>(decodingCString nullTerminatedCodeUnits: Swift.UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding {
    self.init(
      String(decodingCString: nullTerminatedCodeUnits, as: sourceEncoding))
  }
  @inlinable public func withCString<Result>(_ body: (Swift.UnsafePointer<Swift.CChar>) throws -> Result) rethrows -> Result {
     
     
    return try String(self).withCString(body)
  }
  @inlinable public func withCString<Result, TargetEncoding>(encodedAs targetEncoding: TargetEncoding.Type, _ body: (Swift.UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result where TargetEncoding : Swift._UnicodeEncoding {
     
     
    return try String(self).withCString(encodedAs: targetEncoding, body)
  }
  public typealias Element = Swift.Character
  public typealias Indices = Swift.DefaultIndices<Swift.Substring>
  public typealias Iterator = Swift.IndexingIterator<Swift.Substring>
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Substring : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Substring : Swift.CustomStringConvertible {
  @inlinable @inline(__always) public var description: Swift.String {
    get { return String(self) }
  }
}
extension Swift.Substring : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.Substring : Swift.LosslessStringConvertible {
  public init(_ content: Swift.String)
}
extension Swift.Substring {
  @frozen public struct UTF8View : Swift.Sendable {
    @usableFromInline
    internal var _slice: Swift.Slice<Swift.String.UTF8View>
    @inlinable internal init(_ base: Swift.String.UTF8View, _bounds: Swift.Range<Swift.Substring.UTF8View.Index>) {
      _slice = Slice(base: base, bounds: _bounds)
    }
    @_alwaysEmitIntoClient @inline(__always) internal var _wholeGuts: Swift._StringGuts {
      get { _slice._base._guts }
    }
    @_alwaysEmitIntoClient @inline(__always) internal var _base: Swift.String.UTF8View {
      get { _slice._base }
    }
    @_alwaysEmitIntoClient @inline(__always) internal var _bounds: Swift.Range<Swift.Substring.UTF8View.Index> {
      get { _slice._bounds }
    }
  }
}
extension Swift.Substring.UTF8View : Swift.BidirectionalCollection {
  public typealias Index = Swift.String.UTF8View.Index
  public typealias Indices = Swift.String.UTF8View.Indices
  public typealias Element = Swift.String.UTF8View.Element
  public typealias SubSequence = Swift.Substring.UTF8View
  @inlinable public var startIndex: Swift.Substring.UTF8View.Index {
    get { _slice._startIndex }
  }
  @inlinable public var endIndex: Swift.Substring.UTF8View.Index {
    get { _slice._endIndex }
  }
  @inlinable public subscript(index: Swift.Substring.UTF8View.Index) -> Swift.Substring.UTF8View.Element {
    get {
    let index = _wholeGuts.ensureMatchingEncoding(index)
    _precondition(index >= startIndex && index < endIndex,
      "String index is out of bounds")
    return _base[_unchecked: index]
  }
  }
  @inlinable public var indices: Swift.Substring.UTF8View.Indices {
    get { return _slice.indices }
  }
  @inlinable public func index(after i: Swift.Substring.UTF8View.Index) -> Swift.Substring.UTF8View.Index {
     
    return _base.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Swift.Substring.UTF8View.Index) {
     
    _base.formIndex(after: &i)
  }
  @inlinable public func index(_ i: Swift.Substring.UTF8View.Index, offsetBy n: Swift.Int) -> Swift.Substring.UTF8View.Index {
     
    return _base.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.Substring.UTF8View.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.Substring.UTF8View.Index) -> Swift.Substring.UTF8View.Index? {
     
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Swift.Substring.UTF8View.Index, to end: Swift.Substring.UTF8View.Index) -> Swift.Int {
    return _base.distance(from: start, to: end)
  }
  @_alwaysEmitIntoClient @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Swift.Substring.UTF8View.Element>) throws -> R) rethrows -> R? {
    return try _slice.withContiguousStorageIfAvailable(body)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Substring.UTF8View.Index, bounds: Swift.Range<Swift.Substring.UTF8View.Index>) {
     
     
    _base._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Substring.UTF8View.Index>, bounds: Swift.Range<Swift.Substring.UTF8View.Index>) {
     
     
    _base._failEarlyRangeCheck(range, bounds: bounds)
  }
  @inlinable public func index(before i: Swift.Substring.UTF8View.Index) -> Swift.Substring.UTF8View.Index {
     
    return _base.index(before: i)
  }
  @inlinable public func formIndex(before i: inout Swift.Substring.UTF8View.Index) {
     
    _base.formIndex(before: &i)
  }
  @inlinable public subscript(r: Swift.Range<Swift.Substring.UTF8View.Index>) -> Swift.Substring.UTF8View {
    get {
     
    let r = _wholeGuts.validateSubscalarRange(r, in: _bounds)
    return Substring.UTF8View(_slice.base, _bounds: r)
  }
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.Substring.UTF8View>
}
extension Swift.Substring {
  @inlinable public var utf8: Swift.Substring.UTF8View {
    get {
       
      UTF8View(base.utf8, _bounds: _bounds)
    }
    set {
      self = Substring(newValue)
    }
  }
  public init(_ content: Swift.Substring.UTF8View)
}
extension Swift.String {
  public init?(_ codeUnits: Swift.Substring.UTF8View)
}
extension Swift.Substring {
  @frozen public struct UTF16View : Swift.Sendable {
    @usableFromInline
    internal var _slice: Swift.Slice<Swift.String.UTF16View>
    @inlinable internal init(_ base: Swift.String.UTF16View, _bounds: Swift.Range<Swift.Substring.UTF16View.Index>) {
      _slice = Slice(base: base, bounds: _bounds)
    }
    @_alwaysEmitIntoClient @inline(__always) internal var _wholeGuts: Swift._StringGuts {
      get { _slice._base._guts }
    }
    @_alwaysEmitIntoClient @inline(__always) internal var _base: Swift.String.UTF16View {
      get { _slice._base }
    }
    @_alwaysEmitIntoClient @inline(__always) internal var _bounds: Swift.Range<Swift.Substring.UTF16View.Index> {
      get { _slice._bounds }
    }
  }
}
extension Swift.Substring.UTF16View : Swift.BidirectionalCollection {
  public typealias Index = Swift.String.UTF16View.Index
  public typealias Indices = Swift.String.UTF16View.Indices
  public typealias Element = Swift.String.UTF16View.Element
  public typealias SubSequence = Swift.Substring.UTF16View
  @inlinable public var startIndex: Swift.Substring.UTF16View.Index {
    get { _slice._startIndex }
  }
  @inlinable public var endIndex: Swift.Substring.UTF16View.Index {
    get { _slice._endIndex }
  }
  @inlinable public subscript(index: Swift.Substring.UTF16View.Index) -> Swift.Substring.UTF16View.Element {
    get {
    let index = _wholeGuts.ensureMatchingEncoding(index)
    _precondition(index >= startIndex && index < endIndex,
      "String index is out of bounds")
    return _base[_unchecked: index]
  }
  }
  @inlinable public var indices: Swift.Substring.UTF16View.Indices {
    get { return _slice.indices }
  }
  @inlinable public func index(after i: Swift.Substring.UTF16View.Index) -> Swift.Substring.UTF16View.Index {
     
    return _base.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Swift.Substring.UTF16View.Index) {
     
    _base.formIndex(after: &i)
  }
  @inlinable public func index(_ i: Swift.Substring.UTF16View.Index, offsetBy n: Swift.Int) -> Swift.Substring.UTF16View.Index {
     
    return _base.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.Substring.UTF16View.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.Substring.UTF16View.Index) -> Swift.Substring.UTF16View.Index? {
     
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Swift.Substring.UTF16View.Index, to end: Swift.Substring.UTF16View.Index) -> Swift.Int {
    return _base.distance(from: start, to: end)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Substring.UTF16View.Index, bounds: Swift.Range<Swift.Substring.UTF16View.Index>) {
     
     
    _base._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Substring.UTF16View.Index>, bounds: Swift.Range<Swift.Substring.UTF16View.Index>) {
     
     
    _base._failEarlyRangeCheck(range, bounds: bounds)
  }
  @inlinable public func index(before i: Swift.Substring.UTF16View.Index) -> Swift.Substring.UTF16View.Index {
     
    return _base.index(before: i)
  }
  @inlinable public func formIndex(before i: inout Swift.Substring.UTF16View.Index) {
     
    _base.formIndex(before: &i)
  }
  @inlinable public subscript(r: Swift.Range<Swift.Substring.UTF16View.Index>) -> Swift.Substring.UTF16View {
    get {
    let r = _wholeGuts.validateSubscalarRange(r, in: _bounds)
    return Substring.UTF16View(_slice.base, _bounds: r)
  }
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.Substring.UTF16View>
}
extension Swift.Substring {
  @inlinable public var utf16: Swift.Substring.UTF16View {
    get {
       
      UTF16View(base.utf16, _bounds: _bounds)
    }
    set {
      self = Substring(newValue)
    }
  }
  public init(_ content: Swift.Substring.UTF16View)
}
extension Swift.String {
  public init?(_ codeUnits: Swift.Substring.UTF16View)
}
extension Swift.Substring {
  @frozen public struct UnicodeScalarView : Swift.Sendable {
    @usableFromInline
    internal var _slice: Swift.Slice<Swift.String.UnicodeScalarView>
    @_alwaysEmitIntoClient internal init(_unchecked base: Swift.String.UnicodeScalarView, bounds: Swift.Range<Swift.Substring.UnicodeScalarView.Index>) {
      _slice = Slice(base: base, bounds: bounds)
      _invariantCheck()
    }
    @usableFromInline
    @available(*, deprecated, message: "Use `init(_unchecked:bounds)` in new code")
    internal init(_ base: Swift.String.UnicodeScalarView, _bounds: Swift.Range<Swift.Substring.UnicodeScalarView.Index>)
  }
}
extension Swift.Substring.UnicodeScalarView {
  @_alwaysEmitIntoClient @inline(__always) internal var _wholeGuts: Swift._StringGuts {
    get { _slice._base._guts }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var _bounds: Swift.Range<Swift.Substring.UnicodeScalarView.Index> {
    get { _slice._bounds }
  }
}
extension Swift.Substring.UnicodeScalarView {
  @_alwaysEmitIntoClient @inline(__always) internal func _invariantCheck() {}
}
extension Swift.Substring.UnicodeScalarView : Swift.BidirectionalCollection {
  public typealias Index = Swift.String.UnicodeScalarView.Index
  public typealias Indices = Swift.String.UnicodeScalarView.Indices
  public typealias Element = Swift.String.UnicodeScalarView.Element
  public typealias SubSequence = Swift.Substring.UnicodeScalarView
  @inlinable @inline(__always) public var startIndex: Swift.Substring.UnicodeScalarView.Index {
    get { _slice._startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Substring.UnicodeScalarView.Index {
    get { _slice._endIndex }
  }
  @inlinable public subscript(index: Swift.Substring.UnicodeScalarView.Index) -> Swift.Substring.UnicodeScalarView.Element {
    get {
    let index = _wholeGuts.validateScalarIndex(index, in: _bounds)
    return _wholeGuts.errorCorrectedScalar(startingAt: index._encodedOffset).0
  }
  }
  @inlinable public var indices: Swift.Substring.UnicodeScalarView.Indices {
    get {
    return _slice.indices
  }
  }
  @inlinable public func index(after i: Swift.Substring.UnicodeScalarView.Index) -> Swift.Substring.UnicodeScalarView.Index {
    _slice._base.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Swift.Substring.UnicodeScalarView.Index) {
    _slice._base.formIndex(after: &i)
  }
  @inlinable public func index(_ i: Swift.Substring.UnicodeScalarView.Index, offsetBy n: Swift.Int) -> Swift.Substring.UnicodeScalarView.Index {
    _slice._base.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.Substring.UnicodeScalarView.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.Substring.UnicodeScalarView.Index) -> Swift.Substring.UnicodeScalarView.Index? {
    _slice._base.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Swift.Substring.UnicodeScalarView.Index, to end: Swift.Substring.UnicodeScalarView.Index) -> Swift.Int {
    _slice._base.distance(from: start, to: end)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Substring.UnicodeScalarView.Index, bounds: Swift.Range<Swift.Substring.UnicodeScalarView.Index>) {
    _slice._base._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Substring.UnicodeScalarView.Index>, bounds: Swift.Range<Swift.Substring.UnicodeScalarView.Index>) {
    _slice._base._failEarlyRangeCheck(range, bounds: bounds)
  }
  @inlinable public func index(before i: Swift.Substring.UnicodeScalarView.Index) -> Swift.Substring.UnicodeScalarView.Index {
    _slice._base.index(before: i)
  }
  @inlinable public func formIndex(before i: inout Swift.Substring.UnicodeScalarView.Index) {
    _slice._base.formIndex(before: &i)
  }
  public subscript(r: Swift.Range<Swift.Substring.UnicodeScalarView.Index>) -> Swift.Substring.UnicodeScalarView {
    get
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.Substring.UnicodeScalarView>
}
extension Swift.Substring {
  @inlinable public var unicodeScalars: Swift.Substring.UnicodeScalarView {
    get {
       
      UnicodeScalarView(_unchecked: base.unicodeScalars, bounds: _bounds)
    }
    set {
      self = Substring(newValue)
    }
  }
  public init(_ content: Swift.Substring.UnicodeScalarView)
}
extension Swift.String {
  public init(_ content: Swift.Substring.UnicodeScalarView)
}
extension Swift.Substring.UnicodeScalarView : Swift.RangeReplaceableCollection {
  @inlinable public init() { _slice = Slice.init() }
  public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Substring.UnicodeScalarView.Index>, with replacement: C) where C : Swift.Collection, C.Element == Swift.Unicode.Scalar
}
extension Swift.Substring : Swift.RangeReplaceableCollection {
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  @_specialize(exported: false, kind: full, where S == [Swift.Character])
  public init<S>(_ elements: S) where S : Swift.Sequence, S.Element == Swift.Character
  @inlinable public mutating func append<S>(contentsOf elements: S) where S : Swift.Sequence, S.Element == Swift.Character {
    var string = String(self)
    self = Substring()  
    string.append(contentsOf: elements)
    self = Substring(string)
  }
}
extension Swift.Substring {
  public func lowercased() -> Swift.String
  public func uppercased() -> Swift.String
  public func filter(_ isIncluded: (Swift.Substring.Element) throws -> Swift.Bool) rethrows -> Swift.String
}
extension Swift.Substring : Swift.TextOutputStream {
  public mutating func write(_ other: Swift.String)
}
extension Swift.Substring : Swift.TextOutputStreamable {
  @inlinable public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream {
    target.write(String(self))
  }
}
extension Swift.Substring : Swift.ExpressibleByUnicodeScalarLiteral {
  @inlinable public init(unicodeScalarLiteral value: Swift.String) {
     self.init(value)
  }
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Swift.Substring : Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  @inlinable public init(extendedGraphemeClusterLiteral value: Swift.String) {
     self.init(value)
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
}
extension Swift.Substring : Swift.ExpressibleByStringLiteral {
  @inlinable public init(stringLiteral value: Swift.String) {
     self.init(value)
  }
  public typealias StringLiteralType = Swift.String
}
extension Swift.String {
  @available(swift 4)
  public subscript(r: Swift.Range<Swift.String.Index>) -> Swift.Substring {
    get
  }
}
extension Swift.Substring {
  @available(swift 4)
  public subscript(r: Swift.Range<Swift.Substring.Index>) -> Swift.Substring {
    get
  }
}
@usableFromInline
@_transparent internal func _isValidArrayIndex(_ index: Swift.Int, count: Swift.Int) -> Swift.Bool {
  return (index >= 0) && (index <= count)
}
@usableFromInline
@_transparent internal func _isValidArraySubscript(_ index: Swift.Int, count: Swift.Int) -> Swift.Bool {
  return (index >= 0) && (index < count)
}
@objc @_inheritsConvenienceInitializers @usableFromInline
@_fixed_layout internal class __SwiftNativeNSArrayWithContiguousStorage : Swift.__SwiftNativeNSArray {
  @inlinable @nonobjc override internal init() { super.init() }
  @objc @inlinable deinit {}
}
@available(*, unavailable)
extension Swift.__SwiftNativeNSArrayWithContiguousStorage : Swift.Sendable {
}
@_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @objc final internal class _SwiftNSMutableArray : Swift._SwiftNativeNSMutableArray {
  final internal var contents: [Swift.AnyObject]
  @objc @usableFromInline
  deinit
}
@available(*, unavailable)
extension Swift._SwiftNSMutableArray : Swift.Sendable {
}
@usableFromInline
@_fixed_layout @objc internal class __SwiftDeferredNSArray : Swift.__SwiftNativeNSArrayWithContiguousStorage {
  @nonobjc final internal var _heapBufferBridged_DoNotUse: Swift.AnyObject?
  @usableFromInline
  @nonobjc final internal let _nativeStorage: Swift.__ContiguousArrayStorageBase
  @inlinable @nonobjc internal init(_nativeStorage: Swift.__ContiguousArrayStorageBase) {
    self._nativeStorage = _nativeStorage
  }
  @objc deinit
}
@available(*, unavailable)
extension Swift.__SwiftDeferredNSArray : Swift.Sendable {
}
@objc @usableFromInline
@_fixed_layout internal class __ContiguousArrayStorageBase : Swift.__SwiftNativeNSArrayWithContiguousStorage {
  @usableFromInline
  final internal var countAndCapacity: Swift._ArrayBody
  @inlinable @nonobjc internal init(_doNotCallMeBase: ()) {
    _internalInvariantFailure("creating instance of __ContiguousArrayStorageBase")
  }
  @inlinable internal func canStoreElements(ofDynamicType _: any Any.Type) -> Swift.Bool {
    _internalInvariantFailure(
      "Concrete subclasses must implement canStoreElements(ofDynamicType:)")
  }
  @inlinable internal var staticElementType: any Any.Type {
    get {
    _internalInvariantFailure(
      "Concrete subclasses must implement staticElementType")
  }
  }
  @objc @inlinable deinit {
    _internalInvariant(
      self !== _emptyArrayStorage, "Deallocating empty array storage?!")
  }
}
@available(*, unavailable)
extension Swift.__ContiguousArrayStorageBase : Swift.Sendable {
}
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient @_transparent internal func _byteCountForTemporaryAllocation<T>(of type: T.Type, capacity: Swift.Int) -> Swift.Int where T : ~Copyable {
   
   
   
   
   
   
   
  if _isComputed(capacity) {
    _precondition(capacity >= 0, "Allocation capacity must be greater than or equal to zero")
  }
  let stride = MemoryLayout<T>.stride
  let (byteCount, overflow) = capacity.multipliedReportingOverflow(by: stride)
  if _isComputed(capacity) {
    _precondition(!overflow, "Allocation byte count too large")
  }
  return byteCount
}
#else
@_alwaysEmitIntoClient @_transparent internal func _byteCountForTemporaryAllocation<T>(of type: T.Type, capacity: Swift.Int) -> Swift.Int {
   
   
   
   
   
   
   
  if _isComputed(capacity) {
    _precondition(capacity >= 0, "Allocation capacity must be greater than or equal to zero")
  }
  let stride = MemoryLayout<T>.stride
  let (byteCount, overflow) = capacity.multipliedReportingOverflow(by: stride)
  if _isComputed(capacity) {
    _precondition(!overflow, "Allocation byte count too large")
  }
  return byteCount
}
#endif
@_alwaysEmitIntoClient @_transparent internal func _isStackAllocationSafe(byteCount: Swift.Int, alignment: Swift.Int) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinStackAlloc
   
   
  if _isComputed(alignment) {
    _precondition(alignment > 0, "Alignment value must be greater than zero")
    _precondition(_isPowerOf2(alignment), "Alignment value must be a power of two")
  }

   
   
   
   
   
   
   
   
  if alignment > _minAllocationAlignment() {
    return false
  }

   
   
   
   
  if byteCount <= 1024 {
    return true
  }

#if !$Embedded
   
   
  guard #available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)  
  else {
    return false
  }
  return swift_stdlib_isStackAllocationSafe(byteCount, alignment)
#else
  return false
#endif

#else
  fatalError("unsupported compiler")
#endif
}
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient @_transparent internal func _withUnsafeTemporaryAllocation<T, R>(of type: T.Type, capacity: Swift.Int, alignment: Swift.Int, _ body: (Builtin.RawPointer) throws -> R) rethrows -> R where T : ~Copyable, R : ~Copyable {
   
  let byteCount = _byteCountForTemporaryAllocation(of: type, capacity: capacity)

  guard _isStackAllocationSafe(byteCount: byteCount, alignment: alignment) else {
    return try _fallBackToHeapAllocation(byteCount: byteCount, alignment: alignment, body)
  }

   
   
   
  let result: R
  
#if compiler(>=5.5) && $BuiltinStackAlloc
  let stackAddress = Builtin.stackAlloc(
    capacity._builtinWordValue,
    MemoryLayout<T>.stride._builtinWordValue,
    alignment._builtinWordValue
  )
  
   
   
   
  do {
    result = try body(stackAddress)
    Builtin.stackDealloc(stackAddress)
    return result

  } catch {
    Builtin.stackDealloc(stackAddress)
    throw error
  }
#else
  fatalError("unsupported compiler")
#endif
}
#else
@_alwaysEmitIntoClient @_transparent internal func _withUnsafeTemporaryAllocation<T, R>(of type: T.Type, capacity: Swift.Int, alignment: Swift.Int, _ body: (Builtin.RawPointer) throws -> R) rethrows -> R {
   
  let byteCount = _byteCountForTemporaryAllocation(of: type, capacity: capacity)

  guard _isStackAllocationSafe(byteCount: byteCount, alignment: alignment) else {
    return try _fallBackToHeapAllocation(byteCount: byteCount, alignment: alignment, body)
  }

   
   
   
  let result: R
  
#if compiler(>=5.5) && $BuiltinStackAlloc
  let stackAddress = Builtin.stackAlloc(
    capacity._builtinWordValue,
    MemoryLayout<T>.stride._builtinWordValue,
    alignment._builtinWordValue
  )
  
   
   
   
  do {
    result = try body(stackAddress)
    Builtin.stackDealloc(stackAddress)
    return result

  } catch {
    Builtin.stackDealloc(stackAddress)
    throw error
  }
#else
  fatalError("unsupported compiler")
#endif
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient @_transparent internal func _withUnprotectedUnsafeTemporaryAllocation<T, R>(of type: T.Type, capacity: Swift.Int, alignment: Swift.Int, _ body: (Builtin.RawPointer) throws -> R) rethrows -> R where T : ~Copyable, R : ~Copyable {
   
  let byteCount = _byteCountForTemporaryAllocation(of: type, capacity: capacity)

  guard _isStackAllocationSafe(byteCount: byteCount, alignment: alignment) else {
    return try _fallBackToHeapAllocation(byteCount: byteCount, alignment: alignment, body)
  }

   
   
   
  let result: R

#if $BuiltinUnprotectedStackAlloc
  let stackAddress = Builtin.unprotectedStackAlloc(
    capacity._builtinWordValue,
    MemoryLayout<T>.stride._builtinWordValue,
    alignment._builtinWordValue
  )
#else
  let stackAddress = Builtin.stackAlloc(
    capacity._builtinWordValue,
    MemoryLayout<T>.stride._builtinWordValue,
    alignment._builtinWordValue
  )
#endif

   
   
   
  do {
    result = try body(stackAddress)
    Builtin.stackDealloc(stackAddress)
    return result

  } catch {
    Builtin.stackDealloc(stackAddress)
    throw error
  }
}
#else
@_alwaysEmitIntoClient @_transparent internal func _withUnprotectedUnsafeTemporaryAllocation<T, R>(of type: T.Type, capacity: Swift.Int, alignment: Swift.Int, _ body: (Builtin.RawPointer) throws -> R) rethrows -> R {
   
  let byteCount = _byteCountForTemporaryAllocation(of: type, capacity: capacity)

  guard _isStackAllocationSafe(byteCount: byteCount, alignment: alignment) else {
    return try _fallBackToHeapAllocation(byteCount: byteCount, alignment: alignment, body)
  }

   
   
   
  let result: R

#if $BuiltinUnprotectedStackAlloc
  let stackAddress = Builtin.unprotectedStackAlloc(
    capacity._builtinWordValue,
    MemoryLayout<T>.stride._builtinWordValue,
    alignment._builtinWordValue
  )
#else
  let stackAddress = Builtin.stackAlloc(
    capacity._builtinWordValue,
    MemoryLayout<T>.stride._builtinWordValue,
    alignment._builtinWordValue
  )
#endif

   
   
   
  do {
    result = try body(stackAddress)
    Builtin.stackDealloc(stackAddress)
    return result

  } catch {
    Builtin.stackDealloc(stackAddress)
    throw error
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient @_transparent internal func _fallBackToHeapAllocation<R>(byteCount: Swift.Int, alignment: Swift.Int, _ body: (Builtin.RawPointer) throws -> R) rethrows -> R where R : ~Copyable {
  let buffer = UnsafeMutableRawPointer.allocate(
    byteCount: byteCount,
    alignment: alignment
  )
  defer {
    buffer.deallocate()
  }
  return try body(buffer._rawValue)
}
#else
@_alwaysEmitIntoClient @_transparent internal func _fallBackToHeapAllocation<R>(byteCount: Swift.Int, alignment: Swift.Int, _ body: (Builtin.RawPointer) throws -> R) rethrows -> R {
  let buffer = UnsafeMutableRawPointer.allocate(
    byteCount: byteCount,
    alignment: alignment
  )
  defer {
    buffer.deallocate()
  }
  return try body(buffer._rawValue)
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient @_transparent public func withUnsafeTemporaryAllocation<R>(byteCount: Swift.Int, alignment: Swift.Int, _ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R where R : ~Copyable {
  return try _withUnsafeTemporaryAllocation(
    of: Int8.self,
    capacity: byteCount,
    alignment: alignment
  ) { pointer in
    let buffer = UnsafeMutableRawBufferPointer(
      start: .init(pointer),
      count: byteCount
    )
    return try body(buffer)
  }
}
#else
@_alwaysEmitIntoClient @_transparent public func withUnsafeTemporaryAllocation<R>(byteCount: Swift.Int, alignment: Swift.Int, _ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {
  return try _withUnsafeTemporaryAllocation(
    of: Int8.self,
    capacity: byteCount,
    alignment: alignment
  ) { pointer in
    let buffer = UnsafeMutableRawBufferPointer(
      start: .init(pointer),
      count: byteCount
    )
    return try body(buffer)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient @_transparent public func _withUnprotectedUnsafeTemporaryAllocation<R>(byteCount: Swift.Int, alignment: Swift.Int, _ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R where R : ~Copyable {
  return try _withUnprotectedUnsafeTemporaryAllocation(
    of: Int8.self,
    capacity: byteCount,
    alignment: alignment
  ) { pointer in
    let buffer = UnsafeMutableRawBufferPointer(
      start: .init(pointer),
      count: byteCount
    )
    return try body(buffer)
  }
}
#else
@_alwaysEmitIntoClient @_transparent public func _withUnprotectedUnsafeTemporaryAllocation<R>(byteCount: Swift.Int, alignment: Swift.Int, _ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {
  return try _withUnprotectedUnsafeTemporaryAllocation(
    of: Int8.self,
    capacity: byteCount,
    alignment: alignment
  ) { pointer in
    let buffer = UnsafeMutableRawBufferPointer(
      start: .init(pointer),
      count: byteCount
    )
    return try body(buffer)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient @_transparent public func withUnsafeTemporaryAllocation<T, R>(of type: T.Type, capacity: Swift.Int, _ body: (Swift.UnsafeMutableBufferPointer<T>) throws -> R) rethrows -> R where T : ~Copyable, R : ~Copyable {
  return try _withUnsafeTemporaryAllocation(
    of: type,
    capacity: capacity,
    alignment: MemoryLayout<T>.alignment
  ) { pointer in
    Builtin.bindMemory(pointer, capacity._builtinWordValue, type)
    let buffer = UnsafeMutableBufferPointer<T>(
      start: .init(pointer),
      count: capacity
    )
    return try body(buffer)
  }
}
#else
@_alwaysEmitIntoClient @_transparent public func withUnsafeTemporaryAllocation<T, R>(of type: T.Type, capacity: Swift.Int, _ body: (Swift.UnsafeMutableBufferPointer<T>) throws -> R) rethrows -> R {
  return try _withUnsafeTemporaryAllocation(
    of: type,
    capacity: capacity,
    alignment: MemoryLayout<T>.alignment
  ) { pointer in
    Builtin.bindMemory(pointer, capacity._builtinWordValue, type)
    let buffer = UnsafeMutableBufferPointer<T>(
      start: .init(pointer),
      count: capacity
    )
    return try body(buffer)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient @_transparent public func _withUnprotectedUnsafeTemporaryAllocation<T, R>(of type: T.Type, capacity: Swift.Int, _ body: (Swift.UnsafeMutableBufferPointer<T>) throws -> R) rethrows -> R where T : ~Copyable, R : ~Copyable {
  return try _withUnprotectedUnsafeTemporaryAllocation(
    of: type,
    capacity: capacity,
    alignment: MemoryLayout<T>.alignment
  ) { pointer in
    Builtin.bindMemory(pointer, capacity._builtinWordValue, type)
    let buffer = UnsafeMutableBufferPointer<T>(
      start: .init(pointer),
      count: capacity
    )
    return try body(buffer)
  }
}
#else
@_alwaysEmitIntoClient @_transparent public func _withUnprotectedUnsafeTemporaryAllocation<T, R>(of type: T.Type, capacity: Swift.Int, _ body: (Swift.UnsafeMutableBufferPointer<T>) throws -> R) rethrows -> R {
  return try _withUnprotectedUnsafeTemporaryAllocation(
    of: type,
    capacity: capacity,
    alignment: MemoryLayout<T>.alignment
  ) { pointer in
    Builtin.bindMemory(pointer, capacity._builtinWordValue, type)
    let buffer = UnsafeMutableBufferPointer<T>(
      start: .init(pointer),
      count: capacity
    )
    return try body(buffer)
  }
}
#endif
@frozen public struct _UIntBuffer<Element> where Element : Swift.FixedWidthInteger, Element : Swift.UnsignedInteger {
  public typealias Storage = Swift.UInt32
  public var _storage: Swift._UIntBuffer<Element>.Storage
  public var _bitCount: Swift.UInt8
  @inlinable @inline(__always) public init(_storage: Swift._UIntBuffer<Element>.Storage, _bitCount: Swift.UInt8) {
    self._storage = _storage
    self._bitCount = _bitCount
  }
  @inlinable @inline(__always) public init(containing e: Element) {
    _storage = Storage(truncatingIfNeeded: e)
    _bitCount = UInt8(truncatingIfNeeded: Element.bitWidth)
  }
}
extension Swift._UIntBuffer : Swift.Sendable where Element : Swift.Sendable {
}
extension Swift._UIntBuffer : Swift.Sequence {
  public typealias SubSequence = Swift.Slice<Swift._UIntBuffer<Element>>
  @frozen public struct Iterator : Swift.IteratorProtocol, Swift.Sequence {
    public var _impl: Swift._UIntBuffer<Element>
    @inlinable @inline(__always) public init(_ x: Swift._UIntBuffer<Element>) { _impl = x }
    @inlinable @inline(__always) public mutating func next() -> Element? {
      if _impl._bitCount == 0 { return nil }
      defer {
        _impl._storage = _impl._storage &>> Element.bitWidth
        _impl._bitCount = _impl._bitCount &- _impl._elementWidth
      }
      return Element(truncatingIfNeeded: _impl._storage)
    }
    public typealias Iterator = Swift._UIntBuffer<Element>.Iterator
  }
  @inlinable @inline(__always) public func makeIterator() -> Swift._UIntBuffer<Element>.Iterator {
    return Iterator(self)
  }
}
extension Swift._UIntBuffer.Iterator : Swift.Sendable where Element : Swift.Sendable {
}
extension Swift._UIntBuffer : Swift.Collection {
  @frozen public struct Index : Swift.Comparable {
    @usableFromInline
    internal var bitOffset: Swift.UInt8
    @inlinable internal init(bitOffset: Swift.UInt8) { self.bitOffset = bitOffset }
    @inlinable public static func == (lhs: Swift._UIntBuffer<Element>.Index, rhs: Swift._UIntBuffer<Element>.Index) -> Swift.Bool {
      return lhs.bitOffset == rhs.bitOffset
    }
    @inlinable public static func < (lhs: Swift._UIntBuffer<Element>.Index, rhs: Swift._UIntBuffer<Element>.Index) -> Swift.Bool {
      return lhs.bitOffset < rhs.bitOffset
    }
  }
  @inlinable public var startIndex: Swift._UIntBuffer<Element>.Index {
    @inline(__always) get { return Index(bitOffset: 0) }
  }
  @inlinable public var endIndex: Swift._UIntBuffer<Element>.Index {
    @inline(__always) get { return Index(bitOffset: _bitCount) }
  }
  @inlinable @inline(__always) public func index(after i: Swift._UIntBuffer<Element>.Index) -> Swift._UIntBuffer<Element>.Index {
    return Index(bitOffset: i.bitOffset &+ _elementWidth)
  }
  @inlinable internal var _elementWidth: Swift.UInt8 {
    get {
    return UInt8(truncatingIfNeeded: Element.bitWidth)
  }
  }
  @inlinable public subscript(i: Swift._UIntBuffer<Element>.Index) -> Element {
    @inline(__always) get {
      return Element(truncatingIfNeeded: _storage &>> i.bitOffset)
    }
  }
}
extension Swift._UIntBuffer : Swift.BidirectionalCollection {
  @inlinable @inline(__always) public func index(before i: Swift._UIntBuffer<Element>.Index) -> Swift._UIntBuffer<Element>.Index {
    return Index(bitOffset: i.bitOffset &- _elementWidth)
  }
}
extension Swift._UIntBuffer : Swift.RandomAccessCollection {
  public typealias Indices = Swift.DefaultIndices<Swift._UIntBuffer<Element>>
  @inlinable @inline(__always) public func index(_ i: Swift._UIntBuffer<Element>.Index, offsetBy n: Swift.Int) -> Swift._UIntBuffer<Element>.Index {
    let x = Int(i.bitOffset) &+ n &* Element.bitWidth
    return Index(bitOffset: UInt8(truncatingIfNeeded: x))
  }
  @inlinable @inline(__always) public func distance(from i: Swift._UIntBuffer<Element>.Index, to j: Swift._UIntBuffer<Element>.Index) -> Swift.Int {
    return (Int(j.bitOffset) &- Int(i.bitOffset)) / Element.bitWidth
  }
}
extension Swift.FixedWidthInteger {
  @inline(__always) @inlinable internal func _fullShiftLeft<N>(_ n: N) -> Self where N : Swift.FixedWidthInteger {
    return (self &<< ((n &+ 1) &>> 1)) &<< (n &>> 1)
  }
  @inline(__always) @inlinable internal func _fullShiftRight<N>(_ n: N) -> Self where N : Swift.FixedWidthInteger {
    return (self &>> ((n &+ 1) &>> 1)) &>> (n &>> 1)
  }
  @inline(__always) @inlinable internal static func _lowBits<N>(_ n: N) -> Self where N : Swift.FixedWidthInteger {
    return ~((~0 as Self)._fullShiftLeft(n))
  }
}
extension Swift.Range {
  @inline(__always) @inlinable internal func _contains_(_ other: Swift.Range<Bound>) -> Swift.Bool {
    return other.clamped(to: self) == other
  }
}
extension Swift._UIntBuffer : Swift.RangeReplaceableCollection {
  @inlinable @inline(__always) public init() {
    _storage = 0
    _bitCount = 0
  }
  @inlinable public var capacity: Swift.Int {
    get {
    return Storage.bitWidth / Element.bitWidth
  }
  }
  @inlinable @inline(__always) public mutating func append(_ newElement: Element) {
    _debugPrecondition(count + 1 <= capacity)
    _storage &= ~(Storage(Element.max) &<< _bitCount)
    _storage |= Storage(newElement) &<< _bitCount
    _bitCount = _bitCount &+ _elementWidth
  }
  @discardableResult
  @inlinable @inline(__always) public mutating func removeFirst() -> Element {
    _debugPrecondition(!isEmpty)
    let result = Element(truncatingIfNeeded: _storage)
    _bitCount = _bitCount &- _elementWidth
    _storage = _storage._fullShiftRight(_elementWidth)
    return result
  }
  @inlinable @inline(__always) public mutating func replaceSubrange<C>(_ target: Swift.Range<Swift._UIntBuffer<Element>.Index>, with replacement: C) where Element == C.Element, C : Swift.Collection {
    _debugPrecondition(
      (0..<_bitCount)._contains_(
        target.lowerBound.bitOffset..<target.upperBound.bitOffset))
    
    let replacement1 = _UIntBuffer(replacement)

    let targetCount = distance(
      from: target.lowerBound, to: target.upperBound)
    let growth = replacement1.count &- targetCount
    _debugPrecondition(count + growth <= capacity)

    let headCount = distance(from: startIndex, to: target.lowerBound)
    let tailOffset = distance(from: startIndex, to: target.upperBound)

    let w = Element.bitWidth
    let headBits = _storage & ._lowBits(headCount &* w)
    let tailBits = _storage._fullShiftRight(tailOffset &* w)

    _storage = headBits
    _storage |= replacement1._storage &<< (headCount &* w)
    _storage |= tailBits &<< ((tailOffset &+ growth) &* w)
    _bitCount = UInt8(
      truncatingIfNeeded: Int(_bitCount) &+ growth &* w)
  }
}
extension Swift.String {
  @available(*, unavailable, message: "cannot subscript String with an Int, use a String.Index instead.")
  public subscript(i: Swift.Int) -> Swift.Character {
    get
  }
  @available(*, unavailable, message: "cannot subscript String with an integer range, use a String.Index range instead.")
  public subscript<R>(bounds: R) -> Swift.String where R : Swift.RangeExpression, R.Bound == Swift.Int {
    get
  }
}
public protocol _UnicodeEncoding {
  associatedtype CodeUnit : Swift.FixedWidthInteger, Swift.UnsignedInteger where Self.CodeUnit == Self.EncodedScalar.Element
  associatedtype EncodedScalar : Swift.BidirectionalCollection
  static var encodedReplacementCharacter: Self.EncodedScalar { get }
  static func decode(_ content: Self.EncodedScalar) -> Swift.Unicode.Scalar
  static func encode(_ content: Swift.Unicode.Scalar) -> Self.EncodedScalar?
  static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Self.EncodedScalar? where FromEncoding : Swift._UnicodeEncoding
  associatedtype ForwardParser : Swift._UnicodeParser where Self == Self.ForwardParser.Encoding, Self.ForwardParser.Encoding == Self.ReverseParser.Encoding
  associatedtype ReverseParser : Swift._UnicodeParser
  static func _isScalar(_ x: Self.CodeUnit) -> Swift.Bool
}
extension Swift._UnicodeEncoding {
  @inlinable public static func _isScalar(_ x: Self.CodeUnit) -> Swift.Bool { return false }
  @inlinable public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Self.EncodedScalar? where FromEncoding : Swift._UnicodeEncoding {
    return encode(FromEncoding.decode(content))
  }
  @inlinable internal static func _encode(_ content: Swift.Unicode.Scalar) -> Self.EncodedScalar {
    return encode(content) ?? encodedReplacementCharacter
  }
  @inlinable internal static func _transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Self.EncodedScalar where FromEncoding : Swift._UnicodeEncoding {
    return transcode(content, from: FromEncoding.self)
      ?? encodedReplacementCharacter
  }
  @inlinable internal static func _transcode<Source, SourceEncoding>(_ source: Source, from sourceEncoding: SourceEncoding.Type, into processScalar: (Self.EncodedScalar) -> Swift.Void) where Source : Swift.Sequence, SourceEncoding : Swift._UnicodeEncoding, Source.Element == SourceEncoding.CodeUnit {
    var p = SourceEncoding.ForwardParser()
    var i = source.makeIterator()
    while true {
      switch p.parseScalar(from: &i) {
      case .valid(let e): processScalar(_transcode(e, from: sourceEncoding))
      case .error(_): processScalar(encodedReplacementCharacter)
      case .emptyInput: return
      }
    }
  }
}
extension Swift.Unicode {
  public typealias Encoding = Swift._UnicodeEncoding
}
@inlinable @inline(__always) internal func _decodeUTF8(_ x: Swift.UInt8) -> Swift.Unicode.Scalar {
  _internalInvariant(UTF8.isASCII(x))
  return Unicode.Scalar(_unchecked: UInt32(x))
}
@inlinable @inline(__always) internal func _decodeUTF8(_ x: Swift.UInt8, _ y: Swift.UInt8) -> Swift.Unicode.Scalar {
  _internalInvariant(_utf8ScalarLength(x) == 2)
  _internalInvariant(UTF8.isContinuation(y))
  let x = UInt32(x)
  let value = ((x & 0b0001_1111) &<< 6) | _continuationPayload(y)
  return Unicode.Scalar(_unchecked: value)
}
@inlinable @inline(__always) internal func _decodeUTF8(_ x: Swift.UInt8, _ y: Swift.UInt8, _ z: Swift.UInt8) -> Swift.Unicode.Scalar {
  _internalInvariant(_utf8ScalarLength(x) == 3)
  _internalInvariant(UTF8.isContinuation(y) && UTF8.isContinuation(z))
  let x = UInt32(x)
  let value = ((x & 0b0000_1111) &<< 12)
            | (_continuationPayload(y) &<< 6)
            | _continuationPayload(z)
  return Unicode.Scalar(_unchecked: value)
}
@inlinable @inline(__always) internal func _decodeUTF8(_ x: Swift.UInt8, _ y: Swift.UInt8, _ z: Swift.UInt8, _ w: Swift.UInt8) -> Swift.Unicode.Scalar {
  _internalInvariant(_utf8ScalarLength(x) == 4)
  _internalInvariant(
    UTF8.isContinuation(y) && UTF8.isContinuation(z)
    && UTF8.isContinuation(w))
  let x = UInt32(x)
  let value = ((x & 0b0000_1111) &<< 18)
            | (_continuationPayload(y) &<< 12)
            | (_continuationPayload(z) &<< 6)
            | _continuationPayload(w)
  return Unicode.Scalar(_unchecked: value)
}
@inlinable internal func _decodeScalar(_ utf8: Swift.UnsafeBufferPointer<Swift.UInt8>, startingAt i: Swift.Int) -> (Swift.Unicode.Scalar, scalarLength: Swift.Int) {
  let cu0 = utf8[_unchecked: i]
  let len = _utf8ScalarLength(cu0)
  switch  len {
  case 1: return (_decodeUTF8(cu0), len)
  case 2: return (_decodeUTF8(cu0, utf8[_unchecked: i &+ 1]), len)
  case 3: return (_decodeUTF8(
    cu0, utf8[_unchecked: i &+ 1], utf8[_unchecked: i &+ 2]), len)
  case 4:
    return (_decodeUTF8(
      cu0,
      utf8[_unchecked: i &+ 1],
      utf8[_unchecked: i &+ 2],
      utf8[_unchecked: i &+ 3]),
    len)
  default: Builtin.unreachable()
  }
}
@inlinable internal func _decodeScalar(_ utf8: Swift.UnsafeBufferPointer<Swift.UInt8>, endingAt i: Swift.Int) -> (Swift.Unicode.Scalar, scalarLength: Swift.Int) {
  let len = _utf8ScalarLength(utf8, endingAt: i)
  let (scalar, scalarLen) = _decodeScalar(utf8, startingAt: i &- len)
  _internalInvariant(len == scalarLen)
  return (scalar, len)
}
@inlinable @inline(__always) internal func _utf8ScalarLength(_ x: Swift.UInt8) -> Swift.Int {
  _internalInvariant(!UTF8.isContinuation(x))
  if UTF8.isASCII(x) { return 1 }
   
  return (~x).leadingZeroBitCount
}
@inlinable @inline(__always) internal func _utf8ScalarLength(_ utf8: Swift.UnsafeBufferPointer<Swift.UInt8>, endingAt i: Swift.Int) -> Swift.Int {
  var len = 1
  while UTF8.isContinuation(utf8[_unchecked: i &- len]) {
    len &+= 1
  }
  _internalInvariant(len == _utf8ScalarLength(utf8[i &- len]))
  return len
}
@inlinable @inline(__always) internal func _continuationPayload(_ x: Swift.UInt8) -> Swift.UInt32 {
  return UInt32(x & 0x3F)
}
@inlinable internal func _scalarAlign(_ utf8: Swift.UnsafeBufferPointer<Swift.UInt8>, _ idx: Swift.Int) -> Swift.Int {
  guard _fastPath(idx != utf8.count) else { return idx }

  var i = idx
  while _slowPath(UTF8.isContinuation(utf8[_unchecked: i])) {
    i &-= 1
    _internalInvariant(i >= 0,
      "Malformed contents: starts with continuation byte")
  }
  return i
}
extension Swift._StringGuts {
  @inlinable @inline(__always) internal func scalarAlign(_ idx: Swift._StringGuts.Index) -> Swift._StringGuts.Index {
    let result: String.Index
    if _fastPath(idx._isScalarAligned) {
      result = idx
    } else {
       
      result = scalarAlignSlow(idx)._scalarAligned._copyingEncoding(from: idx)
    }

    _internalInvariant(isOnUnicodeScalarBoundary(result),
      "Alignment bit is set for non-aligned index")
    _internalInvariant_5_1(result._isScalarAligned)
    return result
  }
  @inline(never) @_alwaysEmitIntoClient @_effects(releasenone) internal func scalarAlignSlow(_ idx: Swift._StringGuts.Index) -> Swift._StringGuts.Index {
    _internalInvariant_5_1(!idx._isScalarAligned)

    if _slowPath(idx.transcodedOffset != 0 || idx._encodedOffset == 0) {
       
      return String.Index(_encodedOffset: idx._encodedOffset)
    }
    if _slowPath(self.isForeign) {
       
       
       
       
       
      guard idx._encodedOffset != self.count else { return idx }

      let foreignIdx = foreignScalarAlign(idx)
      _internalInvariant_5_1(foreignIdx._isScalarAligned)
      return foreignIdx
    }

    return String.Index(_encodedOffset:
      self.withFastUTF8 { _scalarAlign($0, idx._encodedOffset) }
    )
  }
  @inlinable internal func fastUTF8ScalarLength(startingAt i: Swift.Int) -> Swift.Int {
    _internalInvariant(isFastUTF8)
    let len = _utf8ScalarLength(self.withFastUTF8 { $0[_unchecked: i] })
    _internalInvariant((1...4) ~= len)
    return len
  }
  @inlinable internal func fastUTF8ScalarLength(endingAt i: Swift.Int) -> Swift.Int {
    _internalInvariant(isFastUTF8)

    return self.withFastUTF8 { utf8 in
      _internalInvariant(i == utf8.count || !UTF8.isContinuation(utf8[i]))
      var len = 1
      while UTF8.isContinuation(utf8[i &- len]) {
        _internalInvariant(i &- len > 0)
        len += 1
      }
      _internalInvariant(len <= 4)
      return len
    }
  }
  @inlinable internal func fastUTF8Scalar(startingAt i: Swift.Int) -> Swift.Unicode.Scalar {
    _internalInvariant(isFastUTF8)
    return self.withFastUTF8 { _decodeScalar($0, startingAt: i).0 }
  }
  @_alwaysEmitIntoClient @inline(__always) internal func isOnUnicodeScalarBoundary(_ offset: Swift.Int) -> Swift.Bool {
    isOnUnicodeScalarBoundary(String.Index(_encodedOffset: offset))
  }
  @usableFromInline
  @_effects(releasenone) internal func isOnUnicodeScalarBoundary(_ i: Swift.String.Index) -> Swift.Bool
}
extension Swift._StringGuts {
  @usableFromInline
  @_effects(releasenone) internal func foreignErrorCorrectedScalar(startingAt idx: Swift.String.Index) -> (Swift.Unicode.Scalar, scalarLength: Swift.Int)
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func foreignScalarAlign(_ idx: Swift._StringGuts.Index) -> Swift._StringGuts.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func foreignErrorCorrectedGrapheme(startingAt start: Swift.Int, endingAt end: Swift.Int) -> Swift.Character
}
extension Swift._StringGuts {
  @inlinable @inline(__always) internal func errorCorrectedScalar(startingAt i: Swift.Int) -> (Swift.Unicode.Scalar, scalarLength: Swift.Int) {
    if _fastPath(isFastUTF8) {
      return withFastUTF8 { _decodeScalar($0, startingAt: i) }
    }
    return foreignErrorCorrectedScalar(
      startingAt: String.Index(_encodedOffset: i))
  }
  @inlinable @inline(__always) internal func errorCorrectedCharacter(startingAt start: Swift.Int, endingAt end: Swift.Int) -> Swift.Character {
    if _fastPath(isFastUTF8) {
      return withFastUTF8(range: start..<end) { utf8 in
        return Character(unchecked: String._uncheckedFromUTF8(utf8))
      }
    }

    return foreignErrorCorrectedGrapheme(startingAt: start, endingAt: end)
  }
}
extension Swift.Unicode {
  @frozen public enum ParseResult<T> {
    case valid(T)
    case emptyInput
    case error(length: Swift.Int)
    @inlinable internal var _valid: T? {
      get {
      if case .valid(let result) = self { return result }
      return nil
    }
    }
    @inlinable internal var _error: Swift.Int? {
      get {
      if case .error(let result) = self { return result }
      return nil
    }
    }
  }
}
public protocol _UnicodeParser {
  associatedtype Encoding : Swift._UnicodeEncoding
  init()
  mutating func parseScalar<I>(from input: inout I) -> Swift.Unicode.ParseResult<Self.Encoding.EncodedScalar> where I : Swift.IteratorProtocol, I.Element == Self.Encoding.CodeUnit
}
extension Swift.Unicode {
  public typealias Parser = Swift._UnicodeParser
}
extension Swift.Unicode.ParseResult : Swift.Sendable where T : Swift.Sendable {
}
extension Swift.Unicode.Scalar {
  public struct Properties : Swift.Sendable {
    @usableFromInline
    internal var _scalar: Swift.Unicode.Scalar
  }
  public var properties: Swift.Unicode.Scalar.Properties {
    get
  }
}
extension Swift.Unicode.Scalar.Properties {
  public var isAlphabetic: Swift.Bool {
    get
  }
  public var isASCIIHexDigit: Swift.Bool {
    get
  }
  public var isBidiControl: Swift.Bool {
    get
  }
  public var isBidiMirrored: Swift.Bool {
    get
  }
  public var isDash: Swift.Bool {
    get
  }
  public var isDefaultIgnorableCodePoint: Swift.Bool {
    get
  }
  public var isDeprecated: Swift.Bool {
    get
  }
  public var isDiacritic: Swift.Bool {
    get
  }
  public var isExtender: Swift.Bool {
    get
  }
  public var isFullCompositionExclusion: Swift.Bool {
    get
  }
  public var isGraphemeBase: Swift.Bool {
    get
  }
  public var isGraphemeExtend: Swift.Bool {
    get
  }
  public var isHexDigit: Swift.Bool {
    get
  }
  public var isIDContinue: Swift.Bool {
    get
  }
  public var isIDStart: Swift.Bool {
    get
  }
  public var isIdeographic: Swift.Bool {
    get
  }
  public var isIDSBinaryOperator: Swift.Bool {
    get
  }
  public var isIDSTrinaryOperator: Swift.Bool {
    get
  }
  public var isJoinControl: Swift.Bool {
    get
  }
  public var isLogicalOrderException: Swift.Bool {
    get
  }
  public var isLowercase: Swift.Bool {
    get
  }
  public var isMath: Swift.Bool {
    get
  }
  public var isNoncharacterCodePoint: Swift.Bool {
    get
  }
  public var isQuotationMark: Swift.Bool {
    get
  }
  public var isRadical: Swift.Bool {
    get
  }
  public var isSoftDotted: Swift.Bool {
    get
  }
  public var isTerminalPunctuation: Swift.Bool {
    get
  }
  public var isUnifiedIdeograph: Swift.Bool {
    get
  }
  public var isUppercase: Swift.Bool {
    get
  }
  public var isWhitespace: Swift.Bool {
    get
  }
  public var isXIDContinue: Swift.Bool {
    get
  }
  public var isXIDStart: Swift.Bool {
    get
  }
  public var isSentenceTerminal: Swift.Bool {
    get
  }
  public var isVariationSelector: Swift.Bool {
    get
  }
  public var isPatternSyntax: Swift.Bool {
    get
  }
  public var isPatternWhitespace: Swift.Bool {
    get
  }
  public var isCased: Swift.Bool {
    get
  }
  public var isCaseIgnorable: Swift.Bool {
    get
  }
  public var changesWhenLowercased: Swift.Bool {
    get
  }
  public var changesWhenUppercased: Swift.Bool {
    get
  }
  public var changesWhenTitlecased: Swift.Bool {
    get
  }
  public var changesWhenCaseFolded: Swift.Bool {
    get
  }
  public var changesWhenCaseMapped: Swift.Bool {
    get
  }
  public var changesWhenNFKCCaseFolded: Swift.Bool {
    get
  }
  @available(macOS 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
  public var isEmoji: Swift.Bool {
    get
  }
  @available(macOS 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
  public var isEmojiPresentation: Swift.Bool {
    get
  }
  @available(macOS 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
  public var isEmojiModifier: Swift.Bool {
    get
  }
  @available(macOS 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
  public var isEmojiModifierBase: Swift.Bool {
    get
  }
}
extension Swift.Unicode.Scalar.Properties {
  public var lowercaseMapping: Swift.String {
    get
  }
  public var titlecaseMapping: Swift.String {
    get
  }
  public var uppercaseMapping: Swift.String {
    get
  }
}
extension Swift.Unicode {
  public typealias Version = (major: Swift.Int, minor: Swift.Int)
}
extension Swift.Unicode.Scalar.Properties {
  public var age: Swift.Unicode.Version? {
    get
  }
}
extension Swift.Unicode {
  public enum GeneralCategory : Swift.Sendable {
    case uppercaseLetter
    case lowercaseLetter
    case titlecaseLetter
    case modifierLetter
    case otherLetter
    case nonspacingMark
    case spacingMark
    case enclosingMark
    case decimalNumber
    case letterNumber
    case otherNumber
    case connectorPunctuation
    case dashPunctuation
    case openPunctuation
    case closePunctuation
    case initialPunctuation
    case finalPunctuation
    case otherPunctuation
    case mathSymbol
    case currencySymbol
    case modifierSymbol
    case otherSymbol
    case spaceSeparator
    case lineSeparator
    case paragraphSeparator
    case control
    case format
    case surrogate
    case privateUse
    case unassigned
    public static func == (a: Swift.Unicode.GeneralCategory, b: Swift.Unicode.GeneralCategory) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Swift.Unicode.Scalar.Properties {
  public var generalCategory: Swift.Unicode.GeneralCategory {
    get
  }
}
extension Swift.Unicode.Scalar.Properties {
  public var name: Swift.String? {
    get
  }
  public var nameAlias: Swift.String? {
    get
  }
}
extension Swift.Unicode {
  public struct CanonicalCombiningClass : Swift.Comparable, Swift.Hashable, Swift.RawRepresentable, Swift.Sendable {
    public static let notReordered: Swift.Unicode.CanonicalCombiningClass
    public static let overlay: Swift.Unicode.CanonicalCombiningClass
    public static let nukta: Swift.Unicode.CanonicalCombiningClass
    public static let kanaVoicing: Swift.Unicode.CanonicalCombiningClass
    public static let virama: Swift.Unicode.CanonicalCombiningClass
    public static let attachedBelowLeft: Swift.Unicode.CanonicalCombiningClass
    public static let attachedBelow: Swift.Unicode.CanonicalCombiningClass
    public static let attachedAbove: Swift.Unicode.CanonicalCombiningClass
    public static let attachedAboveRight: Swift.Unicode.CanonicalCombiningClass
    public static let belowLeft: Swift.Unicode.CanonicalCombiningClass
    public static let below: Swift.Unicode.CanonicalCombiningClass
    public static let belowRight: Swift.Unicode.CanonicalCombiningClass
    public static let left: Swift.Unicode.CanonicalCombiningClass
    public static let right: Swift.Unicode.CanonicalCombiningClass
    public static let aboveLeft: Swift.Unicode.CanonicalCombiningClass
    public static let above: Swift.Unicode.CanonicalCombiningClass
    public static let aboveRight: Swift.Unicode.CanonicalCombiningClass
    public static let doubleBelow: Swift.Unicode.CanonicalCombiningClass
    public static let doubleAbove: Swift.Unicode.CanonicalCombiningClass
    public static let iotaSubscript: Swift.Unicode.CanonicalCombiningClass
    public let rawValue: Swift.UInt8
    public init(rawValue: Swift.UInt8)
    public static func == (lhs: Swift.Unicode.CanonicalCombiningClass, rhs: Swift.Unicode.CanonicalCombiningClass) -> Swift.Bool
    public static func < (lhs: Swift.Unicode.CanonicalCombiningClass, rhs: Swift.Unicode.CanonicalCombiningClass) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public typealias RawValue = Swift.UInt8
  }
}
extension Swift.Unicode.Scalar.Properties {
  public var canonicalCombiningClass: Swift.Unicode.CanonicalCombiningClass {
    get
  }
}
extension Swift.Unicode {
  public enum NumericType : Swift.Sendable {
    case decimal
    case digit
    case numeric
    public static func == (a: Swift.Unicode.NumericType, b: Swift.Unicode.NumericType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Swift.Unicode.Scalar.Properties {
  public var numericType: Swift.Unicode.NumericType? {
    get
  }
  public var numericValue: Swift.Double? {
    get
  }
}
extension Swift.Character {
  @inlinable internal var _firstScalar: Swift.Unicode.Scalar {
    get {
    return self.unicodeScalars.first!
  }
  }
  @inlinable internal var _isSingleScalar: Swift.Bool {
    get {
    return self.unicodeScalars.index(
      after: self.unicodeScalars.startIndex
    ) == self.unicodeScalars.endIndex
  }
  }
  @inlinable public var isASCII: Swift.Bool {
    get {
    return asciiValue != nil
  }
  }
  @inlinable public var asciiValue: Swift.UInt8? {
    get {
    if _slowPath(self == "\r\n") { return 0x000A   }
    if _slowPath(!_isSingleScalar || _firstScalar.value >= 0x80) { return nil }
    return UInt8(_firstScalar.value)
  }
  }
  public var isWhitespace: Swift.Bool {
    get
  }
  @inlinable public var isNewline: Swift.Bool {
    get {
    switch _firstScalar.value {
      case 0x000A...0x000D  : return true
      case 0x0085  : return true
      case 0x2028  : return true
      case 0x2029  : return true
      default: return false
    }
  }
  }
  public var isNumber: Swift.Bool {
    get
  }
  @inlinable public var isWholeNumber: Swift.Bool {
    get {
    return wholeNumberValue != nil
  }
  }
  public var wholeNumberValue: Swift.Int? {
    get
  }
  @inlinable public var isHexDigit: Swift.Bool {
    get {
    return hexDigitValue != nil
  }
  }
  public var hexDigitValue: Swift.Int? {
    get
  }
  public var isLetter: Swift.Bool {
    get
  }
  public func uppercased() -> Swift.String
  public func lowercased() -> Swift.String
  @usableFromInline
  internal var _isUppercased: Swift.Bool {
    get
  }
  @usableFromInline
  internal var _isLowercased: Swift.Bool {
    get
  }
  @inlinable public var isUppercase: Swift.Bool {
    get {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isUppercase) {
      return true
    }
    return _isUppercased && isCased
  }
  }
  @inlinable public var isLowercase: Swift.Bool {
    get {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isLowercase) {
      return true
    }
    return _isLowercased && isCased
  }
  }
  @inlinable public var isCased: Swift.Bool {
    get {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isCased) {
      return true
    }
    return !_isUppercased || !_isLowercased
  }
  }
  public var isSymbol: Swift.Bool {
    get
  }
  public var isMathSymbol: Swift.Bool {
    get
  }
  public var isCurrencySymbol: Swift.Bool {
    get
  }
  public var isPunctuation: Swift.Bool {
    get
  }
}
@frozen public struct Unmanaged<Instance> where Instance : AnyObject {
  @usableFromInline
  unowned(unsafe) internal var _value: Instance
  @usableFromInline
  @_transparent internal init(_private: Instance) { _value = _private }
  @_transparent public static func fromOpaque(@_nonEphemeral _ value: Swift.UnsafeRawPointer) -> Swift.Unmanaged<Instance> {
      
     
     
     
     
     
     
     
    unsafeBitCast(value, to: Unmanaged<Instance>.self)
  }
  @_transparent public func toOpaque() -> Swift.UnsafeMutableRawPointer {
     
     
     
     
     
     
    unsafeBitCast(self, to: UnsafeMutableRawPointer.self)
  }
  @_transparent public static func passRetained(_ value: Instance) -> Swift.Unmanaged<Instance> {
     
    Builtin.retain(value)
    return Unmanaged(_private: value)
  }
  @_transparent public static func passUnretained(_ value: Instance) -> Swift.Unmanaged<Instance> {
    return Unmanaged(_private: value)
  }
  @_transparent public func takeUnretainedValue() -> Instance {
    return _value
  }
  @_transparent public func takeRetainedValue() -> Instance {
    let result = _value
    release()
    return result
  }
  @inlinable @_transparent public func _withUnsafeGuaranteedRef<Result>(_ body: (Instance) throws -> Result) rethrows -> Result {
    var tmp = self
     
     
     
     
     
    let fakeBase: Int? = nil
    return try body(Builtin.convertUnownedUnsafeToGuaranteed(fakeBase,
                                                             &tmp._value))
  }
  @_transparent public func retain() -> Swift.Unmanaged<Instance> {
    Builtin.retain(_value)
    return self
  }
  @_transparent public func release() {
    Builtin.release(_value)
  }
  @_transparent public func autorelease() -> Swift.Unmanaged<Instance> {
    Builtin.autorelease(_value)
    return self
  }
}
extension Swift.Unmanaged : Swift.Sendable where Instance : Swift.Sendable {
}
#if compiler(>=5.3) && $NoncopyableGenerics
@frozen public struct UnsafePointer<Pointee> : Swift.Copyable where Pointee : ~Copyable {
  @_preInverseGenerics public let _rawValue: Builtin.RawPointer
  @_transparent @_preInverseGenerics public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}
#else
@frozen public struct UnsafePointer<Pointee> {
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(*, unavailable)
extension Swift.UnsafePointer : Swift.Sendable where Pointee : ~Copyable {
}
#else
@available(*, unavailable)
extension Swift.UnsafePointer : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafePointer : Swift._Pointer where Pointee : ~Copyable {
  public typealias Distance = Swift.Int
}
#else
extension Swift.UnsafePointer : Swift._Pointer {
  public typealias Distance = Swift.Int
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafePointer : Swift.Equatable where Pointee : ~Copyable {
}
#else
extension Swift.UnsafePointer : Swift.Equatable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafePointer : Swift.Hashable where Pointee : ~Copyable {
  @_preInverseGenerics public var hashValue: Swift.Int {
    get
  }
}
#else
extension Swift.UnsafePointer : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafePointer : Swift.Comparable where Pointee : ~Copyable {
}
#else
extension Swift.UnsafePointer : Swift.Comparable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafePointer : Swift.Strideable where Pointee : ~Copyable {
  public typealias Stride = Swift.Int
}
#else
extension Swift.UnsafePointer : Swift.Strideable {
  public typealias Stride = Swift.Int
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafePointer : Swift.CustomDebugStringConvertible where Pointee : ~Copyable {
}
#else
extension Swift.UnsafePointer : Swift.CustomDebugStringConvertible {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafePointer : Swift.CustomReflectable where Pointee : ~Copyable {
}
#else
extension Swift.UnsafePointer : Swift.CustomReflectable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafePointer where Pointee : ~Copyable {
  @inlinable @_preInverseGenerics public func deallocate() {
     
     
     
     
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
}
#else
extension Swift.UnsafePointer {
  @inlinable public func deallocate() {
     
     
     
     
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafePointer where Pointee : ~Copyable {
  @_alwaysEmitIntoClient public var pointee: Pointee {
    @_transparent unsafeAddress {
      return self
    }
  }
}
#else
extension Swift.UnsafePointer {
  @_alwaysEmitIntoClient public var pointee: Pointee {
    @_transparent unsafeAddress {
      return self
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafePointer where Pointee : ~Copyable {
  @_alwaysEmitIntoClient public subscript(i: Swift.Int) -> Pointee {
    @_transparent unsafeAddress {
      return self + i
    }
  }
}
#else
extension Swift.UnsafePointer {
  @_alwaysEmitIntoClient public subscript(i: Swift.Int) -> Pointee {
    @_transparent unsafeAddress {
      return self + i
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafePointer where Pointee : ~Copyable {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, capacity count: Swift.Int, _ body: (_ pointer: Swift.UnsafePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
    _debugPrecondition(
      Int(bitPattern: .init(_rawValue)) & (MemoryLayout<T>.alignment-1) == 0 &&
      ( count == 1 ||
        ( MemoryLayout<Pointee>.stride > MemoryLayout<T>.stride
          ? MemoryLayout<Pointee>.stride % MemoryLayout<T>.stride == 0
          : MemoryLayout<T>.stride % MemoryLayout<Pointee>.stride == 0
        )
      ),
      "self must be a properly aligned pointer for types Pointee and T"
    )
    let binding = Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(_rawValue, binding) }
    return try body(.init(_rawValue))
  }
  #endif
}
#else
extension Swift.UnsafePointer {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, capacity count: Swift.Int, _ body: (_ pointer: Swift.UnsafePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
    _debugPrecondition(
      Int(bitPattern: .init(_rawValue)) & (MemoryLayout<T>.alignment-1) == 0 &&
      ( count == 1 ||
        ( MemoryLayout<Pointee>.stride > MemoryLayout<T>.stride
          ? MemoryLayout<Pointee>.stride % MemoryLayout<T>.stride == 0
          : MemoryLayout<T>.stride % MemoryLayout<Pointee>.stride == 0
        )
      ),
      "self must be a properly aligned pointer for types Pointee and T"
    )
    let binding = Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(_rawValue, binding) }
    return try body(.init(_rawValue))
  }
  #endif
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafePointer {
  @_alwaysEmitIntoClient public func pointer<Property>(to property: Swift.KeyPath<Pointee, Property>) -> Swift.UnsafePointer<Property>? {
    guard let o = property._storedInlineOffset else { return nil }
    _internalInvariant(o >= 0)
    _debugPrecondition(
      o == 0 || UnsafeRawPointer(self) < UnsafeRawPointer(bitPattern: 0 &- o)!,
      "Overflow in pointer arithmetic"
    )
    return .init(Builtin.gepRaw_Word(_rawValue, o._builtinWordValue))
  }
}
#else
extension Swift.UnsafePointer {
  @_alwaysEmitIntoClient public func pointer<Property>(to property: Swift.KeyPath<Pointee, Property>) -> Swift.UnsafePointer<Property>? {
    guard let o = property._storedInlineOffset else { return nil }
    _internalInvariant(o >= 0)
    _debugPrecondition(
      o == 0 || UnsafeRawPointer(self) < UnsafeRawPointer(bitPattern: 0 &- o)!,
      "Overflow in pointer arithmetic"
    )
    return .init(Builtin.gepRaw_Word(_rawValue, o._builtinWordValue))
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafePointer where Pointee : ~Copyable {
  @inlinable @_preInverseGenerics internal static var _max: Swift.UnsafePointer<Pointee> {
    get {
    return UnsafePointer(
      bitPattern: 0 as Int &- MemoryLayout<Pointee>.stride
    )._unsafelyUnwrappedUnchecked
  }
  }
}
#else
extension Swift.UnsafePointer {
  @inlinable internal static var _max: Swift.UnsafePointer<Pointee> {
    get {
    return UnsafePointer(
      bitPattern: 0 as Int &- MemoryLayout<Pointee>.stride
    )._unsafelyUnwrappedUnchecked
  }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@frozen public struct UnsafeMutablePointer<Pointee> : Swift.Copyable where Pointee : ~Copyable {
  @_preInverseGenerics public let _rawValue: Builtin.RawPointer
  @_transparent @_preInverseGenerics public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}
#else
@frozen public struct UnsafeMutablePointer<Pointee> {
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(*, unavailable)
extension Swift.UnsafeMutablePointer : Swift.Sendable where Pointee : ~Copyable {
}
#else
@available(*, unavailable)
extension Swift.UnsafeMutablePointer : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafeMutablePointer : Swift._Pointer where Pointee : ~Copyable {
  public typealias Distance = Swift.Int
}
#else
extension Swift.UnsafeMutablePointer : Swift._Pointer {
  public typealias Distance = Swift.Int
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafeMutablePointer : Swift.Equatable where Pointee : ~Copyable {
}
#else
extension Swift.UnsafeMutablePointer : Swift.Equatable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafeMutablePointer : Swift.Hashable where Pointee : ~Copyable {
  @_preInverseGenerics public var hashValue: Swift.Int {
    get
  }
}
#else
extension Swift.UnsafeMutablePointer : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafeMutablePointer : Swift.Comparable where Pointee : ~Copyable {
}
#else
extension Swift.UnsafeMutablePointer : Swift.Comparable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafeMutablePointer : Swift.Strideable where Pointee : ~Copyable {
  public typealias Stride = Swift.Int
}
#else
extension Swift.UnsafeMutablePointer : Swift.Strideable {
  public typealias Stride = Swift.Int
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafeMutablePointer : Swift.CustomDebugStringConvertible where Pointee : ~Copyable {
}
#else
extension Swift.UnsafeMutablePointer : Swift.CustomDebugStringConvertible {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafeMutablePointer : Swift.CustomReflectable where Pointee : ~Copyable {
}
#else
extension Swift.UnsafeMutablePointer : Swift.CustomReflectable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee : ~Copyable {
  @_transparent @_preInverseGenerics public init(@_nonEphemeral mutating other: Swift.UnsafePointer<Pointee>) {
    self._rawValue = other._rawValue
  }
  @_transparent @_preInverseGenerics public init?(@_nonEphemeral mutating other: Swift.UnsafePointer<Pointee>?) {
    guard let unwrapped = other else { return nil }
    self.init(mutating: unwrapped)
  }
  @_transparent @_preInverseGenerics public init(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<Pointee>) {
   self._rawValue = other._rawValue
  }
  @_transparent @_preInverseGenerics public init?(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<Pointee>?) {
   guard let unwrapped = other else { return nil }
   self.init(unwrapped)
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @_transparent public init(@_nonEphemeral mutating other: Swift.UnsafePointer<Pointee>) {
    self._rawValue = other._rawValue
  }
  @_transparent public init?(@_nonEphemeral mutating other: Swift.UnsafePointer<Pointee>?) {
    guard let unwrapped = other else { return nil }
    self.init(mutating: unwrapped)
  }
  @_transparent public init(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<Pointee>) {
   self._rawValue = other._rawValue
  }
  @_transparent public init?(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<Pointee>?) {
   guard let unwrapped = other else { return nil }
   self.init(unwrapped)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee : ~Copyable {
  @inlinable @_preInverseGenerics public static func allocate(capacity count: Swift.Int) -> Swift.UnsafeMutablePointer<Pointee> {
    let size = MemoryLayout<Pointee>.stride * count
     
     
     
     
     
     
     
     
     
     
     
    var align = Builtin.alignof(Pointee.self)
    if Int(align) <= _minAllocationAlignment() {
      align = (0)._builtinWordValue
    }
    let rawPtr = Builtin.allocRaw(size._builtinWordValue, align)
    Builtin.bindMemory(rawPtr, count._builtinWordValue, Pointee.self)
    return UnsafeMutablePointer(rawPtr)
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @inlinable public static func allocate(capacity count: Swift.Int) -> Swift.UnsafeMutablePointer<Pointee> {
    let size = MemoryLayout<Pointee>.stride * count
     
     
     
     
     
     
     
     
     
     
     
    var align = Builtin.alignof(Pointee.self)
    if Int(align) <= _minAllocationAlignment() {
      align = (0)._builtinWordValue
    }
    let rawPtr = Builtin.allocRaw(size._builtinWordValue, align)
    Builtin.bindMemory(rawPtr, count._builtinWordValue, Pointee.self)
    return UnsafeMutablePointer(rawPtr)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee : ~Copyable {
  @inlinable @_preInverseGenerics public func deallocate() {
     
     
     
     
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @inlinable public func deallocate() {
     
     
     
     
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee : ~Copyable {
  @_alwaysEmitIntoClient public var pointee: Pointee {
    @_transparent unsafeAddress {
      return UnsafePointer(self)
    }
    @_transparent nonmutating unsafeMutableAddress {
      return self
    }
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @_alwaysEmitIntoClient public var pointee: Pointee {
    @_transparent unsafeAddress {
      return UnsafePointer(self)
    }
    @_transparent nonmutating unsafeMutableAddress {
      return self
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer {
  @inlinable public func initialize(repeating repeatedValue: Pointee, count: Swift.Int) {
     
    _debugPrecondition(count >= 0,
      "UnsafeMutablePointer.initialize(repeating:count:): negative count")
     
     
    for offset in 0..<count {
      Builtin.initialize(repeatedValue, (self + offset)._rawValue)
    }
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @inlinable public func initialize(repeating repeatedValue: Pointee, count: Swift.Int) {
     
    _debugPrecondition(count >= 0,
      "UnsafeMutablePointer.initialize(repeating:count:): negative count")
     
     
    for offset in 0..<count {
      Builtin.initialize(repeatedValue, (self + offset)._rawValue)
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee : ~Copyable {
  @_alwaysEmitIntoClient public func initialize(to value: consuming Pointee) {
    Builtin.initialize(value, self._rawValue)
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @_alwaysEmitIntoClient public func initialize(to value: consuming Pointee) {
    Builtin.initialize(value, self._rawValue)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee : ~Copyable {
  @inlinable @_preInverseGenerics public func move() -> Pointee {
    return Builtin.take(_rawValue)
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @inlinable public func move() -> Pointee {
    return Builtin.take(_rawValue)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer {
  @_silgen_name("$sSp6assign9repeating5countyx_SitF")
  @inlinable public func update(repeating repeatedValue: Pointee, count: Swift.Int) {
    _debugPrecondition(count >= 0, "UnsafeMutablePointer.update(repeating:count:) with negative count")
    for i in 0..<count {
      self[i] = repeatedValue
    }
  }
  @available(*, deprecated, renamed: "update(repeating:count:)")
  @_silgen_name("_swift_se0370_UnsafeMutablePointer_assign_repeating_count")
  @_alwaysEmitIntoClient public func assign(repeating repeatedValue: Pointee, count: Swift.Int) {
    update(repeating: repeatedValue, count: count)
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @_silgen_name("$sSp6assign9repeating5countyx_SitF")
  @inlinable public func update(repeating repeatedValue: Pointee, count: Swift.Int) {
    _debugPrecondition(count >= 0, "UnsafeMutablePointer.update(repeating:count:) with negative count")
    for i in 0..<count {
      self[i] = repeatedValue
    }
  }
  @available(*, deprecated, renamed: "update(repeating:count:)")
  @_silgen_name("_swift_se0370_UnsafeMutablePointer_assign_repeating_count")
  @_alwaysEmitIntoClient public func assign(repeating repeatedValue: Pointee, count: Swift.Int) {
    update(repeating: repeatedValue, count: count)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer {
  @_silgen_name("$sSp6assign4from5countySPyxG_SitF")
  @inlinable public func update(from source: Swift.UnsafePointer<Pointee>, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.update with negative count")
    if UnsafePointer(self) < source || UnsafePointer(self) >= source + count {
       
      Builtin.assignCopyArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
       
       
       
       
    }
    else if UnsafePointer(self) != source {
       
      Builtin.assignCopyArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
       
       
       
       
       
       
    }
  }
  @available(*, deprecated, renamed: "update(from:count:)")
  @_silgen_name("_swift_se0370_UnsafeMutablePointer_assign_from_count")
  @_alwaysEmitIntoClient public func assign(from source: Swift.UnsafePointer<Pointee>, count: Swift.Int) {
    update(from: source, count: count)
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @_silgen_name("$sSp6assign4from5countySPyxG_SitF")
  @inlinable public func update(from source: Swift.UnsafePointer<Pointee>, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.update with negative count")
    if UnsafePointer(self) < source || UnsafePointer(self) >= source + count {
       
      Builtin.assignCopyArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
       
       
       
       
    }
    else if UnsafePointer(self) != source {
       
      Builtin.assignCopyArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
       
       
       
       
       
       
    }
  }
  @available(*, deprecated, renamed: "update(from:count:)")
  @_silgen_name("_swift_se0370_UnsafeMutablePointer_assign_from_count")
  @_alwaysEmitIntoClient public func assign(from source: Swift.UnsafePointer<Pointee>, count: Swift.Int) {
    update(from: source, count: count)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee : ~Copyable {
  @inlinable @_preInverseGenerics public func moveInitialize(@_nonEphemeral from source: Swift.UnsafeMutablePointer<Pointee>, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.moveInitialize with negative count")
    if self < source || self >= source + count {
       
      Builtin.takeArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
       
       
       
       
    }
    else if self != source {
       
      Builtin.takeArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
       
       
       
       
       
       
    }
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @inlinable public func moveInitialize(@_nonEphemeral from source: Swift.UnsafeMutablePointer<Pointee>, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.moveInitialize with negative count")
    if self < source || self >= source + count {
       
      Builtin.takeArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
       
       
       
       
    }
    else if self != source {
       
      Builtin.takeArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
       
       
       
       
       
       
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer {
  @inlinable public func initialize(from source: Swift.UnsafePointer<Pointee>, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.initialize with negative count")
    _debugPrecondition(
      UnsafePointer(self) + count <= source ||
      source + count <= UnsafePointer(self),
      "UnsafeMutablePointer.initialize overlapping range")
    Builtin.copyArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
     
     
     
     
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @inlinable public func initialize(from source: Swift.UnsafePointer<Pointee>, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.initialize with negative count")
    _debugPrecondition(
      UnsafePointer(self) + count <= source ||
      source + count <= UnsafePointer(self),
      "UnsafeMutablePointer.initialize overlapping range")
    Builtin.copyArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
     
     
     
     
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee : ~Copyable {
  @_silgen_name("$sSp10moveAssign4from5countySpyxG_SitF")
  @inlinable @_preInverseGenerics public func moveUpdate(@_nonEphemeral from source: Swift.UnsafeMutablePointer<Pointee>, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.moveUpdate(from:) with negative count")
    _debugPrecondition(
      self + count <= source || source + count <= self,
      "moveUpdate overlapping range")
    Builtin.assignTakeArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
     
     
     
     
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @_silgen_name("$sSp10moveAssign4from5countySpyxG_SitF")
  @inlinable public func moveUpdate(@_nonEphemeral from source: Swift.UnsafeMutablePointer<Pointee>, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.moveUpdate(from:) with negative count")
    _debugPrecondition(
      self + count <= source || source + count <= self,
      "moveUpdate overlapping range")
    Builtin.assignTakeArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
     
     
     
     
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer {
  @available(*, deprecated, renamed: "moveUpdate(from:count:)")
  @_silgen_name("_swift_se0370_UnsafeMutablePointer_moveAssign_from_count")
  @_alwaysEmitIntoClient public func moveAssign(@_nonEphemeral from source: Swift.UnsafeMutablePointer<Pointee>, count: Swift.Int) {
    moveUpdate(from: source, count: count)
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @available(*, deprecated, renamed: "moveUpdate(from:count:)")
  @_silgen_name("_swift_se0370_UnsafeMutablePointer_moveAssign_from_count")
  @_alwaysEmitIntoClient public func moveAssign(@_nonEphemeral from source: Swift.UnsafeMutablePointer<Pointee>, count: Swift.Int) {
    moveUpdate(from: source, count: count)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee : ~Copyable {
  @discardableResult
  @inlinable @_preInverseGenerics public func deinitialize(count: Swift.Int) -> Swift.UnsafeMutableRawPointer {
    _debugPrecondition(count >= 0, "UnsafeMutablePointer.deinitialize with negative count")
     
     
    Builtin.destroyArray(Pointee.self, _rawValue, count._builtinWordValue)
    return UnsafeMutableRawPointer(self)
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @discardableResult
  @inlinable public func deinitialize(count: Swift.Int) -> Swift.UnsafeMutableRawPointer {
    _debugPrecondition(count >= 0, "UnsafeMutablePointer.deinitialize with negative count")
     
     
    Builtin.destroyArray(Pointee.self, _rawValue, count._builtinWordValue)
    return UnsafeMutableRawPointer(self)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee : ~Copyable {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, capacity count: Swift.Int, _ body: (_ pointer: Swift.UnsafeMutablePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
    _debugPrecondition(
      Int(bitPattern: .init(_rawValue)) & (MemoryLayout<T>.alignment-1) == 0 &&
      ( count == 1 ||
        ( MemoryLayout<Pointee>.stride > MemoryLayout<T>.stride
          ? MemoryLayout<Pointee>.stride % MemoryLayout<T>.stride == 0
          : MemoryLayout<T>.stride % MemoryLayout<Pointee>.stride == 0
        )
      ),
      "self must be a properly aligned pointer for types Pointee and T"
    )
    let binding = Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(_rawValue, binding) }
    return try body(.init(_rawValue))
  }
  #endif
}
#else
extension Swift.UnsafeMutablePointer {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, capacity count: Swift.Int, _ body: (_ pointer: Swift.UnsafeMutablePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
    _debugPrecondition(
      Int(bitPattern: .init(_rawValue)) & (MemoryLayout<T>.alignment-1) == 0 &&
      ( count == 1 ||
        ( MemoryLayout<Pointee>.stride > MemoryLayout<T>.stride
          ? MemoryLayout<Pointee>.stride % MemoryLayout<T>.stride == 0
          : MemoryLayout<T>.stride % MemoryLayout<Pointee>.stride == 0
        )
      ),
      "self must be a properly aligned pointer for types Pointee and T"
    )
    let binding = Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(_rawValue, binding) }
    return try body(.init(_rawValue))
  }
  #endif
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee : ~Copyable {
  @_alwaysEmitIntoClient public subscript(i: Swift.Int) -> Pointee {
    @_transparent unsafeAddress {
      return UnsafePointer(self + i)
    }
    @_transparent nonmutating unsafeMutableAddress {
      return self + i
    }
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @_alwaysEmitIntoClient public subscript(i: Swift.Int) -> Pointee {
    @_transparent unsafeAddress {
      return UnsafePointer(self + i)
    }
    @_transparent nonmutating unsafeMutableAddress {
      return self + i
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer {
  @_alwaysEmitIntoClient public func pointer<Property>(to property: Swift.KeyPath<Pointee, Property>) -> Swift.UnsafePointer<Property>? {
    guard let o = property._storedInlineOffset else { return nil }
    _internalInvariant(o >= 0)
    _debugPrecondition(
      o == 0 || UnsafeRawPointer(self) < UnsafeRawPointer(bitPattern: 0 &- o)!,
      "Overflow in pointer arithmetic"
    )
    return .init(Builtin.gepRaw_Word(_rawValue, o._builtinWordValue))
  }
  @_alwaysEmitIntoClient public func pointer<Property>(to property: Swift.WritableKeyPath<Pointee, Property>) -> Swift.UnsafeMutablePointer<Property>? {
    guard let o = property._storedInlineOffset else { return nil }
    _internalInvariant(o >= 0)
    _debugPrecondition(
      o == 0 || UnsafeRawPointer(self) < UnsafeRawPointer(bitPattern: 0 &- o)!,
      "Overflow in pointer arithmetic"
    )
    return .init(Builtin.gepRaw_Word(_rawValue, o._builtinWordValue))
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @_alwaysEmitIntoClient public func pointer<Property>(to property: Swift.KeyPath<Pointee, Property>) -> Swift.UnsafePointer<Property>? {
    guard let o = property._storedInlineOffset else { return nil }
    _internalInvariant(o >= 0)
    _debugPrecondition(
      o == 0 || UnsafeRawPointer(self) < UnsafeRawPointer(bitPattern: 0 &- o)!,
      "Overflow in pointer arithmetic"
    )
    return .init(Builtin.gepRaw_Word(_rawValue, o._builtinWordValue))
  }
  @_alwaysEmitIntoClient public func pointer<Property>(to property: Swift.WritableKeyPath<Pointee, Property>) -> Swift.UnsafeMutablePointer<Property>? {
    guard let o = property._storedInlineOffset else { return nil }
    _internalInvariant(o >= 0)
    _debugPrecondition(
      o == 0 || UnsafeRawPointer(self) < UnsafeRawPointer(bitPattern: 0 &- o)!,
      "Overflow in pointer arithmetic"
    )
    return .init(Builtin.gepRaw_Word(_rawValue, o._builtinWordValue))
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee : ~Copyable {
  @inlinable @_preInverseGenerics internal static var _max: Swift.UnsafeMutablePointer<Pointee> {
    get {
    return UnsafeMutablePointer(
      bitPattern: 0 as Int &- MemoryLayout<Pointee>.stride
    )._unsafelyUnwrappedUnchecked
  }
  }
}
#else
extension Swift.UnsafeMutablePointer {
  @inlinable internal static var _max: Swift.UnsafeMutablePointer<Pointee> {
    get {
    return UnsafeMutablePointer(
      bitPattern: 0 as Int &- MemoryLayout<Pointee>.stride
    )._unsafelyUnwrappedUnchecked
  }
  }
}
#endif
@frozen public struct UnsafeRawPointer : Swift._Pointer {
  public typealias Pointee = Swift.UInt8
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(*, unavailable)
extension Swift.UnsafeRawPointer : Swift.Sendable {
}
extension Swift.UnsafeRawPointer {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_transparent @_preInverseGenerics public init<T>(@_nonEphemeral _ other: Swift.UnsafePointer<T>) where T : ~Copyable {
    _rawValue = other._rawValue
  }
  #else
  @_transparent public init<T>(@_nonEphemeral _ other: Swift.UnsafePointer<T>) {
    _rawValue = other._rawValue
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_transparent @_preInverseGenerics public init?<T>(@_nonEphemeral _ other: Swift.UnsafePointer<T>?) where T : ~Copyable {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  #else
  @_transparent public init?<T>(@_nonEphemeral _ other: Swift.UnsafePointer<T>?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  #endif
}
extension Swift.UnsafeRawPointer {
  @_transparent public init(@_nonEphemeral _ other: Swift.UnsafeMutableRawPointer) {
    _rawValue = other._rawValue
  }
  @_transparent public init?(@_nonEphemeral _ other: Swift.UnsafeMutableRawPointer?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
}
extension Swift.UnsafeRawPointer {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_transparent @_preInverseGenerics public init<T>(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<T>) where T : ~Copyable {
    _rawValue = other._rawValue
  }
  #else
  @_transparent public init<T>(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_transparent @_preInverseGenerics public init?<T>(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<T>?) where T : ~Copyable {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  #else
  @_transparent public init?<T>(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  #endif
  @inlinable public func deallocate() {
     
     
     
     
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @_transparent @_preInverseGenerics public func bindMemory<T>(to type: T.Type, capacity count: Swift.Int) -> Swift.UnsafePointer<T> where T : ~Copyable {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafePointer<T>(_rawValue)
  }
  #else
  @discardableResult
  @_transparent public func bindMemory<T>(to type: T.Type, capacity count: Swift.Int) -> Swift.UnsafePointer<T> {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafePointer<T>(_rawValue)
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, capacity count: Swift.Int, _ body: (_ pointer: Swift.UnsafePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
    _debugPrecondition(
      Int(bitPattern: self) & (MemoryLayout<T>.alignment-1) == 0,
      "self must be a properly aligned pointer for type T"
    )
    let binding = Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(_rawValue, binding) }
    return try body(.init(_rawValue))
  }
  #else
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, capacity count: Swift.Int, _ body: (_ pointer: Swift.UnsafePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
    _debugPrecondition(
      Int(bitPattern: self) & (MemoryLayout<T>.alignment-1) == 0,
      "self must be a properly aligned pointer for type T"
    )
    let binding = Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(_rawValue, binding) }
    return try body(.init(_rawValue))
  }
  #endif
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_transparent @_preInverseGenerics public func assumingMemoryBound<T>(to: T.Type) -> Swift.UnsafePointer<T> where T : ~Copyable {
    return UnsafePointer<T>(_rawValue)
  }
  #else
  @_transparent public func assumingMemoryBound<T>(to: T.Type) -> Swift.UnsafePointer<T> {
    return UnsafePointer<T>(_rawValue)
  }
  #endif
  @inlinable public func load<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "load from misaligned raw pointer")

    let rawPointer = (self + offset)._rawValue

#if compiler(>=5.5) && $BuiltinAssumeAlignment
    let alignedPointer =
      Builtin.assumeAlignment(rawPointer,
                              MemoryLayout<T>.alignment._builtinWordValue)
    return Builtin.loadRaw(alignedPointer)
#else
    return Builtin.loadRaw(rawPointer)
#endif
  }
  @inlinable @_alwaysEmitIntoClient public func loadUnaligned<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T where T : Swift.BitwiseCopyable {
    return Builtin.loadRaw((self + offset)._rawValue)
  }
  @inlinable @_alwaysEmitIntoClient public func loadUnaligned<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    _debugPrecondition(
      _isPOD(T.self),
      "loadUnaligned only supports loading BitwiseCopyable types."
    )
    return _withUnprotectedUnsafeTemporaryAllocation(of: T.self, capacity: 1) {
      let temporary = $0.baseAddress._unsafelyUnwrappedUnchecked
      Builtin.int_memcpy_RawPointer_RawPointer_Int64(
        temporary._rawValue,
        (self + offset)._rawValue,
        UInt64(MemoryLayout<T>.size)._value,
          false._value
      )
      return temporary.pointee
    }
  }
}
extension Swift.UnsafeRawPointer : Swift.Strideable {
  @_transparent public func advanced(by n: Swift.Int) -> Swift.UnsafeRawPointer {
    return UnsafeRawPointer(Builtin.gepRaw_Word(_rawValue, n._builtinWordValue))
  }
  public typealias Stride = Swift.Int
}
extension Swift.UnsafeRawPointer {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @inlinable @_alwaysEmitIntoClient public func alignedUp<T>(for type: T.Type) -> Swift.UnsafeRawPointer where T : ~Copyable {
    let mask = UInt(Builtin.alignof(T.self)) &- 1
    let bits = (UInt(Builtin.ptrtoint_Word(_rawValue)) &+ mask) & ~mask
    _debugPrecondition(bits != 0, "Overflow in pointer arithmetic")
    return .init(Builtin.inttoptr_Word(bits._builtinWordValue))
  }
  #else
  @inlinable @_alwaysEmitIntoClient public func alignedUp<T>(for type: T.Type) -> Swift.UnsafeRawPointer {
    let mask = UInt(Builtin.alignof(T.self)) &- 1
    let bits = (UInt(Builtin.ptrtoint_Word(_rawValue)) &+ mask) & ~mask
    _debugPrecondition(bits != 0, "Overflow in pointer arithmetic")
    return .init(Builtin.inttoptr_Word(bits._builtinWordValue))
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @inlinable @_alwaysEmitIntoClient public func alignedDown<T>(for type: T.Type) -> Swift.UnsafeRawPointer where T : ~Copyable {
    let mask = UInt(Builtin.alignof(T.self)) &- 1
    let bits = UInt(Builtin.ptrtoint_Word(_rawValue)) & ~mask
    _debugPrecondition(bits != 0, "Overflow in pointer arithmetic")
    return .init(Builtin.inttoptr_Word(bits._builtinWordValue))
  }
  #else
  @inlinable @_alwaysEmitIntoClient public func alignedDown<T>(for type: T.Type) -> Swift.UnsafeRawPointer {
    let mask = UInt(Builtin.alignof(T.self)) &- 1
    let bits = UInt(Builtin.ptrtoint_Word(_rawValue)) & ~mask
    _debugPrecondition(bits != 0, "Overflow in pointer arithmetic")
    return .init(Builtin.inttoptr_Word(bits._builtinWordValue))
  }
  #endif
  @inlinable @_alwaysEmitIntoClient public func alignedUp(toMultipleOf alignment: Swift.Int) -> Swift.UnsafeRawPointer {
    let mask = UInt(alignment._builtinWordValue) &- 1
    _debugPrecondition(
      alignment > 0 && UInt(alignment._builtinWordValue) & mask == 0,
      "alignment must be a whole power of 2."
    )
    let bits = (UInt(Builtin.ptrtoint_Word(_rawValue)) &+ mask) & ~mask
    _debugPrecondition(bits != 0, "Overflow in pointer arithmetic")
    return .init(Builtin.inttoptr_Word(bits._builtinWordValue))
  }
  @inlinable @_alwaysEmitIntoClient public func alignedDown(toMultipleOf alignment: Swift.Int) -> Swift.UnsafeRawPointer {
    let mask = UInt(alignment._builtinWordValue) &- 1
    _debugPrecondition(
      alignment > 0 && UInt(alignment._builtinWordValue) & mask == 0,
      "alignment must be a whole power of 2."
    )
    let bits = UInt(Builtin.ptrtoint_Word(_rawValue)) & ~mask
    _debugPrecondition(bits != 0, "Overflow in pointer arithmetic")
    return .init(Builtin.inttoptr_Word(bits._builtinWordValue))
  }
}
@frozen public struct UnsafeMutableRawPointer : Swift._Pointer {
  public typealias Pointee = Swift.UInt8
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(*, unavailable)
extension Swift.UnsafeMutableRawPointer : Swift.Sendable {
}
extension Swift.UnsafeMutableRawPointer {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_transparent @_preInverseGenerics public init<T>(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<T>) where T : ~Copyable {
    _rawValue = other._rawValue
  }
  #else
  @_transparent public init<T>(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_transparent @_preInverseGenerics public init?<T>(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<T>?) where T : ~Copyable {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  #else
  @_transparent public init?<T>(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  #endif
  @_transparent public init(@_nonEphemeral mutating other: Swift.UnsafeRawPointer) {
    _rawValue = other._rawValue
  }
  @_transparent public init?(@_nonEphemeral mutating other: Swift.UnsafeRawPointer?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  @inlinable public static func allocate(byteCount: Swift.Int, alignment: Swift.Int) -> Swift.UnsafeMutableRawPointer {
     
     
     
     
     
     
     
     
     
     
     
    var alignment = alignment
    if alignment <= _minAllocationAlignment() {
      alignment = 0
    }
    return UnsafeMutableRawPointer(Builtin.allocRaw(
        byteCount._builtinWordValue, alignment._builtinWordValue))
  }
  @inlinable public func deallocate() {
     
     
     
     
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @_transparent @_preInverseGenerics public func bindMemory<T>(to type: T.Type, capacity count: Swift.Int) -> Swift.UnsafeMutablePointer<T> where T : ~Copyable {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafeMutablePointer<T>(_rawValue)
  }
  #else
  @discardableResult
  @_transparent public func bindMemory<T>(to type: T.Type, capacity count: Swift.Int) -> Swift.UnsafeMutablePointer<T> {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafeMutablePointer<T>(_rawValue)
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, capacity count: Swift.Int, _ body: (_ pointer: Swift.UnsafeMutablePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
    _debugPrecondition(
      Int(bitPattern: self) & (MemoryLayout<T>.alignment-1) == 0,
      "self must be a properly aligned pointer for type T"
    )
    let binding = Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(_rawValue, binding) }
    return try body(.init(_rawValue))
  }
  #else
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, capacity count: Swift.Int, _ body: (_ pointer: Swift.UnsafeMutablePointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
    _debugPrecondition(
      Int(bitPattern: self) & (MemoryLayout<T>.alignment-1) == 0,
      "self must be a properly aligned pointer for type T"
    )
    let binding = Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(_rawValue, binding) }
    return try body(.init(_rawValue))
  }
  #endif
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_transparent @_preInverseGenerics public func assumingMemoryBound<T>(to: T.Type) -> Swift.UnsafeMutablePointer<T> where T : ~Copyable {
    return UnsafeMutablePointer<T>(_rawValue)
  }
  #else
  @_transparent public func assumingMemoryBound<T>(to: T.Type) -> Swift.UnsafeMutablePointer<T> {
    return UnsafeMutablePointer<T>(_rawValue)
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @_alwaysEmitIntoClient public func initializeMemory<T>(as type: T.Type, to value: consuming T) -> Swift.UnsafeMutablePointer<T> where T : ~Copyable {
    Builtin.bindMemory(_rawValue, (1)._builtinWordValue, type)
    Builtin.initialize(consume value, _rawValue)
    return UnsafeMutablePointer(_rawValue)
  }
  #else
  @discardableResult
  @_alwaysEmitIntoClient public func initializeMemory<T>(as type: T.Type, to value: consuming T) -> Swift.UnsafeMutablePointer<T> {
    Builtin.bindMemory(_rawValue, (1)._builtinWordValue, type)
    Builtin.initialize(consume value, _rawValue)
    return UnsafeMutablePointer(_rawValue)
  }
  #endif
  @discardableResult
  @inlinable public func initializeMemory<T>(as type: T.Type, repeating repeatedValue: T, count: Swift.Int) -> Swift.UnsafeMutablePointer<T> {
    _debugPrecondition(count >= 0,
      "UnsafeMutableRawPointer.initializeMemory: negative count")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    var nextPtr = self
    for _ in 0..<count {
      Builtin.initialize(repeatedValue, nextPtr._rawValue)
      nextPtr += MemoryLayout<T>.stride
    }
    return UnsafeMutablePointer(_rawValue)
  }
  @discardableResult
  @inlinable public func initializeMemory<T>(as type: T.Type, from source: Swift.UnsafePointer<T>, count: Swift.Int) -> Swift.UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0,
      "UnsafeMutableRawPointer.initializeMemory with negative count")
    _debugPrecondition(
      (UnsafeRawPointer(self + count * MemoryLayout<T>.stride)
        <= UnsafeRawPointer(source))
      || UnsafeRawPointer(source + count) <= UnsafeRawPointer(self),
      "UnsafeMutableRawPointer.initializeMemory overlapping range")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    Builtin.copyArray(
      T.self, self._rawValue, source._rawValue, count._builtinWordValue)
     
     
     
     
    return UnsafeMutablePointer(_rawValue)
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @inlinable @_preInverseGenerics public func moveInitializeMemory<T>(as type: T.Type, from source: Swift.UnsafeMutablePointer<T>, count: Swift.Int) -> Swift.UnsafeMutablePointer<T> where T : ~Copyable {
    _debugPrecondition(
      count >= 0,
      "UnsafeMutableRawPointer.moveInitializeMemory with negative count")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    if self < UnsafeMutableRawPointer(source)
       || self >= UnsafeMutableRawPointer(source + count) {
       
      Builtin.takeArrayFrontToBack(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
       
       
       
       
       
    }
    else {
       
      Builtin.takeArrayBackToFront(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
       
       
       
       
       
       
    }
    return UnsafeMutablePointer(_rawValue)
  }
  #else
  @discardableResult
  @inlinable public func moveInitializeMemory<T>(as type: T.Type, from source: Swift.UnsafeMutablePointer<T>, count: Swift.Int) -> Swift.UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0,
      "UnsafeMutableRawPointer.moveInitializeMemory with negative count")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    if self < UnsafeMutableRawPointer(source)
       || self >= UnsafeMutableRawPointer(source + count) {
       
      Builtin.takeArrayFrontToBack(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
       
       
       
       
       
    }
    else {
       
      Builtin.takeArrayBackToFront(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
       
       
       
       
       
       
    }
    return UnsafeMutablePointer(_rawValue)
  }
  #endif
  @inlinable public func load<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "load from misaligned raw pointer")

    let rawPointer = (self + offset)._rawValue

#if compiler(>=5.5) && $BuiltinAssumeAlignment
    let alignedPointer =
      Builtin.assumeAlignment(rawPointer,
                              MemoryLayout<T>.alignment._builtinWordValue)
    return Builtin.loadRaw(alignedPointer)
#else
    return Builtin.loadRaw(rawPointer)
#endif
  }
  @inlinable @_alwaysEmitIntoClient public func loadUnaligned<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T where T : Swift.BitwiseCopyable {
    return Builtin.loadRaw((self + offset)._rawValue)
  }
  @inlinable @_alwaysEmitIntoClient public func loadUnaligned<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    _debugPrecondition(
      _isPOD(T.self),
      "loadUnaligned only supports loading BitwiseCopyable types."
    )
    return _withUnprotectedUnsafeTemporaryAllocation(of: T.self, capacity: 1) {
      let temporary = $0.baseAddress._unsafelyUnwrappedUnchecked
      Builtin.int_memcpy_RawPointer_RawPointer_Int64(
        temporary._rawValue,
        (self + offset)._rawValue,
        UInt64(MemoryLayout<T>.size)._value,
          false._value
      )
      return temporary.pointee
    }
  }
  @inlinable @_alwaysEmitIntoClient public func storeBytes<T>(of value: T, toByteOffset offset: Swift.Int = 0, as type: T.Type) where T : Swift.BitwiseCopyable {
#if $BuiltinStoreRaw
    Builtin.storeRaw(value, (self + offset)._rawValue)
#else
    fatalError("Unsupported swift compiler!")
#endif
  }
  @_silgen_name("_swift_se0349_UnsafeMutableRawPointer_storeBytes")
  @inlinable @_alwaysEmitIntoClient public func storeBytes<T>(of value: T, toByteOffset offset: Swift.Int = 0, as type: T.Type) {
    _debugPrecondition(
      _isPOD(T.self),
      "storeBytes only supports storing the bytes of BitwiseCopyable types."
    )

#if $TypedThrows
    withUnsafePointer(to: value) { source in
       
      Builtin.int_memcpy_RawPointer_RawPointer_Int64(
        (self + offset)._rawValue,
        source._rawValue,
        UInt64(MemoryLayout<T>.size)._value,
          false._value
      )
    }
#else
    try! __abi_withUnsafePointer(to: value) { source in
       
      Builtin.int_memcpy_RawPointer_RawPointer_Int64(
        (self + offset)._rawValue,
        source._rawValue,
        UInt64(MemoryLayout<T>.size)._value,
          false._value
      )
    }
#endif
  }
  @_alwaysEmitIntoClient internal func _legacy_se0349_storeBytes_internal<T>(of value: T, toByteOffset offset: Swift.Int = 0, as type: T.Type) {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "storeBytes to misaligned raw pointer")

    var temp = value
#if $TypedThrows
    withUnsafeMutablePointer(to: &temp) { source in
      let rawSrc = UnsafeMutableRawPointer(source)._rawValue
       
      Builtin.int_memcpy_RawPointer_RawPointer_Int64(
        (self + offset)._rawValue, rawSrc, UInt64(MemoryLayout<T>.size)._value,
          false._value)
    }
#else
    __abi_se0413_withUnsafeMutablePointer(to: &temp) { source in
      let rawSrc = UnsafeMutableRawPointer(source)._rawValue
       
      Builtin.int_memcpy_RawPointer_RawPointer_Int64(
        (self + offset)._rawValue, rawSrc, UInt64(MemoryLayout<T>.size)._value,
          false._value)
    }
#endif
  }
  @inlinable public func copyMemory(from source: Swift.UnsafeRawPointer, byteCount: Swift.Int) {
    _debugPrecondition(
      byteCount >= 0, "UnsafeMutableRawPointer.copyMemory with negative count")

    _memmove(dest: self, src: source, size: UInt(byteCount))
  }
}
extension Swift.UnsafeMutableRawPointer : Swift.Strideable {
  @_transparent public func advanced(by n: Swift.Int) -> Swift.UnsafeMutableRawPointer {
    return UnsafeMutableRawPointer(
      Builtin.gepRaw_Word(_rawValue, n._builtinWordValue))
  }
  public typealias Stride = Swift.Int
}
extension Swift.UnsafeMutableRawPointer {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @inlinable @_alwaysEmitIntoClient public func alignedUp<T>(for type: T.Type) -> Swift.UnsafeMutableRawPointer where T : ~Copyable {
    let mask = UInt(Builtin.alignof(T.self)) &- 1
    let bits = (UInt(Builtin.ptrtoint_Word(_rawValue)) &+ mask) & ~mask
    _debugPrecondition(bits != 0, "Overflow in pointer arithmetic")
    return .init(Builtin.inttoptr_Word(bits._builtinWordValue))
  }
  #else
  @inlinable @_alwaysEmitIntoClient public func alignedUp<T>(for type: T.Type) -> Swift.UnsafeMutableRawPointer {
    let mask = UInt(Builtin.alignof(T.self)) &- 1
    let bits = (UInt(Builtin.ptrtoint_Word(_rawValue)) &+ mask) & ~mask
    _debugPrecondition(bits != 0, "Overflow in pointer arithmetic")
    return .init(Builtin.inttoptr_Word(bits._builtinWordValue))
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @inlinable @_alwaysEmitIntoClient public func alignedDown<T>(for type: T.Type) -> Swift.UnsafeMutableRawPointer where T : ~Copyable {
    let mask = UInt(Builtin.alignof(T.self)) &- 1
    let bits = UInt(Builtin.ptrtoint_Word(_rawValue)) & ~mask
    _debugPrecondition(bits != 0, "Overflow in pointer arithmetic")
    return .init(Builtin.inttoptr_Word(bits._builtinWordValue))
  }
  #else
  @inlinable @_alwaysEmitIntoClient public func alignedDown<T>(for type: T.Type) -> Swift.UnsafeMutableRawPointer {
    let mask = UInt(Builtin.alignof(T.self)) &- 1
    let bits = UInt(Builtin.ptrtoint_Word(_rawValue)) & ~mask
    _debugPrecondition(bits != 0, "Overflow in pointer arithmetic")
    return .init(Builtin.inttoptr_Word(bits._builtinWordValue))
  }
  #endif
  @inlinable @_alwaysEmitIntoClient public func alignedUp(toMultipleOf alignment: Swift.Int) -> Swift.UnsafeMutableRawPointer {
    let mask = UInt(alignment._builtinWordValue) &- 1
    _debugPrecondition(
      alignment > 0 && UInt(alignment._builtinWordValue) & mask == 0,
      "alignment must be a whole power of 2."
    )
    let bits = (UInt(Builtin.ptrtoint_Word(_rawValue)) &+ mask) & ~mask
    _debugPrecondition(bits != 0, "Overflow in pointer arithmetic")
    return .init(Builtin.inttoptr_Word(bits._builtinWordValue))
  }
  @inlinable @_alwaysEmitIntoClient public func alignedDown(toMultipleOf alignment: Swift.Int) -> Swift.UnsafeMutableRawPointer {
    let mask = UInt(alignment._builtinWordValue) &- 1
    _debugPrecondition(
      alignment > 0 && UInt(alignment._builtinWordValue) & mask == 0,
      "alignment must be a whole power of 2."
    )
    let bits = UInt(Builtin.ptrtoint_Word(_rawValue)) & ~mask
    _debugPrecondition(bits != 0, "Overflow in pointer arithmetic")
    return .init(Builtin.inttoptr_Word(bits._builtinWordValue))
  }
}
extension Swift.OpaquePointer {
  @_transparent public init(@_nonEphemeral _ from: Swift.UnsafeMutableRawPointer) {
    self._rawValue = from._rawValue
  }
  @_transparent public init?(@_nonEphemeral _ from: Swift.UnsafeMutableRawPointer?) {
    guard let unwrapped = from else { return nil }
    self._rawValue = unwrapped._rawValue
  }
  @_transparent public init(@_nonEphemeral _ from: Swift.UnsafeRawPointer) {
    self._rawValue = from._rawValue
  }
  @_transparent public init?(@_nonEphemeral _ from: Swift.UnsafeRawPointer?) {
    guard let unwrapped = from else { return nil }
    self._rawValue = unwrapped._rawValue
  }
}
public protocol _UTFParser {
  associatedtype Encoding : Swift._UnicodeEncoding
  func _parseMultipleCodeUnits() -> (isValid: Swift.Bool, bitCount: Swift.UInt8)
  func _bufferedScalar(bitCount: Swift.UInt8) -> Self.Encoding.EncodedScalar
  var _buffer: Swift._UIntBuffer<Self.Encoding.CodeUnit> { get set }
}
extension Swift._UTFParser where Self.Encoding.EncodedScalar : Swift.RangeReplaceableCollection {
  @inlinable @inline(__always) public mutating func parseScalar<I>(from input: inout I) -> Swift.Unicode.ParseResult<Self.Encoding.EncodedScalar> where I : Swift.IteratorProtocol, I.Element == Self.Encoding.CodeUnit {

     
    if _fastPath(_buffer.isEmpty) {
      guard let codeUnit = input.next() else { return .emptyInput }
       
      if Encoding._isScalar(codeUnit) {
        return .valid(Encoding.EncodedScalar(CollectionOfOne(codeUnit)))
      }
       
      _buffer.append(codeUnit)
    } else if Encoding._isScalar(
      Encoding.CodeUnit(truncatingIfNeeded: _buffer._storage)
    ) {
       
       
      let codeUnit = Encoding.CodeUnit(truncatingIfNeeded: _buffer._storage)
      _buffer.remove(at: _buffer.startIndex)
      return .valid(Encoding.EncodedScalar(CollectionOfOne(codeUnit)))
    }
     
     
    repeat {
      if let codeUnit = input.next() {
        _buffer.append(codeUnit)
      } else {
        if _buffer.isEmpty { return .emptyInput }
        break  
      }
    } while _buffer.count < _buffer.capacity

     
    let (isValid, scalarBitCount) = _parseMultipleCodeUnits()
    _internalInvariant(scalarBitCount % numericCast(Encoding.CodeUnit.bitWidth) == 0)
    _internalInvariant(1...4 ~= scalarBitCount / 8)
    _internalInvariant(scalarBitCount <= _buffer._bitCount)
    
     
    let encodedScalar = _bufferedScalar(bitCount: scalarBitCount)
    
    _buffer._storage = UInt32(
       
      truncatingIfNeeded: UInt64(_buffer._storage) &>> scalarBitCount)
      
    _buffer._bitCount = _buffer._bitCount &- scalarBitCount

    if _fastPath(isValid) {
      return .valid(encodedScalar)
    }
    return .error(
      length: Int(scalarBitCount / numericCast(Encoding.CodeUnit.bitWidth)))
  }
}
extension Swift.Unicode {
  @frozen public enum UTF8 : Swift.Sendable {
    case _swift3Buffer(Swift.Unicode.UTF8.ForwardParser)
  }
}
extension Swift.Unicode.UTF8 {
  @_alwaysEmitIntoClient public static func width(_ x: Swift.Unicode.Scalar) -> Swift.Int {
    switch x.value {
      case 0..<0x80: return 1
      case 0x80..<0x0800: return 2
      case 0x0800..<0x1_0000: return 3
      default: return 4
    }
  }
}
extension Swift.Unicode.UTF8 : Swift._UnicodeEncoding {
  public typealias CodeUnit = Swift.UInt8
  public typealias EncodedScalar = Swift._ValidUTF8Buffer
  @inlinable public static var encodedReplacementCharacter: Swift.Unicode.UTF8.EncodedScalar {
    get {
    return EncodedScalar.encodedReplacementCharacter
  }
  }
  @inline(__always) @inlinable public static func _isScalar(_ x: Swift.Unicode.UTF8.CodeUnit) -> Swift.Bool {
    return isASCII(x)
  }
  @_alwaysEmitIntoClient @inline(__always) public static func isASCII(_ x: Swift.Unicode.UTF8.CodeUnit) -> Swift.Bool {
    return x & 0b1000_0000 == 0
  }
  @inline(__always) @inlinable public static func decode(_ source: Swift.Unicode.UTF8.EncodedScalar) -> Swift.Unicode.Scalar {
    switch source.count {
    case 1:
      return Unicode.Scalar(_unchecked: source._biasedBits &- 0x01)
    case 2:
      let bits = source._biasedBits &- 0x0101
      var value = (bits & 0b0_______________________11_1111__0000_0000) &>> 8
      value    |= (bits & 0b0________________________________0001_1111) &<< 6
      return Unicode.Scalar(_unchecked: value)
    case 3:
      let bits = source._biasedBits &- 0x010101
      var value = (bits & 0b0____________11_1111__0000_0000__0000_0000) &>> 16
      value    |= (bits & 0b0_______________________11_1111__0000_0000) &>> 2
      value    |= (bits & 0b0________________________________0000_1111) &<< 12
      return Unicode.Scalar(_unchecked: value)
    default:
      _internalInvariant(source.count == 4)
      let bits = source._biasedBits &- 0x01010101
      var value = (bits & 0b0_11_1111__0000_0000__0000_0000__0000_0000) &>> 24
      value    |= (bits & 0b0____________11_1111__0000_0000__0000_0000) &>> 10
      value    |= (bits & 0b0_______________________11_1111__0000_0000) &<< 4
      value    |= (bits & 0b0________________________________0000_0111) &<< 18
      return Unicode.Scalar(_unchecked: value)
    }
  }
  @inline(__always) @inlinable public static func encode(_ source: Swift.Unicode.Scalar) -> Swift.Unicode.UTF8.EncodedScalar? {
    var c = source.value
    if _fastPath(c < (1&<<7)) {
      return EncodedScalar(_containing: UInt8(c))
    }
    var o = c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    if _fastPath(c < (1&<<5)) {
      return EncodedScalar(_biasedBits: (o | c) &+ 0b0__1000_0001__1100_0001)
    }
    o |= c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    if _fastPath(c < (1&<<4)) {
      return EncodedScalar(
        _biasedBits: (o | c) &+ 0b0__1000_0001__1000_0001__1110_0001)
    }
    o |= c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    return EncodedScalar(
      _biasedBits: (o | c ) &+ 0b0__1000_0001__1000_0001__1000_0001__1111_0001)
  }
  @inlinable @inline(__always) public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Swift.Unicode.UTF8.EncodedScalar? where FromEncoding : Swift._UnicodeEncoding {
    if _fastPath(FromEncoding.self == UTF16.self) {
      let c = _identityCast(content, to: UTF16.EncodedScalar.self)
      var u0 = UInt16(truncatingIfNeeded: c._storage)
      if _fastPath(u0 < 0x80) {
        return EncodedScalar(_containing: UInt8(truncatingIfNeeded: u0))
      }
      var r = UInt32(u0 & 0b0__11_1111)
      r &<<= 8
      u0 &>>= 6
      if _fastPath(u0 < (1&<<5)) {
        return EncodedScalar(
          _biasedBits: (UInt32(u0) | r) &+ 0b0__1000_0001__1100_0001)
      }
      r |= UInt32(u0 & 0b0__11_1111)
      r &<<= 8
      if _fastPath(u0 & (0xF800 &>> 6) != (0xD800 &>> 6)) {
        u0 &>>= 6
        return EncodedScalar(
          _biasedBits: (UInt32(u0) | r) &+ 0b0__1000_0001__1000_0001__1110_0001)
      }
    }
    else if _fastPath(FromEncoding.self == UTF8.self) {
      return _identityCast(content, to: UTF8.EncodedScalar.self)
    }
    return encode(FromEncoding.decode(content))
  }
  @frozen public struct ForwardParser : Swift.Sendable {
    public typealias _Buffer = Swift._UIntBuffer<Swift.UInt8>
    public var _buffer: Swift.Unicode.UTF8.ForwardParser._Buffer
    @inline(__always) @inlinable public init() { _buffer = _Buffer() }
  }
  @frozen public struct ReverseParser : Swift.Sendable {
    public typealias _Buffer = Swift._UIntBuffer<Swift.UInt8>
    public var _buffer: Swift.Unicode.UTF8.ReverseParser._Buffer
    @inline(__always) @inlinable public init() { _buffer = _Buffer() }
  }
}
extension Swift.Unicode.UTF8.ReverseParser : Swift.Unicode.Parser, Swift._UTFParser {
  public typealias Encoding = Swift.Unicode.UTF8
  @inline(__always) @inlinable public func _parseMultipleCodeUnits() -> (isValid: Swift.Bool, bitCount: Swift.UInt8) {
    _internalInvariant(_buffer._storage & 0x80 != 0)  
    if _buffer._storage                & 0b0__1110_0000__1100_0000
                                      == 0b0__1100_0000__1000_0000 {
       
      let top4Bits =  _buffer._storage & 0b0__0001_1110__0000_0000
      if _fastPath(top4Bits != 0) { return (true, 2*8) }
    }
    else if _buffer._storage     & 0b0__1111_0000__1100_0000__1100_0000
                                == 0b0__1110_0000__1000_0000__1000_0000 {
       
       
      let top5Bits = _buffer._storage & 0b0__1111__0010_0000__0000_0000
      if _fastPath(
        top5Bits != 0 &&    top5Bits != 0b0__1101__0010_0000__0000_0000) {
        return (true, 3*8)
      }
    }
    else if _buffer._storage & 0b0__1111_1000__1100_0000__1100_0000__1100_0000
                            == 0b0__1111_0000__1000_0000__1000_0000__1000_0000 {
       
      let top5bits = _buffer._storage
                                  & 0b0__0111__0011_0000__0000_0000__0000_0000
      if _fastPath(
        top5bits != 0
        && top5bits <=              0b0__0100__0000_0000__0000_0000__0000_0000
      ) { return (true, 4*8) }
    }
    return (false, _invalidLength() &* 8)
  }
  @usableFromInline
  @inline(never) internal func _invalidLength() -> Swift.UInt8
  @inline(__always) @inlinable public func _bufferedScalar(bitCount: Swift.UInt8) -> Swift.Unicode.UTF8.ReverseParser.Encoding.EncodedScalar {
    let x = UInt32(truncatingIfNeeded: _buffer._storage.byteSwapped)
    let shift = 32 &- bitCount
    return Encoding.EncodedScalar(_biasedBits: (x &+ 0x01010101) &>> shift)
  }
}
extension Swift.Unicode.UTF8.ForwardParser : Swift.Unicode.Parser, Swift._UTFParser {
  public typealias Encoding = Swift.Unicode.UTF8
  @inline(__always) @inlinable public func _parseMultipleCodeUnits() -> (isValid: Swift.Bool, bitCount: Swift.UInt8) {
    _internalInvariant(_buffer._storage & 0x80 != 0)  

    if _buffer._storage & 0b0__1100_0000__1110_0000
                       == 0b0__1000_0000__1100_0000 {
       
       
      if _fastPath(_buffer._storage & 0b0_0001_1110 != 0) { return (true, 2*8) }
    }
    else if _buffer._storage         & 0b0__1100_0000__1100_0000__1111_0000
                                    == 0b0__1000_0000__1000_0000__1110_0000 {
       
       
      let top5Bits =          _buffer._storage & 0b0___0010_0000__0000_1111
      if _fastPath(top5Bits != 0 && top5Bits != 0b0___0010_0000__0000_1101) {
        return (true, 3*8)
      }
    }
    else if _buffer._storage & 0b0__1100_0000__1100_0000__1100_0000__1111_1000
                            == 0b0__1000_0000__1000_0000__1000_0000__1111_0000 {
       
       
      let top5bits = UInt16(_buffer._storage       & 0b0__0011_0000__0000_0111)
      if _fastPath(
        top5bits != 0
        && top5bits.byteSwapped                   <= 0b0__0000_0100__0000_0000
      ) { return (true, 4*8) }
    }
    return (false, _invalidLength() &* 8)
  }
  @usableFromInline
  @inline(never) internal func _invalidLength() -> Swift.UInt8
  @inlinable public func _bufferedScalar(bitCount: Swift.UInt8) -> Swift.Unicode.UTF8.ForwardParser.Encoding.EncodedScalar {
    let x = UInt32(_buffer._storage) &+ 0x01010101
    return _ValidUTF8Buffer(_biasedBits: x & ._lowBits(bitCount))
  }
}
extension Swift.Unicode {
  @frozen public enum UTF16 : Swift.Sendable {
    case _swift3Buffer(Swift.Unicode.UTF16.ForwardParser)
  }
}
extension Swift.Unicode.UTF16 {
  @inlinable public static func width(_ x: Swift.Unicode.Scalar) -> Swift.Int {
    return x.value <= UInt16.max ? 1 : 2
  }
  @inlinable public static func leadSurrogate(_ x: Swift.Unicode.Scalar) -> Swift.UTF16.CodeUnit {
    _precondition(width(x) == 2)
    return 0xD800 + UTF16.CodeUnit(truncatingIfNeeded:
      (x.value - 0x1_0000) &>> (10 as UInt32))
  }
  @inlinable public static func trailSurrogate(_ x: Swift.Unicode.Scalar) -> Swift.UTF16.CodeUnit {
    _precondition(width(x) == 2)
    return 0xDC00 + UTF16.CodeUnit(truncatingIfNeeded:
      (x.value - 0x1_0000) & (((1 as UInt32) &<< 10) - 1))
  }
  @inlinable public static func isLeadSurrogate(_ x: Swift.Unicode.UTF16.CodeUnit) -> Swift.Bool {
    return (x & 0xFC00) == 0xD800
  }
  @inlinable public static func isTrailSurrogate(_ x: Swift.Unicode.UTF16.CodeUnit) -> Swift.Bool {
    return (x & 0xFC00) == 0xDC00
  }
  @_alwaysEmitIntoClient public static func isSurrogate(_ x: Swift.Unicode.UTF16.CodeUnit) -> Swift.Bool {
    return isLeadSurrogate(x) || isTrailSurrogate(x)
  }
  @inlinable public static func _copy<T, U>(source: Swift.UnsafeMutablePointer<T>, destination: Swift.UnsafeMutablePointer<U>, count: Swift.Int) where T : Swift._StringElement, U : Swift._StringElement {
    if MemoryLayout<T>.stride == MemoryLayout<U>.stride {
      _memcpy(
        dest: UnsafeMutablePointer(destination),
        src: UnsafeMutablePointer(source),
        size: UInt(count) * UInt(MemoryLayout<U>.stride))
    }
    else {
      for i in 0..<count {
        let u16 = T._toUTF16CodeUnit((source + i).pointee)
        (destination + i).pointee = U._fromUTF16CodeUnit(u16)
      }
    }
  }
  @inlinable public static func transcodedLength<Input, Encoding>(of input: Input, decodedAs sourceEncoding: Encoding.Type, repairingIllFormedSequences: Swift.Bool) -> (count: Swift.Int, isASCII: Swift.Bool)? where Input : Swift.IteratorProtocol, Encoding : Swift._UnicodeEncoding, Input.Element == Encoding.CodeUnit {

    var utf16Count = 0
    var i = input
    var d = Encoding.ForwardParser()

     
    if sourceEncoding == Unicode.UTF8.self {
      var peek: Encoding.CodeUnit = 0
      while let u = i.next() {
        peek = u
        guard _fastPath(peek < 0x80) else { break }
        utf16Count = utf16Count + 1
      }
      if _fastPath(peek < 0x80) { return (utf16Count, true) }

      var d1 = UTF8.ForwardParser()
      d1._buffer.append(numericCast(peek))
      d = _identityCast(d1, to: Encoding.ForwardParser.self)
    }

    var utf16BitUnion: CodeUnit = 0
    while true {
      let s = d.parseScalar(from: &i)
      if _fastPath(s._valid != nil), let scalarContent = s._valid {
        let utf16 = transcode(scalarContent, from: sourceEncoding)
          ._unsafelyUnwrappedUnchecked
        utf16Count += utf16.count
        for x in utf16 { utf16BitUnion |= x }
      }
      else if let _ = s._error {
        guard _fastPath(repairingIllFormedSequences) else { return nil }
        utf16Count += 1
        utf16BitUnion |= UTF16._replacementCodeUnit
      }
      else {
        return (utf16Count, utf16BitUnion < 0x80)
      }
    }
  }
}
extension Swift.Unicode.UTF16 : Swift.Unicode.Encoding {
  public typealias CodeUnit = Swift.UInt16
  public typealias EncodedScalar = Swift._UIntBuffer<Swift.UInt16>
  @inlinable internal static var _replacementCodeUnit: Swift.Unicode.UTF16.CodeUnit {
    @inline(__always) get { return 0xfffd }
  }
  @inlinable public static var encodedReplacementCharacter: Swift.Unicode.UTF16.EncodedScalar {
    get {
    return EncodedScalar(_storage: 0xFFFD, _bitCount: 16)
  }
  }
  @_alwaysEmitIntoClient public static func isASCII(_ x: Swift.Unicode.UTF16.CodeUnit) -> Swift.Bool {
    return x <= 0x7f
  }
  @inlinable public static func _isScalar(_ x: Swift.Unicode.UTF16.CodeUnit) -> Swift.Bool {
    return x & 0xf800 != 0xd800
  }
  @inlinable @inline(__always) internal static func _decodeSurrogates(_ lead: Swift.Unicode.UTF16.CodeUnit, _ trail: Swift.Unicode.UTF16.CodeUnit) -> Swift.Unicode.Scalar {
    _internalInvariant(isLeadSurrogate(lead))
    _internalInvariant(isTrailSurrogate(trail))
    return Unicode.Scalar(
      _unchecked: 0x10000 +
        (UInt32(lead & 0x03ff) &<< 10 | UInt32(trail & 0x03ff)))
  }
  @inlinable public static func decode(_ source: Swift.Unicode.UTF16.EncodedScalar) -> Swift.Unicode.Scalar {
    let bits = source._storage
    if _fastPath(source._bitCount == 16) {
      return Unicode.Scalar(_unchecked: bits & 0xffff)
    }
    _internalInvariant(source._bitCount == 32)
    let lower: UInt32 = bits >> 16 & 0x03ff
    let upper: UInt32 = (bits & 0x03ff) << 10
    let value = 0x10000 + (lower | upper)
    return Unicode.Scalar(_unchecked: value)
  }
  @inlinable public static func encode(_ source: Swift.Unicode.Scalar) -> Swift.Unicode.UTF16.EncodedScalar? {
    let x = source.value
    if _fastPath(x < ((1 as UInt32) << 16)) {
      return EncodedScalar(_storage: x, _bitCount: 16)
    }
    let x1 = x - ((1 as UInt32) << 16)
    var r = (0xdc00 + (x1 & 0x3ff))
    r &<<= 16
    r |= (0xd800 + (x1 &>> 10 & 0x3ff))
    return EncodedScalar(_storage: r, _bitCount: 32)
  }
  @inlinable @inline(__always) public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Swift.Unicode.UTF16.EncodedScalar? where FromEncoding : Swift._UnicodeEncoding {
    if _fastPath(FromEncoding.self == UTF8.self) {
      let c = _identityCast(content, to: UTF8.EncodedScalar.self)
      var b = c.count
      b = b &- 1
      if _fastPath(b == 0) {
        return EncodedScalar(
          _storage: (c._biasedBits &- 0x1) & 0b0__111_1111, _bitCount: 16)
      }
      var s = c._biasedBits &- 0x01010101
      var r = s
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      b = b &- 1
      
      if _fastPath(b == 0) {
        return EncodedScalar(_storage: r & 0b0__111_1111_1111, _bitCount: 16)
      }
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      b = b &- 1
      
      if _fastPath(b == 0) {
        return EncodedScalar(_storage: r & 0xFFFF, _bitCount: 16)
      }
      
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      r &= (1 &<< 21) - 1
      return encode(Unicode.Scalar(_unchecked: r))
    }
    else if _fastPath(FromEncoding.self == UTF16.self) {
      return unsafeBitCast(content, to: UTF16.EncodedScalar.self)
    }
    return encode(FromEncoding.decode(content))
  }
  @frozen public struct ForwardParser : Swift.Sendable {
    public typealias _Buffer = Swift._UIntBuffer<Swift.UInt16>
    public var _buffer: Swift.Unicode.UTF16.ForwardParser._Buffer
    @inlinable public init() { _buffer = _Buffer() }
  }
  @frozen public struct ReverseParser : Swift.Sendable {
    public typealias _Buffer = Swift._UIntBuffer<Swift.UInt16>
    public var _buffer: Swift.Unicode.UTF16.ReverseParser._Buffer
    @inlinable public init() { _buffer = _Buffer() }
  }
}
extension Swift.Unicode.UTF16.ReverseParser : Swift.Unicode.Parser, Swift._UTFParser {
  public typealias Encoding = Swift.Unicode.UTF16
  @inlinable public func _parseMultipleCodeUnits() -> (isValid: Swift.Bool, bitCount: Swift.UInt8) {
    _internalInvariant(   
      !Encoding._isScalar(UInt16(truncatingIfNeeded: _buffer._storage)))
    if _fastPath(_buffer._storage & 0xFC00_FC00 == 0xD800_DC00) {
      return (true, 2*16)
    }
    return (false, 1*16)
  }
  @inlinable public func _bufferedScalar(bitCount: Swift.UInt8) -> Swift.Unicode.UTF16.ReverseParser.Encoding.EncodedScalar {
    return Encoding.EncodedScalar(
      _storage:
        (_buffer._storage &<< 16 | _buffer._storage &>> 16) &>> (32 - bitCount),
      _bitCount: bitCount
    )
  }
}
extension Swift.Unicode.UTF16.ForwardParser : Swift.Unicode.Parser, Swift._UTFParser {
  public typealias Encoding = Swift.Unicode.UTF16
  @inlinable public func _parseMultipleCodeUnits() -> (isValid: Swift.Bool, bitCount: Swift.UInt8) {
    _internalInvariant(   
      !Encoding._isScalar(UInt16(truncatingIfNeeded: _buffer._storage)))
    if _fastPath(_buffer._storage & 0xFC00_FC00 == 0xDC00_D800) {
      return (true, 2*16)
    }
    return (false, 1*16)
  }
  @inlinable public func _bufferedScalar(bitCount: Swift.UInt8) -> Swift.Unicode.UTF16.ForwardParser.Encoding.EncodedScalar {
    var r = _buffer
    r._bitCount = bitCount
    return r
  }
}
extension Swift.Unicode {
  @frozen public enum UTF32 : Swift.Sendable {
    case _swift3Codec
    public static func == (a: Swift.Unicode.UTF32, b: Swift.Unicode.UTF32) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Swift.Unicode.UTF32 : Swift.Unicode.Encoding {
  public typealias CodeUnit = Swift.UInt32
  public typealias EncodedScalar = Swift.CollectionOfOne<Swift.UInt32>
  @inlinable internal static var _replacementCodeUnit: Swift.Unicode.UTF32.CodeUnit {
    @inline(__always) get { return 0xFFFD }
  }
  @inlinable public static var encodedReplacementCharacter: Swift.Unicode.UTF32.EncodedScalar {
    get {
    return EncodedScalar(_replacementCodeUnit)
  }
  }
  @inlinable @inline(__always) public static func _isScalar(_ x: Swift.Unicode.UTF32.CodeUnit) -> Swift.Bool {
    return true
  }
  @_alwaysEmitIntoClient public static func isASCII(_ x: Swift.Unicode.UTF32.CodeUnit) -> Swift.Bool {
    return x <= 0x7F
  }
  @inlinable @inline(__always) public static func decode(_ source: Swift.Unicode.UTF32.EncodedScalar) -> Swift.Unicode.Scalar {
    return Unicode.Scalar(_unchecked: source.first!)
  }
  @inlinable @inline(__always) public static func encode(_ source: Swift.Unicode.Scalar) -> Swift.Unicode.UTF32.EncodedScalar? {
    return EncodedScalar(source.value)
  }
  @frozen public struct Parser : Swift.Sendable {
    @inlinable public init() { }
  }
  public typealias ForwardParser = Swift.Unicode.UTF32.Parser
  public typealias ReverseParser = Swift.Unicode.UTF32.Parser
}
extension Swift.Unicode.UTF32.Parser : Swift.Unicode.Parser {
  public typealias Encoding = Swift.Unicode.UTF32
  @inlinable public mutating func parseScalar<I>(from input: inout I) -> Swift.Unicode.ParseResult<Swift.Unicode.UTF32.Parser.Encoding.EncodedScalar> where I : Swift.IteratorProtocol, I.Element == Swift.UInt32 {
    let n = input.next()
    if _fastPath(n != nil), let x = n {
       
      guard _fastPath((x &>> 11) != 0b1101_1 && x <= 0x10ffff)
      else { return .error(length: 1) }
      
       
      return .valid(UTF32.EncodedScalar(x))
    }
    return .emptyInput
  }
}
@frozen public enum UnicodeDecodingResult : Swift.Equatable, Swift.Sendable {
  case scalarValue(Swift.Unicode.Scalar)
  case emptyInput
  case error
  @inlinable public static func == (lhs: Swift.UnicodeDecodingResult, rhs: Swift.UnicodeDecodingResult) -> Swift.Bool {
    switch (lhs, rhs) {
    case (.scalarValue(let lhsScalar), .scalarValue(let rhsScalar)):
      return lhsScalar == rhsScalar
    case (.emptyInput, .emptyInput):
      return true
    case (.error, .error):
      return true
    default:
      return false
    }
  }
}
public protocol UnicodeCodec : Swift._UnicodeEncoding {
  init()
  mutating func decode<I>(_ input: inout I) -> Swift.UnicodeDecodingResult where I : Swift.IteratorProtocol, Self.CodeUnit == I.Element
  static func encode(_ input: Swift.Unicode.Scalar, into processCodeUnit: (Self.CodeUnit) -> Swift.Void)
  static func _nullCodeUnitOffset(in input: Swift.UnsafePointer<Self.CodeUnit>) -> Swift.Int
}
extension Swift.Unicode.UTF8 : Swift.UnicodeCodec {
  @inlinable public init() { self = ._swift3Buffer(ForwardParser()) }
  @inlinable @inline(__always) public mutating func decode<I>(_ input: inout I) -> Swift.UnicodeDecodingResult where I : Swift.IteratorProtocol, I.Element == Swift.UInt8 {
    guard case ._swift3Buffer(var parser) = self else {
      Builtin.unreachable()
    }
    defer { self = ._swift3Buffer(parser) }

    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF8.decode(s))
    case .error: return .error
    case .emptyInput: return .emptyInput
    }
  }
  @inlinable public static func _decodeOne(_ buffer: Swift.UInt32) -> (result: Swift.UInt32?, length: Swift.UInt8) {
     

    if buffer & 0x80 == 0 {  
      let value = buffer & 0xff
      return (value, 1)
    }
    var p = ForwardParser()
    p._buffer._storage = buffer
    p._buffer._bitCount = 32
    var i = EmptyCollection<UInt8>().makeIterator()
    switch p.parseScalar(from: &i) {
    case .valid(let s):
      return (
        result: UTF8.decode(s).value,
        length: UInt8(truncatingIfNeeded: s.count))
    case .error(let l):
      return (result: nil, length: UInt8(truncatingIfNeeded: l))
    case .emptyInput: Builtin.unreachable()
    }
  }
  @inlinable @inline(__always) public static func encode(_ input: Swift.Unicode.Scalar, into processCodeUnit: (Swift.Unicode.UTF8.CodeUnit) -> Swift.Void) {
    var s = encode(input)!._biasedBits
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
  }
  @inlinable public static func isContinuation(_ byte: Swift.Unicode.UTF8.CodeUnit) -> Swift.Bool {
    return byte & 0b11_00__0000 == 0b10_00__0000
  }
  @inlinable public static func _nullCodeUnitOffset(in input: Swift.UnsafePointer<Swift.Unicode.UTF8.CodeUnit>) -> Swift.Int {
    return Int(_swift_stdlib_strlen_unsigned(input))
  }
  @inlinable public static func _nullCodeUnitOffset(in input: Swift.UnsafePointer<Swift.CChar>) -> Swift.Int {
    return Int(_swift_stdlib_strlen(input))
  }
}
extension Swift.Unicode.UTF16 : Swift.UnicodeCodec {
  @inlinable public init() { self = ._swift3Buffer(ForwardParser()) }
  @inlinable public mutating func decode<I>(_ input: inout I) -> Swift.UnicodeDecodingResult where I : Swift.IteratorProtocol, I.Element == Swift.UInt16 {
    guard case ._swift3Buffer(var parser) = self else {
      Builtin.unreachable()
    }
    defer { self = ._swift3Buffer(parser) }
    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF16.decode(s))
    case .error: return .error
    case .emptyInput: return .emptyInput
    }
  }
  @inlinable internal mutating func _decodeOne<I>(_ input: inout I) -> (Swift.UnicodeDecodingResult, Swift.Int) where I : Swift.IteratorProtocol, I.Element == Swift.UInt16 {
    let result = decode(&input)
    switch result {
    case .scalarValue(let us):
      return (result, UTF16.width(us))

    case .emptyInput:
      return (result, 0)

    case .error:
      return (result, 1)
    }
  }
  @inlinable public static func encode(_ input: Swift.Unicode.Scalar, into processCodeUnit: (Swift.Unicode.UTF16.CodeUnit) -> Swift.Void) {
    var s = encode(input)!._storage
    processCodeUnit(UInt16(truncatingIfNeeded: s))
    s &>>= 16
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt16(truncatingIfNeeded: s))
  }
}
extension Swift.Unicode.UTF32 : Swift.UnicodeCodec {
  @inlinable public init() { self = ._swift3Codec }
  @inlinable public mutating func decode<I>(_ input: inout I) -> Swift.UnicodeDecodingResult where I : Swift.IteratorProtocol, I.Element == Swift.UInt32 {
    var parser = ForwardParser()
    
    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF32.decode(s))
    case .error:      return .error
    case .emptyInput:   return .emptyInput
    }
  }
  @inlinable public static func encode(_ input: Swift.Unicode.Scalar, into processCodeUnit: (Swift.Unicode.UTF32.CodeUnit) -> Swift.Void) {
    processCodeUnit(UInt32(input))
  }
}
@inlinable @inline(__always) public func transcode<Input, InputEncoding, OutputEncoding>(_ input: Input, from inputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Swift.Bool, into processCodeUnit: (OutputEncoding.CodeUnit) -> Swift.Void) -> Swift.Bool where Input : Swift.IteratorProtocol, InputEncoding : Swift._UnicodeEncoding, OutputEncoding : Swift._UnicodeEncoding, Input.Element == InputEncoding.CodeUnit {
  var input = input

   
   
   

  var p = InputEncoding.ForwardParser()
  var hadError = false
  loop:
  while true {
    switch p.parseScalar(from: &input) {
    case .valid(let s):
      let t = OutputEncoding.transcode(s, from: inputEncoding)
      guard _fastPath(t != nil), let s = t else { break }
      s.forEach(processCodeUnit)
      continue loop
    case .emptyInput:
      return hadError
    case .error:
      if _slowPath(stopOnError) { return true }
      hadError = true
    }
    OutputEncoding.encodedReplacementCharacter.forEach(processCodeUnit)
  }
}
public protocol _StringElement {
  static func _toUTF16CodeUnit(_: Self) -> Swift.UTF16.CodeUnit
  static func _fromUTF16CodeUnit(_ utf16: Swift.UTF16.CodeUnit) -> Self
}
extension Swift.UInt16 : Swift._StringElement {
  @inlinable public static func _toUTF16CodeUnit(_ x: Swift.UTF16.CodeUnit) -> Swift.UTF16.CodeUnit {
    return x
  }
  @inlinable public static func _fromUTF16CodeUnit(_ utf16: Swift.UTF16.CodeUnit) -> Swift.UTF16.CodeUnit {
    return utf16
  }
}
extension Swift.UInt8 : Swift._StringElement {
  @inlinable public static func _toUTF16CodeUnit(_ x: Swift.UTF8.CodeUnit) -> Swift.UTF16.CodeUnit {
    _internalInvariant(x <= 0x7f, "should only be doing this with ASCII")
    return UTF16.CodeUnit(truncatingIfNeeded: x)
  }
  @inlinable public static func _fromUTF16CodeUnit(_ utf16: Swift.UTF16.CodeUnit) -> Swift.UTF8.CodeUnit {
    _internalInvariant(utf16 <= 0x7f, "should only be doing this with ASCII")
    return UTF8.CodeUnit(truncatingIfNeeded: utf16)
  }
}
extension Swift.Unicode.Scalar {
  @inlinable internal init(_unchecked value: Swift.UInt32) {
    _internalInvariant(value < 0xD800 || value > 0xDFFF,
      "high- and low-surrogate code points are not valid Unicode scalar values")
    _internalInvariant(value <= 0x10FFFF, "value is outside of Unicode codespace")

    self._value = value
  }
}
extension Swift.UnicodeCodec {
  @inlinable public static func _nullCodeUnitOffset(in input: Swift.UnsafePointer<Self.CodeUnit>) -> Swift.Int {
    var length = 0
    while input[length] != 0 {
      length += 1
    }
    return length
  }
}
@available(*, unavailable, message: "use 'transcode(_:from:to:stoppingOnError:into:)'")
public func transcode<Input, InputEncoding, OutputEncoding>(_ inputEncoding: InputEncoding.Type, _ outputEncoding: OutputEncoding.Type, _ input: Input, _ output: (OutputEncoding.CodeUnit) -> Swift.Void, stopOnError: Swift.Bool) -> Swift.Bool where Input : Swift.IteratorProtocol, InputEncoding : Swift.UnicodeCodec, OutputEncoding : Swift.UnicodeCodec, Input.Element == InputEncoding.CodeUnit
#if compiler(>=5.3) && $ConformanceSuppression
@frozen public enum Unicode : ~Swift.BitwiseCopyable {
}
#else
@frozen public enum Unicode {
}
#endif
extension Swift._StringGuts {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func isOnGraphemeClusterBoundary(_ i: Swift.String.Index) -> Swift.Bool
}
extension Swift._StringGuts {
  @usableFromInline
  @inline(__always) @_effects(releasenone) internal func _opaqueCharacterStride(startingAt i: Swift.Int) -> Swift.Int
  @usableFromInline
  @inline(__always) @_effects(releasenone) internal func _opaqueCharacterStride(endingAt i: Swift.Int) -> Swift.Int
}
extension Swift.Unicode {
  @available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
  public struct _CharacterRecognizer : Swift.Sendable {
    @_effects(releasenone) public static func quickBreak(between scalar1: Swift.Unicode.Scalar, and scalar2: Swift.Unicode.Scalar) -> Swift.Bool?
    public init()
    @_effects(releasenone) public mutating func hasBreak(before next: Swift.Unicode.Scalar) -> Swift.Bool
    @_effects(releasenone) public mutating func _firstBreak(inUncheckedUnsafeUTF8Buffer buffer: Swift.UnsafeBufferPointer<Swift.UInt8>, startingAt start: Swift.Int = 0) -> Swift.Range<Swift.Int>?
  }
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension Swift.Unicode._CharacterRecognizer : Swift.Equatable {
  public static func == (left: Swift.Unicode._CharacterRecognizer, right: Swift.Unicode._CharacterRecognizer) -> Swift.Bool
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension Swift.Unicode._CharacterRecognizer : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@frozen public struct _ValidUTF8Buffer {
  public typealias Element = Swift.Unicode.UTF8.CodeUnit
  @usableFromInline
  internal var _biasedBits: Swift.UInt32
  @inlinable internal init(_biasedBits: Swift.UInt32) {
    self._biasedBits = _biasedBits
  }
  @inlinable internal init(_containing e: Swift._ValidUTF8Buffer.Element) {
    _internalInvariant(
      e != 192 && e != 193 && !(245...255).contains(e), "invalid UTF8 byte")
    _biasedBits = UInt32(truncatingIfNeeded: e &+ 1)
  }
}
extension Swift._ValidUTF8Buffer : Swift.Sequence {
  public typealias SubSequence = Swift.Slice<Swift._ValidUTF8Buffer>
  @frozen public struct Iterator : Swift.IteratorProtocol, Swift.Sequence {
    @usableFromInline
    internal var _biasedBits: Swift.UInt32
    @inlinable public init(_ x: Swift._ValidUTF8Buffer) { _biasedBits = x._biasedBits }
    @inlinable public mutating func next() -> Swift._ValidUTF8Buffer.Element? {
      if _biasedBits == 0 { return nil }
      defer { _biasedBits >>= 8 }
      return Element(truncatingIfNeeded: _biasedBits) &- 1
    }
    public typealias Element = Swift._ValidUTF8Buffer.Element
    public typealias Iterator = Swift._ValidUTF8Buffer.Iterator
  }
  @inlinable public func makeIterator() -> Swift._ValidUTF8Buffer.Iterator {
    return Iterator(self)
  }
}
extension Swift._ValidUTF8Buffer : Swift.Collection {
  @frozen public struct Index : Swift.Comparable {
    @usableFromInline
    internal var _biasedBits: Swift.UInt32
    @inlinable internal init(_biasedBits: Swift.UInt32) { self._biasedBits = _biasedBits }
    @inlinable public static func == (lhs: Swift._ValidUTF8Buffer.Index, rhs: Swift._ValidUTF8Buffer.Index) -> Swift.Bool {
      return lhs._biasedBits == rhs._biasedBits
    }
    @inlinable public static func < (lhs: Swift._ValidUTF8Buffer.Index, rhs: Swift._ValidUTF8Buffer.Index) -> Swift.Bool {
      return lhs._biasedBits > rhs._biasedBits
    }
  }
  @inlinable public var startIndex: Swift._ValidUTF8Buffer.Index {
    get {
    return Index(_biasedBits: _biasedBits)
  }
  }
  @inlinable public var endIndex: Swift._ValidUTF8Buffer.Index {
    get {
    return Index(_biasedBits: 0)
  }
  }
  @inlinable public var count: Swift.Int {
    get {
    return UInt32.bitWidth &>> 3 &- _biasedBits.leadingZeroBitCount &>> 3
  }
  }
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return _biasedBits == 0
  }
  }
  @inlinable public func index(after i: Swift._ValidUTF8Buffer.Index) -> Swift._ValidUTF8Buffer.Index {
    _debugPrecondition(i._biasedBits != 0)
    return Index(_biasedBits: i._biasedBits >> 8)
  }
  @inlinable public subscript(i: Swift._ValidUTF8Buffer.Index) -> Swift._ValidUTF8Buffer.Element {
    get {
    return Element(truncatingIfNeeded: i._biasedBits) &- 1
  }
  }
}
extension Swift._ValidUTF8Buffer : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift._ValidUTF8Buffer.Index) -> Swift._ValidUTF8Buffer.Index {
    let offset = _ValidUTF8Buffer(_biasedBits: i._biasedBits).count
    _debugPrecondition(offset != 0)
    return Index(_biasedBits: _biasedBits &>> (offset &<< 3 - 8))
  }
}
extension Swift._ValidUTF8Buffer : Swift.RandomAccessCollection {
  public typealias Indices = Swift.DefaultIndices<Swift._ValidUTF8Buffer>
  @inlinable @inline(__always) public func distance(from i: Swift._ValidUTF8Buffer.Index, to j: Swift._ValidUTF8Buffer.Index) -> Swift.Int {
    _debugPrecondition(_isValid(i))
    _debugPrecondition(_isValid(j))
    return (
      i._biasedBits.leadingZeroBitCount - j._biasedBits.leadingZeroBitCount
    ) &>> 3
  }
  @inlinable @inline(__always) public func index(_ i: Swift._ValidUTF8Buffer.Index, offsetBy n: Swift.Int) -> Swift._ValidUTF8Buffer.Index {
    let startOffset = distance(from: startIndex, to: i)
    let newOffset = startOffset + n
    _debugPrecondition(newOffset >= 0)
    _debugPrecondition(newOffset <= count)
    return Index(_biasedBits: _biasedBits._fullShiftRight(newOffset &<< 3))
  }
}
extension Swift._ValidUTF8Buffer : Swift.RangeReplaceableCollection {
  @inlinable public init() {
    _biasedBits = 0
  }
  @inlinable public var capacity: Swift.Int {
    get {
    return _ValidUTF8Buffer.capacity
  }
  }
  @inlinable public static var capacity: Swift.Int {
    get {
    return UInt32.bitWidth / Element.bitWidth
  }
  }
  @inlinable @inline(__always) public mutating func append(_ e: Swift._ValidUTF8Buffer.Element) {
    _debugPrecondition(count + 1 <= capacity)
    _internalInvariant(
      e != 192 && e != 193 && !(245...255).contains(e), "invalid UTF8 byte")
    _biasedBits |= UInt32(e &+ 1) &<< (count &<< 3)
  }
  @discardableResult
  @inlinable @inline(__always) public mutating func removeFirst() -> Swift._ValidUTF8Buffer.Element {
    _debugPrecondition(!isEmpty)
    let result = Element(truncatingIfNeeded: _biasedBits) &- 1
    _biasedBits = _biasedBits._fullShiftRight(8)
    return result
  }
  @inlinable internal func _isValid(_ i: Swift._ValidUTF8Buffer.Index) -> Swift.Bool {
    return i == endIndex || indices.contains(i)
  }
  @inlinable @inline(__always) public mutating func replaceSubrange<C>(_ target: Swift.Range<Swift._ValidUTF8Buffer.Index>, with replacement: C) where C : Swift.Collection, C.Element == Swift.UInt8 {
    _debugPrecondition(_isValid(target.lowerBound))
    _debugPrecondition(_isValid(target.upperBound))
    var r = _ValidUTF8Buffer()
    for x in self[..<target.lowerBound] { r.append(x) }
    for x in replacement                { r.append(x) }
    for x in self[target.upperBound...] { r.append(x) }
    self = r
  }
}
extension Swift._ValidUTF8Buffer {
  @inlinable @inline(__always) public mutating func append(contentsOf other: Swift._ValidUTF8Buffer) {
    _debugPrecondition(count + other.count <= capacity)
    _biasedBits |= UInt32(
      truncatingIfNeeded: other._biasedBits) &<< (count &<< 3)
  }
}
extension Swift._ValidUTF8Buffer {
  @inlinable public static var encodedReplacementCharacter: Swift._ValidUTF8Buffer {
    get {
    return _ValidUTF8Buffer(_biasedBits: 0xBD_BF_EF &+ 0x01_01_01)
  }
  }
  @inlinable internal var _bytes: (bytes: Swift.UInt64, count: Swift.Int) {
    get {
    let count = self.count
    let mask: UInt64 = 1 &<< (UInt64(truncatingIfNeeded: count) &<< 3) &- 1
    let unbiased = UInt64(truncatingIfNeeded: _biasedBits) &- 0x0101010101010101
    return (unbiased & mask, count)
  }
  }
}
@inlinable internal func _writeBackMutableSlice<C, Slice_>(_ self_: inout C, bounds: Swift.Range<C.Index>, slice: Slice_) where C : Swift.MutableCollection, Slice_ : Swift.Collection, C.Element == Slice_.Element, C.Index == Slice_.Index {

  self_._failEarlyRangeCheck(bounds, bounds: self_.startIndex..<self_.endIndex)

   
   
   

  var selfElementIndex = bounds.lowerBound
  let selfElementsEndIndex = bounds.upperBound
  var newElementIndex = slice.startIndex
  let newElementsEndIndex = slice.endIndex

  while selfElementIndex != selfElementsEndIndex &&
    newElementIndex != newElementsEndIndex {

    self_[selfElementIndex] = slice[newElementIndex]
    self_.formIndex(after: &selfElementIndex)
    slice.formIndex(after: &newElementIndex)
  }

  _precondition(
    selfElementIndex == selfElementsEndIndex,
    "Cannot replace a slice of a MutableCollection with a slice of a smaller size")
  _precondition(
    newElementIndex == newElementsEndIndex,
    "Cannot replace a slice of a MutableCollection with a slice of a larger size")
}
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "BidirectionalCollection")
public typealias BidirectionalIndexable = Swift.BidirectionalCollection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "Collection")
public typealias IndexableBase = Swift.Collection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "Collection")
public typealias Indexable = Swift.Collection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "MutableCollection")
public typealias MutableIndexable = Swift.MutableCollection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "RandomAccessCollection")
public typealias RandomAccessIndexable = Swift.RandomAccessCollection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "RangeReplaceableIndexable")
public typealias RangeReplaceableIndexable = Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.2, renamed: "EnumeratedSequence.Iterator")
public typealias EnumeratedIterator<T> = Swift.EnumeratedSequence<T>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "CollectionOfOne.Iterator")
public typealias IteratorOverOne<T> = Swift.CollectionOfOne<T>.Iterator
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "EmptyCollection.Iterator")
public typealias EmptyIterator<T> = Swift.EmptyCollection<T>.Iterator
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyFilterSequence.Iterator")
public typealias LazyFilterIterator<T> = Swift.LazyFilterSequence<T>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 3.1, obsoleted: 5.0, message: "Use Base.Index")
public typealias LazyFilterIndex<Base> = Base.Index where Base : Swift.Collection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyDropWhileSequence.Iterator")
public typealias LazyDropWhileIterator<T> = Swift.LazyDropWhileSequence<T>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyDropWhileCollection.Index")
public typealias LazyDropWhileIndex<T> = Swift.LazyDropWhileCollection<T>.Index where T : Swift.Collection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyDropWhileCollection")
public typealias LazyDropWhileBidirectionalCollection<T> = Swift.LazyDropWhileCollection<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyFilterCollection")
public typealias LazyFilterBidirectionalCollection<T> = Swift.LazyFilterCollection<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyMapSequence.Iterator")
public typealias LazyMapIterator<T, E> = Swift.LazyMapSequence<T, E>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyMapCollection")
public typealias LazyMapBidirectionalCollection<T, E> = Swift.LazyMapCollection<T, E> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyMapCollection")
public typealias LazyMapRandomAccessCollection<T, E> = Swift.LazyMapCollection<T, E> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyCollection")
public typealias LazyBidirectionalCollection<T> = Swift.LazyCollection<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyCollection")
public typealias LazyRandomAccessCollection<T> = Swift.LazyCollection<T> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "FlattenCollection.Index")
public typealias FlattenCollectionIndex<T> = Swift.FlattenCollection<T>.Index where T : Swift.Collection, T.Element : Swift.Collection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "FlattenCollection.Index")
public typealias FlattenBidirectionalCollectionIndex<T> = Swift.FlattenCollection<T>.Index where T : Swift.BidirectionalCollection, T.Element : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "FlattenCollection")
public typealias FlattenBidirectionalCollection<T> = Swift.FlattenCollection<T> where T : Swift.BidirectionalCollection, T.Element : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "JoinedSequence.Iterator")
public typealias JoinedIterator<T> = Swift.JoinedSequence<T>.Iterator where T : Swift.Sequence, T.Element : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "Zip2Sequence.Iterator")
public typealias Zip2Iterator<T, U> = Swift.Zip2Sequence<T, U>.Iterator where T : Swift.Sequence, U : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyPrefixWhileSequence.Iterator")
public typealias LazyPrefixWhileIterator<T> = Swift.LazyPrefixWhileSequence<T>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyPrefixWhileCollection.Index")
public typealias LazyPrefixWhileIndex<T> = Swift.LazyPrefixWhileCollection<T>.Index where T : Swift.Collection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyPrefixWhileCollection")
public typealias LazyPrefixWhileBidirectionalCollection<T> = Swift.LazyPrefixWhileCollection<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "ReversedCollection")
public typealias ReversedRandomAccessCollection<T> = Swift.ReversedCollection<T> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "ReversedCollection.Index")
public typealias ReversedIndex<T> = Swift.ReversedCollection<T>.Index where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias BidirectionalSlice<T> = Swift.Slice<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias RandomAccessSlice<T> = Swift.Slice<T> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias RangeReplaceableSlice<T> = Swift.Slice<T> where T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias RangeReplaceableBidirectionalSlice<T> = Swift.Slice<T> where T : Swift.BidirectionalCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias RangeReplaceableRandomAccessSlice<T> = Swift.Slice<T> where T : Swift.RandomAccessCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableSlice<T> = Swift.Slice<T> where T : Swift.MutableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableBidirectionalSlice<T> = Swift.Slice<T> where T : Swift.BidirectionalCollection, T : Swift.MutableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableRandomAccessSlice<T> = Swift.Slice<T> where T : Swift.MutableCollection, T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableRangeReplaceableSlice<T> = Swift.Slice<T> where T : Swift.MutableCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableRangeReplaceableBidirectionalSlice<T> = Swift.Slice<T> where T : Swift.BidirectionalCollection, T : Swift.MutableCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableRangeReplaceableRandomAccessSlice<T> = Swift.Slice<T> where T : Swift.MutableCollection, T : Swift.RandomAccessCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "DefaultIndices")
public typealias DefaultBidirectionalIndices<T> = Swift.DefaultIndices<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "DefaultIndices")
public typealias DefaultRandomAccessIndices<T> = Swift.DefaultIndices<T> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByNilLiteral")
public typealias NilLiteralConvertible = Swift.ExpressibleByNilLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinIntegerLiteral")
public typealias _BuiltinIntegerLiteralConvertible = Swift._ExpressibleByBuiltinIntegerLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByIntegerLiteral")
public typealias IntegerLiteralConvertible = Swift.ExpressibleByIntegerLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinFloatLiteral")
public typealias _BuiltinFloatLiteralConvertible = Swift._ExpressibleByBuiltinFloatLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByFloatLiteral")
public typealias FloatLiteralConvertible = Swift.ExpressibleByFloatLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinBooleanLiteral")
public typealias _BuiltinBooleanLiteralConvertible = Swift._ExpressibleByBuiltinBooleanLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByBooleanLiteral")
public typealias BooleanLiteralConvertible = Swift.ExpressibleByBooleanLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinUnicodeScalarLiteral")
public typealias _BuiltinUnicodeScalarLiteralConvertible = Swift._ExpressibleByBuiltinUnicodeScalarLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByUnicodeScalarLiteral")
public typealias UnicodeScalarLiteralConvertible = Swift.ExpressibleByUnicodeScalarLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinExtendedGraphemeClusterLiteral")
public typealias _BuiltinExtendedGraphemeClusterLiteralConvertible = Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByExtendedGraphemeClusterLiteral")
public typealias ExtendedGraphemeClusterLiteralConvertible = Swift.ExpressibleByExtendedGraphemeClusterLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinStringLiteral")
public typealias _BuiltinStringLiteralConvertible = Swift._ExpressibleByBuiltinStringLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByStringLiteral")
public typealias StringLiteralConvertible = Swift.ExpressibleByStringLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByArrayLiteral")
public typealias ArrayLiteralConvertible = Swift.ExpressibleByArrayLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByDictionaryLiteral")
public typealias DictionaryLiteralConvertible = Swift.ExpressibleByDictionaryLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByStringInterpolation")
public typealias StringInterpolationConvertible = Swift.ExpressibleByStringInterpolation
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByColorLiteral")
public typealias _ColorLiteralConvertible = Swift._ExpressibleByColorLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByImageLiteral")
public typealias _ImageLiteralConvertible = Swift._ExpressibleByImageLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByFileReferenceLiteral")
public typealias _FileReferenceLiteralConvertible = Swift._ExpressibleByFileReferenceLiteral
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "ClosedRange.Index")
public typealias ClosedRangeIndex<T> = Swift.ClosedRange<T>.Index where T : Swift.Strideable, T.Stride : Swift.SignedInteger
@available(*, unavailable, renamed: "Optional")
public typealias ImplicitlyUnwrappedOptional<Wrapped> = Swift.Optional<Wrapped>
extension Swift.Range where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  @available(swift, deprecated: 4.2, obsoleted: 5.0, message: "CountableRange is now a Range. No need to convert any more.")
  public init(_ other: Swift.Range<Bound>)
}
extension Swift.ClosedRange where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  @available(swift, deprecated: 4.2, obsoleted: 5.0, message: "CountableClosedRange is now a ClosedRange. No need to convert any more.")
  public init(_ other: Swift.ClosedRange<Bound>)
}
@available(swift, deprecated: 5.0, renamed: "KeyValuePairs")
public typealias DictionaryLiteral<Key, Value> = Swift.KeyValuePairs<Key, Value>
extension Swift.LazySequenceProtocol {
  @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
  public func flatMap<ElementOfResult>(_ transform: @escaping (Self.Elements.Element) -> ElementOfResult?) -> Swift.LazyMapSequence<Swift.LazyFilterSequence<Swift.LazyMapSequence<Self.Elements, ElementOfResult?>>, ElementOfResult>
}
extension Swift.String {
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please use String directly")
  public typealias CharacterView = Swift.String
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please use String directly")
  public var characters: Swift.String {
    get
    set
  }
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please mutate the String directly")
  public mutating func withMutableCharacters<R>(_ body: (inout Swift.String) -> R) -> R
}
extension Swift.String.UnicodeScalarView : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnicodeScalarView.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
public typealias UTF8 = Swift.Unicode.UTF8
public typealias UTF16 = Swift.Unicode.UTF16
public typealias UTF32 = Swift.Unicode.UTF32
public typealias UnicodeScalar = Swift.Unicode.Scalar
extension Swift.String.UTF16View : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UTF16View.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.String.UTF8View : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UTF8View.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.Substring {
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please use Substring directly")
  public typealias CharacterView = Swift.Substring
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please use Substring directly")
  public var characters: Swift.Substring {
    get
    set
  }
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please mutate the Substring directly")
  public mutating func withMutableCharacters<R>(_ body: (inout Swift.Substring) -> R) -> R
}
extension Swift.Substring : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "Substring.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.Collection {
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func index<T>(_ i: Self.Index, offsetBy n: T) -> Self.Index where T : Swift.BinaryInteger
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func formIndex<T>(_ i: inout Self.Index, offsetBy n: T) where T : Swift.BinaryInteger
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func index<T>(_ i: Self.Index, offsetBy n: T, limitedBy limit: Self.Index) -> Self.Index? where T : Swift.BinaryInteger
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func formIndex<T>(_ i: inout Self.Index, offsetBy n: T, limitedBy limit: Self.Index) -> Swift.Bool where T : Swift.BinaryInteger
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func distance<T>(from start: Self.Index, to end: Self.Index) -> T where T : Swift.BinaryInteger
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer {
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "initialize(repeating:count:)")
  public func initialize(to newValue: Pointee, count: Swift.Int = 1)
  @available(swift, deprecated: 4.1, obsoleted: 5.0, message: "the default argument to deinitialize(count:) has been removed, please specify the count explicitly")
  @discardableResult
  public func deinitialize() -> Swift.UnsafeMutableRawPointer
  @available(swift, deprecated: 4.1, obsoleted: 5.0, message: "Swift currently only supports freeing entire heap blocks, use deallocate() instead")
  public func deallocate(capacity _: Swift.Int)
  @available(swift, deprecated: 4.2, obsoleted: 5.0, message: "it will be removed in Swift 5.0.  Please use 'UnsafeMutableBufferPointer.initialize(from:)' instead")
  public func initialize<C>(from source: C) where Pointee == C.Element, C : Swift.Collection
}
#else
extension Swift.UnsafeMutablePointer {
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "initialize(repeating:count:)")
  public func initialize(to newValue: Pointee, count: Swift.Int = 1)
  @available(swift, deprecated: 4.1, obsoleted: 5.0, message: "the default argument to deinitialize(count:) has been removed, please specify the count explicitly")
  @discardableResult
  public func deinitialize() -> Swift.UnsafeMutableRawPointer
  @available(swift, deprecated: 4.1, obsoleted: 5.0, message: "Swift currently only supports freeing entire heap blocks, use deallocate() instead")
  public func deallocate(capacity _: Swift.Int)
  @available(swift, deprecated: 4.2, obsoleted: 5.0, message: "it will be removed in Swift 5.0.  Please use 'UnsafeMutableBufferPointer.initialize(from:)' instead")
  public func initialize<C>(from source: C) where Pointee == C.Element, C : Swift.Collection
}
#endif
extension Swift.UnsafeMutableRawPointer {
  @available(*, unavailable, renamed: "init(mutating:)")
  public init(@_nonEphemeral _ from: Swift.UnsafeRawPointer)
  @available(*, unavailable, renamed: "init(mutating:)")
  public init?(@_nonEphemeral _ from: Swift.UnsafeRawPointer?)
  @available(*, unavailable, renamed: "init(mutating:)")
  public init<T>(@_nonEphemeral _ from: Swift.UnsafePointer<T>)
  @available(*, unavailable, renamed: "init(mutating:)")
  public init?<T>(@_nonEphemeral _ from: Swift.UnsafePointer<T>?)
}
extension Swift.UnsafeRawPointer : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafeRawPointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Swift.UnsafeMutableRawPointer : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafeMutableRawPointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafePointer : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafePointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
#else
extension Swift.UnsafePointer : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafePointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafeMutablePointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
#else
extension Swift.UnsafeMutablePointer : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafeMutablePointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
#endif
@available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "UnsafeBufferPointer.Iterator")
public typealias UnsafeBufferPointerIterator<T> = Swift.UnsafeBufferPointer<T>.Iterator
@available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "UnsafeRawBufferPointer.Iterator")
public typealias UnsafeRawBufferPointerIterator<T> = Swift.UnsafeBufferPointer<T>.Iterator
@available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "UnsafeRawBufferPointer.Iterator")
public typealias UnsafeMutableRawBufferPointerIterator<T> = Swift.UnsafeBufferPointer<T>.Iterator
extension Swift.UnsafeMutableRawPointer {
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "allocate(byteCount:alignment:)")
  public static func allocate(bytes size: Swift.Int, alignedTo alignment: Swift.Int) -> Swift.UnsafeMutableRawPointer
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "deallocate()", message: "Swift currently only supports freeing entire heap blocks, use deallocate() instead")
  public func deallocate(bytes _: Swift.Int, alignedTo _: Swift.Int)
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "copyMemory(from:byteCount:)")
  public func copyBytes(from source: Swift.UnsafeRawPointer, count: Swift.Int)
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "initializeMemory(as:repeating:count:)")
  @discardableResult
  public func initializeMemory<T>(as type: T.Type, at offset: Swift.Int = 0, count: Swift.Int = 1, to repeatedValue: T) -> Swift.UnsafeMutablePointer<T>
  @available(swift, deprecated: 4.1, obsoleted: 5.0, message: "it will be removed in Swift 5.0.  Please use 'UnsafeMutableRawBufferPointer.initialize(from:)' instead")
  @discardableResult
  public func initializeMemory<C>(as type: C.Element.Type, from source: C) -> Swift.UnsafeMutablePointer<C.Element> where C : Swift.Collection
}
extension Swift.UnsafeMutableRawBufferPointer {
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "allocate(byteCount:alignment:)")
  public static func allocate(count: Swift.Int) -> Swift.UnsafeMutableRawBufferPointer
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "copyMemory(from:)")
  public func copyBytes(from source: Swift.UnsafeRawBufferPointer)
}
extension Swift.Sequence {
  @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
  public func flatMap<ElementOfResult>(_ transform: (Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]
}
extension Swift.Collection {
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
  public func flatMap(_ transform: (Self.Element) throws -> Swift.String?) rethrows -> [Swift.String]
}
extension Swift.Collection {
  @available(swift, deprecated: 5.0, renamed: "firstIndex(where:)")
  @inlinable public func index(where _predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index? {
    return try firstIndex(where: _predicate)
  }
}
extension Swift.Collection where Self.Element : Swift.Equatable {
  @available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
  @inlinable public func index(of element: Self.Element) -> Self.Index? {
    return firstIndex(of: element)
  }
}
extension Swift.Zip2Sequence {
  @available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "Sequence1.Iterator")
  public typealias Stream1 = Sequence1.Iterator
  @available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "Sequence2.Iterator")
  public typealias Stream2 = Sequence2.Iterator
}
@available(swift, deprecated: 4.2, message: "PlaygroundQuickLook will be removed in a future Swift version. For customizing how types are presented in playgrounds, use CustomPlaygroundDisplayConvertible instead.")
public typealias PlaygroundQuickLook = Swift._PlaygroundQuickLook
@frozen public enum _PlaygroundQuickLook {
  case text(Swift.String)
  case int(Swift.Int64)
  case uInt(Swift.UInt64)
  case float(Swift.Float32)
  case double(Swift.Float64)
  case image(Any)
  case sound(Any)
  case color(Any)
  case bezierPath(Any)
  case attributedString(Any)
  case rectangle(Swift.Float64, Swift.Float64, Swift.Float64, Swift.Float64)
  case point(Swift.Float64, Swift.Float64)
  case size(Swift.Float64, Swift.Float64)
  case bool(Swift.Bool)
  case range(Swift.Int64, Swift.Int64)
  case view(Any)
  case sprite(Any)
  case url(Swift.String)
  case _raw([Swift.UInt8], Swift.String)
}
@available(*, unavailable)
extension Swift._PlaygroundQuickLook : Swift.Sendable {
}
extension Swift._PlaygroundQuickLook {
  @available(swift, deprecated: 4.2, obsoleted: 5.0, message: "PlaygroundQuickLook will be removed in a future Swift version.")
  public init(reflecting subject: Any)
}
@available(swift, deprecated: 4.2, obsoleted: 5.0, message: "CustomPlaygroundQuickLookable will be removed in a future Swift version. For customizing how types are presented in playgrounds, use CustomPlaygroundDisplayConvertible instead.")
public typealias CustomPlaygroundQuickLookable = Swift._CustomPlaygroundQuickLookable
public protocol _CustomPlaygroundQuickLookable {
  var customPlaygroundQuickLook: Swift._PlaygroundQuickLook { get }
}
@available(swift, deprecated: 4.2, obsoleted: 5.0, message: "_DefaultCustomPlaygroundQuickLookable will be removed in a future Swift version. For customizing how types are presented in playgrounds, use CustomPlaygroundDisplayConvertible instead.")
public typealias _DefaultCustomPlaygroundQuickLookable = Swift.__DefaultCustomPlaygroundQuickLookable
public protocol __DefaultCustomPlaygroundQuickLookable {
  var _defaultCustomPlaygroundQuickLook: Swift._PlaygroundQuickLook { get }
}
extension Swift.String {
  @available(*, deprecated, message: "All index distances are now of type Int")
  public typealias IndexDistance = Swift.Int
}
@available(iOS 13.0, tvOS 13.0, *)
@usableFromInline
internal let _availabilityNextMajorVersion: (Swift.Int, Swift.Int, Swift.Int)
@_effects(readnone) @_transparent public func _stdlib_isOSVersionAtLeast(_ major: Builtin.Word, _ minor: Builtin.Word, _ patch: Builtin.Word) -> Builtin.Int1 {
  return _stdlib_isOSVersionAtLeast_AEIC(major, minor, patch)
}
@_semantics("availability.osversion") @_effects(readnone) @_alwaysEmitIntoClient public func _stdlib_isOSVersionAtLeast_AEIC(_ major: Builtin.Word, _ minor: Builtin.Word, _ patch: Builtin.Word) -> Builtin.Int1 {

  let queryVersion = (Int(major), Int(minor), Int(patch))
  let major32 = Int32(truncatingIfNeeded:Int(queryVersion.0))
  let minor32 = Int32(truncatingIfNeeded:Int(queryVersion.1))
  let patch32 = Int32(truncatingIfNeeded:Int(queryVersion.2))

   
   
  let result32 = Int32(Builtin.targetOSVersionAtLeast(major32._value,
                                                      minor32._value,
                                                      patch32._value))
  return (result32 != (0 as Int32))._value
}
public typealias _SwiftStdlibVersion = SwiftShims._SwiftStdlibVersion
extension SwiftShims._SwiftStdlibVersion {
  @_alwaysEmitIntoClient public static var v5_6_0: SwiftShims._SwiftStdlibVersion {
    get { Self(_value: 0x050600) }
  }
  @_alwaysEmitIntoClient public static var v5_7_0: SwiftShims._SwiftStdlibVersion {
    get { Self(_value: 0x050700) }
  }
  @_alwaysEmitIntoClient public static var v5_8_0: SwiftShims._SwiftStdlibVersion {
    get { Self(_value: 0x050800) }
  }
  @_alwaysEmitIntoClient public static var v5_9_0: SwiftShims._SwiftStdlibVersion {
    get { Self(_value: 0x050900) }
  }
  @_alwaysEmitIntoClient public static var v5_10_0: SwiftShims._SwiftStdlibVersion {
    get { Self(_value: 0x050A00) }
  }
  @_alwaysEmitIntoClient public static var v6_0_0: SwiftShims._SwiftStdlibVersion {
    get { Self(_value: 0x060000) }
  }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static var current: SwiftShims._SwiftStdlibVersion {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension SwiftShims._SwiftStdlibVersion : Swift.CustomStringConvertible {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public var description: Swift.String {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct CollectionDifference<ChangeElement> {
  @frozen public enum Change {
    case insert(offset: Swift.Int, element: ChangeElement, associatedWith: Swift.Int?)
    case remove(offset: Swift.Int, element: ChangeElement, associatedWith: Swift.Int?)
  }
  public let insertions: [Swift.CollectionDifference<ChangeElement>.Change]
  public let removals: [Swift.CollectionDifference<ChangeElement>.Change]
  public init?<Changes>(_ changes: Changes) where Changes : Swift.Collection, Changes.Element == Swift.CollectionDifference<ChangeElement>.Change
  public func inverse() -> Swift.CollectionDifference<ChangeElement>
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference : Swift.Collection {
  public typealias Element = Swift.CollectionDifference<ChangeElement>.Change
  @frozen public struct Index {
    @usableFromInline
    internal let _offset: Swift.Int
  }
  public var startIndex: Swift.CollectionDifference<ChangeElement>.Index {
    get
  }
  public var endIndex: Swift.CollectionDifference<ChangeElement>.Index {
    get
  }
  public func index(after index: Swift.CollectionDifference<ChangeElement>.Index) -> Swift.CollectionDifference<ChangeElement>.Index
  public subscript(position: Swift.CollectionDifference<ChangeElement>.Index) -> Swift.CollectionDifference<ChangeElement>.Element {
    get
  }
  public func index(before index: Swift.CollectionDifference<ChangeElement>.Index) -> Swift.CollectionDifference<ChangeElement>.Index
  public func formIndex(_ index: inout Swift.CollectionDifference<ChangeElement>.Index, offsetBy distance: Swift.Int)
  public func distance(from start: Swift.CollectionDifference<ChangeElement>.Index, to end: Swift.CollectionDifference<ChangeElement>.Index) -> Swift.Int
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Indices = Swift.DefaultIndices<Swift.CollectionDifference<ChangeElement>>
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Iterator = Swift.IndexingIterator<Swift.CollectionDifference<ChangeElement>>
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias SubSequence = Swift.Slice<Swift.CollectionDifference<ChangeElement>>
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference.Index : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.CollectionDifference<ChangeElement>.Index, rhs: Swift.CollectionDifference<ChangeElement>.Index) -> Swift.Bool {
    return lhs._offset == rhs._offset
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference.Index : Swift.Comparable {
  @inlinable public static func < (lhs: Swift.CollectionDifference<ChangeElement>.Index, rhs: Swift.CollectionDifference<ChangeElement>.Index) -> Swift.Bool {
    return lhs._offset < rhs._offset
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference.Index : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_offset)
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference.Change : Swift.Equatable where ChangeElement : Swift.Equatable {
  public static func == (a: Swift.CollectionDifference<ChangeElement>.Change, b: Swift.CollectionDifference<ChangeElement>.Change) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference : Swift.Equatable where ChangeElement : Swift.Equatable {
  public static func == (a: Swift.CollectionDifference<ChangeElement>, b: Swift.CollectionDifference<ChangeElement>) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference.Change : Swift.Hashable where ChangeElement : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference : Swift.Hashable where ChangeElement : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference where ChangeElement : Swift.Hashable {
  public func inferringMoves() -> Swift.CollectionDifference<ChangeElement>
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference.Change : Swift.Codable where ChangeElement : Swift.Decodable, ChangeElement : Swift.Encodable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference : Swift.Codable where ChangeElement : Swift.Decodable, ChangeElement : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference : Swift.Sendable where ChangeElement : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference.Change : Swift.Sendable where ChangeElement : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference.Index : Swift.Sendable where ChangeElement : Swift.Sendable {
}
@frozen public struct CollectionOfOne<Element> {
  @usableFromInline
  internal var _element: Element
  @inlinable public init(_ element: Element) {
    self._element = element
  }
}
extension Swift.CollectionOfOne {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _elements: Element?
    @inlinable public init(_elements: Element?) {
      self._elements = _elements
    }
  }
}
extension Swift.CollectionOfOne.Iterator : Swift.IteratorProtocol {
  @inlinable public mutating func next() -> Element? {
    let result = _elements
    _elements = nil
    return result
  }
}
extension Swift.CollectionOfOne : Swift.RandomAccessCollection, Swift.MutableCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = Swift.Slice<Swift.CollectionOfOne<Element>>
  @inlinable public var startIndex: Swift.CollectionOfOne<Element>.Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.CollectionOfOne<Element>.Index {
    get {
    return 1
  }
  }
  @inlinable public func index(after i: Swift.CollectionOfOne<Element>.Index) -> Swift.CollectionOfOne<Element>.Index {
    _precondition(i == startIndex)
    return 1
  }
  @inlinable public func index(before i: Swift.CollectionOfOne<Element>.Index) -> Swift.CollectionOfOne<Element>.Index {
    _precondition(i == endIndex)
    return 0
  }
  @inlinable public __consuming func makeIterator() -> Swift.CollectionOfOne<Element>.Iterator {
    return Iterator(_elements: _element)
  }
  @inlinable public subscript(position: Swift.Int) -> Element {
    _read {
      _precondition(position == 0, "Index out of range")
      yield _element
    }
    _modify {
      _precondition(position == 0, "Index out of range")
      yield &_element
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.CollectionOfOne<Element>.SubSequence {
    get {
      _failEarlyRangeCheck(bounds, bounds: 0..<1)
      return Slice(base: self, bounds: bounds)
    }
    set {
      _failEarlyRangeCheck(bounds, bounds: 0..<1)
      let n = newValue.count
      _precondition(bounds.count == n, "CollectionOfOne can't be resized")
      if n == 1 { self = newValue.base }
    }
  }
  @inlinable public var count: Swift.Int {
    get {
    return 1
  }
  }
}
extension Swift.CollectionOfOne : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.CollectionOfOne : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.CollectionOfOne : Swift.Sendable where Element : Swift.Sendable {
}
extension Swift.CollectionOfOne.Iterator : Swift.Sendable where Element : Swift.Sendable {
}
extension Swift.RangeReplaceableCollection {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public func applying(_ difference: Swift.CollectionDifference<Self.Element>) -> Self?
}
extension Swift.BidirectionalCollection {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public func difference<C>(from other: C, by areEquivalent: (C.Element, Self.Element) -> Swift.Bool) -> Swift.CollectionDifference<Self.Element> where C : Swift.BidirectionalCollection, Self.Element == C.Element
}
extension Swift.BidirectionalCollection where Self.Element : Swift.Equatable {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public func difference<C>(from other: C) -> Swift.CollectionDifference<Self.Element> where C : Swift.BidirectionalCollection, Self.Element == C.Element
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@frozen public struct Duration : Swift.Sendable {
  public var _low: Swift.UInt64
  public var _high: Swift.Int64
  @inlinable public init(_high: Swift.Int64, low: Swift.UInt64) {
    self._low = low
    self._high = _high
  }
  public init(secondsComponent: Swift.Int64, attosecondsComponent: Swift.Int64)
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Duration {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public var components: (seconds: Swift.Int64, attoseconds: Swift.Int64) {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Duration {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @inlinable public static func seconds<T>(_ seconds: T) -> Swift.Duration where T : Swift.BinaryInteger {
    guard let high = Int64(exactly: seconds >> 64) else { fatalError() }
    let low = UInt64(truncatingIfNeeded: seconds)
    let lowScaled = low.multipliedFullWidth(by: 1_000_000_000_000_000_000)
    let highScaled = high * 1_000_000_000_000_000_000
    return Duration(_high: highScaled + Int64(lowScaled.high), low: lowScaled.low)
  }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func seconds(_ seconds: Swift.Double) -> Swift.Duration
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @inlinable public static func milliseconds<T>(_ milliseconds: T) -> Swift.Duration where T : Swift.BinaryInteger {
    guard let high = Int64(exactly: milliseconds >> 64) else { fatalError() }
    let low = UInt64(truncatingIfNeeded: milliseconds)
    let lowScaled = low.multipliedFullWidth(by: 1_000_000_000_000_000)
    let highScaled = high * 1_000_000_000_000_000
    return Duration(_high: highScaled + Int64(lowScaled.high), low: lowScaled.low)
  }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func milliseconds(_ milliseconds: Swift.Double) -> Swift.Duration
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @inlinable public static func microseconds<T>(_ microseconds: T) -> Swift.Duration where T : Swift.BinaryInteger {
    guard let high = Int64(exactly: microseconds >> 64) else { fatalError() }
    let low = UInt64(truncatingIfNeeded: microseconds)
    let lowScaled = low.multipliedFullWidth(by: 1_000_000_000_000)
    let highScaled = high * 1_000_000_000_000
    return Duration(_high: highScaled + Int64(lowScaled.high), low: lowScaled.low)
  }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func microseconds(_ microseconds: Swift.Double) -> Swift.Duration
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @inlinable public static func nanoseconds<T>(_ nanoseconds: T) -> Swift.Duration where T : Swift.BinaryInteger {
    guard let high = Int64(exactly: nanoseconds >> 64) else { fatalError() }
    let low = UInt64(truncatingIfNeeded: nanoseconds)
    let lowScaled = low.multipliedFullWidth(by: 1_000_000_000)
    let highScaled = high * 1_000_000_000
    return Duration(_high: highScaled + Int64(lowScaled.high), low: lowScaled.low)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Duration : Swift.Codable {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public init(from decoder: any Swift.Decoder) throws
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Duration : Swift.Hashable {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Duration : Swift.Equatable {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func == (lhs: Swift.Duration, rhs: Swift.Duration) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Duration : Swift.Comparable {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func < (lhs: Swift.Duration, rhs: Swift.Duration) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Duration : Swift.AdditiveArithmetic {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static var zero: Swift.Duration {
    get
  }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func + (lhs: Swift.Duration, rhs: Swift.Duration) -> Swift.Duration
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func - (lhs: Swift.Duration, rhs: Swift.Duration) -> Swift.Duration
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func += (lhs: inout Swift.Duration, rhs: Swift.Duration)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func -= (lhs: inout Swift.Duration, rhs: Swift.Duration)
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Duration {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func / (lhs: Swift.Duration, rhs: Swift.Double) -> Swift.Duration
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func /= (lhs: inout Swift.Duration, rhs: Swift.Double)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func / <T>(lhs: Swift.Duration, rhs: T) -> Swift.Duration where T : Swift.BinaryInteger
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func /= <T>(lhs: inout Swift.Duration, rhs: T) where T : Swift.BinaryInteger
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func / (lhs: Swift.Duration, rhs: Swift.Duration) -> Swift.Double
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func * (lhs: Swift.Duration, rhs: Swift.Double) -> Swift.Duration
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func * <T>(lhs: Swift.Duration, rhs: T) -> Swift.Duration where T : Swift.BinaryInteger
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func *= <T>(lhs: inout Swift.Duration, rhs: T) where T : Swift.BinaryInteger
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Duration : Swift.CustomStringConvertible {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public var description: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Duration : Swift.DurationProtocol {
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol DurationProtocol : Swift.AdditiveArithmetic, Swift.Comparable, Swift.Sendable {
  static func / (lhs: Self, rhs: Swift.Int) -> Self
  static func /= (lhs: inout Self, rhs: Swift.Int)
  static func * (lhs: Self, rhs: Swift.Int) -> Self
  static func *= (lhs: inout Self, rhs: Swift.Int)
  static func / (lhs: Self, rhs: Self) -> Swift.Double
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.DurationProtocol {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func /= (lhs: inout Self, rhs: Swift.Int)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func *= (lhs: inout Self, rhs: Swift.Int)
}
extension Swift.BinaryFloatingPoint where Self.RawSignificand : Swift.FixedWidthInteger {
  @inlinable public static func random<T>(in range: Swift.Range<Self>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )
    let delta = range.upperBound - range.lowerBound
     
     
     
     
     
    _precondition(
      delta.isFinite,
      "There is no uniform distribution on an infinite range"
    )
    let rand: Self.RawSignificand
    if Self.RawSignificand.bitWidth == Self.significandBitCount + 1 {
      rand = generator.next()
    } else {
      let significandCount = Self.significandBitCount + 1
      let maxSignificand: Self.RawSignificand = 1 << significandCount
       
       
       
      rand = generator.next() & (maxSignificand - 1)
    }
    let unitRandom = Self.init(rand) * (Self.ulpOfOne / 2)
    let randFloat = delta * unitRandom + range.lowerBound
    if randFloat == range.upperBound {
      return Self.random(in: range, using: &generator)
    }
    return randFloat
  }
  @inlinable public static func random(in range: Swift.Range<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
  @inlinable public static func random<T>(in range: Swift.ClosedRange<Self>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )
    let delta = range.upperBound - range.lowerBound
     
     
     
     
     
    _precondition(
      delta.isFinite,
      "There is no uniform distribution on an infinite range"
    )
    let rand: Self.RawSignificand
    if Self.RawSignificand.bitWidth == Self.significandBitCount + 1 {
      rand = generator.next()
      let tmp: UInt8 = generator.next() & 1
      if rand == Self.RawSignificand.max && tmp == 1 {
        return range.upperBound
      }
    } else {
      let significandCount = Self.significandBitCount + 1
      let maxSignificand: Self.RawSignificand = 1 << significandCount
      rand = generator.next(upperBound: maxSignificand + 1)
      if rand == maxSignificand {
        return range.upperBound
      }
    }
    let unitRandom = Self.init(rand) * (Self.ulpOfOne / 2)
    let randFloat = delta * unitRandom + range.lowerBound
    return randFloat
  }
  @inlinable public static func random(in range: Swift.ClosedRange<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol InstantProtocol<Duration> : Swift.Comparable, Swift.Hashable, Swift.Sendable {
  associatedtype Duration : Swift.DurationProtocol
  func advanced(by duration: Self.Duration) -> Self
  func duration(to other: Self) -> Self.Duration
}
#else
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol InstantProtocol : Swift.Comparable, Swift.Hashable, Swift.Sendable {
  associatedtype Duration : Swift.DurationProtocol
  func advanced(by duration: Self.Duration) -> Self
  func duration(to other: Self) -> Self.Duration
}
#endif
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen public struct Int128 : Swift.Sendable {
  public var _value: Builtin.Int128
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public init(_ _value: Builtin.Int128) {
    self._value = _value
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var _low: Swift.UInt64 {
    @_transparent get {
    UInt64(Builtin.trunc_Int128_Int64(_value))
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var _high: Swift.Int64 {
    @_transparent get {
    let shifted: Int128 = self &>> 64
    return Int64(Builtin.trunc_Int128_Int64(shifted._value))
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public init(_low: Swift.UInt64, _high: Swift.Int64) {
    self = unsafeBitCast((_low, _high), to: Int128.self)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public init(bitPattern: Swift.UInt128) {
    self.init(bitPattern._value)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static var zero: Swift.Int128 {
    @_transparent get {
    Self(Builtin.zeroInitializer())
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static var min: Swift.Int128 {
    @_transparent get {
    Self(_low: .zero, _high: .min)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static var max: Swift.Int128 {
    @_transparent get {
    Self(_low: .max, _high: .max)
  }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 : Swift.ExpressibleByIntegerLiteral, Swift._ExpressibleByBuiltinIntegerLiteral {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias IntegerLiteralType = Swift.Int128
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    self.init(Builtin.s_to_s_checked_trunc_IntLiteral_Int128(x).0)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init?<T>(exactly source: T) where T : Swift.BinaryInteger {
    guard let high = Int64(exactly: source >> 64) else { return nil }
    let low = UInt64(truncatingIfNeeded: source)
    self.init(_low: low, _high: high)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init<T>(_ source: T) where T : Swift.BinaryInteger {
    guard let value = Self(exactly: source) else {
      fatalError("value cannot be converted to Int128 because it is outside the representable range")
    }
    self = value
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init<T>(clamping source: T) where T : Swift.BinaryInteger {
    guard let value = Self(exactly: source) else {
      self = source < .zero ? .min : .max
      return
    }
    self = value
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger {
    let high = Int64(truncatingIfNeeded: source >> 64)
    let low = UInt64(truncatingIfNeeded: source)
    self.init(_low: low, _high: high)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public init(_truncatingBits source: Swift.UInt) {
    self.init(_low: UInt64(source), _high: .zero)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint {
    if source.magnitude < 0x1.0p64 {
      guard let magnitude = UInt64(exactly: source.magnitude) else {
        return nil
      }
      self = Int128(_low: magnitude, _high: 0)
      if source < 0 { self = -self }
    } else {
      let highAsFloat = (source * 0x1.0p-64).rounded(.down)
      guard let high = Int64(exactly: highAsFloat) else { return nil }
       
       
       
      guard let low = UInt64(exactly: source - 0x1.0p64*highAsFloat) else {
        return nil
      }
      self.init(_low: low, _high: high)
    }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint {
    guard let value = Self(exactly: source.rounded(.towardZero)) else {
      fatalError("value cannot be converted to Int128 because it is outside the representable range")
    }
    self = value
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 : Swift.Equatable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func == (a: Swift.Int128, b: Swift.Int128) -> Swift.Bool {
    Bool(Builtin.cmp_eq_Int128(a._value, b._value))
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 : Swift.Comparable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func < (a: Swift.Int128, b: Swift.Int128) -> Swift.Bool {
    Bool(Builtin.cmp_slt_Int128(a._value, b._value))
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 : Swift.Hashable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_low)
    hasher.combine(_high)
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public func addingReportingOverflow(_ other: Swift.Int128) -> (partialValue: Swift.Int128, overflow: Swift.Bool) {
    let (result, overflow) = Builtin.sadd_with_overflow_Int128(
      self._value, other._value, Builtin.zeroInitializer()
    )
    return (Self(result), Bool(overflow))
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public func subtractingReportingOverflow(_ other: Swift.Int128) -> (partialValue: Swift.Int128, overflow: Swift.Bool) {
    let (result, overflow) = Builtin.ssub_with_overflow_Int128(
      self._value, other._value, Builtin.zeroInitializer()
    )
    return (Self(result), Bool(overflow))
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public func multipliedReportingOverflow(by other: Swift.Int128) -> (partialValue: Swift.Int128, overflow: Swift.Bool) {
    let a = self.magnitude
    let b = other.magnitude
    let (magnitude, overflow) = a.multipliedReportingOverflow(by: b)
    if (self < 0) != (other < 0) {
      let partialValue = Self(bitPattern: 0 &- magnitude)
      return (partialValue, overflow || partialValue > 0)
    } else {
      let partialValue = Self(bitPattern: magnitude)
      return (partialValue, overflow || partialValue < 0)
    }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public func dividedReportingOverflow(by other: Swift.Int128) -> (partialValue: Swift.Int128, overflow: Swift.Bool) {
    _precondition(other != .zero, "Division by zero")
    if self == .min && other == -1 { return (.min, true) }
    return (Self(Builtin.sdiv_Int128(self._value, other._value)), false)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.Int128) -> (partialValue: Swift.Int128, overflow: Swift.Bool) {
    _precondition(other != .zero, "Division by zero in remainder operation")
    if self == .min && other == -1 { return (0, true) }
    return (Self(Builtin.srem_Int128(self._value, other._value)), false)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 : Swift.AdditiveArithmetic {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func + (a: Swift.Int128, b: Swift.Int128) -> Swift.Int128 {
    let (result, overflow) = a.addingReportingOverflow(b)
     
     
     
     
    Builtin.condfail_message(
      overflow._value,
      StaticString("arithmetic overflow").unsafeRawPointer
    )
    return result
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func - (a: Swift.Int128, b: Swift.Int128) -> Swift.Int128 {
    let (result, overflow) = a.subtractingReportingOverflow(b)
    Builtin.condfail_message(
      overflow._value,
      StaticString("arithmetic overflow").unsafeRawPointer
    )
    return result
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func * (a: Swift.Int128, b: Swift.Int128) -> Swift.Int128 {
    let (result, overflow) = a.multipliedReportingOverflow(by: b)
    Builtin.condfail_message(
      overflow._value,
      StaticString("arithmetic overflow").unsafeRawPointer
    )
    return result
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func *= (a: inout Swift.Int128, b: Swift.Int128) {
    a = a * b
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func / (a: Swift.Int128, b: Swift.Int128) -> Swift.Int128 {
    a.dividedReportingOverflow(by: b).partialValue
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func /= (a: inout Swift.Int128, b: Swift.Int128) {
    a = a / b
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func % (a: Swift.Int128, b: Swift.Int128) -> Swift.Int128 {
    a.remainderReportingOverflow(dividingBy: b).partialValue
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func %= (a: inout Swift.Int128, b: Swift.Int128) {
    a = a % b
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 : Swift.SignedNumeric {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias Magnitude = Swift.UInt128
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var magnitude: Swift.Int128.Magnitude {
    @_transparent get {
    let unsignedSelf = UInt128(_value)
    return self < 0 ? 0 &- unsignedSelf : unsignedSelf
  }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 : Swift.BinaryInteger {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var words: Swift.UInt128.Words {
    @_transparent get {
    Words(_value: UInt128(_value))
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func &= (a: inout Swift.Int128, b: Swift.Int128) {
    a._value = Builtin.and_Int128(a._value, b._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func |= (a: inout Swift.Int128, b: Swift.Int128) {
    a._value = Builtin.or_Int128(a._value, b._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func ^= (a: inout Swift.Int128, b: Swift.Int128) {
    a._value = Builtin.xor_Int128(a._value, b._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func &>>= (a: inout Swift.Int128, b: Swift.Int128) {
    let masked = b & 127
    a._value = Builtin.ashr_Int128(a._value, masked._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func &<<= (a: inout Swift.Int128, b: Swift.Int128) {
    let masked = b & 127
    a._value = Builtin.shl_Int128(a._value, masked._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    _low == 0 ? 64 + _high.trailingZeroBitCount : _low.trailingZeroBitCount
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
    UInt(Builtin.trunc_Int128_Int64(_value))
  }
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Stride = Swift.Int
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Words = Swift.UInt128.Words
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 : Swift.FixedWidthInteger, Swift.SignedInteger {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { 128 }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    _high.nonzeroBitCount &+ _low.nonzeroBitCount
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    _high == 0 ? 64 + _low.leadingZeroBitCount : _high.leadingZeroBitCount
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var byteSwapped: Swift.Int128 {
    @_transparent get {
    return Self(_low: UInt64(bitPattern: _high.byteSwapped),
                _high: Int64(bitPattern: _low.byteSwapped))
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func &* (lhs: Swift.Int128, rhs: Swift.Int128) -> Swift.Int128 {
     
     
     
    Self(Builtin.mul_Int128(lhs._value, rhs._value))
  }
}
public struct Mirror {
  public let subjectType: any Any.Type
  public let children: Swift.Mirror.Children
  public let displayStyle: Swift.Mirror.DisplayStyle?
  public init(reflecting subject: Any)
  public init<Subject, C>(_ subject: Subject, children: C, displayStyle: Swift.Mirror.DisplayStyle? = nil, ancestorRepresentation: Swift.Mirror.AncestorRepresentation = .generated) where C : Swift.Collection, C.Element == (label: Swift.String?, value: Any)
  public init<Subject, C>(_ subject: Subject, unlabeledChildren: C, displayStyle: Swift.Mirror.DisplayStyle? = nil, ancestorRepresentation: Swift.Mirror.AncestorRepresentation = .generated) where C : Swift.Collection
  public init<Subject>(_ subject: Subject, children: Swift.KeyValuePairs<Swift.String, Any>, displayStyle: Swift.Mirror.DisplayStyle? = nil, ancestorRepresentation: Swift.Mirror.AncestorRepresentation = .generated)
  public var superclassMirror: Swift.Mirror? {
    get
  }
}
@available(*, unavailable)
extension Swift.Mirror : Swift.Sendable {
}
extension Swift.Mirror {
  public enum AncestorRepresentation {
    case generated
    case customized(() -> Swift.Mirror)
    case suppressed
  }
  public typealias Child = (label: Swift.String?, value: Any)
  public typealias Children = Swift.AnyCollection<Swift.Mirror.Child>
  public enum DisplayStyle : Swift.Sendable {
    case `struct`, `class`, `enum`, tuple, optional, collection
    case dictionary, set
    public static func == (a: Swift.Mirror.DisplayStyle, b: Swift.Mirror.DisplayStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(*, unavailable)
extension Swift.Mirror.AncestorRepresentation : Swift.Sendable {
}
public protocol CustomReflectable {
  var customMirror: Swift.Mirror { get }
}
public protocol CustomLeafReflectable : Swift.CustomReflectable {
}
public protocol MirrorPath {
}
extension Swift.Int : Swift.MirrorPath {
}
extension Swift.String : Swift.MirrorPath {
}
extension Swift.Mirror {
  public func descendant(_ first: any Swift.MirrorPath, _ rest: any Swift.MirrorPath...) -> Any?
}
extension Swift.String {
  public init<Subject>(describing instance: Subject)
  @inlinable public init<Subject>(describing instance: Subject) where Subject : Swift.CustomStringConvertible {
    self = instance.description
  }
  @inlinable public init<Subject>(describing instance: Subject) where Subject : Swift.TextOutputStreamable {
    self.init()
    instance.write(to: &self)
  }
  @inlinable public init<Subject>(describing instance: Subject) where Subject : Swift.CustomStringConvertible, Subject : Swift.TextOutputStreamable {
    self = instance.description
  }
  public init<Subject>(reflecting subject: Subject)
}
extension Swift.Mirror : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Swift.Mirror : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
public protocol CustomPlaygroundDisplayConvertible {
  var playgroundDescription: Any { get }
}
#if compiler(>=5.3) && $ConformanceSuppression
@frozen public enum CommandLine : ~Swift.BitwiseCopyable {
}
#else
@frozen public enum CommandLine {
}
#endif
extension Swift.CommandLine {
  @usableFromInline
  internal static var _argc: Swift.Int32
  @usableFromInline
  internal static var _unsafeArgv: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Swift.Int8>?>
  public static var argc: Swift.Int32 {
    get
  }
  public static var unsafeArgv: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Swift.Int8>?> {
    get
  }
  public static var arguments: [Swift.String] {
    get
    @available(*, deprecated, message: "Do not modify CommandLine.arguments. It will become read-only in a future version of Swift.")
    @available(swift, obsoleted: 6.0)
    set
  }
}
@usableFromInline
@frozen internal struct _SliceBuffer<Element> : Swift._ArrayBufferProtocol, Swift.RandomAccessCollection {
  @usableFromInline
  internal typealias NativeBuffer = Swift._ContiguousArrayBuffer<Element>
  @usableFromInline
  internal var owner: Swift.AnyObject
  @usableFromInline
  internal let subscriptBaseAddress: Swift.UnsafeMutablePointer<Element>
  @usableFromInline
  internal var startIndex: Swift.Int
  @usableFromInline
  internal var endIndexAndFlags: Swift.UInt
  @inlinable internal init(owner: Swift.AnyObject, subscriptBaseAddress: Swift.UnsafeMutablePointer<Element>, startIndex: Swift.Int, endIndexAndFlags: Swift.UInt) {
    self.owner = owner
    self.subscriptBaseAddress = subscriptBaseAddress
    self.startIndex = startIndex
    self.endIndexAndFlags = endIndexAndFlags
  }
  @inlinable internal init(owner: Swift.AnyObject, subscriptBaseAddress: Swift.UnsafeMutablePointer<Element>, indices: Swift.Range<Swift.Int>, hasNativeBuffer: Swift.Bool) {
    self.owner = owner
    self.subscriptBaseAddress = subscriptBaseAddress
    self.startIndex = indices.lowerBound
    let bufferFlag = UInt(hasNativeBuffer ? 1 : 0)
    self.endIndexAndFlags = (UInt(indices.upperBound) << 1) | bufferFlag
    _invariantCheck()
  }
  @inlinable internal init() {
    let empty = _ContiguousArrayBuffer<Element>()
    #if $Embedded
    self.owner = Builtin.castToNativeObject(_emptyArrayStorage)
    #else
    self.owner = _emptyArrayStorage
    #endif
    self.subscriptBaseAddress = empty.firstElementAddress
    self.startIndex = empty.startIndex
    self.endIndexAndFlags = 1
    _invariantCheck()
  }
  @inlinable internal init(_buffer buffer: Swift._SliceBuffer<Element>.NativeBuffer, shiftedToStartIndex: Swift.Int) {
    let shift = buffer.startIndex - shiftedToStartIndex
    self.init(
      owner: buffer.owner,
      subscriptBaseAddress: buffer.subscriptBaseAddress + shift,
      indices: shiftedToStartIndex..<shiftedToStartIndex + buffer.count,
      hasNativeBuffer: true)
  }
  @inlinable internal func _invariantCheck() {
    let isNative = _hasNativeBuffer
    let isNativeStorage: Bool
    #if !$Embedded
    isNativeStorage = owner is __ContiguousArrayStorageBase
    #else
    isNativeStorage = true
    #endif
    _internalInvariant(isNativeStorage == isNative)
    if isNative {
      _internalInvariant(count <= nativeBuffer.count)
    }
  }
  @inlinable internal var _hasNativeBuffer: Swift.Bool {
    get {
    return (endIndexAndFlags & 1) != 0
  }
  }
  @inlinable internal var nativeBuffer: Swift._SliceBuffer<Element>.NativeBuffer {
    get {
    _internalInvariant(_hasNativeBuffer)
    #if !$Embedded
    return NativeBuffer(
      owner as? __ContiguousArrayStorageBase ?? _emptyArrayStorage)
    #else
    return NativeBuffer(unsafeBitCast(_nativeObject(toNative: owner),
      to: __ContiguousArrayStorageBase.self))
    #endif
  }
  }
  @inlinable internal var nativeOwner: Swift.AnyObject {
    get {
    _internalInvariant(_hasNativeBuffer, "Expect a native array")
    return owner
  }
  }
  @inlinable internal mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Int>, with insertCount: Swift.Int, elementsOf newValues: __owned C) where Element == C.Element, C : Swift.Collection {

    _invariantCheck()
    _internalInvariant(insertCount <= newValues.count)

    _internalInvariant(_hasNativeBuffer)
    _internalInvariant(isUniquelyReferenced())

    let eraseCount = subrange.count
    let growth = insertCount - eraseCount
    let oldCount = count

    var native = nativeBuffer
    let hiddenElementCount = firstElementAddress - native.firstElementAddress

    _internalInvariant(native.count + growth <= native.capacity)

    let start = subrange.lowerBound - startIndex + hiddenElementCount
    let end = subrange.upperBound - startIndex + hiddenElementCount
    native.replaceSubrange(
      start..<end,
      with: insertCount,
      elementsOf: newValues)

    self.endIndex = self.startIndex + oldCount + growth

    _invariantCheck()
  }
  @inlinable internal var identity: Swift.UnsafeRawPointer {
    get {
    return UnsafeRawPointer(firstElementAddress)
  }
  }
  @inlinable internal var firstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    return subscriptBaseAddress + startIndex
  }
  }
  @inlinable internal var firstElementAddressIfContiguous: Swift.UnsafeMutablePointer<Element>? {
    get {
    return firstElementAddress
  }
  }
  @inlinable internal mutating func requestUniqueMutableBackingBuffer(minimumCapacity: Swift.Int) -> Swift._SliceBuffer<Element>.NativeBuffer? {
    _invariantCheck()
     
     
    if _fastPath(isUniquelyReferenced()) {
      if capacity >= minimumCapacity {
         
         
         
         
         
        var native = nativeBuffer
        let offset = self.firstElementAddress - native.firstElementAddress
        let backingCount = native.count
        let myCount = count

        if _slowPath(backingCount > myCount + offset) {
          native.replaceSubrange(
            (myCount+offset)..<backingCount,
            with: 0,
            elementsOf: EmptyCollection())
        }
        _invariantCheck()
        return native
      }
    }
    return nil
  }
  @inlinable internal mutating func isMutableAndUniquelyReferenced() -> Swift.Bool {
     
     
     
     
     
     
     
    if !_hasNativeBuffer {
      return false
    }
    return isUniquelyReferenced()
  }
  @inlinable internal func requestNativeBuffer() -> Swift._ContiguousArrayBuffer<Element>? {
    _invariantCheck()
    if _fastPath(_hasNativeBuffer && nativeBuffer.count == count) {
      return nativeBuffer
    }
    return nil
  }
  @discardableResult
  @inlinable internal __consuming func _copyContents(subRange bounds: Swift.Range<Swift.Int>, initializing target: Swift.UnsafeMutablePointer<Element>) -> Swift.UnsafeMutablePointer<Element> {
    _invariantCheck()
    _internalInvariant(bounds.lowerBound >= startIndex)
    _internalInvariant(bounds.upperBound >= bounds.lowerBound)
    _internalInvariant(bounds.upperBound <= endIndex)
    let c = bounds.count
    target.initialize(from: subscriptBaseAddress + bounds.lowerBound, count: c)
    return target + c
  }
  @inlinable internal __consuming func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift._SliceBuffer<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    _invariantCheck()
    guard buffer.count > 0 else { return (makeIterator(), 0) }
    let c = Swift.min(self.count, buffer.count)
    buffer.baseAddress!.initialize(
      from: firstElementAddress,
      count: c)
    _fixLifetime(owner)
    return (IndexingIterator(_elements: self, _position: startIndex + c), c)
  }
  @inlinable internal var arrayPropertyIsNativeTypeChecked: Swift.Bool {
    get {
    return _hasNativeBuffer
  }
  }
  @inlinable internal var count: Swift.Int {
    get {
      return endIndex - startIndex
    }
    set {
      let growth = newValue - count
      if growth != 0 {
        nativeBuffer.mutableCount += growth
        self.endIndex += growth
      }
      _invariantCheck()
    }
  }
  @inlinable internal func _checkValidSubscript(_ index: Swift.Int) {
    _precondition(
      index >= startIndex && index < endIndex, "Index out of bounds")
  }
  @inlinable internal var capacity: Swift.Int {
    get {
    let count = self.count
    if _slowPath(!_hasNativeBuffer) {
      return count
    }
    let n = nativeBuffer
    let nativeEnd = n.firstElementAddress + n.count
    if (firstElementAddress + count) == nativeEnd {
      return count + (n.capacity - n.count)
    }
    return count
  }
  }
  @inlinable internal mutating func isUniquelyReferenced() -> Swift.Bool {
    return isKnownUniquelyReferenced(&owner)
  }
  @_alwaysEmitIntoClient internal mutating func beginCOWMutation() -> Swift.Bool {
    if !_hasNativeBuffer {
      return false
    }
    if Bool(Builtin.beginCOWMutation(&owner)) {
      return true
    }
    return false;
  }
  @_alwaysEmitIntoClient @inline(__always) internal mutating func endCOWMutation() {
    Builtin.endCOWMutation(&owner)
  }
  @inlinable internal func getElement(_ i: Swift.Int) -> Element {
    _internalInvariant(i >= startIndex, "slice index is out of range (before startIndex)")
    _internalInvariant(i < endIndex, "slice index is out of range")
    return subscriptBaseAddress[i]
  }
  @inlinable internal subscript(position: Swift.Int) -> Element {
    get {
      return getElement(position)
    }
    nonmutating set {
      _internalInvariant(position >= startIndex, "slice index is out of range (before startIndex)")
      _internalInvariant(position < endIndex, "slice index is out of range")
      subscriptBaseAddress[position] = newValue
    }
  }
  @inlinable internal subscript(bounds: Swift.Range<Swift.Int>) -> Swift._SliceBuffer<Element> {
    get {
      _internalInvariant(bounds.lowerBound >= startIndex)
      _internalInvariant(bounds.upperBound >= bounds.lowerBound)
      _internalInvariant(bounds.upperBound <= endIndex)
      return _SliceBuffer(
        owner: owner,
        subscriptBaseAddress: subscriptBaseAddress,
        indices: bounds,
        hasNativeBuffer: _hasNativeBuffer)
    }
    set {
      fatalError("not implemented")
    }
  }
  @inlinable internal var endIndex: Swift.Int {
    get {
      return Int(endIndexAndFlags >> 1)
    }
    set {
      endIndexAndFlags = (UInt(newValue) << 1) | (_hasNativeBuffer ? 1 : 0)
    }
  }
  @usableFromInline
  internal typealias Indices = Swift.Range<Swift.Int>
  @inlinable internal func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(UnsafeBufferPointer(start: firstElementAddress,
      count: count))
  }
  @inlinable internal mutating func withUnsafeMutableBufferPointer<R>(_ body: (Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(
      UnsafeMutableBufferPointer(start: firstElementAddress, count: count))
  }
  @inlinable internal func unsafeCastElements<T>(to type: T.Type) -> Swift._SliceBuffer<T> {
    _internalInvariant(_isClassOrObjCExistential(T.self))
    let baseAddress = UnsafeMutableRawPointer(self.subscriptBaseAddress)
      .assumingMemoryBound(to: T.self)
    return _SliceBuffer<T>(
      owner: self.owner,
      subscriptBaseAddress: baseAddress,
      startIndex: self.startIndex,
      endIndexAndFlags: self.endIndexAndFlags)
  }
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._SliceBuffer<Element>>
  @usableFromInline
  internal typealias SubSequence = Swift._SliceBuffer<Element>
}
@available(*, unavailable)
extension Swift._SliceBuffer : Swift.Sendable {
}
extension Swift._SliceBuffer {
  @inlinable internal __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    if _hasNativeBuffer {
      let n = nativeBuffer
      if count == n.count {
        return ContiguousArray(_buffer: n)
      }
    }

    let result = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: count,
      minimumCapacity: 0)
    result.firstElementAddress.initialize(
      from: firstElementAddress, count: count)
    return ContiguousArray(_buffer: result)
  }
}
@available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
@frozen public struct StaticBigInt : Swift._ExpressibleByBuiltinIntegerLiteral, Swift.ExpressibleByIntegerLiteral, Swift.Sendable {
  @available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
  @usableFromInline
  internal let _value: Builtin.IntLiteral
  @available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
  @inlinable public init(_builtinIntegerLiteral value: Builtin.IntLiteral) {
    _value = value
  }
  @available(iOS 16.4, tvOS 16.4, watchOS 9.4, macOS 13.3, *)
  public typealias IntegerLiteralType = Swift.StaticBigInt
}
@available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
extension Swift.StaticBigInt {
  @available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
  @inlinable public func signum() -> Swift.Int {
    _isNegative ? -1 : (bitWidth == 1) ? 0 : +1
  }
  @available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
  @inlinable internal var _isNegative: Swift.Bool {
    get {
#if compiler(>=5.8) && $BuiltinIntLiteralAccessors
    Bool(Builtin.isNegative_IntLiteral(_value))
#else
    fatalError("Swift compiler is incompatible with this SDK version")
#endif
  }
  }
  @available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
  @inlinable public var bitWidth: Swift.Int {
    get {
#if compiler(>=5.8) && $BuiltinIntLiteralAccessors
    Int(Builtin.bitWidth_IntLiteral(_value))
#else
    fatalError("Swift compiler is incompatible with this SDK version")
#endif
  }
  }
  @available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
  @inlinable public subscript(wordIndex: Swift.Int) -> Swift.UInt {
    get {
    _precondition(wordIndex >= 0, "Negative word index")
    let bitIndex = wordIndex.multipliedReportingOverflow(by: UInt.bitWidth)
    guard !bitIndex.overflow, bitIndex.partialValue < bitWidth else {
      return _isNegative ? ~0 : 0
    }
#if compiler(>=5.8) && $BuiltinIntLiteralAccessors
    return UInt(
      Builtin.wordAtIndex_IntLiteral(_value, wordIndex._builtinWordValue)
    )
#else
    fatalError("Swift compiler is incompatible with this SDK version")
#endif
  }
  }
}
@available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
extension Swift.StaticBigInt : Swift.CustomDebugStringConvertible {
  @available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
extension Swift.StaticBigInt : Swift.CustomReflectable {
  @available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen public struct UInt128 : Swift.Sendable {
  public var _value: Builtin.Int128
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public init(_ _value: Builtin.Int128) {
    self._value = _value
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var _low: Swift.UInt64 {
    @_transparent get {
    UInt64(Builtin.trunc_Int128_Int64(_value))
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var _high: Swift.UInt64 {
    @_transparent get {
    let shifted: UInt128 = self &>> 64
    return UInt64(Builtin.trunc_Int128_Int64(shifted._value))
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public init(_low: Swift.UInt64, _high: Swift.UInt64) {
    self = unsafeBitCast((_low, _high), to: Self.self)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public init(bitPattern: Swift.Int128) {
    self.init(bitPattern._value)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static var zero: Swift.UInt128 {
    @_transparent get {
    Self(Builtin.zeroInitializer())
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static var min: Swift.UInt128 {
    @_transparent get {
    zero
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static var max: Swift.UInt128 {
    @_transparent get {
    Self(_low: .max, _high: .max)
  }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 : Swift.ExpressibleByIntegerLiteral, Swift._ExpressibleByBuiltinIntegerLiteral {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias IntegerLiteralType = Swift.UInt128
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    self.init(Builtin.s_to_u_checked_trunc_IntLiteral_Int128(x).0)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init?<T>(exactly source: T) where T : Swift.BinaryInteger {
    guard let high = UInt64(exactly: source >> 64) else { return nil }
    let low = UInt64(truncatingIfNeeded: source)
    self.init(_low: low, _high: high)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init<T>(_ source: T) where T : Swift.BinaryInteger {
    guard let value = Self(exactly: source) else {
      fatalError("value cannot be converted to UInt128 because it is outside the representable range")
    }
    self = value
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init<T>(clamping source: T) where T : Swift.BinaryInteger {
    guard let value = Self(exactly: source) else {
      self = source < .zero ? .zero : .max
      return
    }
    self = value
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger {
    let high = UInt64(truncatingIfNeeded: source >> 64)
    let low = UInt64(truncatingIfNeeded: source)
    self.init(_low: low, _high: high)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public init(_truncatingBits source: Swift.UInt) {
    self.init(_low: UInt64(source), _high: .zero)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint {
    let highAsFloat = (source * 0x1.0p-64).rounded(.towardZero)
    guard let high = UInt64(exactly: highAsFloat) else { return nil }
    guard let low = UInt64(
      exactly: high == 0 ? source : source - 0x1.0p64*highAsFloat
    ) else { return nil }
    self.init(_low: low, _high: high)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint {
    guard let value = Self(exactly: source.rounded(.towardZero)) else {
      fatalError("value cannot be converted to UInt128 because it is outside the representable range")
    }
    self = value
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 : Swift.Equatable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func == (a: Swift.UInt128, b: Swift.UInt128) -> Swift.Bool {
    Bool(Builtin.cmp_eq_Int128(a._value, b._value))
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 : Swift.Comparable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func < (a: Swift.UInt128, b: Swift.UInt128) -> Swift.Bool {
    Bool(Builtin.cmp_ult_Int128(a._value, b._value))
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 : Swift.Hashable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_low)
    hasher.combine(_high)
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public func addingReportingOverflow(_ other: Swift.UInt128) -> (partialValue: Swift.UInt128, overflow: Swift.Bool) {
    let (result, overflow) = Builtin.uadd_with_overflow_Int128(
      self._value, other._value, Builtin.zeroInitializer()
    )
    return (Self(result), Bool(overflow))
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public func subtractingReportingOverflow(_ other: Swift.UInt128) -> (partialValue: Swift.UInt128, overflow: Swift.Bool) {
    let (result, overflow) = Builtin.usub_with_overflow_Int128(
      self._value, other._value, Builtin.zeroInitializer()
    )
    return (Self(result), Bool(overflow))
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public func multipliedReportingOverflow(by other: Swift.UInt128) -> (partialValue: Swift.UInt128, overflow: Swift.Bool) {
    let (result, overflow) = Builtin.umul_with_overflow_Int128(
      self._value, other._value, Builtin.zeroInitializer()
    )
    return (Self(result), Bool(overflow))
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public func dividedReportingOverflow(by other: Swift.UInt128) -> (partialValue: Swift.UInt128, overflow: Swift.Bool) {
    _precondition(other != .zero, "Division by zero")
     
    return (Self(Builtin.udiv_Int128(self._value, other._value)), false)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.UInt128) -> (partialValue: Swift.UInt128, overflow: Swift.Bool) {
    _precondition(other != .zero, "Division by zero in remainder operation")
     
    return (Self(Builtin.urem_Int128(self._value, other._value)), false)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 : Swift.AdditiveArithmetic {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func + (a: Swift.UInt128, b: Swift.UInt128) -> Swift.UInt128 {
    let (result, overflow) = a.addingReportingOverflow(b)
     
     
     
     
    Builtin.condfail_message(
      overflow._value,
      StaticString("arithmetic overflow").unsafeRawPointer
    )
    return result
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func - (a: Swift.UInt128, b: Swift.UInt128) -> Swift.UInt128 {
    let (result, overflow) = a.subtractingReportingOverflow(b)
    Builtin.condfail_message(
      overflow._value,
      StaticString("arithmetic overflow").unsafeRawPointer
    )
    return result
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func * (a: Swift.UInt128, b: Swift.UInt128) -> Swift.UInt128 {
    let (result, overflow) = a.multipliedReportingOverflow(by: b)
    Builtin.condfail_message(
      overflow._value,
      StaticString("arithmetic overflow").unsafeRawPointer
    )
    return result
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func *= (a: inout Swift.UInt128, b: Swift.UInt128) {
    a = a * b
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func / (a: Swift.UInt128, b: Swift.UInt128) -> Swift.UInt128 {
    a.dividedReportingOverflow(by: b).partialValue
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func /= (a: inout Swift.UInt128, b: Swift.UInt128) {
    a = a / b
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func % (a: Swift.UInt128, b: Swift.UInt128) -> Swift.UInt128 {
    a.remainderReportingOverflow(dividingBy: b).partialValue
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func %= (a: inout Swift.UInt128, b: Swift.UInt128) {
    a = a % b
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 : Swift.Numeric {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias Magnitude = Swift.UInt128
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var magnitude: Swift.UInt128 {
    @_transparent get {
    self
  }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 : Swift.BinaryInteger {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @frozen public struct Words {
    @usableFromInline
    internal let _value: Swift.UInt128
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @_transparent public init(_value: Swift.UInt128) {
      self._value = _value
    }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var words: Swift.UInt128.Words {
    @_transparent get {
    Words(_value: self)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func &= (a: inout Swift.UInt128, b: Swift.UInt128) {
    a._value = Builtin.and_Int128(a._value, b._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func |= (a: inout Swift.UInt128, b: Swift.UInt128) {
    a._value = Builtin.or_Int128(a._value, b._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func ^= (a: inout Swift.UInt128, b: Swift.UInt128) {
    a._value = Builtin.xor_Int128(a._value, b._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func &>>= (a: inout Swift.UInt128, b: Swift.UInt128) {
    let masked = b & 127
    a._value = Builtin.lshr_Int128(a._value, masked._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func &<<= (a: inout Swift.UInt128, b: Swift.UInt128) {
    let masked = b & 127
    a._value = Builtin.shl_Int128(a._value, masked._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    _low == 0 ? 64 + _high.trailingZeroBitCount : _low.trailingZeroBitCount
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
    UInt(Builtin.trunc_Int128_Int64(_value))
  }
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Stride = Swift.Int
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128.Words : Swift.RandomAccessCollection {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias Element = Swift.UInt
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias Index = Swift.Int
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias SubSequence = Swift.Slice<Swift.UInt128.Words>
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias Indices = Swift.Range<Swift.Int>
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var count: Swift.Int {
    @_transparent get {
    128 / UInt.bitWidth
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var startIndex: Swift.Int {
    @_transparent get {
    0
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var endIndex: Swift.Int {
    @_transparent get {
    count
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var indices: Swift.UInt128.Words.Indices {
    @_transparent get {
    startIndex ..< endIndex
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public func index(after i: Swift.Int) -> Swift.Int {
    i + 1
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public func index(before i: Swift.Int) -> Swift.Int {
    i - 1
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public subscript(position: Swift.Int) -> Swift.UInt {
    @inlinable get {
      _precondition(position >= 0 && position < count, "Index out of bounds")
      var value = _value
      let index = position
      return _withUnprotectedUnsafePointer(to: &value) {
        $0.withMemoryRebound(to: UInt.self, capacity: count) { $0[index] }
      }
    }
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Iterator = Swift.IndexingIterator<Swift.UInt128.Words>
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 : Swift.FixedWidthInteger, Swift.UnsignedInteger {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { 128 }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    _high.nonzeroBitCount &+ _low.nonzeroBitCount
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    _high == 0 ? 64 + _low.leadingZeroBitCount : _high.leadingZeroBitCount
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public var byteSwapped: Swift.UInt128 {
    @_transparent get {
    return Self(_low: _high.byteSwapped, _high: _low.byteSwapped)
  }
  }
}
@inlinable public func sequence<T>(first: T, next: @escaping (T) -> T?) -> Swift.UnfoldFirstSequence<T> {
   
   
   
   
  return sequence(state: (first, true), next: { (state: inout (T?, Bool)) -> T? in
    switch state {
    case (let value, true):
      state.1 = false
      return value
    case (let value?, _):
      let nextValue = next(value)
      state.0 = nextValue
      return nextValue
    case (nil, _):
      return nil
    }
  })
}
@inlinable public func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) -> Swift.UnfoldSequence<T, State> {
  return UnfoldSequence(_state: state, _next: next)
}
public typealias UnfoldFirstSequence<T> = Swift.UnfoldSequence<T, (T?, Swift.Bool)>
@frozen public struct UnfoldSequence<Element, State> : Swift.Sequence, Swift.IteratorProtocol {
  @usableFromInline
  internal var _state: State
  @usableFromInline
  internal let _next: (inout State) -> Element?
  @usableFromInline
  internal var _done: Swift.Bool = false
  @inlinable public mutating func next() -> Element? {
    guard !_done else { return nil }
    if let elt = _next(&_state) {
        return elt
    } else {
        _done = true
        return nil
    }
  }
  @inlinable internal init(_state: State, _next: @escaping (inout State) -> Element?) {
    self._state = _state
    self._next = _next
  }
  public typealias Iterator = Swift.UnfoldSequence<Element, State>
}
extension Swift.UnfoldSequence : @unchecked Swift.Sendable where Element : Swift.Sendable, State : Swift.Sendable {
}
extension Swift.Slice where Base == Swift.UnsafeMutableRawBufferPointer {
  @inlinable @_alwaysEmitIntoClient public func copyBytes<C>(from source: C) where C : Swift.Collection, C.Element == Swift.UInt8 {
    let buffer = Base(rebasing: self)
    buffer.copyBytes(from: source)
  }
  @discardableResult
  @inlinable @_alwaysEmitIntoClient public func initializeMemory<T>(as type: T.Type, repeating repeatedValue: T) -> Swift.UnsafeMutableBufferPointer<T> {
    let buffer = Base(rebasing: self)
    return buffer.initializeMemory(as: T.self, repeating: repeatedValue)
  }
  @inlinable @_alwaysEmitIntoClient public func initializeMemory<S>(as type: S.Element.Type, from source: S) -> (unwritten: S.Iterator, initialized: Swift.UnsafeMutableBufferPointer<S.Element>) where S : Swift.Sequence {
    let buffer = Base(rebasing: self)
    return buffer.initializeMemory(as: S.Element.self, from: source)
  }
  @inlinable @_alwaysEmitIntoClient public func initializeMemory<C>(as type: C.Element.Type, fromContentsOf source: C) -> Swift.UnsafeMutableBufferPointer<C.Element> where C : Swift.Collection {
    let buffer = Base(rebasing: self)
    return buffer.initializeMemory(as: C.Element.self, fromContentsOf: source)
  }
  @discardableResult
  @inlinable @_alwaysEmitIntoClient public func moveInitializeMemory<T>(as type: T.Type, fromContentsOf source: Swift.UnsafeMutableBufferPointer<T>) -> Swift.UnsafeMutableBufferPointer<T> {
    let buffer = Base(rebasing: self)
    return buffer.moveInitializeMemory(as: T.self, fromContentsOf: source)
  }
  @discardableResult
  @inlinable @_alwaysEmitIntoClient public func moveInitializeMemory<T>(as type: T.Type, fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<T>>) -> Swift.UnsafeMutableBufferPointer<T> {
    let buffer = Base(rebasing: self)
    return buffer.moveInitializeMemory(as: T.self, fromContentsOf: source)
  }
  @discardableResult
  @inlinable @_alwaysEmitIntoClient public func bindMemory<T>(to type: T.Type) -> Swift.UnsafeMutableBufferPointer<T> {
    let buffer = Base(rebasing: self)
    return buffer.bindMemory(to: T.self)
  }
  #if compiler(>=5.3) && $TypedThrows
  @inlinable @_alwaysEmitIntoClient public func withMemoryRebound<T, Result, E>(to type: T.Type, _ body: (Swift.UnsafeMutableBufferPointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
    let buffer = Base(rebasing: self)
    return try buffer.withMemoryRebound(to: T.self, body)
  }
  #endif
  @inlinable @_alwaysEmitIntoClient public func assumingMemoryBound<T>(to type: T.Type) -> Swift.UnsafeMutableBufferPointer<T> {
    let buffer = Base(rebasing: self)
    return buffer.assumingMemoryBound(to: T.self)
  }
  @inlinable @_alwaysEmitIntoClient public func load<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    let buffer = Base(rebasing: self)
    return buffer.load(fromByteOffset: offset, as: T.self)
  }
  @inlinable @_alwaysEmitIntoClient public func loadUnaligned<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T where T : Swift.BitwiseCopyable {
    let buffer = Base(rebasing: self)
    return buffer.loadUnaligned(fromByteOffset: offset, as: T.self)
  }
  @inlinable @_alwaysEmitIntoClient public func loadUnaligned<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    let buffer = Base(rebasing: self)
    return buffer.loadUnaligned(fromByteOffset: offset, as: T.self)
  }
  @inlinable @_alwaysEmitIntoClient public func storeBytes<T>(of value: T, toByteOffset offset: Swift.Int = 0, as type: T.Type) {
    let buffer = Base(rebasing: self)
    buffer.storeBytes(of: value, toByteOffset: offset, as: T.self)
  }
}
extension Swift.Slice where Base == Swift.UnsafeRawBufferPointer {
  @discardableResult
  @inlinable @_alwaysEmitIntoClient public func bindMemory<T>(to type: T.Type) -> Swift.UnsafeBufferPointer<T> {
    let buffer = Base(rebasing: self)
    return buffer.bindMemory(to: T.self)
  }
  #if compiler(>=5.3) && $TypedThrows
  @inlinable @_alwaysEmitIntoClient public func withMemoryRebound<T, Result, E>(to type: T.Type, _ body: (Swift.UnsafeBufferPointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
    let buffer = Base(rebasing: self)
    return try buffer.withMemoryRebound(to: T.self, body)
  }
  #endif
  @inlinable @_alwaysEmitIntoClient public func assumingMemoryBound<T>(to type: T.Type) -> Swift.UnsafeBufferPointer<T> {
    let buffer = Base(rebasing: self)
    return buffer.assumingMemoryBound(to: T.self)
  }
  @inlinable @_alwaysEmitIntoClient public func load<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    let buffer = Base(rebasing: self)
    return buffer.load(fromByteOffset: offset, as: T.self)
  }
  @inlinable @_alwaysEmitIntoClient public func loadUnaligned<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T where T : Swift.BitwiseCopyable {
    let buffer = Base(rebasing: self)
    return buffer.loadUnaligned(fromByteOffset: offset, as: T.self)
  }
  @inlinable @_alwaysEmitIntoClient public func loadUnaligned<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    let buffer = Base(rebasing: self)
    return buffer.loadUnaligned(fromByteOffset: offset, as: T.self)
  }
}
extension Swift.Slice {
  @inlinable @_alwaysEmitIntoClient public func withMemoryRebound<T, Result, Element>(to type: T.Type, _ body: (Swift.UnsafeBufferPointer<T>) throws -> Result) rethrows -> Result where Base == Swift.UnsafeBufferPointer<Element> {
    let rebased = UnsafeBufferPointer<Element>(rebasing: self)
    return try rebased.withMemoryRebound(to: T.self, body)
  }
}
extension Swift.Slice {
  @inlinable @_alwaysEmitIntoClient public func initialize<Element>(repeating repeatedValue: Element) where Base == Swift.UnsafeMutableBufferPointer<Element> {
    Base(rebasing: self).initialize(repeating: repeatedValue)
  }
  @inlinable @_alwaysEmitIntoClient public func initialize<S>(from source: S) -> (unwritten: S.Iterator, index: Swift.Slice<Base>.Index) where Base == Swift.UnsafeMutableBufferPointer<S.Element>, S : Swift.Sequence {
    let buffer = Base(rebasing: self)
    let (iterator, index) = buffer.initialize(from: source)
    let distance = buffer.distance(from: buffer.startIndex, to: index)
    return (iterator, startIndex.advanced(by: distance))
  }
  @inlinable @_alwaysEmitIntoClient public func initialize<Element>(fromContentsOf source: some Collection<Element>) -> Swift.Slice<Base>.Index where Base == Swift.UnsafeMutableBufferPointer<Element> {
    let buffer = Base(rebasing: self)
    let index = buffer.initialize(fromContentsOf: source)
    let distance = buffer.distance(from: buffer.startIndex, to: index)
    return startIndex.advanced(by: distance)
  }
  @inlinable @_alwaysEmitIntoClient public func update<Element>(repeating repeatedValue: Element) where Base == Swift.UnsafeMutableBufferPointer<Element> {
    Base(rebasing: self).update(repeating: repeatedValue)
  }
  @inlinable @_alwaysEmitIntoClient public func update<S>(from source: S) -> (unwritten: S.Iterator, index: Swift.Slice<Base>.Index) where Base == Swift.UnsafeMutableBufferPointer<S.Element>, S : Swift.Sequence {
    let buffer = Base(rebasing: self)
    let (iterator, index) = buffer.update(from: source)
    let distance = buffer.distance(from: buffer.startIndex, to: index)
    return (iterator, startIndex.advanced(by: distance))
  }
  @inlinable @_alwaysEmitIntoClient public func update<Element>(fromContentsOf source: some Collection<Element>) -> Swift.Slice<Base>.Index where Base == Swift.UnsafeMutableBufferPointer<Element> {
    let buffer = Base(rebasing: self)
    let index = buffer.update(fromContentsOf: source)
    let distance = buffer.distance(from: buffer.startIndex, to: index)
    return startIndex.advanced(by: distance)
  }
  @inlinable @_alwaysEmitIntoClient public func moveInitialize<Element>(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) -> Swift.Slice<Base>.Index where Base == Swift.UnsafeMutableBufferPointer<Element> {
    let buffer = Base(rebasing: self)
    let index = buffer.moveInitialize(fromContentsOf: source)
    let distance = buffer.distance(from: buffer.startIndex, to: index)
    return startIndex.advanced(by: distance)
  }
  @inlinable @_alwaysEmitIntoClient public func moveInitialize<Element>(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) -> Swift.Slice<Base>.Index where Base == Swift.UnsafeMutableBufferPointer<Element> {
    let buffer = Base(rebasing: self)
    let index = buffer.moveInitialize(fromContentsOf: source)
    let distance = buffer.distance(from: buffer.startIndex, to: index)
    return startIndex.advanced(by: distance)
  }
  @inlinable @_alwaysEmitIntoClient public func moveUpdate<Element>(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) -> Swift.Slice<Base>.Index where Base == Swift.UnsafeMutableBufferPointer<Element> {
    let buffer = Base(rebasing: self)
    let index = buffer.moveUpdate(fromContentsOf: source)
    let distance = buffer.distance(from: buffer.startIndex, to: index)
    return startIndex.advanced(by: distance)
  }
  @inlinable @_alwaysEmitIntoClient public func moveUpdate<Element>(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) -> Swift.Slice<Base>.Index where Base == Swift.UnsafeMutableBufferPointer<Element> {
    let buffer = Base(rebasing: self)
    let index = buffer.moveUpdate(fromContentsOf: source)
    let distance = buffer.distance(from: buffer.startIndex, to: index)
    return startIndex.advanced(by: distance)
  }
  @discardableResult
  @inlinable @_alwaysEmitIntoClient public func deinitialize<Element>() -> Swift.UnsafeMutableRawBufferPointer where Base == Swift.UnsafeMutableBufferPointer<Element> {
    Base(rebasing: self).deinitialize()
  }
  @inlinable @_alwaysEmitIntoClient public func initializeElement<Element>(at index: Swift.Int, to value: Element) where Base == Swift.UnsafeMutableBufferPointer<Element> {
    assert(startIndex <= index && index < endIndex)
    base.baseAddress.unsafelyUnwrapped.advanced(by: index).initialize(to: value)
  }
  @inlinable @_alwaysEmitIntoClient public func moveElement<Element>(from index: Swift.Slice<Base>.Index) -> Element where Base == Swift.UnsafeMutableBufferPointer<Element> {
    assert(startIndex <= index && index < endIndex)
    return base.baseAddress.unsafelyUnwrapped.advanced(by: index).move()
  }
  @inlinable @_alwaysEmitIntoClient public func deinitializeElement<Element>(at index: Swift.UnsafeMutableBufferPointer<Element>.Index) where Base == Swift.UnsafeMutableBufferPointer<Element> {
    assert(startIndex <= index && index < endIndex)
    base.baseAddress.unsafelyUnwrapped.advanced(by: index).deinitialize(count: 1)
  }
  @inlinable @_alwaysEmitIntoClient public func withMemoryRebound<T, Result, Element>(to type: T.Type, _ body: (Swift.UnsafeMutableBufferPointer<T>) throws -> Result) rethrows -> Result where Base == Swift.UnsafeMutableBufferPointer<Element> {
    try Base(rebasing: self).withMemoryRebound(to: T.self, body)
  }
  @inlinable @_alwaysEmitIntoClient public func withContiguousMutableStorageIfAvailable<R, Element>(_ body: (_ buffer: inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? where Base == Swift.UnsafeMutableBufferPointer<Element> {
    try base.withContiguousStorageIfAvailable { buffer in
      let start = base.baseAddress?.advanced(by: startIndex)
      var slice = UnsafeMutableBufferPointer(start: start, count: count)
      let (b,c) = (slice.baseAddress, slice.count)
      defer {
        _precondition(
          slice.baseAddress == b && slice.count == c,
          "withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed")
      }
      return try body(&slice)
    }
  }
}
public protocol CVarArg {
  var _cVarArgEncoding: [Swift.Int] { get }
}
public protocol _CVarArgPassedAsDouble : Swift.CVarArg {
}
public protocol _CVarArgAligned : Swift.CVarArg {
  var _cVarArgAlignment: Swift.Int { get }
}
@usableFromInline
internal typealias _VAUInt = Swift.CUnsignedInt
@usableFromInline
internal typealias _VAInt = Swift.Int32
@inlinable public func withVaList<R>(_ args: [any Swift.CVarArg], _ body: (Swift.CVaListPointer) -> R) -> R {
  let builder = __VaListBuilder()
  for a in args {
    builder.append(a)
  }
  return _withVaList(builder, body)
}
@inlinable internal func _withVaList<R>(_ builder: Swift.__VaListBuilder, _ body: (Swift.CVaListPointer) -> R) -> R {
  let result = body(builder.va_list())
  _fixLifetime(builder)
  return result
}
@inlinable public func getVaList(_ args: [any Swift.CVarArg]) -> Swift.CVaListPointer {
  let builder = __VaListBuilder()
  for a in args {
    builder.append(a)
  }
   
  Builtin.retain(builder)
  Builtin.autorelease(builder)
  return builder.va_list()
}
@inlinable public func _encodeBitsAsWords<T>(_ x: T) -> [Swift.Int] {
  let result = [Int](
    repeating: 0,
    count: (MemoryLayout<T>.size + MemoryLayout<Int>.size - 1) / MemoryLayout<Int>.size)
  _internalInvariant(!result.isEmpty)
  var tmp = x
   
#if $TypedThrows
  _withUnprotectedUnsafeMutablePointer(to: &tmp) {
    _memcpy(dest: UnsafeMutablePointer(result._baseAddressIfContiguous!),
            src: $0,
            size: UInt(MemoryLayout<T>.size))
  }
#else
  __abi_se0413_withUnsafeMutablePointer(to: &tmp) {
    _memcpy(dest: UnsafeMutablePointer(result._baseAddressIfContiguous!),
            src: $0,
            size: UInt(MemoryLayout<T>.size))
  }
#endif
  return result
}
extension Swift.Int : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension Swift.Bool : Swift.CVarArg {
  public var _cVarArgEncoding: [Swift.Int] {
    get
  }
}
extension Swift.Int64 : Swift.CVarArg, Swift._CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
  @inlinable public var _cVarArgAlignment: Swift.Int {
    get {
     
    return MemoryLayout.alignment(ofValue: self)
  }
  }
}
extension Swift.Int32 : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(_VAInt(self))
  }
  }
}
extension Swift.Int16 : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(_VAInt(self))
  }
  }
}
extension Swift.Int8 : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(_VAInt(self))
  }
  }
}
extension Swift.UInt : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension Swift.UInt64 : Swift.CVarArg, Swift._CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
  @inlinable public var _cVarArgAlignment: Swift.Int {
    get {
     
    return MemoryLayout.alignment(ofValue: self)
  }
  }
}
extension Swift.UInt32 : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(_VAUInt(self))
  }
  }
}
extension Swift.UInt16 : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(_VAUInt(self))
  }
  }
}
extension Swift.UInt8 : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(_VAUInt(self))
  }
  }
}
extension Swift.OpaquePointer : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafePointer : Swift.CVarArg where Pointee : ~Copyable {
  @inlinable @_preInverseGenerics public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
#else
extension Swift.UnsafePointer : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafeMutablePointer : Swift.CVarArg where Pointee : ~Copyable {
  @inlinable @_preInverseGenerics public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
#endif
extension Swift.AutoreleasingUnsafeMutablePointer : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension Swift.Float : Swift._CVarArgPassedAsDouble, Swift._CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(Double(self))
  }
  }
  @inlinable public var _cVarArgAlignment: Swift.Int {
    get {
     
    return MemoryLayout.alignment(ofValue: Double(self))
  }
  }
}
extension Swift.Double : Swift._CVarArgPassedAsDouble, Swift._CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
  @inlinable public var _cVarArgAlignment: Swift.Int {
    get {
     
    return MemoryLayout.alignment(ofValue: self)
  }
  }
}
@usableFromInline
@_fixed_layout final internal class __VaListBuilder {
  @inlinable internal init() {}
  @inlinable final internal func append(_ arg: any Swift.CVarArg) {

     
     
     
     
     

     
    appendWords(arg._cVarArgEncoding)
  }
  @usableFromInline
  final internal func va_list() -> Swift.CVaListPointer
  @inlinable final internal func appendWords(_ words: [Swift.Int]) {
    let newCount = count + words.count
    if newCount > allocated {
      let oldAllocated = allocated
      let oldStorage = storage
      let oldCount = count

      allocated = max(newCount, allocated * 2)
      let newStorage = allocStorage(wordCount: allocated)
      storage = newStorage
       

      if let allocatedOldStorage = oldStorage {
        newStorage.moveInitialize(from: allocatedOldStorage, count: oldCount)
        deallocStorage(wordCount: oldAllocated, storage: allocatedOldStorage)
      }
    }

    let allocatedStorage = storage!
    for word in words {
      allocatedStorage[count] = word
      count += 1
    }
  }
  @inlinable final internal func rawSizeAndAlignment(_ wordCount: Swift.Int) -> (Builtin.Word, Builtin.Word) {
    return ((wordCount * MemoryLayout<Int>.stride)._builtinWordValue,
      requiredAlignmentInBytes._builtinWordValue)
  }
  @inlinable final internal func allocStorage(wordCount: Swift.Int) -> Swift.UnsafeMutablePointer<Swift.Int> {
    let (rawSize, rawAlignment) = rawSizeAndAlignment(wordCount)
    let rawStorage = Builtin.allocRaw(rawSize, rawAlignment)
    return UnsafeMutablePointer<Int>(rawStorage)
  }
  @usableFromInline
  final internal func deallocStorage(wordCount: Swift.Int, storage: Swift.UnsafeMutablePointer<Swift.Int>)
  @objc @inlinable deinit {
    if let allocatedStorage = storage {
      deallocStorage(wordCount: allocated, storage: allocatedStorage)
    }
  }
  @usableFromInline
  final internal let requiredAlignmentInBytes: Swift.Int = MemoryLayout<Double>.alignment
  @usableFromInline
  final internal var count: Swift.Int = 0
  @usableFromInline
  final internal var allocated: Swift.Int = 0
  @usableFromInline
  final internal var storage: Swift.UnsafeMutablePointer<Swift.Int>?
}
@available(*, unavailable)
extension Swift.__VaListBuilder : Swift.Sendable {
}
@inlinable public func zip<Sequence1, Sequence2>(_ sequence1: Sequence1, _ sequence2: Sequence2) -> Swift.Zip2Sequence<Sequence1, Sequence2> where Sequence1 : Swift.Sequence, Sequence2 : Swift.Sequence {
  return Zip2Sequence(sequence1, sequence2)
}
@frozen public struct Zip2Sequence<Sequence1, Sequence2> where Sequence1 : Swift.Sequence, Sequence2 : Swift.Sequence {
  @usableFromInline
  internal let _sequence1: Sequence1
  @usableFromInline
  internal let _sequence2: Sequence2
  @inlinable internal init(_ sequence1: Sequence1, _ sequence2: Sequence2) {
    (_sequence1, _sequence2) = (sequence1, sequence2)
  }
}
extension Swift.Zip2Sequence {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _baseStream1: Sequence1.Iterator
    @usableFromInline
    internal var _baseStream2: Sequence2.Iterator
    @usableFromInline
    internal var _reachedEnd: Swift.Bool = false
    @inlinable internal init(_ iterator1: Sequence1.Iterator, _ iterator2: Sequence2.Iterator) {
      (_baseStream1, _baseStream2) = (iterator1, iterator2)
    }
  }
}
extension Swift.Zip2Sequence.Iterator : Swift.IteratorProtocol {
  public typealias Element = (Sequence1.Element, Sequence2.Element)
  @inlinable public mutating func next() -> Swift.Zip2Sequence<Sequence1, Sequence2>.Iterator.Element? {
     
     
     
     
     

    if _reachedEnd {
      return nil
    }

    guard let element1 = _baseStream1.next(),
          let element2 = _baseStream2.next() else {
      _reachedEnd = true
      return nil
    }

    return (element1, element2)
  }
}
extension Swift.Zip2Sequence : Swift.Sequence {
  public typealias Element = (Sequence1.Element, Sequence2.Element)
  @inlinable public __consuming func makeIterator() -> Swift.Zip2Sequence<Sequence1, Sequence2>.Iterator {
    return Iterator(
      _sequence1.makeIterator(),
      _sequence2.makeIterator())
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return Swift.min(
      _sequence1.underestimatedCount,
      _sequence2.underestimatedCount
    )
  }
  }
}
extension Swift.Zip2Sequence : Swift.Sendable where Sequence1 : Swift.Sendable, Sequence2 : Swift.Sendable {
}
extension Swift.Zip2Sequence.Iterator : Swift.Sendable where Sequence1.Iterator : Swift.Sendable, Sequence2.Iterator : Swift.Sendable {
}
infix operator .== : ComparisonPrecedence
infix operator .!= : ComparisonPrecedence
infix operator .< : ComparisonPrecedence
infix operator .<= : ComparisonPrecedence
infix operator .> : ComparisonPrecedence
infix operator .>= : ComparisonPrecedence
infix operator .& : LogicalConjunctionPrecedence
infix operator .^ : LogicalDisjunctionPrecedence
infix operator .| : LogicalDisjunctionPrecedence
infix operator .&= : AssignmentPrecedence
infix operator .^= : AssignmentPrecedence
infix operator .|= : AssignmentPrecedence
prefix operator .!
public protocol SIMDStorage {
  associatedtype Scalar : Swift.Decodable, Swift.Encodable, Swift.Hashable
  var scalarCount: Swift.Int { get }
  init()
  subscript(index: Swift.Int) -> Self.Scalar { get set }
}
extension Swift.SIMDStorage {
  @_alwaysEmitIntoClient public static var scalarCount: Swift.Int {
    get {
     
     
     
    return Self().scalarCount
  }
  }
}
public protocol SIMDScalar : Swift.BitwiseCopyable {
  associatedtype SIMDMaskScalar : Swift.FixedWidthInteger, Swift.SIMDScalar, Swift.SignedInteger where Self.SIMDMaskScalar == Self.SIMDMaskScalar.SIMDMaskScalar
  associatedtype SIMD2Storage : Swift.SIMDStorage where Self.SIMD2Storage.Scalar == Self.SIMD32Storage.Scalar
  associatedtype SIMD4Storage : Swift.SIMDStorage where Self.SIMD4Storage.Scalar == Self.SIMD64Storage.Scalar
  associatedtype SIMD8Storage : Swift.SIMDStorage
  associatedtype SIMD16Storage : Swift.SIMDStorage where Self == Self.SIMD16Storage.Scalar, Self.SIMD16Storage.Scalar == Self.SIMD2Storage.Scalar
  associatedtype SIMD32Storage : Swift.SIMDStorage where Self.SIMD32Storage.Scalar == Self.SIMD4Storage.Scalar
  associatedtype SIMD64Storage : Swift.SIMDStorage where Self.SIMD64Storage.Scalar == Self.SIMD8Storage.Scalar
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol SIMD<Scalar> : Swift.CustomStringConvertible, Swift.Decodable, Swift.Encodable, Swift.ExpressibleByArrayLiteral, Swift.Hashable, Swift.SIMDStorage {
  associatedtype MaskStorage : Swift.SIMD where Self.MaskStorage.Scalar : Swift.FixedWidthInteger, Self.MaskStorage.Scalar : Swift.SignedInteger
}
#else
public protocol SIMD : Swift.CustomStringConvertible, Swift.Decodable, Swift.Encodable, Swift.ExpressibleByArrayLiteral, Swift.Hashable, Swift.SIMDStorage {
  associatedtype MaskStorage : Swift.SIMD where Self.MaskStorage.Scalar : Swift.FixedWidthInteger, Self.MaskStorage.Scalar : Swift.SignedInteger
}
#endif
extension Swift.SIMD {
  @_transparent public var indices: Swift.Range<Swift.Int> {
    @_transparent get {
    return 0 ..< scalarCount
  }
  }
  @_transparent public init(repeating value: Self.Scalar) {
    self.init()
    for i in indices { self[i] = value }
  }
  @_transparent public static func == (a: Self, b: Self) -> Swift.Bool {
    var result = true
    for i in a.indices { result = result && a[i] == b[i] }
    return result
  }
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    for i in indices { hasher.combine(self[i]) }
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public var description: Swift.String {
    get
  }
  @_transparent public static func .== (a: Self, b: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    var result = SIMDMask<MaskStorage>()
    for i in result.indices { result[i] = a[i] == b[i] }
    return result
  }
  @_transparent public static func .!= (a: Self, b: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    var result = SIMDMask<MaskStorage>()
    for i in result.indices { result[i] = a[i] != b[i] }
    return result
  }
  @_transparent public mutating func replace(with other: Self, where mask: Swift.SIMDMask<Self.MaskStorage>) {
    for i in indices { self[i] = mask[i] ? other[i] : self[i] }
  }
  @inlinable public init(arrayLiteral scalars: Self.Scalar...) {
    self.init(scalars)
  }
  @inlinable public init<S>(_ scalars: S) where S : Swift.Sequence, Self.Scalar == S.Element {
    self.init()
    var index = 0
    for scalar in scalars {
      if index == scalarCount {
        _preconditionFailure("Too many elements in sequence.")
      }
      self[index] = scalar
      index += 1
    }
    if index < scalarCount {
      _preconditionFailure("Not enough elements in sequence.")
    }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD2<Index>) -> Swift.SIMD2<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD2<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD3<Index>) -> Swift.SIMD3<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD3<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD4<Index>) -> Swift.SIMD4<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD4<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD8<Index>) -> Swift.SIMD8<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD8<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD16<Index>) -> Swift.SIMD16<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD16<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD32<Index>) -> Swift.SIMD32<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD32<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD64<Index>) -> Swift.SIMD64<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD64<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
}
extension Swift.SIMD where Self.Scalar : Swift.Comparable {
  @_transparent public static func .< (a: Self, b: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    var result = SIMDMask<MaskStorage>()
    for i in result.indices { result[i] = a[i] < b[i] }
    return result
  }
  @_transparent public static func .<= (a: Self, b: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    var result = SIMDMask<MaskStorage>()
    for i in result.indices { result[i] = a[i] <= b[i] }
    return result
  }
  @_alwaysEmitIntoClient public func min() -> Self.Scalar {
    return indices.reduce(into: self[0]) { $0 = Swift.min($0, self[$1]) }
  }
  @_alwaysEmitIntoClient public func max() -> Self.Scalar {
    return indices.reduce(into: self[0]) { $0 = Swift.max($0, self[$1]) }
  }
}
extension Swift.SIMD {
  @_transparent public static func .== (a: Self.Scalar, b: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return Self(repeating: a) .== b
  }
  @_transparent public static func .!= (a: Self.Scalar, b: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return Self(repeating: a) .!= b
  }
  @_transparent public static func .== (a: Self, b: Self.Scalar) -> Swift.SIMDMask<Self.MaskStorage> {
    return a .== Self(repeating: b)
  }
  @_transparent public static func .!= (a: Self, b: Self.Scalar) -> Swift.SIMDMask<Self.MaskStorage> {
    return a .!= Self(repeating: b)
  }
  @_transparent public mutating func replace(with other: Self.Scalar, where mask: Swift.SIMDMask<Self.MaskStorage>) {
    replace(with: Self(repeating: other), where: mask)
  }
  @_transparent public func replacing(with other: Self, where mask: Swift.SIMDMask<Self.MaskStorage>) -> Self {
    var result = self
    result.replace(with: other, where: mask)
    return result
  }
  @_transparent public func replacing(with other: Self.Scalar, where mask: Swift.SIMDMask<Self.MaskStorage>) -> Self {
    return replacing(with: Self(repeating: other), where: mask)
  }
}
extension Swift.SIMD where Self.Scalar : Swift.Comparable {
  @_transparent public static func .>= (a: Self, b: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return b .<= a
  }
  @_transparent public static func .> (a: Self, b: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return b .< a
  }
  @_transparent public static func .< (a: Self.Scalar, b: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return Self(repeating: a) .< b
  }
  @_transparent public static func .<= (a: Self.Scalar, b: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return Self(repeating: a) .<= b
  }
  @_transparent public static func .>= (a: Self.Scalar, b: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return Self(repeating: a) .>= b
  }
  @_transparent public static func .> (a: Self.Scalar, b: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return Self(repeating: a) .> b
  }
  @_transparent public static func .< (a: Self, b: Self.Scalar) -> Swift.SIMDMask<Self.MaskStorage> {
    return a .< Self(repeating: b)
  }
  @_transparent public static func .<= (a: Self, b: Self.Scalar) -> Swift.SIMDMask<Self.MaskStorage> {
    return a .<= Self(repeating: b)
  }
  @_transparent public static func .>= (a: Self, b: Self.Scalar) -> Swift.SIMDMask<Self.MaskStorage> {
    return a .>= Self(repeating: b)
  }
  @_transparent public static func .> (a: Self, b: Self.Scalar) -> Swift.SIMDMask<Self.MaskStorage> {
    return a .> Self(repeating: b)
  }
  @_alwaysEmitIntoClient public mutating func clamp(lowerBound: Self, upperBound: Self) {
    self = self.clamped(lowerBound: lowerBound, upperBound: upperBound)
  }
  @_alwaysEmitIntoClient public func clamped(lowerBound: Self, upperBound: Self) -> Self {
    return pointwiseMin(upperBound, pointwiseMax(lowerBound, self))
  }
}
extension Swift.SIMD where Self.Scalar : Swift.FixedWidthInteger {
  @_transparent public static var zero: Self {
    @_transparent get {
    return Self()
  }
  }
  @_alwaysEmitIntoClient public static var one: Self {
    get {
    return Self(repeating: 1)
  }
  }
  @inlinable public static func random<T>(in range: Swift.Range<Self.Scalar>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    var result = Self()
    for i in result.indices {
      result[i] = Scalar.random(in: range, using: &generator)
    }
    return result
  }
  @inlinable public static func random(in range: Swift.Range<Self.Scalar>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
  @inlinable public static func random<T>(in range: Swift.ClosedRange<Self.Scalar>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    var result = Self()
    for i in result.indices {
      result[i] = Scalar.random(in: range, using: &generator)
    }
    return result
  }
  @inlinable public static func random(in range: Swift.ClosedRange<Self.Scalar>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}
extension Swift.SIMD where Self.Scalar : Swift.FloatingPoint {
  @_transparent public static var zero: Self {
    @_transparent get {
    return Self()
  }
  }
  @_alwaysEmitIntoClient public static var one: Self {
    get {
    return Self(repeating: 1)
  }
  }
  @_alwaysEmitIntoClient public mutating func clamp(lowerBound: Self, upperBound: Self) {
    self = self.clamped(lowerBound: lowerBound, upperBound: upperBound)
  }
  @_alwaysEmitIntoClient public func clamped(lowerBound: Self, upperBound: Self) -> Self {
    return pointwiseMin(upperBound, pointwiseMax(lowerBound, self))
  }
}
extension Swift.SIMD where Self.Scalar : Swift.BinaryFloatingPoint, Self.Scalar.RawSignificand : Swift.FixedWidthInteger {
  @inlinable public static func random<T>(in range: Swift.Range<Self.Scalar>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    var result = Self()
    for i in result.indices {
      result[i] = Scalar.random(in: range, using: &generator)
    }
    return result
  }
  @inlinable public static func random(in range: Swift.Range<Self.Scalar>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
  @inlinable public static func random<T>(in range: Swift.ClosedRange<Self.Scalar>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    var result = Self()
    for i in result.indices {
      result[i] = Scalar.random(in: range, using: &generator)
    }
    return result
  }
  @inlinable public static func random(in range: Swift.ClosedRange<Self.Scalar>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}
@frozen public struct SIMDMask<Storage> : Swift.SIMD where Storage : Swift.SIMD, Storage.Scalar : Swift.FixedWidthInteger, Storage.Scalar : Swift.SignedInteger {
  public var _storage: Storage
  public typealias MaskStorage = Storage
  public typealias Scalar = Swift.Bool
  @_transparent public init() {
    _storage = Storage()
  }
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return _storage.scalarCount
  }
  }
  @_transparent public init(_ _storage: Storage) {
    self._storage = _storage
  }
  public subscript(index: Swift.Int) -> Swift.Bool {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index] < 0
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue ? -1 : 0
    }
  }
  public typealias ArrayLiteralElement = Swift.SIMDMask<Storage>.Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.SIMDMask : Swift.Sendable where Storage : Swift.Sendable {
}
extension Swift.SIMDMask {
  @inlinable public static func random<T>(using generator: inout T) -> Swift.SIMDMask<Storage> where T : Swift.RandomNumberGenerator {
    var result = SIMDMask()
    for i in result.indices { result[i] = Bool.random(using: &generator) }
    return result
  }
  @inlinable public static func random() -> Swift.SIMDMask<Storage> {
    var g = SystemRandomNumberGenerator()
    return SIMDMask.random(using: &g)
  }
}
extension Swift.SIMD where Self.Scalar : Swift.FixedWidthInteger {
  @_transparent public var leadingZeroBitCount: Self {
    @_transparent get {
    var result = Self()
    for i in indices { result[i] = Scalar(self[i].leadingZeroBitCount) }
    return result
  }
  }
  @_transparent public var trailingZeroBitCount: Self {
    @_transparent get {
    var result = Self()
    for i in indices { result[i] = Scalar(self[i].trailingZeroBitCount) }
    return result
  }
  }
  @_transparent public var nonzeroBitCount: Self {
    @_transparent get {
    var result = Self()
    for i in indices { result[i] = Scalar(self[i].nonzeroBitCount) }
    return result
  }
  }
  @_transparent prefix public static func ~ (a: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = ~a[i] }
    return result
  }
  @_transparent public static func & (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] & b[i] }
    return result
  }
  @_transparent public static func ^ (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] ^ b[i] }
    return result
  }
  @_transparent public static func | (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] | b[i] }
    return result
  }
  @_transparent public static func &<< (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] &<< b[i] }
    return result
  }
  @_transparent public static func &>> (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] &>> b[i] }
    return result
  }
  @_transparent public static func &+ (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] &+ b[i] }
    return result
  }
  @_transparent public static func &- (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] &- b[i] }
    return result
  }
  @_transparent public static func &* (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] &* b[i] }
    return result
  }
  @_transparent public static func / (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] / b[i] }
    return result
  }
  @_transparent public static func % (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] % b[i] }
    return result
  }
  @_alwaysEmitIntoClient public func wrappedSum() -> Self.Scalar {
    var result: Scalar = 0
    for i in indices {
      result &+= self[i]
    }
    return result
  }
}
extension Swift.SIMD where Self.Scalar : Swift.FloatingPoint {
  @_transparent public static func + (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] + b[i] }
    return result
  }
  @_transparent public static func - (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] - b[i] }
    return result
  }
  @_transparent public static func * (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] * b[i] }
    return result
  }
  @_transparent public static func / (a: Self, b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = a[i] / b[i] }
    return result
  }
  @_transparent public func addingProduct(_ a: Self, _ b: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = self[i].addingProduct(a[i], b[i]) }
    return result
  }
  @_transparent public func squareRoot() -> Self {
    var result = Self()
    for i in result.indices { result[i] = self[i].squareRoot() }
    return result
  }
  @_transparent public func rounded(_ rule: Swift.FloatingPointRoundingRule) -> Self {
    var result = Self()
    for i in result.indices { result[i] = self[i].rounded(rule) }
    return result
  }
  @_alwaysEmitIntoClient public func min() -> Self.Scalar {
    return indices.reduce(into: self[0]) { $0 = Scalar.minimum($0, self[$1]) }
  }
  @_alwaysEmitIntoClient public func max() -> Self.Scalar {
    return indices.reduce(into: self[0]) { $0 = Scalar.maximum($0, self[$1]) }
  }
  @_alwaysEmitIntoClient public func sum() -> Self.Scalar {
     
     
     
     
     
     
    var result = -Scalar.zero
    for i in indices {
      result += self[i]
    }
    return result
  }
}
extension Swift.SIMDMask {
  @_transparent prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(~a._storage)
  }
  @_transparent public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(a._storage & b._storage)
  }
  @_transparent public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(a._storage ^ b._storage)
  }
  @_transparent public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(a._storage | b._storage)
  }
}
extension Swift.SIMD where Self.Scalar : Swift.FixedWidthInteger {
  @_transparent public static func & (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) & b
  }
  @_transparent public static func ^ (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) ^ b
  }
  @_transparent public static func | (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) | b
  }
  @_transparent public static func &<< (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) &<< b
  }
  @_transparent public static func &>> (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) &>> b
  }
  @_transparent public static func &+ (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) &+ b
  }
  @_transparent public static func &- (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) &- b
  }
  @_transparent public static func &* (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) &* b
  }
  @_transparent public static func / (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) / b
  }
  @_transparent public static func % (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) % b
  }
  @_transparent public static func & (a: Self, b: Self.Scalar) -> Self {
    return a & Self(repeating: b)
  }
  @_transparent public static func ^ (a: Self, b: Self.Scalar) -> Self {
    return a ^ Self(repeating: b)
  }
  @_transparent public static func | (a: Self, b: Self.Scalar) -> Self {
    return a | Self(repeating: b)
  }
  @_transparent public static func &<< (a: Self, b: Self.Scalar) -> Self {
    return a &<< Self(repeating: b)
  }
  @_transparent public static func &>> (a: Self, b: Self.Scalar) -> Self {
    return a &>> Self(repeating: b)
  }
  @_transparent public static func &+ (a: Self, b: Self.Scalar) -> Self {
    return a &+ Self(repeating: b)
  }
  @_transparent public static func &- (a: Self, b: Self.Scalar) -> Self {
    return a &- Self(repeating: b)
  }
  @_transparent public static func &* (a: Self, b: Self.Scalar) -> Self {
    return a &* Self(repeating: b)
  }
  @_transparent public static func / (a: Self, b: Self.Scalar) -> Self {
    return a / Self(repeating: b)
  }
  @_transparent public static func % (a: Self, b: Self.Scalar) -> Self {
    return a % Self(repeating: b)
  }
  @_transparent public static func &= (a: inout Self, b: Self) {
    a = a & b
  }
  @_transparent public static func ^= (a: inout Self, b: Self) {
    a = a ^ b
  }
  @_transparent public static func |= (a: inout Self, b: Self) {
    a = a | b
  }
  @_transparent public static func &<<= (a: inout Self, b: Self) {
    a = a &<< b
  }
  @_transparent public static func &>>= (a: inout Self, b: Self) {
    a = a &>> b
  }
  @_transparent public static func &+= (a: inout Self, b: Self) {
    a = a &+ b
  }
  @_transparent public static func &-= (a: inout Self, b: Self) {
    a = a &- b
  }
  @_transparent public static func &*= (a: inout Self, b: Self) {
    a = a &* b
  }
  @_transparent public static func /= (a: inout Self, b: Self) {
    a = a / b
  }
  @_transparent public static func %= (a: inout Self, b: Self) {
    a = a % b
  }
  @_transparent public static func &= (a: inout Self, b: Self.Scalar) {
    a = a & b
  }
  @_transparent public static func ^= (a: inout Self, b: Self.Scalar) {
    a = a ^ b
  }
  @_transparent public static func |= (a: inout Self, b: Self.Scalar) {
    a = a | b
  }
  @_transparent public static func &<<= (a: inout Self, b: Self.Scalar) {
    a = a &<< b
  }
  @_transparent public static func &>>= (a: inout Self, b: Self.Scalar) {
    a = a &>> b
  }
  @_transparent public static func &+= (a: inout Self, b: Self.Scalar) {
    a = a &+ b
  }
  @_transparent public static func &-= (a: inout Self, b: Self.Scalar) {
    a = a &- b
  }
  @_transparent public static func &*= (a: inout Self, b: Self.Scalar) {
    a = a &* b
  }
  @_transparent public static func /= (a: inout Self, b: Self.Scalar) {
    a = a / b
  }
  @_transparent public static func %= (a: inout Self, b: Self.Scalar) {
    a = a % b
  }
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+' instead")
  public static func + (a: Self, b: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-' instead")
  public static func - (a: Self, b: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*' instead")
  public static func * (a: Self, b: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+' instead")
  public static func + (a: Self, b: Self.Scalar) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-' instead")
  public static func - (a: Self, b: Self.Scalar) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*' instead")
  public static func * (a: Self, b: Self.Scalar) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+' instead")
  public static func + (a: Self.Scalar, b: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-' instead")
  public static func - (a: Self.Scalar, b: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*' instead")
  public static func * (a: Self.Scalar, b: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+=' instead")
  public static func += (a: inout Self, b: Self)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-=' instead")
  public static func -= (a: inout Self, b: Self)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*=' instead")
  public static func *= (a: inout Self, b: Self)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+=' instead")
  public static func += (a: inout Self, b: Self.Scalar)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-=' instead")
  public static func -= (a: inout Self, b: Self.Scalar)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*=' instead")
  public static func *= (a: inout Self, b: Self.Scalar)
}
extension Swift.SIMD where Self.Scalar : Swift.FloatingPoint {
  @_transparent prefix public static func - (a: Self) -> Self {
    return 0 - a
  }
  @_transparent public static func + (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) + b
  }
  @_transparent public static func - (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) - b
  }
  @_transparent public static func * (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) * b
  }
  @_transparent public static func / (a: Self.Scalar, b: Self) -> Self {
    return Self(repeating: a) / b
  }
  @_transparent public static func + (a: Self, b: Self.Scalar) -> Self {
    return a + Self(repeating: b)
  }
  @_transparent public static func - (a: Self, b: Self.Scalar) -> Self {
    return a - Self(repeating: b)
  }
  @_transparent public static func * (a: Self, b: Self.Scalar) -> Self {
    return a * Self(repeating: b)
  }
  @_transparent public static func / (a: Self, b: Self.Scalar) -> Self {
    return a / Self(repeating: b)
  }
  @_transparent public static func += (a: inout Self, b: Self) {
    a = a + b
  }
  @_transparent public static func -= (a: inout Self, b: Self) {
    a = a - b
  }
  @_transparent public static func *= (a: inout Self, b: Self) {
    a = a * b
  }
  @_transparent public static func /= (a: inout Self, b: Self) {
    a = a / b
  }
  @_transparent public static func += (a: inout Self, b: Self.Scalar) {
    a = a + b
  }
  @_transparent public static func -= (a: inout Self, b: Self.Scalar) {
    a = a - b
  }
  @_transparent public static func *= (a: inout Self, b: Self.Scalar) {
    a = a * b
  }
  @_transparent public static func /= (a: inout Self, b: Self.Scalar) {
    a = a / b
  }
  @_transparent public func addingProduct(_ a: Self.Scalar, _ b: Self) -> Self {
    return self.addingProduct(Self(repeating: a), b)
  }
  @_transparent public func addingProduct(_ a: Self, _ b: Self.Scalar) -> Self {
    return self.addingProduct(a, Self(repeating: b))
  }
  @_transparent public mutating func addProduct(_ a: Self, _ b: Self) {
    self = self.addingProduct(a, b)
  }
  @_transparent public mutating func addProduct(_ a: Self.Scalar, _ b: Self) {
    self = self.addingProduct(a, b)
  }
  @_transparent public mutating func addProduct(_ a: Self, _ b: Self.Scalar) {
    self = self.addingProduct(a, b)
  }
  @_transparent public mutating func formSquareRoot() {
    self = self.squareRoot()
  }
  @_transparent public mutating func round(_ rule: Swift.FloatingPointRoundingRule) {
    self = self.rounded(rule)
  }
}
extension Swift.SIMDMask {
  @_transparent public static func .& (a: Swift.Bool, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(repeating: a) .& b
  }
  @_transparent public static func .^ (a: Swift.Bool, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(repeating: a) .^ b
  }
  @_transparent public static func .| (a: Swift.Bool, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(repeating: a) .| b
  }
  @_transparent public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.Bool) -> Swift.SIMDMask<Storage> {
    return a .& SIMDMask(repeating: b)
  }
  @_transparent public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.Bool) -> Swift.SIMDMask<Storage> {
    return a .^ SIMDMask(repeating: b)
  }
  @_transparent public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.Bool) -> Swift.SIMDMask<Storage> {
    return a .| SIMDMask(repeating: b)
  }
  @_transparent public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_transparent public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_transparent public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_transparent public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.Bool) {
    a = a .& b
  }
  @_transparent public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.Bool) {
    a = a .^ b
  }
  @_transparent public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.Bool) {
    a = a .| b
  }
}
@_alwaysEmitIntoClient public func any<Storage>(_ mask: Swift.SIMDMask<Storage>) -> Swift.Bool where Storage : Swift.SIMD, Storage.Scalar : Swift.FixedWidthInteger, Storage.Scalar : Swift.SignedInteger {
  return mask._storage.min() < 0
}
@_alwaysEmitIntoClient public func all<Storage>(_ mask: Swift.SIMDMask<Storage>) -> Swift.Bool where Storage : Swift.SIMD, Storage.Scalar : Swift.FixedWidthInteger, Storage.Scalar : Swift.SignedInteger {
  return mask._storage.max() < 0
}
@_alwaysEmitIntoClient public func pointwiseMin<T>(_ a: T, _ b: T) -> T where T : Swift.SIMD, T.Scalar : Swift.Comparable {
  var result = T()
  for i in result.indices {
    result[i] = min(a[i], b[i])
  }
  return result
}
@_alwaysEmitIntoClient public func pointwiseMax<T>(_ a: T, _ b: T) -> T where T : Swift.SIMD, T.Scalar : Swift.Comparable {
  var result = T()
  for i in result.indices {
    result[i] = max(a[i], b[i])
  }
  return result
}
@_alwaysEmitIntoClient public func pointwiseMin<T>(_ a: T, _ b: T) -> T where T : Swift.SIMD, T.Scalar : Swift.FloatingPoint {
  var result = T()
  for i in result.indices {
    result[i] = T.Scalar.minimum(a[i], b[i])
  }
  return result
}
@_alwaysEmitIntoClient public func pointwiseMax<T>(_ a: T, _ b: T) -> T where T : Swift.SIMD, T.Scalar : Swift.FloatingPoint {
  var result = T()
  for i in result.indices {
    result[i] = T.Scalar.maximum(a[i], b[i])
  }
  return result
}
extension Swift.SIMD where Self : Swift.AdditiveArithmetic, Self.Scalar : Swift.FloatingPoint {
  @_alwaysEmitIntoClient public static func += (a: inout Self, b: Self) {
    a = a + b
  }
  @_alwaysEmitIntoClient public static func -= (a: inout Self, b: Self) {
    a = a - b
  }
}
@available(swift, deprecated: 4.2, obsoleted: 5.0)
@_objcRuntimeName(_TtCs18__stdlib_AtomicInt) final public class _stdlib_AtomicInt {
  public init(_ value: Swift.Int = 0)
  final public func store(_ desired: Swift.Int)
  final public func load() -> Swift.Int
  @discardableResult
  final public func fetchAndAdd(_ operand: Swift.Int) -> Swift.Int
  final public func addAndFetch(_ operand: Swift.Int) -> Swift.Int
  @discardableResult
  final public func fetchAndAnd(_ operand: Swift.Int) -> Swift.Int
  final public func andAndFetch(_ operand: Swift.Int) -> Swift.Int
  @discardableResult
  final public func fetchAndOr(_ operand: Swift.Int) -> Swift.Int
  final public func orAndFetch(_ operand: Swift.Int) -> Swift.Int
  @discardableResult
  final public func fetchAndXor(_ operand: Swift.Int) -> Swift.Int
  final public func xorAndFetch(_ operand: Swift.Int) -> Swift.Int
  final public func compareExchange(expected: inout Swift.Int, desired: Swift.Int) -> Swift.Bool
  @objc deinit
}
@available(*, unavailable)
extension Swift._stdlib_AtomicInt : Swift.Sendable {
}
@usableFromInline
internal func _swift_stdlib_atomicCompareExchangeStrongInt(object target: Swift.UnsafeMutablePointer<Swift.Int>, expected: Swift.UnsafeMutablePointer<Swift.Int>, desired: Swift.Int) -> Swift.Bool
public func _swift_stdlib_atomicLoadInt(object target: Swift.UnsafeMutablePointer<Swift.Int>) -> Swift.Int
@usableFromInline
internal func _swift_stdlib_atomicStoreInt(object target: Swift.UnsafeMutablePointer<Swift.Int>, desired: Swift.Int)
public func _swift_stdlib_atomicFetchAddInt(object target: Swift.UnsafeMutablePointer<Swift.Int>, operand: Swift.Int) -> Swift.Int
@usableFromInline
internal func _swift_stdlib_atomicFetchAddInt32(object target: Swift.UnsafeMutablePointer<Swift.Int32>, operand: Swift.Int32) -> Swift.Int32
@usableFromInline
internal func _swift_stdlib_atomicFetchAddInt64(object target: Swift.UnsafeMutablePointer<Swift.Int64>, operand: Swift.Int64) -> Swift.Int64
public func _swift_stdlib_atomicFetchAndInt(object target: Swift.UnsafeMutablePointer<Swift.Int>, operand: Swift.Int) -> Swift.Int
@usableFromInline
internal func _swift_stdlib_atomicFetchAndInt32(object target: Swift.UnsafeMutablePointer<Swift.Int32>, operand: Swift.Int32) -> Swift.Int32
@usableFromInline
internal func _swift_stdlib_atomicFetchAndInt64(object target: Swift.UnsafeMutablePointer<Swift.Int64>, operand: Swift.Int64) -> Swift.Int64
public func _swift_stdlib_atomicFetchOrInt(object target: Swift.UnsafeMutablePointer<Swift.Int>, operand: Swift.Int) -> Swift.Int
@usableFromInline
internal func _swift_stdlib_atomicFetchOrInt32(object target: Swift.UnsafeMutablePointer<Swift.Int32>, operand: Swift.Int32) -> Swift.Int32
@usableFromInline
internal func _swift_stdlib_atomicFetchOrInt64(object target: Swift.UnsafeMutablePointer<Swift.Int64>, operand: Swift.Int64) -> Swift.Int64
public func _swift_stdlib_atomicFetchXorInt(object target: Swift.UnsafeMutablePointer<Swift.Int>, operand: Swift.Int) -> Swift.Int
@usableFromInline
internal func _swift_stdlib_atomicFetchXorInt32(object target: Swift.UnsafeMutablePointer<Swift.Int32>, operand: Swift.Int32) -> Swift.Int32
@usableFromInline
internal func _swift_stdlib_atomicFetchXorInt64(object target: Swift.UnsafeMutablePointer<Swift.Int64>, operand: Swift.Int64) -> Swift.Int64
@inlinable internal func _isspace_clocale(_ u: Swift.UTF16.CodeUnit) -> Swift.Bool {
  return "\t\n\u{b}\u{c}\r ".utf16.contains(u)
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 : Swift.LosslessStringConvertible {
  @inlinable public init?<S>(_ text: S) where S : Swift.StringProtocol {
 
    self.init(Substring(text))
 
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  public init?(_ text: Swift.Substring)
}
extension Swift.Float : Swift.LosslessStringConvertible {
  @inlinable public init?<S>(_ text: S) where S : Swift.StringProtocol {
 
 
 
 
 
 
      self = 0.0
#if $TypedThrows
      let success = _withUnprotectedUnsafeMutablePointer(to: &self) { p -> Bool in
        text.withCString { chars -> Bool in
          switch chars[0] {
          case 9, 10, 11, 12, 13, 32:
            return false  
          case 0:
            return false  
          default:
            break
          }
          let endPtr = _swift_stdlib_strtof_clocale(chars, p)
           
          return endPtr != nil && endPtr![0] == 0
        }
      }
#else
      let success = __abi_se0413_withUnsafeMutablePointer(to: &self) { p -> Bool in
        text.withCString { chars -> Bool in
          switch chars[0] {
          case 9, 10, 11, 12, 13, 32:
            return false  
          case 0:
            return false  
          default:
            break
          }
          let endPtr = _swift_stdlib_strtof_clocale(chars, p)
           
          return endPtr != nil && endPtr![0] == 0
        }
      }
#endif
      if !success {
        return nil
      }
 
 
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  public init?(_ text: Swift.Substring)
}
extension Swift.Double : Swift.LosslessStringConvertible {
  @inlinable public init?<S>(_ text: S) where S : Swift.StringProtocol {
 
 
 
 
 
 
      self = 0.0
#if $TypedThrows
      let success = _withUnprotectedUnsafeMutablePointer(to: &self) { p -> Bool in
        text.withCString { chars -> Bool in
          switch chars[0] {
          case 9, 10, 11, 12, 13, 32:
            return false  
          case 0:
            return false  
          default:
            break
          }
          let endPtr = _swift_stdlib_strtod_clocale(chars, p)
           
          return endPtr != nil && endPtr![0] == 0
        }
      }
#else
      let success = __abi_se0413_withUnsafeMutablePointer(to: &self) { p -> Bool in
        text.withCString { chars -> Bool in
          switch chars[0] {
          case 9, 10, 11, 12, 13, 32:
            return false  
          case 0:
            return false  
          default:
            break
          }
          let endPtr = _swift_stdlib_strtod_clocale(chars, p)
           
          return endPtr != nil && endPtr![0] == 0
        }
      }
#endif
      if !success {
        return nil
      }
 
 
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  public init?(_ text: Swift.Substring)
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct Float16 {
  public var _value: Builtin.FPIEEE16
  @_transparent public init() {
    let zero: Int64 = 0
    self._value = Builtin.sitofp_Int64_FPIEEE16(zero._value)
  }
  @_transparent public init(_ _value: Builtin.FPIEEE16) {
    self._value = _value
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 : Swift.BinaryFloatingPoint {
  public typealias Magnitude = Swift.Float16
  public typealias Exponent = Swift.Int
  public typealias RawSignificand = Swift.UInt16
  @inlinable public static var exponentBitCount: Swift.Int {
    get {
    return 5
  }
  }
  @inlinable public static var significandBitCount: Swift.Int {
    get {
    return 10
  }
  }
  @inlinable internal static var _infinityExponent: Swift.UInt {
    @inline(__always) get { return 1 &<< UInt(exponentBitCount) - 1 }
  }
  @inlinable internal static var _exponentBias: Swift.UInt {
    @inline(__always) get { return _infinityExponent &>> 1 }
  }
  @inlinable internal static var _significandMask: Swift.UInt16 {
    @inline(__always) get {
      return 1 &<< UInt16(significandBitCount) - 1
    }
  }
  @inlinable internal static var _quietNaNMask: Swift.UInt16 {
    @inline(__always) get {
      return 1 &<< UInt16(significandBitCount - 1)
    }
  }
  @inlinable public var bitPattern: Swift.UInt16 {
    get {
    return UInt16(Builtin.bitcast_FPIEEE16_Int16(_value))
  }
  }
  @inlinable public init(bitPattern: Swift.UInt16) {
    self.init(Builtin.bitcast_Int16_FPIEEE16(bitPattern._value))
  }
  @inlinable public var sign: Swift.FloatingPointSign {
    get {
    let shift = Float16.significandBitCount + Float16.exponentBitCount
    return FloatingPointSign(
      rawValue: Int(bitPattern &>> UInt16(shift))
    )!
  }
  }
  @available(*, unavailable, renamed: "sign")
  public var isSignMinus: Swift.Bool {
    get
  }
  @inlinable public var exponentBitPattern: Swift.UInt {
    get {
    return UInt(bitPattern &>> UInt16(Float16.significandBitCount)) &
      Float16._infinityExponent
  }
  }
  @inlinable public var significandBitPattern: Swift.UInt16 {
    get {
    return UInt16(bitPattern) & Float16._significandMask
  }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponentBitPattern: Swift.UInt, significandBitPattern: Swift.UInt16) {
    let signShift = Float16.significandBitCount + Float16.exponentBitCount
    let sign = UInt16(sign == .minus ? 1 : 0)
    let exponent = UInt16(
      exponentBitPattern & Float16._infinityExponent
    )
    let significand = UInt16(
      significandBitPattern & Float16._significandMask
    )
    self.init(bitPattern:
      sign &<< UInt16(signShift) |
      exponent &<< UInt16(Float16.significandBitCount) |
      significand
    )
  }
  @inlinable public var isCanonical: Swift.Bool {
    get {
     
     
     
     
    if Self.leastNonzeroMagnitude == Self.leastNormalMagnitude {
      if exponentBitPattern == 0 && significandBitPattern != 0 {
        return false
      }
    }
    return true
  }
  }
  @inlinable public static var infinity: Swift.Float16 {
    get {
 
    return Float16(
      sign: .plus,
      exponentBitPattern: _infinityExponent,
      significandBitPattern: 0
    )
 
  }
  }
  @inlinable public static var nan: Swift.Float16 {
    get {
 
    return Float16(nan: 0, signaling: false)
 
  }
  }
  @inlinable public static var signalingNaN: Swift.Float16 {
    get {
    return Float16(nan: 0, signaling: true)
  }
  }
  @available(*, unavailable, renamed: "nan")
  public static var quietNaN: Swift.Float16 {
    get
  }
  @inlinable public static var greatestFiniteMagnitude: Swift.Float16 {
    get {
 
    return Float16(
      sign: .plus,
      exponentBitPattern: _infinityExponent - 1,
      significandBitPattern: _significandMask
    )
 
  }
  }
  @inlinable public static var pi: Swift.Float16 {
    get {
 
    return 0x1.92p1
 
  }
  }
  @inlinable public var ulp: Swift.Float16 {
    get {
 
    guard _fastPath(isFinite) else { return .nan }
    if _fastPath(isNormal) {
      let bitPattern_ = bitPattern & Float16.infinity.bitPattern
      return Float16(bitPattern: bitPattern_) * 0x1p-10
    }
     
    return .leastNormalMagnitude * 0x1p-10
 
  }
  }
  @inlinable public static var leastNormalMagnitude: Swift.Float16 {
    get {
    return 0x1.0p-14
  }
  }
  @inlinable public static var leastNonzeroMagnitude: Swift.Float16 {
    get {
    return leastNormalMagnitude * ulpOfOne
  }
  }
  @inlinable public static var ulpOfOne: Swift.Float16 {
    get {
    return 0x1.0p-10
  }
  }
  @inlinable public var exponent: Swift.Int {
    get {
    if !isFinite { return .max }
    if isZero { return .min }
    let provisional = Int(exponentBitPattern) - Int(Float16._exponentBias)
    if isNormal { return provisional }
    let shift =
      Float16.significandBitCount - significandBitPattern._binaryLogarithm()
    return provisional + 1 - shift
  }
  }
  @inlinable public var significand: Swift.Float16 {
    get {
    if isNaN { return self }
    if isNormal {
      return Float16(sign: .plus,
        exponentBitPattern: Float16._exponentBias,
        significandBitPattern: significandBitPattern)
    }
    if isSubnormal {
      let shift =
        Float16.significandBitCount - significandBitPattern._binaryLogarithm()
      return Float16(
        sign: .plus,
        exponentBitPattern: Float16._exponentBias,
        significandBitPattern: significandBitPattern &<< shift
      )
    }
     
    return Float16(
      sign: .plus,
      exponentBitPattern: exponentBitPattern,
      significandBitPattern: 0
    )
  }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: Swift.Float16) {
    var result = significand
    if sign == .minus { result = -result }
    if significand.isFinite && !significand.isZero {
      var clamped = exponent
      let leastNormalExponent = 1 - Int(Float16._exponentBias)
      let greatestFiniteExponent = Int(Float16._exponentBias)
      if clamped < leastNormalExponent {
        clamped = max(clamped, 3*leastNormalExponent)
        while clamped < leastNormalExponent {
          result  *= Float16.leastNormalMagnitude
          clamped -= leastNormalExponent
        }
      }
      else if clamped > greatestFiniteExponent {
        clamped = min(clamped, 3*greatestFiniteExponent)
        let step = Float16(sign: .plus,
          exponentBitPattern: Float16._infinityExponent - 1,
          significandBitPattern: 0)
        while clamped > greatestFiniteExponent {
          result  *= step
          clamped -= greatestFiniteExponent
        }
      }
      let scale = Float16(
        sign: .plus,
        exponentBitPattern: UInt(Int(Float16._exponentBias) + clamped),
        significandBitPattern: 0
      )
      result = result * scale
    }
    self = result
  }
  @inlinable public init(nan payload: Swift.Float16.RawSignificand, signaling: Swift.Bool) {
     
    _precondition(payload < (Float16._quietNaNMask &>> 1),
      "NaN payload is not encodable.")
    var significand = payload
    significand |= Float16._quietNaNMask &>> (signaling ? 1 : 0)
    self.init(
      sign: .plus,
      exponentBitPattern: Float16._infinityExponent,
      significandBitPattern: significand
    )
  }
  @inlinable public var nextUp: Swift.Float16 {
    get {
 
     
    let x = self + 0
    if _fastPath(x < .infinity) {
      let increment = Int16(bitPattern: x.bitPattern) &>> 15 | 1
      let bitPattern_ = x.bitPattern &+ UInt16(bitPattern: increment)
      return Float16(bitPattern: bitPattern_)
    }
    return x
 
  }
  }
  @_transparent public init(signOf sign: Swift.Float16, magnitudeOf mag: Swift.Float16) {
    _value = Builtin.int_copysign_FPIEEE16(mag._value, sign._value)
  }
  @_transparent public mutating func round(_ rule: Swift.FloatingPointRoundingRule) {
    switch rule {
    case .toNearestOrAwayFromZero:
      _value = Builtin.int_round_FPIEEE16(_value)
    case .toNearestOrEven:
      _value = Builtin.int_rint_FPIEEE16(_value)
    case .towardZero:
      _value = Builtin.int_trunc_FPIEEE16(_value)
    case .awayFromZero:
      if sign == .minus {
        _value = Builtin.int_floor_FPIEEE16(_value)
      }
      else {
        _value = Builtin.int_ceil_FPIEEE16(_value)
      }
    case .up:
      _value = Builtin.int_ceil_FPIEEE16(_value)
    case .down:
      _value = Builtin.int_floor_FPIEEE16(_value)
    #if !$Embedded
    @unknown default:
      self._roundSlowPath(rule)
    #endif
    }
  }
  @usableFromInline
  internal mutating func _roundSlowPath(_ rule: Swift.FloatingPointRoundingRule)
  @_transparent public mutating func negate() {
    _value = Builtin.fneg_FPIEEE16(self._value)
  }
  @_transparent public static func += (lhs: inout Swift.Float16, rhs: Swift.Float16) {
    lhs._value = Builtin.fadd_FPIEEE16(lhs._value, rhs._value)
  }
  @_transparent public static func -= (lhs: inout Swift.Float16, rhs: Swift.Float16) {
    lhs._value = Builtin.fsub_FPIEEE16(lhs._value, rhs._value)
  }
  @_transparent public static func *= (lhs: inout Swift.Float16, rhs: Swift.Float16) {
    lhs._value = Builtin.fmul_FPIEEE16(lhs._value, rhs._value)
  }
  @_transparent public static func /= (lhs: inout Swift.Float16, rhs: Swift.Float16) {
    lhs._value = Builtin.fdiv_FPIEEE16(lhs._value, rhs._value)
  }
  @inlinable @inline(__always) public mutating func formRemainder(dividingBy other: Swift.Float16) {
 
    self = Float16(_stdlib_remainderf(Float(self), Float(other)))
 
  }
  @inlinable @inline(__always) public mutating func formTruncatingRemainder(dividingBy other: Swift.Float16) {
    _value = Builtin.frem_FPIEEE16(self._value, other._value)
  }
  @_transparent public mutating func formSquareRoot() {
 
    self = Float16(_stdlib_squareRootf(Float(self)))
 
  }
  @_transparent public mutating func addProduct(_ lhs: Swift.Float16, _ rhs: Swift.Float16) {
    _value = Builtin.int_fma_FPIEEE16(lhs._value, rhs._value, _value)
  }
  @_transparent public func isEqual(to other: Swift.Float16) -> Swift.Bool {
    return Bool(Builtin.fcmp_oeq_FPIEEE16(self._value, other._value))
  }
  @_transparent public func isLess(than other: Swift.Float16) -> Swift.Bool {
    return Bool(Builtin.fcmp_olt_FPIEEE16(self._value, other._value))
  }
  @_transparent public func isLessThanOrEqualTo(_ other: Swift.Float16) -> Swift.Bool {
    return Bool(Builtin.fcmp_ole_FPIEEE16(self._value, other._value))
  }
  @inlinable public var isNormal: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern > 0 && isFinite
    }
  }
  @inlinable public var isFinite: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern < Float16._infinityExponent
    }
  }
  @inlinable public var isZero: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern == 0
    }
  }
  @inlinable public var isSubnormal: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern != 0
    }
  }
  @inlinable public var isInfinite: Swift.Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern == 0
    }
  }
  @inlinable public var isNaN: Swift.Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern != 0
    }
  }
  @inlinable public var isSignalingNaN: Swift.Bool {
    @inline(__always) get {
      return isNaN && (significandBitPattern & Float16._quietNaNMask) == 0
    }
  }
  @inlinable public var binade: Swift.Float16 {
    get {
 
    guard _fastPath(isFinite) else { return .nan }
    if _slowPath(isSubnormal) {
      let bitPattern_ =
        (self * 0x1p10).bitPattern
          & (-Float16.infinity).bitPattern
      return Float16(bitPattern: bitPattern_) * 0x1p-10
    }
    return Float16(bitPattern: bitPattern & (-Float16.infinity).bitPattern)
 
  }
  }
  @inlinable public var significandWidth: Swift.Int {
    get {
    let trailingZeroBits = significandBitPattern.trailingZeroBitCount
    if isNormal {
      guard significandBitPattern != 0 else { return 0 }
      return Float16.significandBitCount &- trailingZeroBits
    }
    if isSubnormal {
      let leadingZeroBits = significandBitPattern.leadingZeroBitCount
      return UInt16.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
    }
    return -1
  }
  }
  @inlinable @inline(__always) public init(floatLiteral value: Swift.Float16) {
    self = value
  }
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias FloatLiteralType = Swift.Float16
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias RawExponent = Swift.UInt
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 : Swift._ExpressibleByBuiltinIntegerLiteral, Swift.ExpressibleByIntegerLiteral {
  @_transparent public init(_builtinIntegerLiteral value: Builtin.IntLiteral) {
    self = Float16(Builtin.itofp_with_overflow_IntLiteral_FPIEEE16(value))
  }
  @_transparent public init(integerLiteral value: Swift.Int64) {
    self = Float16(Builtin.sitofp_Int64_FPIEEE16(value._value))
  }
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias IntegerLiteralType = Swift.Int64
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 : Swift._ExpressibleByBuiltinFloatLiteral {
  @_transparent public init(_builtinFloatLiteral value: Builtin.FPIEEE64) {
 
     
    self = Float16(Builtin.fptrunc_FPIEEE64_FPIEEE16(value))
 
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    var v = self
    if isZero {
       
       
      v = 0
    }
 
    hasher.combine(v.bitPattern)
 
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
     
     
    let v = isZero ? 0 : self
 
    return Hasher._hash(seed: seed, bytes: UInt64(v.bitPattern), count: 2)
 
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 {
  @inlinable public var magnitude: Swift.Float16 {
    @inline(__always) get {
      return Float16(Builtin.int_fabs_FPIEEE16(_value))
    }
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 {
  @_transparent prefix public static func - (x: Swift.Float16) -> Swift.Float16 {
    return Float16(Builtin.fneg_FPIEEE16(x._value))
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 : Swift.Sendable {
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 {
  @_transparent public init(_ v: Swift.Int) {
    _value = Builtin.sitofp_Int64_FPIEEE16(v._value)
  }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
      if Source.isSigned {
        let asInt = Int64(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE16(asInt._value)
      } else {
        let asUInt = UInt64(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE16(asUInt._value)
      }
    } else {
       
       
       
      self = Float16._convert(from: value).value
    }
  }
  @_alwaysEmitIntoClient @inline(never) public init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
       
       
       
       
       
       
       
       
       
       
       
      if Source.isSigned {
        let extended = Int(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE16(extended._value)
 
        guard self.isFinite && Int(self) == extended else {
 
          return nil
        }
      } else {
        let extended = UInt(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE16(extended._value)
 
        guard self.isFinite && UInt(self) == extended else {
 
          return nil
        }
      }
    } else {
       
       
       
      let (value_, exact) = Self._convert(from: value)
      guard exact else { return nil }
      self = value_
    }
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @inlinable @inline(__always) public init(_ other: Swift.Float16) {
 
    _value = other._value
 
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @inlinable @inline(__always) public init?(exactly other: Swift.Float16) {
    self.init(other)
     
     
     
    if Float16(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Float) {
 
    _value = Builtin.fptrunc_FPIEEE32_FPIEEE16(other._value)
 
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Float) {
    self.init(other)
     
     
     
    if Float(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Double) {
 
    _value = Builtin.fptrunc_FPIEEE64_FPIEEE16(other._value)
 
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Double) {
    self.init(other)
     
     
     
    if Double(self) != other {
      return nil
    }
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 {
  @_transparent public static func + (lhs: Swift.Float16, rhs: Swift.Float16) -> Swift.Float16 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Float16, rhs: Swift.Float16) -> Swift.Float16 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Float16, rhs: Swift.Float16) -> Swift.Float16 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Float16, rhs: Swift.Float16) -> Swift.Float16 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 : Swift.Strideable {
  @_transparent public func distance(to other: Swift.Float16) -> Swift.Float16 {
    return other - self
  }
  @_transparent public func advanced(by amount: Swift.Float16) -> Swift.Float16 {
    return self + amount
  }
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias Stride = Swift.Float16
}
@frozen public struct Float {
  public var _value: Builtin.FPIEEE32
  @_transparent public init() {
    let zero: Int64 = 0
    self._value = Builtin.sitofp_Int64_FPIEEE32(zero._value)
  }
  @_transparent public init(_ _value: Builtin.FPIEEE32) {
    self._value = _value
  }
}
extension Swift.Float : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Swift.Float : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.Float : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Swift.Float : Swift.BinaryFloatingPoint {
  public typealias Magnitude = Swift.Float
  public typealias Exponent = Swift.Int
  public typealias RawSignificand = Swift.UInt32
  @inlinable public static var exponentBitCount: Swift.Int {
    get {
    return 8
  }
  }
  @inlinable public static var significandBitCount: Swift.Int {
    get {
    return 23
  }
  }
  @inlinable internal static var _infinityExponent: Swift.UInt {
    @inline(__always) get { return 1 &<< UInt(exponentBitCount) - 1 }
  }
  @inlinable internal static var _exponentBias: Swift.UInt {
    @inline(__always) get { return _infinityExponent &>> 1 }
  }
  @inlinable internal static var _significandMask: Swift.UInt32 {
    @inline(__always) get {
      return 1 &<< UInt32(significandBitCount) - 1
    }
  }
  @inlinable internal static var _quietNaNMask: Swift.UInt32 {
    @inline(__always) get {
      return 1 &<< UInt32(significandBitCount - 1)
    }
  }
  @inlinable public var bitPattern: Swift.UInt32 {
    get {
    return UInt32(Builtin.bitcast_FPIEEE32_Int32(_value))
  }
  }
  @inlinable public init(bitPattern: Swift.UInt32) {
    self.init(Builtin.bitcast_Int32_FPIEEE32(bitPattern._value))
  }
  @inlinable public var sign: Swift.FloatingPointSign {
    get {
    let shift = Float.significandBitCount + Float.exponentBitCount
    return FloatingPointSign(
      rawValue: Int(bitPattern &>> UInt32(shift))
    )!
  }
  }
  @available(*, unavailable, renamed: "sign")
  public var isSignMinus: Swift.Bool {
    get
  }
  @inlinable public var exponentBitPattern: Swift.UInt {
    get {
    return UInt(bitPattern &>> UInt32(Float.significandBitCount)) &
      Float._infinityExponent
  }
  }
  @inlinable public var significandBitPattern: Swift.UInt32 {
    get {
    return UInt32(bitPattern) & Float._significandMask
  }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponentBitPattern: Swift.UInt, significandBitPattern: Swift.UInt32) {
    let signShift = Float.significandBitCount + Float.exponentBitCount
    let sign = UInt32(sign == .minus ? 1 : 0)
    let exponent = UInt32(
      exponentBitPattern & Float._infinityExponent
    )
    let significand = UInt32(
      significandBitPattern & Float._significandMask
    )
    self.init(bitPattern:
      sign &<< UInt32(signShift) |
      exponent &<< UInt32(Float.significandBitCount) |
      significand
    )
  }
  @inlinable public var isCanonical: Swift.Bool {
    get {
     
     
     
     
    if Self.leastNonzeroMagnitude == Self.leastNormalMagnitude {
      if exponentBitPattern == 0 && significandBitPattern != 0 {
        return false
      }
    }
    return true
  }
  }
  @inlinable public static var infinity: Swift.Float {
    get {
 
    return Float(bitPattern: 0x7f800000)
 
  }
  }
  @inlinable public static var nan: Swift.Float {
    get {
 
    return Float(bitPattern: 0x7fc00000)
 
  }
  }
  @inlinable public static var signalingNaN: Swift.Float {
    get {
    return Float(nan: 0, signaling: true)
  }
  }
  @available(*, unavailable, renamed: "nan")
  public static var quietNaN: Swift.Float {
    get
  }
  @inlinable public static var greatestFiniteMagnitude: Swift.Float {
    get {
 
    return 0x1.fffffep127
 
  }
  }
  @inlinable public static var pi: Swift.Float {
    get {
 
     
     
     
     
     
    return 0x1.921fb4p1
 
  }
  }
  @inlinable public var ulp: Swift.Float {
    get {
 
    guard _fastPath(isFinite) else { return .nan }
    if _fastPath(isNormal) {
      let bitPattern_ = bitPattern & Float.infinity.bitPattern
      return Float(bitPattern: bitPattern_) * 0x1p-23
    }
     
    return .leastNormalMagnitude * 0x1p-23
 
  }
  }
  @inlinable public static var leastNormalMagnitude: Swift.Float {
    get {
    return 0x1.0p-126
  }
  }
  @inlinable public static var leastNonzeroMagnitude: Swift.Float {
    get {
    return leastNormalMagnitude * ulpOfOne
  }
  }
  @inlinable public static var ulpOfOne: Swift.Float {
    get {
    return 0x1.0p-23
  }
  }
  @inlinable public var exponent: Swift.Int {
    get {
    if !isFinite { return .max }
    if isZero { return .min }
    let provisional = Int(exponentBitPattern) - Int(Float._exponentBias)
    if isNormal { return provisional }
    let shift =
      Float.significandBitCount - significandBitPattern._binaryLogarithm()
    return provisional + 1 - shift
  }
  }
  @inlinable public var significand: Swift.Float {
    get {
    if isNaN { return self }
    if isNormal {
      return Float(sign: .plus,
        exponentBitPattern: Float._exponentBias,
        significandBitPattern: significandBitPattern)
    }
    if isSubnormal {
      let shift =
        Float.significandBitCount - significandBitPattern._binaryLogarithm()
      return Float(
        sign: .plus,
        exponentBitPattern: Float._exponentBias,
        significandBitPattern: significandBitPattern &<< shift
      )
    }
     
    return Float(
      sign: .plus,
      exponentBitPattern: exponentBitPattern,
      significandBitPattern: 0
    )
  }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: Swift.Float) {
    var result = significand
    if sign == .minus { result = -result }
    if significand.isFinite && !significand.isZero {
      var clamped = exponent
      let leastNormalExponent = 1 - Int(Float._exponentBias)
      let greatestFiniteExponent = Int(Float._exponentBias)
      if clamped < leastNormalExponent {
        clamped = max(clamped, 3*leastNormalExponent)
        while clamped < leastNormalExponent {
          result  *= Float.leastNormalMagnitude
          clamped -= leastNormalExponent
        }
      }
      else if clamped > greatestFiniteExponent {
        clamped = min(clamped, 3*greatestFiniteExponent)
        let step = Float(sign: .plus,
          exponentBitPattern: Float._infinityExponent - 1,
          significandBitPattern: 0)
        while clamped > greatestFiniteExponent {
          result  *= step
          clamped -= greatestFiniteExponent
        }
      }
      let scale = Float(
        sign: .plus,
        exponentBitPattern: UInt(Int(Float._exponentBias) + clamped),
        significandBitPattern: 0
      )
      result = result * scale
    }
    self = result
  }
  @inlinable public init(nan payload: Swift.Float.RawSignificand, signaling: Swift.Bool) {
     
    _precondition(payload < (Float._quietNaNMask &>> 1),
      "NaN payload is not encodable.")
    var significand = payload
    significand |= Float._quietNaNMask &>> (signaling ? 1 : 0)
    self.init(
      sign: .plus,
      exponentBitPattern: Float._infinityExponent,
      significandBitPattern: significand
    )
  }
  @inlinable public var nextUp: Swift.Float {
    get {
 
     
    let x = self + 0
    if _fastPath(x < .infinity) {
      let increment = Int32(bitPattern: x.bitPattern) &>> 31 | 1
      let bitPattern_ = x.bitPattern &+ UInt32(bitPattern: increment)
      return Float(bitPattern: bitPattern_)
    }
    return x
 
  }
  }
  @_transparent public init(signOf sign: Swift.Float, magnitudeOf mag: Swift.Float) {
    _value = Builtin.int_copysign_FPIEEE32(mag._value, sign._value)
  }
  @_transparent public mutating func round(_ rule: Swift.FloatingPointRoundingRule) {
    switch rule {
    case .toNearestOrAwayFromZero:
      _value = Builtin.int_round_FPIEEE32(_value)
    case .toNearestOrEven:
      _value = Builtin.int_rint_FPIEEE32(_value)
    case .towardZero:
      _value = Builtin.int_trunc_FPIEEE32(_value)
    case .awayFromZero:
      if sign == .minus {
        _value = Builtin.int_floor_FPIEEE32(_value)
      }
      else {
        _value = Builtin.int_ceil_FPIEEE32(_value)
      }
    case .up:
      _value = Builtin.int_ceil_FPIEEE32(_value)
    case .down:
      _value = Builtin.int_floor_FPIEEE32(_value)
    #if !$Embedded
    @unknown default:
      self._roundSlowPath(rule)
    #endif
    }
  }
  @usableFromInline
  internal mutating func _roundSlowPath(_ rule: Swift.FloatingPointRoundingRule)
  @_transparent public mutating func negate() {
    _value = Builtin.fneg_FPIEEE32(self._value)
  }
  @_transparent public static func += (lhs: inout Swift.Float, rhs: Swift.Float) {
    lhs._value = Builtin.fadd_FPIEEE32(lhs._value, rhs._value)
  }
  @_transparent public static func -= (lhs: inout Swift.Float, rhs: Swift.Float) {
    lhs._value = Builtin.fsub_FPIEEE32(lhs._value, rhs._value)
  }
  @_transparent public static func *= (lhs: inout Swift.Float, rhs: Swift.Float) {
    lhs._value = Builtin.fmul_FPIEEE32(lhs._value, rhs._value)
  }
  @_transparent public static func /= (lhs: inout Swift.Float, rhs: Swift.Float) {
    lhs._value = Builtin.fdiv_FPIEEE32(lhs._value, rhs._value)
  }
  @inlinable @inline(__always) public mutating func formRemainder(dividingBy other: Swift.Float) {
 
    self = _stdlib_remainderf(self, other)
 
  }
  @inlinable @inline(__always) public mutating func formTruncatingRemainder(dividingBy other: Swift.Float) {
    _value = Builtin.frem_FPIEEE32(self._value, other._value)
  }
  @_transparent public mutating func formSquareRoot() {
 
    self = _stdlib_squareRootf(self)
 
  }
  @_transparent public mutating func addProduct(_ lhs: Swift.Float, _ rhs: Swift.Float) {
    _value = Builtin.int_fma_FPIEEE32(lhs._value, rhs._value, _value)
  }
  @_transparent public func isEqual(to other: Swift.Float) -> Swift.Bool {
    return Bool(Builtin.fcmp_oeq_FPIEEE32(self._value, other._value))
  }
  @_transparent public func isLess(than other: Swift.Float) -> Swift.Bool {
    return Bool(Builtin.fcmp_olt_FPIEEE32(self._value, other._value))
  }
  @_transparent public func isLessThanOrEqualTo(_ other: Swift.Float) -> Swift.Bool {
    return Bool(Builtin.fcmp_ole_FPIEEE32(self._value, other._value))
  }
  @inlinable public var isNormal: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern > 0 && isFinite
    }
  }
  @inlinable public var isFinite: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern < Float._infinityExponent
    }
  }
  @inlinable public var isZero: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern == 0
    }
  }
  @inlinable public var isSubnormal: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern != 0
    }
  }
  @inlinable public var isInfinite: Swift.Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern == 0
    }
  }
  @inlinable public var isNaN: Swift.Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern != 0
    }
  }
  @inlinable public var isSignalingNaN: Swift.Bool {
    @inline(__always) get {
      return isNaN && (significandBitPattern & Float._quietNaNMask) == 0
    }
  }
  @inlinable public var binade: Swift.Float {
    get {
 
    guard _fastPath(isFinite) else { return .nan }
    if _slowPath(isSubnormal) {
      let bitPattern_ =
        (self * 0x1p23).bitPattern
          & (-Float.infinity).bitPattern
      return Float(bitPattern: bitPattern_) * 0x1p-23
    }
    return Float(bitPattern: bitPattern & (-Float.infinity).bitPattern)
 
  }
  }
  @inlinable public var significandWidth: Swift.Int {
    get {
    let trailingZeroBits = significandBitPattern.trailingZeroBitCount
    if isNormal {
      guard significandBitPattern != 0 else { return 0 }
      return Float.significandBitCount &- trailingZeroBits
    }
    if isSubnormal {
      let leadingZeroBits = significandBitPattern.leadingZeroBitCount
      return UInt32.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
    }
    return -1
  }
  }
  @inlinable @inline(__always) public init(floatLiteral value: Swift.Float) {
    self = value
  }
  public typealias FloatLiteralType = Swift.Float
  public typealias RawExponent = Swift.UInt
}
extension Swift.Float : Swift._ExpressibleByBuiltinIntegerLiteral, Swift.ExpressibleByIntegerLiteral {
  @_transparent public init(_builtinIntegerLiteral value: Builtin.IntLiteral) {
    self = Float(Builtin.itofp_with_overflow_IntLiteral_FPIEEE32(value))
  }
  @_transparent public init(integerLiteral value: Swift.Int64) {
    self = Float(Builtin.sitofp_Int64_FPIEEE32(value._value))
  }
  public typealias IntegerLiteralType = Swift.Int64
}
extension Swift.Float : Swift._ExpressibleByBuiltinFloatLiteral {
  @_transparent public init(_builtinFloatLiteral value: Builtin.FPIEEE64) {
 
     
    self = Float(Builtin.fptrunc_FPIEEE64_FPIEEE32(value))
 
  }
}
extension Swift.Float : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    var v = self
    if isZero {
       
       
      v = 0
    }
 
    hasher.combine(v.bitPattern)
 
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
     
     
    let v = isZero ? 0 : self
 
    return Hasher._hash(seed: seed, bytes: UInt64(v.bitPattern), count: 4)
 
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Float : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.Float {
  @inlinable public var magnitude: Swift.Float {
    @inline(__always) get {
      return Float(Builtin.int_fabs_FPIEEE32(_value))
    }
  }
}
extension Swift.Float {
  @_transparent prefix public static func - (x: Swift.Float) -> Swift.Float {
    return Float(Builtin.fneg_FPIEEE32(x._value))
  }
}
extension Swift.Float : Swift.Sendable {
}
extension Swift.Float {
  @_transparent public init(_ v: Swift.Int) {
    _value = Builtin.sitofp_Int64_FPIEEE32(v._value)
  }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
      if Source.isSigned {
        let asInt = Int64(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE32(asInt._value)
      } else {
        let asUInt = UInt64(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE32(asUInt._value)
      }
    } else {
       
       
       
      self = Float._convert(from: value).value
    }
  }
  @_alwaysEmitIntoClient @inline(never) public init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
       
       
       
       
       
       
       
       
       
       
       
      if Source.isSigned {
        let extended = Int(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE32(extended._value)
 
        guard self < 0x1.0p63 && Int(self) == extended else {
 
          return nil
        }
      } else {
        let extended = UInt(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE32(extended._value)
 
        guard self < 0x1.0p64 && UInt(self) == extended else {
 
          return nil
        }
      }
    } else {
       
       
       
      let (value_, exact) = Self._convert(from: value)
      guard exact else { return nil }
      self = value_
    }
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @inlinable @inline(__always) public init(_ other: Swift.Float16) {
 
    _value = Builtin.fpext_FPIEEE16_FPIEEE32(other._value)
 
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @inlinable @inline(__always) public init?(exactly other: Swift.Float16) {
    self.init(other)
     
     
     
    if Float16(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Float) {
 
    _value = other._value
 
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Float) {
    self.init(other)
     
     
     
    if Float(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Double) {
 
    _value = Builtin.fptrunc_FPIEEE64_FPIEEE32(other._value)
 
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Double) {
    self.init(other)
     
     
     
    if Double(self) != other {
      return nil
    }
  }
}
extension Swift.Float {
  @_transparent public static func + (lhs: Swift.Float, rhs: Swift.Float) -> Swift.Float {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Float, rhs: Swift.Float) -> Swift.Float {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Float, rhs: Swift.Float) -> Swift.Float {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Float, rhs: Swift.Float) -> Swift.Float {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
}
extension Swift.Float : Swift.Strideable {
  @_transparent public func distance(to other: Swift.Float) -> Swift.Float {
    return other - self
  }
  @_transparent public func advanced(by amount: Swift.Float) -> Swift.Float {
    return self + amount
  }
  public typealias Stride = Swift.Float
}
@frozen public struct Double {
  public var _value: Builtin.FPIEEE64
  @_transparent public init() {
    let zero: Int64 = 0
    self._value = Builtin.sitofp_Int64_FPIEEE64(zero._value)
  }
  @_transparent public init(_ _value: Builtin.FPIEEE64) {
    self._value = _value
  }
}
extension Swift.Double : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Swift.Double : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.Double : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Swift.Double : Swift.BinaryFloatingPoint {
  public typealias Magnitude = Swift.Double
  public typealias Exponent = Swift.Int
  public typealias RawSignificand = Swift.UInt64
  @inlinable public static var exponentBitCount: Swift.Int {
    get {
    return 11
  }
  }
  @inlinable public static var significandBitCount: Swift.Int {
    get {
    return 52
  }
  }
  @inlinable internal static var _infinityExponent: Swift.UInt {
    @inline(__always) get { return 1 &<< UInt(exponentBitCount) - 1 }
  }
  @inlinable internal static var _exponentBias: Swift.UInt {
    @inline(__always) get { return _infinityExponent &>> 1 }
  }
  @inlinable internal static var _significandMask: Swift.UInt64 {
    @inline(__always) get {
      return 1 &<< UInt64(significandBitCount) - 1
    }
  }
  @inlinable internal static var _quietNaNMask: Swift.UInt64 {
    @inline(__always) get {
      return 1 &<< UInt64(significandBitCount - 1)
    }
  }
  @inlinable public var bitPattern: Swift.UInt64 {
    get {
    return UInt64(Builtin.bitcast_FPIEEE64_Int64(_value))
  }
  }
  @inlinable public init(bitPattern: Swift.UInt64) {
    self.init(Builtin.bitcast_Int64_FPIEEE64(bitPattern._value))
  }
  @inlinable public var sign: Swift.FloatingPointSign {
    get {
    let shift = Double.significandBitCount + Double.exponentBitCount
    return FloatingPointSign(
      rawValue: Int(bitPattern &>> UInt64(shift))
    )!
  }
  }
  @available(*, unavailable, renamed: "sign")
  public var isSignMinus: Swift.Bool {
    get
  }
  @inlinable public var exponentBitPattern: Swift.UInt {
    get {
    return UInt(bitPattern &>> UInt64(Double.significandBitCount)) &
      Double._infinityExponent
  }
  }
  @inlinable public var significandBitPattern: Swift.UInt64 {
    get {
    return UInt64(bitPattern) & Double._significandMask
  }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponentBitPattern: Swift.UInt, significandBitPattern: Swift.UInt64) {
    let signShift = Double.significandBitCount + Double.exponentBitCount
    let sign = UInt64(sign == .minus ? 1 : 0)
    let exponent = UInt64(
      exponentBitPattern & Double._infinityExponent
    )
    let significand = UInt64(
      significandBitPattern & Double._significandMask
    )
    self.init(bitPattern:
      sign &<< UInt64(signShift) |
      exponent &<< UInt64(Double.significandBitCount) |
      significand
    )
  }
  @inlinable public var isCanonical: Swift.Bool {
    get {
     
     
     
     
    if Self.leastNonzeroMagnitude == Self.leastNormalMagnitude {
      if exponentBitPattern == 0 && significandBitPattern != 0 {
        return false
      }
    }
    return true
  }
  }
  @inlinable public static var infinity: Swift.Double {
    get {
 
    return Double(bitPattern: 0x7ff0000000000000)
 
  }
  }
  @inlinable public static var nan: Swift.Double {
    get {
 
    return Double(bitPattern: 0x7ff8000000000000)
 
  }
  }
  @inlinable public static var signalingNaN: Swift.Double {
    get {
    return Double(nan: 0, signaling: true)
  }
  }
  @available(*, unavailable, renamed: "nan")
  public static var quietNaN: Swift.Double {
    get
  }
  @inlinable public static var greatestFiniteMagnitude: Swift.Double {
    get {
 
    return 0x1.fffffffffffffp1023
 
  }
  }
  @inlinable public static var pi: Swift.Double {
    get {
 
    return 0x1.921fb54442d18p1
 
  }
  }
  @inlinable public var ulp: Swift.Double {
    get {
 
    guard _fastPath(isFinite) else { return .nan }
    if _fastPath(isNormal) {
      let bitPattern_ = bitPattern & Double.infinity.bitPattern
      return Double(bitPattern: bitPattern_) * 0x1p-52
    }
     
    return .leastNormalMagnitude * 0x1p-52
 
  }
  }
  @inlinable public static var leastNormalMagnitude: Swift.Double {
    get {
    return 0x1.0p-1022
  }
  }
  @inlinable public static var leastNonzeroMagnitude: Swift.Double {
    get {
    return leastNormalMagnitude * ulpOfOne
  }
  }
  @inlinable public static var ulpOfOne: Swift.Double {
    get {
    return 0x1.0p-52
  }
  }
  @inlinable public var exponent: Swift.Int {
    get {
    if !isFinite { return .max }
    if isZero { return .min }
    let provisional = Int(exponentBitPattern) - Int(Double._exponentBias)
    if isNormal { return provisional }
    let shift =
      Double.significandBitCount - significandBitPattern._binaryLogarithm()
    return provisional + 1 - shift
  }
  }
  @inlinable public var significand: Swift.Double {
    get {
    if isNaN { return self }
    if isNormal {
      return Double(sign: .plus,
        exponentBitPattern: Double._exponentBias,
        significandBitPattern: significandBitPattern)
    }
    if isSubnormal {
      let shift =
        Double.significandBitCount - significandBitPattern._binaryLogarithm()
      return Double(
        sign: .plus,
        exponentBitPattern: Double._exponentBias,
        significandBitPattern: significandBitPattern &<< shift
      )
    }
     
    return Double(
      sign: .plus,
      exponentBitPattern: exponentBitPattern,
      significandBitPattern: 0
    )
  }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: Swift.Double) {
    var result = significand
    if sign == .minus { result = -result }
    if significand.isFinite && !significand.isZero {
      var clamped = exponent
      let leastNormalExponent = 1 - Int(Double._exponentBias)
      let greatestFiniteExponent = Int(Double._exponentBias)
      if clamped < leastNormalExponent {
        clamped = max(clamped, 3*leastNormalExponent)
        while clamped < leastNormalExponent {
          result  *= Double.leastNormalMagnitude
          clamped -= leastNormalExponent
        }
      }
      else if clamped > greatestFiniteExponent {
        clamped = min(clamped, 3*greatestFiniteExponent)
        let step = Double(sign: .plus,
          exponentBitPattern: Double._infinityExponent - 1,
          significandBitPattern: 0)
        while clamped > greatestFiniteExponent {
          result  *= step
          clamped -= greatestFiniteExponent
        }
      }
      let scale = Double(
        sign: .plus,
        exponentBitPattern: UInt(Int(Double._exponentBias) + clamped),
        significandBitPattern: 0
      )
      result = result * scale
    }
    self = result
  }
  @inlinable public init(nan payload: Swift.Double.RawSignificand, signaling: Swift.Bool) {
     
    _precondition(payload < (Double._quietNaNMask &>> 1),
      "NaN payload is not encodable.")
    var significand = payload
    significand |= Double._quietNaNMask &>> (signaling ? 1 : 0)
    self.init(
      sign: .plus,
      exponentBitPattern: Double._infinityExponent,
      significandBitPattern: significand
    )
  }
  @inlinable public var nextUp: Swift.Double {
    get {
 
     
    let x = self + 0
    if _fastPath(x < .infinity) {
      let increment = Int64(bitPattern: x.bitPattern) &>> 63 | 1
      let bitPattern_ = x.bitPattern &+ UInt64(bitPattern: increment)
      return Double(bitPattern: bitPattern_)
    }
    return x
 
  }
  }
  @_transparent public init(signOf sign: Swift.Double, magnitudeOf mag: Swift.Double) {
    _value = Builtin.int_copysign_FPIEEE64(mag._value, sign._value)
  }
  @_transparent public mutating func round(_ rule: Swift.FloatingPointRoundingRule) {
    switch rule {
    case .toNearestOrAwayFromZero:
      _value = Builtin.int_round_FPIEEE64(_value)
    case .toNearestOrEven:
      _value = Builtin.int_rint_FPIEEE64(_value)
    case .towardZero:
      _value = Builtin.int_trunc_FPIEEE64(_value)
    case .awayFromZero:
      if sign == .minus {
        _value = Builtin.int_floor_FPIEEE64(_value)
      }
      else {
        _value = Builtin.int_ceil_FPIEEE64(_value)
      }
    case .up:
      _value = Builtin.int_ceil_FPIEEE64(_value)
    case .down:
      _value = Builtin.int_floor_FPIEEE64(_value)
    #if !$Embedded
    @unknown default:
      self._roundSlowPath(rule)
    #endif
    }
  }
  @usableFromInline
  internal mutating func _roundSlowPath(_ rule: Swift.FloatingPointRoundingRule)
  @_transparent public mutating func negate() {
    _value = Builtin.fneg_FPIEEE64(self._value)
  }
  @_transparent public static func += (lhs: inout Swift.Double, rhs: Swift.Double) {
    lhs._value = Builtin.fadd_FPIEEE64(lhs._value, rhs._value)
  }
  @_transparent public static func -= (lhs: inout Swift.Double, rhs: Swift.Double) {
    lhs._value = Builtin.fsub_FPIEEE64(lhs._value, rhs._value)
  }
  @_transparent public static func *= (lhs: inout Swift.Double, rhs: Swift.Double) {
    lhs._value = Builtin.fmul_FPIEEE64(lhs._value, rhs._value)
  }
  @_transparent public static func /= (lhs: inout Swift.Double, rhs: Swift.Double) {
    lhs._value = Builtin.fdiv_FPIEEE64(lhs._value, rhs._value)
  }
  @inlinable @inline(__always) public mutating func formRemainder(dividingBy other: Swift.Double) {
 
    self = _stdlib_remainder(self, other)
 
  }
  @inlinable @inline(__always) public mutating func formTruncatingRemainder(dividingBy other: Swift.Double) {
    _value = Builtin.frem_FPIEEE64(self._value, other._value)
  }
  @_transparent public mutating func formSquareRoot() {
 
    self = _stdlib_squareRoot(self)
 
  }
  @_transparent public mutating func addProduct(_ lhs: Swift.Double, _ rhs: Swift.Double) {
    _value = Builtin.int_fma_FPIEEE64(lhs._value, rhs._value, _value)
  }
  @_transparent public func isEqual(to other: Swift.Double) -> Swift.Bool {
    return Bool(Builtin.fcmp_oeq_FPIEEE64(self._value, other._value))
  }
  @_transparent public func isLess(than other: Swift.Double) -> Swift.Bool {
    return Bool(Builtin.fcmp_olt_FPIEEE64(self._value, other._value))
  }
  @_transparent public func isLessThanOrEqualTo(_ other: Swift.Double) -> Swift.Bool {
    return Bool(Builtin.fcmp_ole_FPIEEE64(self._value, other._value))
  }
  @inlinable public var isNormal: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern > 0 && isFinite
    }
  }
  @inlinable public var isFinite: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern < Double._infinityExponent
    }
  }
  @inlinable public var isZero: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern == 0
    }
  }
  @inlinable public var isSubnormal: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern != 0
    }
  }
  @inlinable public var isInfinite: Swift.Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern == 0
    }
  }
  @inlinable public var isNaN: Swift.Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern != 0
    }
  }
  @inlinable public var isSignalingNaN: Swift.Bool {
    @inline(__always) get {
      return isNaN && (significandBitPattern & Double._quietNaNMask) == 0
    }
  }
  @inlinable public var binade: Swift.Double {
    get {
 
    guard _fastPath(isFinite) else { return .nan }
    if _slowPath(isSubnormal) {
      let bitPattern_ =
        (self * 0x1p52).bitPattern
          & (-Double.infinity).bitPattern
      return Double(bitPattern: bitPattern_) * 0x1p-52
    }
    return Double(bitPattern: bitPattern & (-Double.infinity).bitPattern)
 
  }
  }
  @inlinable public var significandWidth: Swift.Int {
    get {
    let trailingZeroBits = significandBitPattern.trailingZeroBitCount
    if isNormal {
      guard significandBitPattern != 0 else { return 0 }
      return Double.significandBitCount &- trailingZeroBits
    }
    if isSubnormal {
      let leadingZeroBits = significandBitPattern.leadingZeroBitCount
      return UInt64.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
    }
    return -1
  }
  }
  @inlinable @inline(__always) public init(floatLiteral value: Swift.Double) {
    self = value
  }
  public typealias FloatLiteralType = Swift.Double
  public typealias RawExponent = Swift.UInt
}
extension Swift.Double : Swift._ExpressibleByBuiltinIntegerLiteral, Swift.ExpressibleByIntegerLiteral {
  @_transparent public init(_builtinIntegerLiteral value: Builtin.IntLiteral) {
    self = Double(Builtin.itofp_with_overflow_IntLiteral_FPIEEE64(value))
  }
  @_transparent public init(integerLiteral value: Swift.Int64) {
    self = Double(Builtin.sitofp_Int64_FPIEEE64(value._value))
  }
  public typealias IntegerLiteralType = Swift.Int64
}
extension Swift.Double : Swift._ExpressibleByBuiltinFloatLiteral {
  @_transparent public init(_builtinFloatLiteral value: Builtin.FPIEEE64) {
 
    self = Double(value)
 
  }
}
extension Swift.Double : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    var v = self
    if isZero {
       
       
      v = 0
    }
 
    hasher.combine(v.bitPattern)
 
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
     
     
    let v = isZero ? 0 : self
 
    return Hasher._hash(seed: seed, v.bitPattern)
 
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Double : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.Double {
  @inlinable public var magnitude: Swift.Double {
    @inline(__always) get {
      return Double(Builtin.int_fabs_FPIEEE64(_value))
    }
  }
}
extension Swift.Double {
  @_transparent prefix public static func - (x: Swift.Double) -> Swift.Double {
    return Double(Builtin.fneg_FPIEEE64(x._value))
  }
}
extension Swift.Double : Swift.Sendable {
}
extension Swift.Double {
  @_transparent public init(_ v: Swift.Int) {
    _value = Builtin.sitofp_Int64_FPIEEE64(v._value)
  }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
      if Source.isSigned {
        let asInt = Int64(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE64(asInt._value)
      } else {
        let asUInt = UInt64(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE64(asUInt._value)
      }
    } else {
       
       
       
      self = Double._convert(from: value).value
    }
  }
  @_alwaysEmitIntoClient @inline(never) public init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
       
       
       
       
       
       
       
       
       
       
       
      if Source.isSigned {
        let extended = Int(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE64(extended._value)
 
        guard self < 0x1.0p63 && Int(self) == extended else {
 
          return nil
        }
      } else {
        let extended = UInt(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE64(extended._value)
 
        guard self < 0x1.0p64 && UInt(self) == extended else {
 
          return nil
        }
      }
    } else {
       
       
       
      let (value_, exact) = Self._convert(from: value)
      guard exact else { return nil }
      self = value_
    }
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @inlinable @inline(__always) public init(_ other: Swift.Float16) {
 
    _value = Builtin.fpext_FPIEEE16_FPIEEE64(other._value)
 
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @inlinable @inline(__always) public init?(exactly other: Swift.Float16) {
    self.init(other)
     
     
     
    if Float16(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Float) {
 
    _value = Builtin.fpext_FPIEEE32_FPIEEE64(other._value)
 
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Float) {
    self.init(other)
     
     
     
    if Float(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Double) {
 
    _value = other._value
 
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Double) {
    self.init(other)
     
     
     
    if Double(self) != other {
      return nil
    }
  }
}
extension Swift.Double {
  @_transparent public static func + (lhs: Swift.Double, rhs: Swift.Double) -> Swift.Double {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Double, rhs: Swift.Double) -> Swift.Double {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Double, rhs: Swift.Double) -> Swift.Double {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Double, rhs: Swift.Double) -> Swift.Double {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
}
extension Swift.Double : Swift.Strideable {
  @_transparent public func distance(to other: Swift.Double) -> Swift.Double {
    return other - self
  }
  @_transparent public func advanced(by amount: Swift.Double) -> Swift.Double {
    return self + amount
  }
  public typealias Stride = Swift.Double
}
@available(*, unavailable, message: "Float80 is not available on target platform.")
@frozen public struct Float80 {
  @_transparent public init() {
    fatalError("Float80 is not available")
  }
}
@available(*, unavailable, message: "For floating point numbers use truncatingRemainder instead")
@_transparent public func % <T>(lhs: T, rhs: T) -> T where T : Swift.BinaryFloatingPoint {
  fatalError("% is not available.")
}
@available(*, unavailable, message: "For floating point numbers use formTruncatingRemainder instead")
@_transparent public func %= <T>(lhs: inout T, rhs: T) where T : Swift.BinaryFloatingPoint {
  fatalError("%= is not available.")
}
@frozen public struct UInt8 : Swift.FixedWidthInteger, Swift.UnsignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.UInt8
  public var _value: Builtin.Int8
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int8(x).0
  }
  @_transparent public init(bitPattern x: Swift.Int8) {
    _value = x._value
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init(_ source: Swift.Float16) {
    _precondition(source.isFinite,
      "Float16 value cannot be converted to UInt8 because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Float16 value cannot be converted to UInt8 because the result would be less than UInt8.min")
 
    _precondition(source < 256.0,
      "Float16 value cannot be converted to UInt8 because the result would be greater than UInt8.max")
 
    self._value = Builtin.fptoui_FPIEEE16_Int8(source._value)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init?(exactly source: Swift.Float16) {
     
     
     
 
    guard source > -1.0 && source < 256.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE16_Int8(source._value)
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt8 because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt8 because the result would be less than UInt8.min")
 
    _precondition(source < 256.0,
      "Float value cannot be converted to UInt8 because the result would be greater than UInt8.max")
 
    self._value = Builtin.fptoui_FPIEEE32_Int8(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
     
     
     
 
    guard source > -1.0 && source < 256.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int8(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt8 because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt8 because the result would be less than UInt8.min")
 
    _precondition(source < 256.0,
      "Double value cannot be converted to UInt8 because the result would be greater than UInt8.max")
 
    self._value = Builtin.fptoui_FPIEEE64_Int8(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
     
     
     
 
    guard source > -1.0 && source < 256.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int8(source._value)
  }
  @_transparent public static func == (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.Bool {
    return Bool(Builtin.cmp_ult_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
 
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt8(result)
  }
  @_transparent public static func -= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
 
    let (result, overflow) =
      Builtin.usub_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt8(result)
  }
  @_transparent public static func *= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
 
    let (result, overflow) =
      Builtin.umul_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt8(result)
  }
  @_transparent public static func /= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
 
     
     
    if _slowPath(rhs == (0 as UInt8)) {
      _preconditionFailure(
        "Division by zero")
    }
 
    let (result, overflow) =
      (Builtin.udiv_Int8(lhs._value, rhs._value),
      false._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt8(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.UInt8) -> (partialValue: Swift.UInt8, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int8(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.UInt8) -> (partialValue: Swift.UInt8, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int8(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.UInt8) -> (partialValue: Swift.UInt8, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int8(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.UInt8) -> (partialValue: Swift.UInt8, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as UInt8)) {
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.udiv_Int8(self._value, other._value),
      false._value)

 

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.UInt8) -> (partialValue: Swift.UInt8, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as UInt8)) {
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.urem_Int8(self._value, other._value),
      false._value)

 

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
     
     
    if _slowPath(rhs == (0 as UInt8)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
 

    let (newStorage, _) = (
      Builtin.urem_Int8(lhs._value, rhs._value),
      false._value)
    lhs = UInt8(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int8) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
    lhs = UInt8(Builtin.and_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
    lhs = UInt8(Builtin.or_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
    lhs = UInt8(Builtin.xor_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
    let rhs_ = rhs & 7
    lhs = UInt8(
      Builtin.lshr_Int8(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
    let rhs_ = rhs & 7
    lhs = UInt8(
      Builtin.shl_Int8(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 8 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt8(
        Builtin.int_ctlz_Int8(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt8(
        Builtin.int_cttz_Int8(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt8(
        Builtin.int_ctpop_Int8(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection, Swift.Sendable {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.UInt8.Words>
    @usableFromInline
    internal var _value: Swift.UInt8
    @inlinable public init(_ value: Swift.UInt8) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (8 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.UInt8.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt8(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt8.Words>
  }
  @_transparent public var words: Swift.UInt8.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
 
    return UInt(
      Builtin.zextOrBitCast_Int8_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
 
    self.init(
      Builtin.truncOrBitCast_Int64_Int8(bits._value))
  }
  public typealias Magnitude = Swift.UInt8
  @inlinable public func multipliedFullWidth(by other: Swift.UInt8) -> (high: Swift.UInt8, low: Swift.UInt8.Magnitude) {
     
    let lhs_ = Builtin.zext_Int8_Int16(self._value)
    let rhs_ = Builtin.zext_Int8_Int16(other._value)

    let res = Builtin.mul_Int16(lhs_, rhs_)
    let low = UInt8.Magnitude(Builtin.truncOrBitCast_Int16_Int8(res))
    let shift = Builtin.zextOrBitCast_Int8_Int16(UInt8(8)._value)
    let shifted = Builtin.ashr_Int16(res, shift)
    let high = UInt8(Builtin.truncOrBitCast_Int16_Int8(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.UInt8, low: Swift.UInt8.Magnitude)) -> (quotient: Swift.UInt8, remainder: Swift.UInt8) {
    _precondition(self != 0, "Division by zero")
 
    _precondition(self > dividend.high, "Quotient is not representable")
 
    let a = UInt16(dividend.high) &<< 8 |
            UInt16(dividend.low)
    let b = UInt16(self)
    let (q, r) = a.quotientAndRemainder(dividingBy: b)
 
     
     
    return (UInt8(truncatingIfNeeded: q), UInt8(truncatingIfNeeded: r))
 
  }
  @_transparent public var byteSwapped: Swift.UInt8 {
    @_transparent get {
 
    return self
 
  }
  }
  @inlinable @inline(__always) public func signum() -> Swift.UInt8 {
    let isPositive = UInt8(Builtin.zext_Int1_Int8(
      (self > (0 as UInt8))._value))
    return isPositive | (self &>> 7)
  }
  public typealias Stride = Swift.Int
}
extension Swift.UInt8 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt8(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
 
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt8(_value)),
      count: 1)
 
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.UInt8 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.UInt8 {
  @_transparent public static func & (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent @_alwaysEmitIntoClient public static func != (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.Bool {
    return !(lhs == rhs)
  }
  @_transparent public static func <= (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.Bool {
    return rhs < lhs
  }
}
extension Swift.UInt8 : Swift.Sendable {
}
@frozen public struct Int8 : Swift.FixedWidthInteger, Swift.SignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int8
  public var _value: Builtin.Int8
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int8(x).0
  }
  @_transparent public init(bitPattern x: Swift.UInt8) {
    _value = x._value
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init(_ source: Swift.Float16) {
    _precondition(source.isFinite,
      "Float16 value cannot be converted to Int8 because it is either infinite or NaN")
 
    _precondition(source > -129.0,
      "Float16 value cannot be converted to Int8 because the result would be less than Int8.min")
 
    _precondition(source < 128.0,
      "Float16 value cannot be converted to Int8 because the result would be greater than Int8.max")
 
    self._value = Builtin.fptosi_FPIEEE16_Int8(source._value)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init?(exactly source: Swift.Float16) {
     
     
     
 
    guard source > -129.0 && source < 128.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE16_Int8(source._value)
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int8 because it is either infinite or NaN")
 
    _precondition(source > -129.0,
      "Float value cannot be converted to Int8 because the result would be less than Int8.min")
 
    _precondition(source < 128.0,
      "Float value cannot be converted to Int8 because the result would be greater than Int8.max")
 
    self._value = Builtin.fptosi_FPIEEE32_Int8(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
     
     
     
 
    guard source > -129.0 && source < 128.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int8(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int8 because it is either infinite or NaN")
 
    _precondition(source > -129.0,
      "Double value cannot be converted to Int8 because the result would be less than Int8.min")
 
    _precondition(source < 128.0,
      "Double value cannot be converted to Int8 because the result would be greater than Int8.max")
 
    self._value = Builtin.fptosi_FPIEEE64_Int8(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
     
     
     
 
    guard source > -129.0 && source < 128.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int8(source._value)
  }
  @_transparent public static func == (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Bool {
    return Bool(Builtin.cmp_slt_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.Int8, rhs: Swift.Int8) {
 
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int8(result)
  }
  @_transparent public static func -= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
 
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int8(result)
  }
  @_transparent public static func *= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
 
    let (result, overflow) =
      Builtin.smul_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int8(result)
  }
  @_transparent public static func /= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
 
     
     
    if _slowPath(rhs == (0 as Int8)) {
      _preconditionFailure(
        "Division by zero")
    }
 
    if _slowPath(
      lhs == Int8.min && rhs == (-1 as Int8)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
 
    let (result, overflow) =
      (Builtin.sdiv_Int8(lhs._value, rhs._value),
      false._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int8(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.Int8) -> (partialValue: Swift.Int8, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int8(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.Int8) -> (partialValue: Swift.Int8, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int8(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.Int8) -> (partialValue: Swift.Int8, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int8(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.Int8) -> (partialValue: Swift.Int8, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as Int8)) {
      return (partialValue: self, overflow: true)
    }
 
    if _slowPath(self == Int8.min && other == (-1 as Int8)) {
 
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.sdiv_Int8(self._value, other._value),
      false._value)

 

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.Int8) -> (partialValue: Swift.Int8, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as Int8)) {
      return (partialValue: self, overflow: true)
    }
 
    if _slowPath(self == Int8.min && other == (-1 as Int8)) {
 
      return (partialValue: 0, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.srem_Int8(self._value, other._value),
      false._value)

 

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
     
     
    if _slowPath(rhs == (0 as Int8)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
 
    if _slowPath(lhs == Int8.min && rhs == (-1 as Int8)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
 

    let (newStorage, _) = (
      Builtin.srem_Int8(lhs._value, rhs._value),
      false._value)
    lhs = Int8(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int8) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
    lhs = Int8(Builtin.and_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
    lhs = Int8(Builtin.or_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
    lhs = Int8(Builtin.xor_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
    let rhs_ = rhs & 7
    lhs = Int8(
      Builtin.ashr_Int8(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
    let rhs_ = rhs & 7
    lhs = Int8(
      Builtin.shl_Int8(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 8 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int8(
        Builtin.int_ctlz_Int8(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int8(
        Builtin.int_cttz_Int8(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int8(
        Builtin.int_ctpop_Int8(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection, Swift.Sendable {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.Int8.Words>
    @usableFromInline
    internal var _value: Swift.Int8
    @inlinable public init(_ value: Swift.Int8) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (8 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.Int8.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int8(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int8.Words>
  }
  @_transparent public var words: Swift.Int8.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
 
    return UInt(
      Builtin.sextOrBitCast_Int8_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
 
    self.init(
      Builtin.truncOrBitCast_Int64_Int8(bits._value))
  }
  public typealias Magnitude = Swift.UInt8
  @_transparent public var magnitude: Swift.UInt8 {
    @_transparent get {
    let base = UInt8(_value)
    return self < (0 as Int8) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Swift.Int8) -> (high: Swift.Int8, low: Swift.Int8.Magnitude) {
     
    let lhs_ = Builtin.sext_Int8_Int16(self._value)
    let rhs_ = Builtin.sext_Int8_Int16(other._value)

    let res = Builtin.mul_Int16(lhs_, rhs_)
    let low = Int8.Magnitude(Builtin.truncOrBitCast_Int16_Int8(res))
    let shift = Builtin.zextOrBitCast_Int8_Int16(UInt8(8)._value)
    let shifted = Builtin.ashr_Int16(res, shift)
    let high = Int8(Builtin.truncOrBitCast_Int16_Int8(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.Int8, low: Swift.Int8.Magnitude)) -> (quotient: Swift.Int8, remainder: Swift.Int8) {
    _precondition(self != 0, "Division by zero")
 
    let a = Int16(dividend.high) &<< 8 |
            Int16(dividend.low)
    let b = Int16(self)
    let (q, r) = a.quotientAndRemainder(dividingBy: b)
 
     
     
    guard let quotient = Int8(exactly: q) else {
      _preconditionFailure("Quotient is not representable")
    }
    return (quotient, Int8(truncatingIfNeeded: r))
 
  }
  @_transparent public var byteSwapped: Swift.Int8 {
    @_transparent get {
 
    return self
 
  }
  }
  @inlinable @inline(__always) public func signum() -> Swift.Int8 {
    let isPositive = Int8(Builtin.zext_Int1_Int8(
      (self > (0 as Int8))._value))
    return isPositive | (self &>> 7)
  }
  public typealias Stride = Swift.Int
}
extension Swift.Int8 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt8(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
 
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt8(_value)),
      count: 1)
 
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Int8 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.Int8 {
  @_transparent public static func & (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent @_alwaysEmitIntoClient public static func != (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Bool {
    return !(lhs == rhs)
  }
  @_transparent public static func <= (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Bool {
    return rhs < lhs
  }
}
extension Swift.Int8 : Swift.Sendable {
}
@_transparent public func _assumeNonNegative(_ x: Swift.Int8) -> Swift.Int8 {
  _internalInvariant(x >= (0 as Int8))
  return Int8(Builtin.assumeNonNegative_Int8(x._value))
}
@frozen public struct UInt16 : Swift.FixedWidthInteger, Swift.UnsignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.UInt16
  public var _value: Builtin.Int16
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int16(x).0
  }
  @_transparent public init(bitPattern x: Swift.Int16) {
    _value = x._value
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init(_ source: Swift.Float16) {
    _precondition(source.isFinite,
      "Float16 value cannot be converted to UInt16 because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Float16 value cannot be converted to UInt16 because the result would be less than UInt16.min")
 
     
     
 
    self._value = Builtin.fptoui_FPIEEE16_Int16(source._value)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init?(exactly source: Swift.Float16) {
     
     
     
 
     
     
    guard source > -1.0 && source.isFinite else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE16_Int16(source._value)
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt16 because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt16 because the result would be less than UInt16.min")
 
    _precondition(source < 65536.0,
      "Float value cannot be converted to UInt16 because the result would be greater than UInt16.max")
 
    self._value = Builtin.fptoui_FPIEEE32_Int16(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
     
     
     
 
    guard source > -1.0 && source < 65536.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int16(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt16 because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt16 because the result would be less than UInt16.min")
 
    _precondition(source < 65536.0,
      "Double value cannot be converted to UInt16 because the result would be greater than UInt16.max")
 
    self._value = Builtin.fptoui_FPIEEE64_Int16(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
     
     
     
 
    guard source > -1.0 && source < 65536.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int16(source._value)
  }
  @_transparent public static func == (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.Bool {
    return Bool(Builtin.cmp_ult_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
 
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt16(result)
  }
  @_transparent public static func -= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
 
    let (result, overflow) =
      Builtin.usub_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt16(result)
  }
  @_transparent public static func *= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
 
    let (result, overflow) =
      Builtin.umul_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt16(result)
  }
  @_transparent public static func /= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
 
     
     
    if _slowPath(rhs == (0 as UInt16)) {
      _preconditionFailure(
        "Division by zero")
    }
 
    let (result, overflow) =
      (Builtin.udiv_Int16(lhs._value, rhs._value),
      false._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt16(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.UInt16) -> (partialValue: Swift.UInt16, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int16(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.UInt16) -> (partialValue: Swift.UInt16, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int16(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.UInt16) -> (partialValue: Swift.UInt16, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int16(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.UInt16) -> (partialValue: Swift.UInt16, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as UInt16)) {
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.udiv_Int16(self._value, other._value),
      false._value)

 

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.UInt16) -> (partialValue: Swift.UInt16, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as UInt16)) {
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.urem_Int16(self._value, other._value),
      false._value)

 

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
     
     
    if _slowPath(rhs == (0 as UInt16)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
 

    let (newStorage, _) = (
      Builtin.urem_Int16(lhs._value, rhs._value),
      false._value)
    lhs = UInt16(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int16) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
    lhs = UInt16(Builtin.and_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
    lhs = UInt16(Builtin.or_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
    lhs = UInt16(Builtin.xor_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
    let rhs_ = rhs & 15
    lhs = UInt16(
      Builtin.lshr_Int16(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
    let rhs_ = rhs & 15
    lhs = UInt16(
      Builtin.shl_Int16(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 16 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt16(
        Builtin.int_ctlz_Int16(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt16(
        Builtin.int_cttz_Int16(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt16(
        Builtin.int_ctpop_Int16(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection, Swift.Sendable {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.UInt16.Words>
    @usableFromInline
    internal var _value: Swift.UInt16
    @inlinable public init(_ value: Swift.UInt16) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (16 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.UInt16.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt16(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt16.Words>
  }
  @_transparent public var words: Swift.UInt16.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
 
    return UInt(
      Builtin.zextOrBitCast_Int16_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
 
    self.init(
      Builtin.truncOrBitCast_Int64_Int16(bits._value))
  }
  public typealias Magnitude = Swift.UInt16
  @inlinable public func multipliedFullWidth(by other: Swift.UInt16) -> (high: Swift.UInt16, low: Swift.UInt16.Magnitude) {
     
    let lhs_ = Builtin.zext_Int16_Int32(self._value)
    let rhs_ = Builtin.zext_Int16_Int32(other._value)

    let res = Builtin.mul_Int32(lhs_, rhs_)
    let low = UInt16.Magnitude(Builtin.truncOrBitCast_Int32_Int16(res))
    let shift = Builtin.zextOrBitCast_Int8_Int32(UInt8(16)._value)
    let shifted = Builtin.ashr_Int32(res, shift)
    let high = UInt16(Builtin.truncOrBitCast_Int32_Int16(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.UInt16, low: Swift.UInt16.Magnitude)) -> (quotient: Swift.UInt16, remainder: Swift.UInt16) {
    _precondition(self != 0, "Division by zero")
 
    _precondition(self > dividend.high, "Quotient is not representable")
 
    let a = UInt32(dividend.high) &<< 16 |
            UInt32(dividend.low)
    let b = UInt32(self)
    let (q, r) = a.quotientAndRemainder(dividingBy: b)
 
     
     
    return (UInt16(truncatingIfNeeded: q), UInt16(truncatingIfNeeded: r))
 
  }
  @_transparent public var byteSwapped: Swift.UInt16 {
    @_transparent get {
 
    return UInt16(Builtin.int_bswap_Int16(_value))
 
  }
  }
  @inlinable @inline(__always) public func signum() -> Swift.UInt16 {
    let isPositive = UInt16(Builtin.zext_Int1_Int16(
      (self > (0 as UInt16))._value))
    return isPositive | (self &>> 15)
  }
  public typealias Stride = Swift.Int
}
extension Swift.UInt16 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt16(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
 
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt16(_value)),
      count: 2)
 
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.UInt16 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.UInt16 {
  @_transparent public static func & (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent @_alwaysEmitIntoClient public static func != (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.Bool {
    return !(lhs == rhs)
  }
  @_transparent public static func <= (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.Bool {
    return rhs < lhs
  }
}
extension Swift.UInt16 : Swift.Sendable {
}
@frozen public struct Int16 : Swift.FixedWidthInteger, Swift.SignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int16
  public var _value: Builtin.Int16
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int16(x).0
  }
  @_transparent public init(bitPattern x: Swift.UInt16) {
    _value = x._value
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init(_ source: Swift.Float16) {
    _precondition(source.isFinite,
      "Float16 value cannot be converted to Int16 because it is either infinite or NaN")
 
    _precondition(source > -32800.0,
      "Float16 value cannot be converted to Int16 because the result would be less than Int16.min")
 
    _precondition(source < 32768.0,
      "Float16 value cannot be converted to Int16 because the result would be greater than Int16.max")
 
    self._value = Builtin.fptosi_FPIEEE16_Int16(source._value)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init?(exactly source: Swift.Float16) {
     
     
     
 
    guard source > -32800.0 && source < 32768.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE16_Int16(source._value)
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int16 because it is either infinite or NaN")
 
    _precondition(source > -32769.0,
      "Float value cannot be converted to Int16 because the result would be less than Int16.min")
 
    _precondition(source < 32768.0,
      "Float value cannot be converted to Int16 because the result would be greater than Int16.max")
 
    self._value = Builtin.fptosi_FPIEEE32_Int16(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
     
     
     
 
    guard source > -32769.0 && source < 32768.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int16(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int16 because it is either infinite or NaN")
 
    _precondition(source > -32769.0,
      "Double value cannot be converted to Int16 because the result would be less than Int16.min")
 
    _precondition(source < 32768.0,
      "Double value cannot be converted to Int16 because the result would be greater than Int16.max")
 
    self._value = Builtin.fptosi_FPIEEE64_Int16(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
     
     
     
 
    guard source > -32769.0 && source < 32768.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int16(source._value)
  }
  @_transparent public static func == (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Bool {
    return Bool(Builtin.cmp_slt_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.Int16, rhs: Swift.Int16) {
 
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int16(result)
  }
  @_transparent public static func -= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
 
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int16(result)
  }
  @_transparent public static func *= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
 
    let (result, overflow) =
      Builtin.smul_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int16(result)
  }
  @_transparent public static func /= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
 
     
     
    if _slowPath(rhs == (0 as Int16)) {
      _preconditionFailure(
        "Division by zero")
    }
 
    if _slowPath(
      lhs == Int16.min && rhs == (-1 as Int16)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
 
    let (result, overflow) =
      (Builtin.sdiv_Int16(lhs._value, rhs._value),
      false._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int16(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.Int16) -> (partialValue: Swift.Int16, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int16(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.Int16) -> (partialValue: Swift.Int16, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int16(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.Int16) -> (partialValue: Swift.Int16, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int16(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.Int16) -> (partialValue: Swift.Int16, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as Int16)) {
      return (partialValue: self, overflow: true)
    }
 
    if _slowPath(self == Int16.min && other == (-1 as Int16)) {
 
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.sdiv_Int16(self._value, other._value),
      false._value)

 

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.Int16) -> (partialValue: Swift.Int16, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as Int16)) {
      return (partialValue: self, overflow: true)
    }
 
    if _slowPath(self == Int16.min && other == (-1 as Int16)) {
 
      return (partialValue: 0, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.srem_Int16(self._value, other._value),
      false._value)

 

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
     
     
    if _slowPath(rhs == (0 as Int16)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
 
    if _slowPath(lhs == Int16.min && rhs == (-1 as Int16)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
 

    let (newStorage, _) = (
      Builtin.srem_Int16(lhs._value, rhs._value),
      false._value)
    lhs = Int16(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int16) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
    lhs = Int16(Builtin.and_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
    lhs = Int16(Builtin.or_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
    lhs = Int16(Builtin.xor_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
    let rhs_ = rhs & 15
    lhs = Int16(
      Builtin.ashr_Int16(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
    let rhs_ = rhs & 15
    lhs = Int16(
      Builtin.shl_Int16(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 16 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int16(
        Builtin.int_ctlz_Int16(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int16(
        Builtin.int_cttz_Int16(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int16(
        Builtin.int_ctpop_Int16(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection, Swift.Sendable {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.Int16.Words>
    @usableFromInline
    internal var _value: Swift.Int16
    @inlinable public init(_ value: Swift.Int16) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (16 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.Int16.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int16(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int16.Words>
  }
  @_transparent public var words: Swift.Int16.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
 
    return UInt(
      Builtin.sextOrBitCast_Int16_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
 
    self.init(
      Builtin.truncOrBitCast_Int64_Int16(bits._value))
  }
  public typealias Magnitude = Swift.UInt16
  @_transparent public var magnitude: Swift.UInt16 {
    @_transparent get {
    let base = UInt16(_value)
    return self < (0 as Int16) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Swift.Int16) -> (high: Swift.Int16, low: Swift.Int16.Magnitude) {
     
    let lhs_ = Builtin.sext_Int16_Int32(self._value)
    let rhs_ = Builtin.sext_Int16_Int32(other._value)

    let res = Builtin.mul_Int32(lhs_, rhs_)
    let low = Int16.Magnitude(Builtin.truncOrBitCast_Int32_Int16(res))
    let shift = Builtin.zextOrBitCast_Int8_Int32(UInt8(16)._value)
    let shifted = Builtin.ashr_Int32(res, shift)
    let high = Int16(Builtin.truncOrBitCast_Int32_Int16(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.Int16, low: Swift.Int16.Magnitude)) -> (quotient: Swift.Int16, remainder: Swift.Int16) {
    _precondition(self != 0, "Division by zero")
 
    let a = Int32(dividend.high) &<< 16 |
            Int32(dividend.low)
    let b = Int32(self)
    let (q, r) = a.quotientAndRemainder(dividingBy: b)
 
     
     
    guard let quotient = Int16(exactly: q) else {
      _preconditionFailure("Quotient is not representable")
    }
    return (quotient, Int16(truncatingIfNeeded: r))
 
  }
  @_transparent public var byteSwapped: Swift.Int16 {
    @_transparent get {
 
    return Int16(Builtin.int_bswap_Int16(_value))
 
  }
  }
  @inlinable @inline(__always) public func signum() -> Swift.Int16 {
    let isPositive = Int16(Builtin.zext_Int1_Int16(
      (self > (0 as Int16))._value))
    return isPositive | (self &>> 15)
  }
  public typealias Stride = Swift.Int
}
extension Swift.Int16 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt16(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
 
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt16(_value)),
      count: 2)
 
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Int16 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.Int16 {
  @_transparent public static func & (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent @_alwaysEmitIntoClient public static func != (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Bool {
    return !(lhs == rhs)
  }
  @_transparent public static func <= (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Bool {
    return rhs < lhs
  }
}
extension Swift.Int16 : Swift.Sendable {
}
@_transparent public func _assumeNonNegative(_ x: Swift.Int16) -> Swift.Int16 {
  _internalInvariant(x >= (0 as Int16))
  return Int16(Builtin.assumeNonNegative_Int16(x._value))
}
@frozen public struct UInt32 : Swift.FixedWidthInteger, Swift.UnsignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.UInt32
  public var _value: Builtin.Int32
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int32(x).0
  }
  @_transparent public init(bitPattern x: Swift.Int32) {
    _value = x._value
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init(_ source: Swift.Float16) {
    _precondition(source.isFinite,
      "Float16 value cannot be converted to UInt32 because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Float16 value cannot be converted to UInt32 because the result would be less than UInt32.min")
 
     
     
 
    self._value = Builtin.fptoui_FPIEEE16_Int32(source._value)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init?(exactly source: Swift.Float16) {
     
     
     
 
     
     
    guard source > -1.0 && source.isFinite else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE16_Int32(source._value)
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt32 because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt32 because the result would be less than UInt32.min")
 
    _precondition(source < 4294967296.0,
      "Float value cannot be converted to UInt32 because the result would be greater than UInt32.max")
 
    self._value = Builtin.fptoui_FPIEEE32_Int32(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
     
     
     
 
    guard source > -1.0 && source < 4294967296.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int32(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt32 because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt32 because the result would be less than UInt32.min")
 
    _precondition(source < 4294967296.0,
      "Double value cannot be converted to UInt32 because the result would be greater than UInt32.max")
 
    self._value = Builtin.fptoui_FPIEEE64_Int32(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
     
     
     
 
    guard source > -1.0 && source < 4294967296.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int32(source._value)
  }
  @_transparent public static func == (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.Bool {
    return Bool(Builtin.cmp_ult_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
 
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt32(result)
  }
  @_transparent public static func -= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
 
    let (result, overflow) =
      Builtin.usub_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt32(result)
  }
  @_transparent public static func *= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
 
    let (result, overflow) =
      Builtin.umul_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt32(result)
  }
  @_transparent public static func /= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
 
     
     
    if _slowPath(rhs == (0 as UInt32)) {
      _preconditionFailure(
        "Division by zero")
    }
 
    let (result, overflow) =
      (Builtin.udiv_Int32(lhs._value, rhs._value),
      false._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt32(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.UInt32) -> (partialValue: Swift.UInt32, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int32(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.UInt32) -> (partialValue: Swift.UInt32, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int32(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.UInt32) -> (partialValue: Swift.UInt32, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int32(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.UInt32) -> (partialValue: Swift.UInt32, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as UInt32)) {
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.udiv_Int32(self._value, other._value),
      false._value)

 

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.UInt32) -> (partialValue: Swift.UInt32, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as UInt32)) {
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.urem_Int32(self._value, other._value),
      false._value)

 

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
     
     
    if _slowPath(rhs == (0 as UInt32)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
 

    let (newStorage, _) = (
      Builtin.urem_Int32(lhs._value, rhs._value),
      false._value)
    lhs = UInt32(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int32) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
    lhs = UInt32(Builtin.and_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
    lhs = UInt32(Builtin.or_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
    lhs = UInt32(Builtin.xor_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
    let rhs_ = rhs & 31
    lhs = UInt32(
      Builtin.lshr_Int32(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
    let rhs_ = rhs & 31
    lhs = UInt32(
      Builtin.shl_Int32(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 32 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt32(
        Builtin.int_ctlz_Int32(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt32(
        Builtin.int_cttz_Int32(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt32(
        Builtin.int_ctpop_Int32(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection, Swift.Sendable {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.UInt32.Words>
    @usableFromInline
    internal var _value: Swift.UInt32
    @inlinable public init(_ value: Swift.UInt32) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (32 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.UInt32.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt32(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt32.Words>
  }
  @_transparent public var words: Swift.UInt32.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
 
    return UInt(
      Builtin.zextOrBitCast_Int32_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
 
    self.init(
      Builtin.truncOrBitCast_Int64_Int32(bits._value))
  }
  public typealias Magnitude = Swift.UInt32
  @inlinable public func multipliedFullWidth(by other: Swift.UInt32) -> (high: Swift.UInt32, low: Swift.UInt32.Magnitude) {
     
    let lhs_ = Builtin.zext_Int32_Int64(self._value)
    let rhs_ = Builtin.zext_Int32_Int64(other._value)

    let res = Builtin.mul_Int64(lhs_, rhs_)
    let low = UInt32.Magnitude(Builtin.truncOrBitCast_Int64_Int32(res))
    let shift = Builtin.zextOrBitCast_Int8_Int64(UInt8(32)._value)
    let shifted = Builtin.ashr_Int64(res, shift)
    let high = UInt32(Builtin.truncOrBitCast_Int64_Int32(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.UInt32, low: Swift.UInt32.Magnitude)) -> (quotient: Swift.UInt32, remainder: Swift.UInt32) {
    _precondition(self != 0, "Division by zero")
 
    _precondition(self > dividend.high, "Quotient is not representable")
 
    let a = UInt64(dividend.high) &<< 32 |
            UInt64(dividend.low)
    let b = UInt64(self)
    let (q, r) = a.quotientAndRemainder(dividingBy: b)
 
     
     
    return (UInt32(truncatingIfNeeded: q), UInt32(truncatingIfNeeded: r))
 
  }
  @_transparent public var byteSwapped: Swift.UInt32 {
    @_transparent get {
 
    return UInt32(Builtin.int_bswap_Int32(_value))
 
  }
  }
  @inlinable @inline(__always) public func signum() -> Swift.UInt32 {
    let isPositive = UInt32(Builtin.zext_Int1_Int32(
      (self > (0 as UInt32))._value))
    return isPositive | (self &>> 31)
  }
  public typealias Stride = Swift.Int
}
extension Swift.UInt32 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt32(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
 
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt32(_value)),
      count: 4)
 
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.UInt32 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.UInt32 {
  @_transparent public static func & (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent @_alwaysEmitIntoClient public static func != (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.Bool {
    return !(lhs == rhs)
  }
  @_transparent public static func <= (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.Bool {
    return rhs < lhs
  }
}
extension Swift.UInt32 : Swift.Sendable {
}
@frozen public struct Int32 : Swift.FixedWidthInteger, Swift.SignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int32
  public var _value: Builtin.Int32
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int32(x).0
  }
  @_transparent public init(bitPattern x: Swift.UInt32) {
    _value = x._value
  }
  @available(*, unavailable, message: "Please use Int32(bitPattern: UInt32) in combination with Float.bitPattern property.")
  public init(bitPattern x: Swift.Float)
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init(_ source: Swift.Float16) {
    _precondition(source.isFinite,
      "Float16 value cannot be converted to Int32 because it is either infinite or NaN")
 
     
     
 
    self._value = Builtin.fptosi_FPIEEE16_Int32(source._value)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init?(exactly source: Swift.Float16) {
     
     
     
 
     
     
    guard source.isFinite else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE16_Int32(source._value)
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int32 because it is either infinite or NaN")
 
    _precondition(source > -2147483904.0,
      "Float value cannot be converted to Int32 because the result would be less than Int32.min")
 
    _precondition(source < 2147483648.0,
      "Float value cannot be converted to Int32 because the result would be greater than Int32.max")
 
    self._value = Builtin.fptosi_FPIEEE32_Int32(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
     
     
     
 
    guard source > -2147483904.0 && source < 2147483648.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int32(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int32 because it is either infinite or NaN")
 
    _precondition(source > -2147483649.0,
      "Double value cannot be converted to Int32 because the result would be less than Int32.min")
 
    _precondition(source < 2147483648.0,
      "Double value cannot be converted to Int32 because the result would be greater than Int32.max")
 
    self._value = Builtin.fptosi_FPIEEE64_Int32(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
     
     
     
 
    guard source > -2147483649.0 && source < 2147483648.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int32(source._value)
  }
  @_transparent public static func == (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Bool {
    return Bool(Builtin.cmp_slt_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.Int32, rhs: Swift.Int32) {
 
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int32(result)
  }
  @_transparent public static func -= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
 
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int32(result)
  }
  @_transparent public static func *= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
 
    let (result, overflow) =
      Builtin.smul_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int32(result)
  }
  @_transparent public static func /= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
 
     
     
    if _slowPath(rhs == (0 as Int32)) {
      _preconditionFailure(
        "Division by zero")
    }
 
    if _slowPath(
      lhs == Int32.min && rhs == (-1 as Int32)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
 
    let (result, overflow) =
      (Builtin.sdiv_Int32(lhs._value, rhs._value),
      false._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int32(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.Int32) -> (partialValue: Swift.Int32, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int32(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.Int32) -> (partialValue: Swift.Int32, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int32(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.Int32) -> (partialValue: Swift.Int32, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int32(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.Int32) -> (partialValue: Swift.Int32, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as Int32)) {
      return (partialValue: self, overflow: true)
    }
 
    if _slowPath(self == Int32.min && other == (-1 as Int32)) {
 
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.sdiv_Int32(self._value, other._value),
      false._value)

 

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.Int32) -> (partialValue: Swift.Int32, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as Int32)) {
      return (partialValue: self, overflow: true)
    }
 
    if _slowPath(self == Int32.min && other == (-1 as Int32)) {
 
      return (partialValue: 0, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.srem_Int32(self._value, other._value),
      false._value)

 

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
     
     
    if _slowPath(rhs == (0 as Int32)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
 
    if _slowPath(lhs == Int32.min && rhs == (-1 as Int32)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
 

    let (newStorage, _) = (
      Builtin.srem_Int32(lhs._value, rhs._value),
      false._value)
    lhs = Int32(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int32) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
    lhs = Int32(Builtin.and_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
    lhs = Int32(Builtin.or_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
    lhs = Int32(Builtin.xor_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
    let rhs_ = rhs & 31
    lhs = Int32(
      Builtin.ashr_Int32(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
    let rhs_ = rhs & 31
    lhs = Int32(
      Builtin.shl_Int32(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 32 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int32(
        Builtin.int_ctlz_Int32(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int32(
        Builtin.int_cttz_Int32(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int32(
        Builtin.int_ctpop_Int32(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection, Swift.Sendable {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.Int32.Words>
    @usableFromInline
    internal var _value: Swift.Int32
    @inlinable public init(_ value: Swift.Int32) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (32 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.Int32.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int32(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int32.Words>
  }
  @_transparent public var words: Swift.Int32.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
 
    return UInt(
      Builtin.sextOrBitCast_Int32_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
 
    self.init(
      Builtin.truncOrBitCast_Int64_Int32(bits._value))
  }
  public typealias Magnitude = Swift.UInt32
  @_transparent public var magnitude: Swift.UInt32 {
    @_transparent get {
    let base = UInt32(_value)
    return self < (0 as Int32) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Swift.Int32) -> (high: Swift.Int32, low: Swift.Int32.Magnitude) {
     
    let lhs_ = Builtin.sext_Int32_Int64(self._value)
    let rhs_ = Builtin.sext_Int32_Int64(other._value)

    let res = Builtin.mul_Int64(lhs_, rhs_)
    let low = Int32.Magnitude(Builtin.truncOrBitCast_Int64_Int32(res))
    let shift = Builtin.zextOrBitCast_Int8_Int64(UInt8(32)._value)
    let shifted = Builtin.ashr_Int64(res, shift)
    let high = Int32(Builtin.truncOrBitCast_Int64_Int32(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.Int32, low: Swift.Int32.Magnitude)) -> (quotient: Swift.Int32, remainder: Swift.Int32) {
    _precondition(self != 0, "Division by zero")
 
    let a = Int64(dividend.high) &<< 32 |
            Int64(dividend.low)
    let b = Int64(self)
    let (q, r) = a.quotientAndRemainder(dividingBy: b)
 
     
     
    guard let quotient = Int32(exactly: q) else {
      _preconditionFailure("Quotient is not representable")
    }
    return (quotient, Int32(truncatingIfNeeded: r))
 
  }
  @_transparent public var byteSwapped: Swift.Int32 {
    @_transparent get {
 
    return Int32(Builtin.int_bswap_Int32(_value))
 
  }
  }
  @inlinable @inline(__always) public func signum() -> Swift.Int32 {
    let isPositive = Int32(Builtin.zext_Int1_Int32(
      (self > (0 as Int32))._value))
    return isPositive | (self &>> 31)
  }
  public typealias Stride = Swift.Int
}
extension Swift.Int32 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt32(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
 
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt32(_value)),
      count: 4)
 
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Int32 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.Int32 {
  @_transparent public static func & (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent @_alwaysEmitIntoClient public static func != (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Bool {
    return !(lhs == rhs)
  }
  @_transparent public static func <= (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Bool {
    return rhs < lhs
  }
}
extension Swift.Int32 : Swift.Sendable {
}
@_transparent public func _assumeNonNegative(_ x: Swift.Int32) -> Swift.Int32 {
  _internalInvariant(x >= (0 as Int32))
  return Int32(Builtin.assumeNonNegative_Int32(x._value))
}
@frozen public struct UInt64 : Swift.FixedWidthInteger, Swift.UnsignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.UInt64
  public var _value: Builtin.Int64
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int64(x).0
  }
  @_transparent public init(bitPattern x: Swift.Int64) {
    _value = x._value
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init(_ source: Swift.Float16) {
    _precondition(source.isFinite,
      "Float16 value cannot be converted to UInt64 because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Float16 value cannot be converted to UInt64 because the result would be less than UInt64.min")
 
     
     
 
    self._value = Builtin.fptoui_FPIEEE16_Int64(source._value)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init?(exactly source: Swift.Float16) {
     
     
     
 
     
     
    guard source > -1.0 && source.isFinite else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE16_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt64 because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt64 because the result would be less than UInt64.min")
 
    _precondition(source < 18446744073709551616.0,
      "Float value cannot be converted to UInt64 because the result would be greater than UInt64.max")
 
    self._value = Builtin.fptoui_FPIEEE32_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
     
     
     
 
    guard source > -1.0 && source < 18446744073709551616.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt64 because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt64 because the result would be less than UInt64.min")
 
    _precondition(source < 18446744073709551616.0,
      "Double value cannot be converted to UInt64 because the result would be greater than UInt64.max")
 
    self._value = Builtin.fptoui_FPIEEE64_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
     
     
     
 
    guard source > -1.0 && source < 18446744073709551616.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int64(source._value)
  }
  @_transparent public static func == (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.Bool {
    return Bool(Builtin.cmp_ult_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
 
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt64(result)
  }
  @_transparent public static func -= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
 
    let (result, overflow) =
      Builtin.usub_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt64(result)
  }
  @_transparent public static func *= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
 
    let (result, overflow) =
      Builtin.umul_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt64(result)
  }
  @_transparent public static func /= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
 
     
     
    if _slowPath(rhs == (0 as UInt64)) {
      _preconditionFailure(
        "Division by zero")
    }
 
    let (result, overflow) =
      (Builtin.udiv_Int64(lhs._value, rhs._value),
      false._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt64(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.UInt64) -> (partialValue: Swift.UInt64, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int64(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.UInt64) -> (partialValue: Swift.UInt64, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int64(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.UInt64) -> (partialValue: Swift.UInt64, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int64(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.UInt64) -> (partialValue: Swift.UInt64, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as UInt64)) {
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.udiv_Int64(self._value, other._value),
      false._value)

 

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.UInt64) -> (partialValue: Swift.UInt64, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as UInt64)) {
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.urem_Int64(self._value, other._value),
      false._value)

 

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
     
     
    if _slowPath(rhs == (0 as UInt64)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
 

    let (newStorage, _) = (
      Builtin.urem_Int64(lhs._value, rhs._value),
      false._value)
    lhs = UInt64(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int64) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
    lhs = UInt64(Builtin.and_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
    lhs = UInt64(Builtin.or_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
    lhs = UInt64(Builtin.xor_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
    let rhs_ = rhs & 63
    lhs = UInt64(
      Builtin.lshr_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
    let rhs_ = rhs & 63
    lhs = UInt64(
      Builtin.shl_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 64 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt64(
        Builtin.int_ctlz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt64(
        Builtin.int_cttz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt64(
        Builtin.int_ctpop_Int64(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection, Swift.Sendable {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.UInt64.Words>
    @usableFromInline
    internal var _value: Swift.UInt64
    @inlinable public init(_ value: Swift.UInt64) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (64 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.UInt64.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt64(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt64.Words>
  }
  @_transparent public var words: Swift.UInt64.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
 
    return UInt(
      Builtin.zextOrBitCast_Int64_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
 
    self.init(
      Builtin.truncOrBitCast_Int64_Int64(bits._value))
  }
  public typealias Magnitude = Swift.UInt64
  @inlinable public func multipliedFullWidth(by other: Swift.UInt64) -> (high: Swift.UInt64, low: Swift.UInt64.Magnitude) {
     
    let lhs_ = Builtin.zext_Int64_Int128(self._value)
    let rhs_ = Builtin.zext_Int64_Int128(other._value)

    let res = Builtin.mul_Int128(lhs_, rhs_)
    let low = UInt64.Magnitude(Builtin.truncOrBitCast_Int128_Int64(res))
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let shifted = Builtin.ashr_Int128(res, shift)
    let high = UInt64(Builtin.truncOrBitCast_Int128_Int64(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.UInt64, low: Swift.UInt64.Magnitude)) -> (quotient: Swift.UInt64, remainder: Swift.UInt64) {
    _precondition(self != 0, "Division by zero")
 
    _precondition(self > dividend.high, "Quotient is not representable")
 
    let lhsHigh = Builtin.zext_Int64_Int128(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let lhsHighShifted = Builtin.shl_Int128(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int64_Int128(dividend.low._value)
    let a = Builtin.or_Int128(lhsHighShifted, lhsLow)
    let b = Builtin.zext_Int64_Int128(self._value)
    
    let q = Builtin.udiv_Int128(a, b)
    let r = Builtin.urem_Int128(a, b)

 
     
     
    let quotient = Builtin.truncOrBitCast_Int128_Int64(q)
 
    let remainder = Builtin.truncOrBitCast_Int128_Int64(r)

    return (quotient: Self(quotient), remainder: Self(remainder))
 
  }
  @_transparent public var byteSwapped: Swift.UInt64 {
    @_transparent get {
 
    return UInt64(Builtin.int_bswap_Int64(_value))
 
  }
  }
  @inlinable @inline(__always) public func signum() -> Swift.UInt64 {
    let isPositive = UInt64(Builtin.zext_Int1_Int64(
      (self > (0 as UInt64))._value))
    return isPositive | (self &>> 63)
  }
  public typealias Stride = Swift.Int
}
extension Swift.UInt64 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt64(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
 
    return Hasher._hash(seed: seed, UInt64(_value))
 
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.UInt64 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.UInt64 {
  @_transparent public static func & (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent @_alwaysEmitIntoClient public static func != (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.Bool {
    return !(lhs == rhs)
  }
  @_transparent public static func <= (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.Bool {
    return rhs < lhs
  }
}
extension Swift.UInt64 : Swift.Sendable {
}
@frozen public struct Int64 : Swift.FixedWidthInteger, Swift.SignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int64
  public var _value: Builtin.Int64
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int64(x).0
  }
  @_transparent public init(bitPattern x: Swift.UInt64) {
    _value = x._value
  }
  @available(*, unavailable, message: "Please use Int64(bitPattern: UInt64) in combination with Double.bitPattern property.")
  public init(bitPattern x: Swift.Double)
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init(_ source: Swift.Float16) {
    _precondition(source.isFinite,
      "Float16 value cannot be converted to Int64 because it is either infinite or NaN")
 
     
     
 
    self._value = Builtin.fptosi_FPIEEE16_Int64(source._value)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init?(exactly source: Swift.Float16) {
     
     
     
 
     
     
    guard source.isFinite else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE16_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int64 because it is either infinite or NaN")
 
    _precondition(source > -9223373136366403584.0,
      "Float value cannot be converted to Int64 because the result would be less than Int64.min")
 
    _precondition(source < 9223372036854775808.0,
      "Float value cannot be converted to Int64 because the result would be greater than Int64.max")
 
    self._value = Builtin.fptosi_FPIEEE32_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
     
     
     
 
    guard source > -9223373136366403584.0 && source < 9223372036854775808.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int64 because it is either infinite or NaN")
 
    _precondition(source > -9223372036854777856.0,
      "Double value cannot be converted to Int64 because the result would be less than Int64.min")
 
    _precondition(source < 9223372036854775808.0,
      "Double value cannot be converted to Int64 because the result would be greater than Int64.max")
 
    self._value = Builtin.fptosi_FPIEEE64_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
     
     
     
 
    guard source > -9223372036854777856.0 && source < 9223372036854775808.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int64(source._value)
  }
  @_transparent public static func == (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Bool {
    return Bool(Builtin.cmp_slt_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.Int64, rhs: Swift.Int64) {
 
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int64(result)
  }
  @_transparent public static func -= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
 
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int64(result)
  }
  @_transparent public static func *= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
 
    let (result, overflow) =
      Builtin.smul_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int64(result)
  }
  @_transparent public static func /= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
 
     
     
    if _slowPath(rhs == (0 as Int64)) {
      _preconditionFailure(
        "Division by zero")
    }
 
    if _slowPath(
      lhs == Int64.min && rhs == (-1 as Int64)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
 
    let (result, overflow) =
      (Builtin.sdiv_Int64(lhs._value, rhs._value),
      false._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int64(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.Int64) -> (partialValue: Swift.Int64, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int64(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.Int64) -> (partialValue: Swift.Int64, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int64(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.Int64) -> (partialValue: Swift.Int64, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int64(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.Int64) -> (partialValue: Swift.Int64, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as Int64)) {
      return (partialValue: self, overflow: true)
    }
 
    if _slowPath(self == Int64.min && other == (-1 as Int64)) {
 
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.sdiv_Int64(self._value, other._value),
      false._value)

 

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.Int64) -> (partialValue: Swift.Int64, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as Int64)) {
      return (partialValue: self, overflow: true)
    }
 
    if _slowPath(self == Int64.min && other == (-1 as Int64)) {
 
      return (partialValue: 0, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.srem_Int64(self._value, other._value),
      false._value)

 

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
     
     
    if _slowPath(rhs == (0 as Int64)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
 
    if _slowPath(lhs == Int64.min && rhs == (-1 as Int64)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
 

    let (newStorage, _) = (
      Builtin.srem_Int64(lhs._value, rhs._value),
      false._value)
    lhs = Int64(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int64) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
    lhs = Int64(Builtin.and_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
    lhs = Int64(Builtin.or_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
    lhs = Int64(Builtin.xor_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
    let rhs_ = rhs & 63
    lhs = Int64(
      Builtin.ashr_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
    let rhs_ = rhs & 63
    lhs = Int64(
      Builtin.shl_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 64 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int64(
        Builtin.int_ctlz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int64(
        Builtin.int_cttz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int64(
        Builtin.int_ctpop_Int64(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection, Swift.Sendable {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.Int64.Words>
    @usableFromInline
    internal var _value: Swift.Int64
    @inlinable public init(_ value: Swift.Int64) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (64 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.Int64.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int64(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int64.Words>
  }
  @_transparent public var words: Swift.Int64.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
 
    return UInt(
      Builtin.sextOrBitCast_Int64_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
 
    self.init(
      Builtin.truncOrBitCast_Int64_Int64(bits._value))
  }
  public typealias Magnitude = Swift.UInt64
  @_transparent public var magnitude: Swift.UInt64 {
    @_transparent get {
    let base = UInt64(_value)
    return self < (0 as Int64) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Swift.Int64) -> (high: Swift.Int64, low: Swift.Int64.Magnitude) {
     
    let lhs_ = Builtin.sext_Int64_Int128(self._value)
    let rhs_ = Builtin.sext_Int64_Int128(other._value)

    let res = Builtin.mul_Int128(lhs_, rhs_)
    let low = Int64.Magnitude(Builtin.truncOrBitCast_Int128_Int64(res))
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let shifted = Builtin.ashr_Int128(res, shift)
    let high = Int64(Builtin.truncOrBitCast_Int128_Int64(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.Int64, low: Swift.Int64.Magnitude)) -> (quotient: Swift.Int64, remainder: Swift.Int64) {
    _precondition(self != 0, "Division by zero")
 
    let lhsHigh = Builtin.sext_Int64_Int128(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let lhsHighShifted = Builtin.shl_Int128(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int64_Int128(dividend.low._value)
    let a = Builtin.or_Int128(lhsHighShifted, lhsLow)
    let b = Builtin.sext_Int64_Int128(self._value)
    
    let q = Builtin.sdiv_Int128(a, b)
    let r = Builtin.srem_Int128(a, b)

 
     
     
    let (quotient, overflow) =
      Builtin.s_to_s_checked_trunc_Int128_Int64(q)
    _precondition(!Bool(overflow), "Quotient is not representable")
 
    let remainder = Builtin.truncOrBitCast_Int128_Int64(r)

    return (quotient: Self(quotient), remainder: Self(remainder))
 
  }
  @_transparent public var byteSwapped: Swift.Int64 {
    @_transparent get {
 
    return Int64(Builtin.int_bswap_Int64(_value))
 
  }
  }
  @inlinable @inline(__always) public func signum() -> Swift.Int64 {
    let isPositive = Int64(Builtin.zext_Int1_Int64(
      (self > (0 as Int64))._value))
    return isPositive | (self &>> 63)
  }
  public typealias Stride = Swift.Int
}
extension Swift.Int64 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt64(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
 
    return Hasher._hash(seed: seed, UInt64(_value))
 
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Int64 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.Int64 {
  @_transparent public static func & (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent @_alwaysEmitIntoClient public static func != (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Bool {
    return !(lhs == rhs)
  }
  @_transparent public static func <= (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Bool {
    return rhs < lhs
  }
}
extension Swift.Int64 : Swift.Sendable {
}
@_transparent public func _assumeNonNegative(_ x: Swift.Int64) -> Swift.Int64 {
  _internalInvariant(x >= (0 as Int64))
  return Int64(Builtin.assumeNonNegative_Int64(x._value))
}
@frozen public struct UInt : Swift.FixedWidthInteger, Swift.UnsignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.UInt
  public var _value: Builtin.Int64
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int64(x).0
  }
  @_transparent public init(bitPattern x: Swift.Int) {
    _value = x._value
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init(_ source: Swift.Float16) {
    _precondition(source.isFinite,
      "Float16 value cannot be converted to UInt because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Float16 value cannot be converted to UInt because the result would be less than UInt.min")
 
     
     
 
    self._value = Builtin.fptoui_FPIEEE16_Int64(source._value)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init?(exactly source: Swift.Float16) {
     
     
     
 
     
     
    guard source > -1.0 && source.isFinite else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE16_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt because the result would be less than UInt.min")
 
    _precondition(source < 18446744073709551616.0,
      "Float value cannot be converted to UInt because the result would be greater than UInt.max")
 
    self._value = Builtin.fptoui_FPIEEE32_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
     
     
     
 
    guard source > -1.0 && source < 18446744073709551616.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt because it is either infinite or NaN")
 
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt because the result would be less than UInt.min")
 
    _precondition(source < 18446744073709551616.0,
      "Double value cannot be converted to UInt because the result would be greater than UInt.max")
 
    self._value = Builtin.fptoui_FPIEEE64_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
     
     
     
 
    guard source > -1.0 && source < 18446744073709551616.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int64(source._value)
  }
  @_transparent public static func == (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.Bool {
    return Bool(Builtin.cmp_ult_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.UInt, rhs: Swift.UInt) {
 
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt(result)
  }
  @_transparent public static func -= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
 
    let (result, overflow) =
      Builtin.usub_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt(result)
  }
  @_transparent public static func *= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
 
    let (result, overflow) =
      Builtin.umul_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt(result)
  }
  @_transparent public static func /= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
 
     
     
    if _slowPath(rhs == (0 as UInt)) {
      _preconditionFailure(
        "Division by zero")
    }
 
    let (result, overflow) =
      (Builtin.udiv_Int64(lhs._value, rhs._value),
      false._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.UInt) -> (partialValue: Swift.UInt, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int64(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.UInt) -> (partialValue: Swift.UInt, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int64(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.UInt) -> (partialValue: Swift.UInt, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int64(
        self._value, other._value, false._value)
 

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.UInt) -> (partialValue: Swift.UInt, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as UInt)) {
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.udiv_Int64(self._value, other._value),
      false._value)

 

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.UInt) -> (partialValue: Swift.UInt, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as UInt)) {
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.urem_Int64(self._value, other._value),
      false._value)

 

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
     
     
    if _slowPath(rhs == (0 as UInt)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
 

    let (newStorage, _) = (
      Builtin.urem_Int64(lhs._value, rhs._value),
      false._value)
    lhs = UInt(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int64) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
    lhs = UInt(Builtin.and_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
    lhs = UInt(Builtin.or_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
    lhs = UInt(Builtin.xor_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
    let rhs_ = rhs & 63
    lhs = UInt(
      Builtin.lshr_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
    let rhs_ = rhs & 63
    lhs = UInt(
      Builtin.shl_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 64 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt(
        Builtin.int_ctlz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt(
        Builtin.int_cttz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt(
        Builtin.int_ctpop_Int64(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection, Swift.Sendable {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.UInt.Words>
    @usableFromInline
    internal var _value: Swift.UInt
    @inlinable public init(_ value: Swift.UInt) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (64 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.UInt.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt.Words>
  }
  @_transparent public var words: Swift.UInt.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
 
    return UInt(
      Builtin.zextOrBitCast_Int64_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
 
    self.init(
      Builtin.truncOrBitCast_Int64_Int64(bits._value))
  }
  public typealias Magnitude = Swift.UInt
  @inlinable public func multipliedFullWidth(by other: Swift.UInt) -> (high: Swift.UInt, low: Swift.UInt.Magnitude) {
     
    let lhs_ = Builtin.zext_Int64_Int128(self._value)
    let rhs_ = Builtin.zext_Int64_Int128(other._value)

    let res = Builtin.mul_Int128(lhs_, rhs_)
    let low = UInt.Magnitude(Builtin.truncOrBitCast_Int128_Int64(res))
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let shifted = Builtin.ashr_Int128(res, shift)
    let high = UInt(Builtin.truncOrBitCast_Int128_Int64(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.UInt, low: Swift.UInt.Magnitude)) -> (quotient: Swift.UInt, remainder: Swift.UInt) {
    _precondition(self != 0, "Division by zero")
 
    _precondition(self > dividend.high, "Quotient is not representable")
 
    let lhsHigh = Builtin.zext_Int64_Int128(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let lhsHighShifted = Builtin.shl_Int128(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int64_Int128(dividend.low._value)
    let a = Builtin.or_Int128(lhsHighShifted, lhsLow)
    let b = Builtin.zext_Int64_Int128(self._value)
    
    let q = Builtin.udiv_Int128(a, b)
    let r = Builtin.urem_Int128(a, b)

 
     
     
    let quotient = Builtin.truncOrBitCast_Int128_Int64(q)
 
    let remainder = Builtin.truncOrBitCast_Int128_Int64(r)

    return (quotient: Self(quotient), remainder: Self(remainder))
 
  }
  @_transparent public var byteSwapped: Swift.UInt {
    @_transparent get {
 
    return UInt(Builtin.int_bswap_Int64(_value))
 
  }
  }
  @_transparent public init(_ _v: Builtin.Word) {
 
    self._value = Builtin.zextOrBitCast_Word_Int64(_v)
 
  }
  @_transparent public var _builtinWordValue: Builtin.Word {
    @_transparent get {
 
    return Builtin.truncOrBitCast_Int64_Word(_value)
 
  }
  }
  @inlinable @inline(__always) public func signum() -> Swift.UInt {
    let isPositive = UInt(Builtin.zext_Int1_Int64(
      (self > (0 as UInt))._value))
    return isPositive | (self &>> 63)
  }
  public typealias Stride = Swift.Int
}
extension Swift.UInt : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
 
    return Hasher._hash(seed: seed, UInt64(_value))
 
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.UInt : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.UInt {
  @_transparent public static func & (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent @_alwaysEmitIntoClient public static func != (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.Bool {
    return !(lhs == rhs)
  }
  @_transparent public static func <= (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.Bool {
    return rhs < lhs
  }
}
extension Swift.UInt : Swift.Sendable {
}
@frozen public struct Int : Swift.FixedWidthInteger, Swift.SignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
  public var _value: Builtin.Int64
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int64(x).0
  }
  @_transparent public init(bitPattern x: Swift.UInt) {
    _value = x._value
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init(_ source: Swift.Float16) {
    _precondition(source.isFinite,
      "Float16 value cannot be converted to Int because it is either infinite or NaN")
 
     
     
 
    self._value = Builtin.fptosi_FPIEEE16_Int64(source._value)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @_transparent public init?(exactly source: Swift.Float16) {
     
     
     
 
     
     
    guard source.isFinite else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE16_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int because it is either infinite or NaN")
 
    _precondition(source > -9223373136366403584.0,
      "Float value cannot be converted to Int because the result would be less than Int.min")
 
    _precondition(source < 9223372036854775808.0,
      "Float value cannot be converted to Int because the result would be greater than Int.max")
 
    self._value = Builtin.fptosi_FPIEEE32_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
     
     
     
 
    guard source > -9223373136366403584.0 && source < 9223372036854775808.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int because it is either infinite or NaN")
 
    _precondition(source > -9223372036854777856.0,
      "Double value cannot be converted to Int because the result would be less than Int.min")
 
    _precondition(source < 9223372036854775808.0,
      "Double value cannot be converted to Int because the result would be greater than Int.max")
 
    self._value = Builtin.fptosi_FPIEEE64_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
     
     
     
 
    guard source > -9223372036854777856.0 && source < 9223372036854775808.0 else {
 
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int64(source._value)
  }
  @_transparent public static func == (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Bool {
    return Bool(Builtin.cmp_slt_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.Int, rhs: Swift.Int) {
 
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int(result)
  }
  @_transparent public static func -= (lhs: inout Swift.Int, rhs: Swift.Int) {
 
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int(result)
  }
  @_transparent public static func *= (lhs: inout Swift.Int, rhs: Swift.Int) {
 
    let (result, overflow) =
      Builtin.smul_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int(result)
  }
  @_transparent public static func /= (lhs: inout Swift.Int, rhs: Swift.Int) {
 
     
     
    if _slowPath(rhs == (0 as Int)) {
      _preconditionFailure(
        "Division by zero")
    }
 
    if _slowPath(
      lhs == Int.min && rhs == (-1 as Int)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
 
    let (result, overflow) =
      (Builtin.sdiv_Int64(lhs._value, rhs._value),
      false._value)
 
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.Int) -> (partialValue: Swift.Int, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int64(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.Int) -> (partialValue: Swift.Int, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int64(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.Int) -> (partialValue: Swift.Int, overflow: Swift.Bool) {
 

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int64(
        self._value, other._value, false._value)
 

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.Int) -> (partialValue: Swift.Int, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as Int)) {
      return (partialValue: self, overflow: true)
    }
 
    if _slowPath(self == Int.min && other == (-1 as Int)) {
 
      return (partialValue: self, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.sdiv_Int64(self._value, other._value),
      false._value)

 

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.Int) -> (partialValue: Swift.Int, overflow: Swift.Bool) {
 
     
     
    if _slowPath(other == (0 as Int)) {
      return (partialValue: self, overflow: true)
    }
 
    if _slowPath(self == Int.min && other == (-1 as Int)) {
 
      return (partialValue: 0, overflow: true)
    }
 

    let (newStorage, overflow) = (
      Builtin.srem_Int64(self._value, other._value),
      false._value)

 

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.Int, rhs: Swift.Int) {
     
     
    if _slowPath(rhs == (0 as Int)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
 
    if _slowPath(lhs == Int.min && rhs == (-1 as Int)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
 

    let (newStorage, _) = (
      Builtin.srem_Int64(lhs._value, rhs._value),
      false._value)
    lhs = Int(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int64) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.Int, rhs: Swift.Int) {
    lhs = Int(Builtin.and_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.Int, rhs: Swift.Int) {
    lhs = Int(Builtin.or_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.Int, rhs: Swift.Int) {
    lhs = Int(Builtin.xor_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.Int, rhs: Swift.Int) {
    let rhs_ = rhs & 63
    lhs = Int(
      Builtin.ashr_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.Int, rhs: Swift.Int) {
    let rhs_ = rhs & 63
    lhs = Int(
      Builtin.shl_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 64 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int(
        Builtin.int_ctlz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int(
        Builtin.int_cttz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int(
        Builtin.int_ctpop_Int64(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection, Swift.Sendable {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.Int.Words>
    @usableFromInline
    internal var _value: Swift.Int
    @inlinable public init(_ value: Swift.Int) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (64 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.Int.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int.Words>
  }
  @_transparent public var words: Swift.Int.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
 
    return UInt(
      Builtin.sextOrBitCast_Int64_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
 
    self.init(
      Builtin.truncOrBitCast_Int64_Int64(bits._value))
  }
  public typealias Magnitude = Swift.UInt
  @_transparent public var magnitude: Swift.UInt {
    @_transparent get {
    let base = UInt(_value)
    return self < (0 as Int) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Swift.Int) -> (high: Swift.Int, low: Swift.Int.Magnitude) {
     
    let lhs_ = Builtin.sext_Int64_Int128(self._value)
    let rhs_ = Builtin.sext_Int64_Int128(other._value)

    let res = Builtin.mul_Int128(lhs_, rhs_)
    let low = Int.Magnitude(Builtin.truncOrBitCast_Int128_Int64(res))
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let shifted = Builtin.ashr_Int128(res, shift)
    let high = Int(Builtin.truncOrBitCast_Int128_Int64(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.Int, low: Swift.Int.Magnitude)) -> (quotient: Swift.Int, remainder: Swift.Int) {
    _precondition(self != 0, "Division by zero")
 
    let lhsHigh = Builtin.sext_Int64_Int128(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let lhsHighShifted = Builtin.shl_Int128(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int64_Int128(dividend.low._value)
    let a = Builtin.or_Int128(lhsHighShifted, lhsLow)
    let b = Builtin.sext_Int64_Int128(self._value)
    
    let q = Builtin.sdiv_Int128(a, b)
    let r = Builtin.srem_Int128(a, b)

 
     
     
    let (quotient, overflow) =
      Builtin.s_to_s_checked_trunc_Int128_Int64(q)
    _precondition(!Bool(overflow), "Quotient is not representable")
 
    let remainder = Builtin.truncOrBitCast_Int128_Int64(r)

    return (quotient: Self(quotient), remainder: Self(remainder))
 
  }
  @_transparent public var byteSwapped: Swift.Int {
    @_transparent get {
 
    return Int(Builtin.int_bswap_Int64(_value))
 
  }
  }
  @_transparent public init(_ _v: Builtin.Word) {
 
    self._value = Builtin.sextOrBitCast_Word_Int64(_v)
 
  }
  @_transparent public var _builtinWordValue: Builtin.Word {
    @_transparent get {
 
    return Builtin.truncOrBitCast_Int64_Word(_value)
 
  }
  }
  @inlinable @inline(__always) public func signum() -> Swift.Int {
    let isPositive = Int(Builtin.zext_Int1_Int64(
      (self > (0 as Int))._value))
    return isPositive | (self &>> 63)
  }
  public typealias Stride = Swift.Int
}
extension Swift.Int : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
 
    return Hasher._hash(seed: seed, UInt64(_value))
 
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Int : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Swift.Int {
  @_transparent public static func & (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent @_alwaysEmitIntoClient public static func != (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Bool {
    return !(lhs == rhs)
  }
  @_transparent public static func <= (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Bool {
    return rhs < lhs
  }
}
extension Swift.Int : Swift.Sendable {
}
@_transparent public func _assumeNonNegative(_ x: Swift.Int) -> Swift.Int {
  _internalInvariant(x >= (0 as Int))
  return Int(Builtin.assumeNonNegative_Int64(x._value))
}
extension Swift.Int {
  @_transparent public func distance(to other: Swift.Int) -> Swift.Int {
    return other - self
  }
  @_transparent public func advanced(by n: Swift.Int) -> Swift.Int {
    return self + n
  }
}
@_transparent @inlinable internal func _unsafePlus(_ lhs: Swift.Int, _ rhs: Swift.Int) -> Swift.Int {
  return lhs &+ rhs
}
@_transparent @inlinable internal func _unsafeMinus(_ lhs: Swift.Int, _ rhs: Swift.Int) -> Swift.Int {
  return lhs &- rhs
}
#if compiler(>=5.3) && $NoncopyableGenerics
@frozen public struct UnsafeMutableBufferPointer<Element> : Swift.Copyable where Element : ~Copyable {
  @usableFromInline
  @_preInverseGenerics internal let _position: Swift.UnsafeMutablePointer<Element>?
  @_preInverseGenerics public let count: Swift.Int
  @_alwaysEmitIntoClient internal init(@_nonEphemeral _uncheckedStart start: Swift.UnsafeMutablePointer<Element>?, count: Swift.Int) {
    _position = start
    self.count = count
  }
  @inlinable @_preInverseGenerics public init(@_nonEphemeral start: Swift.UnsafeMutablePointer<Element>?, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutableBufferPointer with negative count")
    _debugPrecondition(
      count == 0 || start != nil,
      "UnsafeMutableBufferPointer has a nil start and nonzero count")
    self.init(_uncheckedStart: start, count: _assumeNonNegative(count))
  }
  @inlinable @_preInverseGenerics public init(_empty: ()) {
    _position = nil
    count = 0
  }
  @inlinable @_preInverseGenerics public init(mutating other: Swift.UnsafeBufferPointer<Element>) {
    _position = UnsafeMutablePointer<Element>(mutating: other._position)
    count = other.count
  }
}
#else
@frozen public struct UnsafeMutableBufferPointer<Element> {
  @usableFromInline
  internal let _position: Swift.UnsafeMutablePointer<Element>?
  public let count: Swift.Int
  @_alwaysEmitIntoClient internal init(@_nonEphemeral _uncheckedStart start: Swift.UnsafeMutablePointer<Element>?, count: Swift.Int) {
    _position = start
    self.count = count
  }
  @inlinable public init(@_nonEphemeral start: Swift.UnsafeMutablePointer<Element>?, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutableBufferPointer with negative count")
    _debugPrecondition(
      count == 0 || start != nil,
      "UnsafeMutableBufferPointer has a nil start and nonzero count")
    self.init(_uncheckedStart: start, count: _assumeNonNegative(count))
  }
  @inlinable public init(_empty: ()) {
    _position = nil
    count = 0
  }
  @inlinable public init(mutating other: Swift.UnsafeBufferPointer<Element>) {
    _position = UnsafeMutablePointer<Element>(mutating: other._position)
    count = other.count
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(*, unavailable)
extension Swift.UnsafeMutableBufferPointer : Swift.Sendable where Element : ~Copyable {
}
#else
@available(*, unavailable)
extension Swift.UnsafeMutableBufferPointer : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer where Element : ~Copyable {
  @inlinable @_preInverseGenerics public var baseAddress: Swift.UnsafeMutablePointer<Element>? {
    get {
    _position
  }
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @inlinable public var baseAddress: Swift.UnsafeMutablePointer<Element>? {
    get {
    _position
  }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer {
  public typealias Iterator = Swift.UnsafeBufferPointer<Element>.Iterator
}
#else
extension Swift.UnsafeMutableBufferPointer {
  public typealias Iterator = Swift.UnsafeBufferPointer<Element>.Iterator
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer : Swift.Sequence {
  @inlinable public func makeIterator() -> Swift.UnsafeMutableBufferPointer<Element>.Iterator {
    guard let start = _position else {
      return Iterator(_position: nil, _end: nil)
    }
    return Iterator(_position: start, _end: start + count)
  }
  @inlinable public func _copyContents(initializing destination: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.UnsafeMutableBufferPointer<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    guard !isEmpty && !destination.isEmpty else { return (makeIterator(), 0) }
    let s = self.baseAddress._unsafelyUnwrappedUnchecked
    let d = destination.baseAddress._unsafelyUnwrappedUnchecked
    let n = Swift.min(destination.count, self.count)
    d.initialize(from: s, count: n)
    return (Iterator(_position: s + n, _end: s + count), n)
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
 
    return try body(UnsafeBufferPointer(self))
 
  }
}
#else
extension Swift.UnsafeMutableBufferPointer : Swift.Sequence {
  @inlinable public func makeIterator() -> Swift.UnsafeMutableBufferPointer<Element>.Iterator {
    guard let start = _position else {
      return Iterator(_position: nil, _end: nil)
    }
    return Iterator(_position: start, _end: start + count)
  }
  @inlinable public func _copyContents(initializing destination: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.UnsafeMutableBufferPointer<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    guard !isEmpty && !destination.isEmpty else { return (makeIterator(), 0) }
    let s = self.baseAddress._unsafelyUnwrappedUnchecked
    let d = destination.baseAddress._unsafelyUnwrappedUnchecked
    let n = Swift.min(destination.count, self.count)
    d.initialize(from: s, count: n)
    return (Iterator(_position: s + n, _end: s + count), n)
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
 
    return try body(UnsafeBufferPointer(self))
 
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer where Element : ~Copyable {
  public typealias Index = Swift.Int
  @_alwaysEmitIntoClient @_preInverseGenerics public var isEmpty: Swift.Bool {
    get { count == 0 }
  }
  @inlinable @_preInverseGenerics public var startIndex: Swift.Int {
    get { 0 }
  }
  @inlinable @_preInverseGenerics public var endIndex: Swift.Int {
    get { count }
  }
  @inlinable @_preInverseGenerics public func index(after i: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
     
     
     
     
    let result = i.addingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable @_preInverseGenerics public func formIndex(after i: inout Swift.Int) {
     
     
     
     
     
     
    let result = i.addingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    i = result.partialValue
  }
  @inlinable @_preInverseGenerics public func index(before i: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
    let result = i.subtractingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable @_preInverseGenerics public func formIndex(before i: inout Swift.Int) {
     
     
     
     
     
     
    let result = i.subtractingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    i = result.partialValue
  }
  @inlinable @_preInverseGenerics public func index(_ i: Swift.Int, offsetBy n: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
    let result = i.addingReportingOverflow(n)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable @_preInverseGenerics public func index(_ i: Swift.Int, offsetBy n: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
     
     
     
     
     
     
    let maxOffset = limit.subtractingReportingOverflow(i)
    _debugPrecondition(!maxOffset.overflow)
    let l = maxOffset.partialValue

    if n > 0 ? l >= 0 && l < n : l <= 0 && n < l {
      return nil
    }

    let result = i.addingReportingOverflow(n)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable @_preInverseGenerics public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
     
     
     
     
    let result = end.subtractingReportingOverflow(start)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @_alwaysEmitIntoClient public subscript(i: Swift.Int) -> Element {
    @_transparent unsafeAddress {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return UnsafePointer(_position._unsafelyUnwrappedUnchecked) + i
    }
    @_transparent nonmutating unsafeMutableAddress {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked + i
    }
  }
  @_alwaysEmitIntoClient internal subscript(_unchecked i: Swift.Int) -> Element {
    @_transparent unsafeAddress {
      _internalInvariant(i >= 0)
      _internalInvariant(i < endIndex)
      return UnsafePointer(_position._unsafelyUnwrappedUnchecked) + i
    }
    nonmutating unsafeMutableAddress {
      _internalInvariant(i >= 0)
      _internalInvariant(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked + i
    }
  }
  @inlinable @_preInverseGenerics public func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
    guard i != j else { return }
    _debugPrecondition(i >= 0 && j >= 0)
    _debugPrecondition(i < endIndex && j < endIndex)
    let pi = (_position! + i)
    let pj = (_position! + j)
    let tmp = pi.move()
    pi.moveInitialize(from: pj, count: 1)
    pj.initialize(to: tmp)
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  public typealias Index = Swift.Int
  @_alwaysEmitIntoClient public var isEmpty: Swift.Bool {
    get { count == 0 }
  }
  @inlinable public var startIndex: Swift.Int {
    get { 0 }
  }
  @inlinable public var endIndex: Swift.Int {
    get { count }
  }
  @inlinable public func index(after i: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
     
     
     
     
    let result = i.addingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable public func formIndex(after i: inout Swift.Int) {
     
     
     
     
     
     
    let result = i.addingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    i = result.partialValue
  }
  @inlinable public func index(before i: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
    let result = i.subtractingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable public func formIndex(before i: inout Swift.Int) {
     
     
     
     
     
     
    let result = i.subtractingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    i = result.partialValue
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy n: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
    let result = i.addingReportingOverflow(n)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy n: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
     
     
     
     
     
     
    let maxOffset = limit.subtractingReportingOverflow(i)
    _debugPrecondition(!maxOffset.overflow)
    let l = maxOffset.partialValue

    if n > 0 ? l >= 0 && l < n : l <= 0 && n < l {
      return nil
    }

    let result = i.addingReportingOverflow(n)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
     
     
     
     
    let result = end.subtractingReportingOverflow(start)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @_alwaysEmitIntoClient public subscript(i: Swift.Int) -> Element {
    @_transparent unsafeAddress {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return UnsafePointer(_position._unsafelyUnwrappedUnchecked) + i
    }
    @_transparent nonmutating unsafeMutableAddress {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked + i
    }
  }
  @_alwaysEmitIntoClient internal subscript(_unchecked i: Swift.Int) -> Element {
    @_transparent unsafeAddress {
      _internalInvariant(i >= 0)
      _internalInvariant(i < endIndex)
      return UnsafePointer(_position._unsafelyUnwrappedUnchecked) + i
    }
    nonmutating unsafeMutableAddress {
      _internalInvariant(i >= 0)
      _internalInvariant(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked + i
    }
  }
  @inlinable public func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
    guard i != j else { return }
    _debugPrecondition(i >= 0 && j >= 0)
    _debugPrecondition(i < endIndex && j < endIndex)
    let pi = (_position! + i)
    let pj = (_position! + j)
    let tmp = pi.move()
    pi.moveInitialize(from: pj, count: 1)
    pj.initialize(to: tmp)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer where Element : ~Copyable {
  @_alwaysEmitIntoClient public func extracting(_ bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeMutableBufferPointer<Element> {
    _precondition(bounds.lowerBound >= 0 && bounds.upperBound <= count,
      "Index out of range")
    guard let start = self.baseAddress else {
      return Self(start: nil, count: 0)
    }
    return Self(start: start + bounds.lowerBound, count: bounds.count)
  }
  @_alwaysEmitIntoClient public func extracting(_ bounds: some RangeExpression<Int>) -> Swift.UnsafeMutableBufferPointer<Element> {
    extracting(bounds.relative(to: Range(uncheckedBounds: (0, count))))
  }
  @_alwaysEmitIntoClient public func extracting(_ bounds: (Swift.UnboundedRange_) -> ()) -> Swift.UnsafeMutableBufferPointer<Element> {
    self
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @_alwaysEmitIntoClient public func extracting(_ bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeMutableBufferPointer<Element> {
    _precondition(bounds.lowerBound >= 0 && bounds.upperBound <= count,
      "Index out of range")
    guard let start = self.baseAddress else {
      return Self(start: nil, count: 0)
    }
    return Self(start: start + bounds.lowerBound, count: bounds.count)
  }
  @_alwaysEmitIntoClient public func extracting(_ bounds: some RangeExpression<Int>) -> Swift.UnsafeMutableBufferPointer<Element> {
    extracting(bounds.relative(to: Range(uncheckedBounds: (0, count))))
  }
  @_alwaysEmitIntoClient public func extracting(_ bounds: (Swift.UnboundedRange_) -> ()) -> Swift.UnsafeMutableBufferPointer<Element> {
    self
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer {
  @inlinable public subscript(i: Swift.Int) -> Element {
    @_transparent get {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked[i]
    }
    @_transparent nonmutating _modify {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      yield &_position._unsafelyUnwrappedUnchecked[i]
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer : Swift.Collection, Swift.MutableCollection, Swift.BidirectionalCollection, Swift.RandomAccessCollection {
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
     
    _debugPrecondition(index >= bounds.lowerBound)
    _debugPrecondition(index < bounds.upperBound)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
     
    _debugPrecondition(range.lowerBound >= bounds.lowerBound)
    _debugPrecondition(range.upperBound <= bounds.upperBound)
  }
  @inlinable public var indices: Swift.UnsafeMutableBufferPointer<Element>.Indices {
    get {
     
    return Indices(uncheckedBounds: (startIndex, endIndex))
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>> {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(
        base: self, bounds: bounds)
    }
    nonmutating set {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      _debugPrecondition(bounds.count == newValue.count)

       
      if !newValue.isEmpty {
        (_position! + bounds.lowerBound).update(
          from: newValue.base._position! + newValue.startIndex,
          count: newValue.count)
      }
    }
  }
  @available(*, deprecated, renamed: "withContiguousMutableStorageIfAvailable")
  @inlinable public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try body(&self)
  }
  @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    let (oldBase, oldCount) = (self.baseAddress, self.count)
    defer {
      _debugPrecondition((oldBase, oldCount) == (self.baseAddress, self.count),
      "UnsafeMutableBufferPointer.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed")
    }
    return try body(&self)
  }
}
#else
extension Swift.UnsafeMutableBufferPointer : Swift.Collection, Swift.MutableCollection, Swift.BidirectionalCollection, Swift.RandomAccessCollection {
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
     
    _debugPrecondition(index >= bounds.lowerBound)
    _debugPrecondition(index < bounds.upperBound)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
     
    _debugPrecondition(range.lowerBound >= bounds.lowerBound)
    _debugPrecondition(range.upperBound <= bounds.upperBound)
  }
  @inlinable public var indices: Swift.UnsafeMutableBufferPointer<Element>.Indices {
    get {
     
    return Indices(uncheckedBounds: (startIndex, endIndex))
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>> {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(
        base: self, bounds: bounds)
    }
    nonmutating set {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      _debugPrecondition(bounds.count == newValue.count)

       
      if !newValue.isEmpty {
        (_position! + bounds.lowerBound).update(
          from: newValue.base._position! + newValue.startIndex,
          count: newValue.count)
      }
    }
  }
  @available(*, deprecated, renamed: "withContiguousMutableStorageIfAvailable")
  @inlinable public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try body(&self)
  }
  @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    let (oldBase, oldCount) = (self.baseAddress, self.count)
    defer {
      _debugPrecondition((oldBase, oldCount) == (self.baseAddress, self.count),
      "UnsafeMutableBufferPointer.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed")
    }
    return try body(&self)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer {
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer where Element : ~Copyable {
  @inlinable @_preInverseGenerics public func deallocate() {
    _position?.deallocate()
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @inlinable public func deallocate() {
    _position?.deallocate()
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer where Element : ~Copyable {
  @inlinable @_preInverseGenerics public static func allocate(capacity count: Swift.Int) -> Swift.UnsafeMutableBufferPointer<Element> {
    let base  = UnsafeMutablePointer<Element>.allocate(capacity: count)
    return UnsafeMutableBufferPointer(start: base, count: count)
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @inlinable public static func allocate(capacity count: Swift.Int) -> Swift.UnsafeMutableBufferPointer<Element> {
    let base  = UnsafeMutablePointer<Element>.allocate(capacity: count)
    return UnsafeMutableBufferPointer(start: base, count: count)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer {
  @inlinable public func initialize(repeating repeatedValue: Element) {
    guard let dstBase = _position else {
      return
    }

    dstBase.initialize(repeating: repeatedValue, count: count)
  }
  @_silgen_name("$sSr10initialize4from8IteratorQyd___Sitqd___t7ElementQyd__RszSTRd__lF")
  @inlinable public func initialize<S>(from source: S) -> (unwritten: S.Iterator, index: Swift.UnsafeMutableBufferPointer<Element>.Index) where Element == S.Element, S : Swift.Sequence {
    return source._copyContents(initializing: self)
  }
  @_alwaysEmitIntoClient public func initialize(fromContentsOf source: some Collection<Element>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
    let count = source.withContiguousStorageIfAvailable {
      guard let sourceAddress = $0.baseAddress, !$0.isEmpty else {
        return 0
      }
      _precondition(
        $0.count <= self.count,
        "buffer cannot contain every element from source."
      )
      baseAddress?.initialize(from: sourceAddress, count: $0.count)
      return $0.count
    }
    if let count {
      return startIndex.advanced(by: count)
    }

    var (iterator, copied) = source._copyContents(initializing: self)
    _precondition(
      iterator.next() == nil,
      "buffer cannot contain every element from source."
    )
    return startIndex.advanced(by: copied)
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @inlinable public func initialize(repeating repeatedValue: Element) {
    guard let dstBase = _position else {
      return
    }

    dstBase.initialize(repeating: repeatedValue, count: count)
  }
  @_silgen_name("$sSr10initialize4from8IteratorQyd___Sitqd___t7ElementQyd__RszSTRd__lF")
  @inlinable public func initialize<S>(from source: S) -> (unwritten: S.Iterator, index: Swift.UnsafeMutableBufferPointer<Element>.Index) where Element == S.Element, S : Swift.Sequence {
    return source._copyContents(initializing: self)
  }
  @_alwaysEmitIntoClient public func initialize(fromContentsOf source: some Collection<Element>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
    let count = source.withContiguousStorageIfAvailable {
      guard let sourceAddress = $0.baseAddress, !$0.isEmpty else {
        return 0
      }
      _precondition(
        $0.count <= self.count,
        "buffer cannot contain every element from source."
      )
      baseAddress?.initialize(from: sourceAddress, count: $0.count)
      return $0.count
    }
    if let count {
      return startIndex.advanced(by: count)
    }

    var (iterator, copied) = source._copyContents(initializing: self)
    _precondition(
      iterator.next() == nil,
      "buffer cannot contain every element from source."
    )
    return startIndex.advanced(by: copied)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer {
  @_silgen_name("$sSr6assign9repeatingyx_tF")
  @inlinable public func update(repeating repeatedValue: Element) {
    guard let dstBase = _position else {
      return
    }

    dstBase.update(repeating: repeatedValue, count: count)
  }
  @available(*, deprecated, renamed: "update(repeating:)")
  @_silgen_name("_swift_se0370_UnsafeMutableBufferPointer_assign_repeating")
  @_alwaysEmitIntoClient public func assign(repeating repeatedValue: Element) {
    update(repeating: repeatedValue)
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @_silgen_name("$sSr6assign9repeatingyx_tF")
  @inlinable public func update(repeating repeatedValue: Element) {
    guard let dstBase = _position else {
      return
    }

    dstBase.update(repeating: repeatedValue, count: count)
  }
  @available(*, deprecated, renamed: "update(repeating:)")
  @_silgen_name("_swift_se0370_UnsafeMutableBufferPointer_assign_repeating")
  @_alwaysEmitIntoClient public func assign(repeating repeatedValue: Element) {
    update(repeating: repeatedValue)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer {
  @_alwaysEmitIntoClient public func update<S>(from source: S) -> (unwritten: S.Iterator, index: Swift.UnsafeMutableBufferPointer<Element>.Index) where Element == S.Element, S : Swift.Sequence {
    var iterator = source.makeIterator()
    guard !self.isEmpty else { return (iterator, startIndex) }
    _internalInvariant(_position != nil)
    var index = startIndex
    while index < endIndex {
      guard let element = iterator.next() else { break }
      _position._unsafelyUnwrappedUnchecked[index] = element
      formIndex(after: &index)
    }
    return (iterator, index)
  }
  @_alwaysEmitIntoClient public func update(fromContentsOf source: some Collection<Element>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
    let count = source.withContiguousStorageIfAvailable {
      guard let sourceAddress = $0.baseAddress else {
        return 0
      }
      _precondition(
        $0.count <= self.count,
        "buffer cannot contain every element from source."
      )
      baseAddress?.update(from: sourceAddress, count: $0.count)
      return $0.count
    }
    if let count {
      return startIndex.advanced(by: count)
    }

    if self.isEmpty {
      _precondition(
        source.isEmpty,
        "buffer cannot contain every element from source."
      )
      return startIndex
    }
    _internalInvariant(_position != nil)
    var iterator = source.makeIterator()
    var index = startIndex
    while let value = iterator.next() {
      guard index < endIndex else {
        _preconditionFailure(
          "buffer cannot contain every element from source."
        )
        break
      }
      _position._unsafelyUnwrappedUnchecked[index] = value
      formIndex(after: &index)
    }
    return index
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @_alwaysEmitIntoClient public func update<S>(from source: S) -> (unwritten: S.Iterator, index: Swift.UnsafeMutableBufferPointer<Element>.Index) where Element == S.Element, S : Swift.Sequence {
    var iterator = source.makeIterator()
    guard !self.isEmpty else { return (iterator, startIndex) }
    _internalInvariant(_position != nil)
    var index = startIndex
    while index < endIndex {
      guard let element = iterator.next() else { break }
      _position._unsafelyUnwrappedUnchecked[index] = element
      formIndex(after: &index)
    }
    return (iterator, index)
  }
  @_alwaysEmitIntoClient public func update(fromContentsOf source: some Collection<Element>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
    let count = source.withContiguousStorageIfAvailable {
      guard let sourceAddress = $0.baseAddress else {
        return 0
      }
      _precondition(
        $0.count <= self.count,
        "buffer cannot contain every element from source."
      )
      baseAddress?.update(from: sourceAddress, count: $0.count)
      return $0.count
    }
    if let count {
      return startIndex.advanced(by: count)
    }

    if self.isEmpty {
      _precondition(
        source.isEmpty,
        "buffer cannot contain every element from source."
      )
      return startIndex
    }
    _internalInvariant(_position != nil)
    var iterator = source.makeIterator()
    var index = startIndex
    while let value = iterator.next() {
      guard index < endIndex else {
        _preconditionFailure(
          "buffer cannot contain every element from source."
        )
        break
      }
      _position._unsafelyUnwrappedUnchecked[index] = value
      formIndex(after: &index)
    }
    return index
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer where Element : ~Copyable {
  @_alwaysEmitIntoClient public func moveInitialize(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
    guard let sourceAddress = source.baseAddress, !source.isEmpty else {
      return startIndex
    }
    _precondition(
      source.count <= self.count,
      "buffer cannot contain every element from source."
    )
    baseAddress?.moveInitialize(from: sourceAddress, count: source.count)
    return startIndex.advanced(by: source.count)
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @_alwaysEmitIntoClient public func moveInitialize(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
    guard let sourceAddress = source.baseAddress, !source.isEmpty else {
      return startIndex
    }
    _precondition(
      source.count <= self.count,
      "buffer cannot contain every element from source."
    )
    baseAddress?.moveInitialize(from: sourceAddress, count: source.count)
    return startIndex.advanced(by: source.count)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer {
  @_alwaysEmitIntoClient public func moveInitialize(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
    return moveInitialize(fromContentsOf: Self(rebasing: source))
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @_alwaysEmitIntoClient public func moveInitialize(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
    return moveInitialize(fromContentsOf: Self(rebasing: source))
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer where Element : ~Copyable {
  @_alwaysEmitIntoClient public func moveUpdate(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
    guard let sourceAddress = source.baseAddress, !source.isEmpty else {
      return startIndex
    }
    _precondition(
      source.count <= self.count,
      "buffer cannot contain every element from source."
    )
    baseAddress?.moveUpdate(from: sourceAddress, count: source.count)
    return startIndex.advanced(by: source.count)
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @_alwaysEmitIntoClient public func moveUpdate(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
    guard let sourceAddress = source.baseAddress, !source.isEmpty else {
      return startIndex
    }
    _precondition(
      source.count <= self.count,
      "buffer cannot contain every element from source."
    )
    baseAddress?.moveUpdate(from: sourceAddress, count: source.count)
    return startIndex.advanced(by: source.count)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer {
  @_alwaysEmitIntoClient public func moveUpdate(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
    return moveUpdate(fromContentsOf: Self(rebasing: source))
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @_alwaysEmitIntoClient public func moveUpdate(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
    return moveUpdate(fromContentsOf: Self(rebasing: source))
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer where Element : ~Copyable {
  @discardableResult
  @_alwaysEmitIntoClient public func deinitialize() -> Swift.UnsafeMutableRawBufferPointer {
    guard let rawValue = baseAddress?._rawValue
      else { return .init(start: nil, count: 0) }
    Builtin.destroyArray(Element.self, rawValue, count._builtinWordValue)
    return .init(start: UnsafeMutableRawPointer(rawValue),
                 count: count*MemoryLayout<Element>.stride)
   }
  @_alwaysEmitIntoClient public func initializeElement(at index: Swift.UnsafeMutableBufferPointer<Element>.Index, to value: consuming Element) {
    _debugPrecondition(startIndex <= index && index < endIndex)
    let p = baseAddress._unsafelyUnwrappedUnchecked.advanced(by: index)
    p.initialize(to: value)
  }
  @_alwaysEmitIntoClient public func moveElement(from index: Swift.UnsafeMutableBufferPointer<Element>.Index) -> Element {
    _debugPrecondition(startIndex <= index && index < endIndex)
    return baseAddress._unsafelyUnwrappedUnchecked.advanced(by: index).move()
  }
  @_alwaysEmitIntoClient public func deinitializeElement(at index: Swift.UnsafeMutableBufferPointer<Element>.Index) {
    _debugPrecondition(startIndex <= index && index < endIndex)
    let p = baseAddress._unsafelyUnwrappedUnchecked.advanced(by: index)
    p.deinitialize(count: 1)
  }
}
#else
extension Swift.UnsafeMutableBufferPointer {
  @discardableResult
  @_alwaysEmitIntoClient public func deinitialize() -> Swift.UnsafeMutableRawBufferPointer {
    guard let rawValue = baseAddress?._rawValue
      else { return .init(start: nil, count: 0) }
    Builtin.destroyArray(Element.self, rawValue, count._builtinWordValue)
    return .init(start: UnsafeMutableRawPointer(rawValue),
                 count: count*MemoryLayout<Element>.stride)
   }
  @_alwaysEmitIntoClient public func initializeElement(at index: Swift.UnsafeMutableBufferPointer<Element>.Index, to value: consuming Element) {
    _debugPrecondition(startIndex <= index && index < endIndex)
    let p = baseAddress._unsafelyUnwrappedUnchecked.advanced(by: index)
    p.initialize(to: value)
  }
  @_alwaysEmitIntoClient public func moveElement(from index: Swift.UnsafeMutableBufferPointer<Element>.Index) -> Element {
    _debugPrecondition(startIndex <= index && index < endIndex)
    return baseAddress._unsafelyUnwrappedUnchecked.advanced(by: index).move()
  }
  @_alwaysEmitIntoClient public func deinitializeElement(at index: Swift.UnsafeMutableBufferPointer<Element>.Index) {
    _debugPrecondition(startIndex <= index && index < endIndex)
    let p = baseAddress._unsafelyUnwrappedUnchecked.advanced(by: index)
    p.deinitialize(count: 1)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer where Element : ~Copyable {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, _ body: (_ buffer: Swift.UnsafeMutableBufferPointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
    guard let base = _position?._rawValue else {
      return try body(.init(start: nil, count: 0))
    }

    _debugPrecondition(
      Int(bitPattern: .init(base)) & (MemoryLayout<T>.alignment-1) == 0,
      "baseAddress must be a properly aligned pointer for types Element and T"
    )

    let newCount: Int
    if MemoryLayout<T>.stride == MemoryLayout<Element>.stride {
      newCount = count
    } else {
      newCount = count * MemoryLayout<Element>.stride / MemoryLayout<T>.stride
      _debugPrecondition(
        MemoryLayout<T>.stride > MemoryLayout<Element>.stride
        ? MemoryLayout<T>.stride % MemoryLayout<Element>.stride == 0
        : MemoryLayout<Element>.stride % MemoryLayout<T>.stride == 0,
        "Buffer must contain a whole number of Element instances"
      )
    }
    let binding = Builtin.bindMemory(base, newCount._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(base, binding) }
    return try body(.init(start: .init(base), count: newCount))
  }
  #endif
}
#else
extension Swift.UnsafeMutableBufferPointer {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, _ body: (_ buffer: Swift.UnsafeMutableBufferPointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
    guard let base = _position?._rawValue else {
      return try body(.init(start: nil, count: 0))
    }

    _debugPrecondition(
      Int(bitPattern: .init(base)) & (MemoryLayout<T>.alignment-1) == 0,
      "baseAddress must be a properly aligned pointer for types Element and T"
    )

    let newCount: Int
    if MemoryLayout<T>.stride == MemoryLayout<Element>.stride {
      newCount = count
    } else {
      newCount = count * MemoryLayout<Element>.stride / MemoryLayout<T>.stride
      _debugPrecondition(
        MemoryLayout<T>.stride > MemoryLayout<Element>.stride
        ? MemoryLayout<T>.stride % MemoryLayout<Element>.stride == 0
        : MemoryLayout<Element>.stride % MemoryLayout<T>.stride == 0,
        "Buffer must contain a whole number of Element instances"
      )
    }
    let binding = Builtin.bindMemory(base, newCount._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(base, binding) }
    return try body(.init(start: .init(base), count: newCount))
  }
  #endif
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafeMutableBufferPointer : Swift.CustomDebugStringConvertible where Element : ~Copyable {
  @_preInverseGenerics public var debugDescription: Swift.String {
    get
  }
}
#else
extension Swift.UnsafeMutableBufferPointer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@frozen public struct UnsafeBufferPointer<Element> : Swift.Copyable where Element : ~Copyable {
  @usableFromInline
  @_preInverseGenerics internal let _position: Swift.UnsafePointer<Element>?
  @_preInverseGenerics public let count: Swift.Int
  @_alwaysEmitIntoClient internal init(@_nonEphemeral _uncheckedStart start: Swift.UnsafePointer<Element>?, count: Swift.Int) {
    _position = start
    self.count = count
  }
  @inlinable @_preInverseGenerics public init(@_nonEphemeral start: Swift.UnsafePointer<Element>?, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeBufferPointer with negative count")
    _debugPrecondition(
      count == 0 || start != nil,
      "UnsafeBufferPointer has a nil start and nonzero count")
    self.init(_uncheckedStart: start, count: _assumeNonNegative(count))
  }
  @inlinable @_preInverseGenerics public init(_empty: ()) {
    _position = nil
    count = 0
  }
  @inlinable @_preInverseGenerics public init(_ other: Swift.UnsafeMutableBufferPointer<Element>) {
    _position = UnsafePointer<Element>(other._position)
    count = other.count
  }
}
#else
@frozen public struct UnsafeBufferPointer<Element> {
  @usableFromInline
  internal let _position: Swift.UnsafePointer<Element>?
  public let count: Swift.Int
  @_alwaysEmitIntoClient internal init(@_nonEphemeral _uncheckedStart start: Swift.UnsafePointer<Element>?, count: Swift.Int) {
    _position = start
    self.count = count
  }
  @inlinable public init(@_nonEphemeral start: Swift.UnsafePointer<Element>?, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeBufferPointer with negative count")
    _debugPrecondition(
      count == 0 || start != nil,
      "UnsafeBufferPointer has a nil start and nonzero count")
    self.init(_uncheckedStart: start, count: _assumeNonNegative(count))
  }
  @inlinable public init(_empty: ()) {
    _position = nil
    count = 0
  }
  @inlinable public init(_ other: Swift.UnsafeMutableBufferPointer<Element>) {
    _position = UnsafePointer<Element>(other._position)
    count = other.count
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(*, unavailable)
extension Swift.UnsafeBufferPointer : Swift.Sendable where Element : ~Copyable {
}
#else
@available(*, unavailable)
extension Swift.UnsafeBufferPointer : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeBufferPointer where Element : ~Copyable {
  @inlinable @_preInverseGenerics public var baseAddress: Swift.UnsafePointer<Element>? {
    get {
    _position
  }
  }
}
#else
extension Swift.UnsafeBufferPointer {
  @inlinable public var baseAddress: Swift.UnsafePointer<Element>? {
    get {
    _position
  }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeBufferPointer {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _position: Swift.UnsafePointer<Swift.UnsafeBufferPointer<Element>.Iterator.Element>?, _end: Swift.UnsafePointer<Swift.UnsafeBufferPointer<Element>.Iterator.Element>?
    @inlinable public init(_position: Swift.UnsafePointer<Swift.UnsafeBufferPointer<Element>.Iterator.Element>?, _end: Swift.UnsafePointer<Swift.UnsafeBufferPointer<Element>.Iterator.Element>?) {
        self._position = _position
        self._end = _end
    }
  }
}
#else
extension Swift.UnsafeBufferPointer {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _position: Swift.UnsafePointer<Swift.UnsafeBufferPointer<Element>.Iterator.Element>?, _end: Swift.UnsafePointer<Swift.UnsafeBufferPointer<Element>.Iterator.Element>?
    @inlinable public init(_position: Swift.UnsafePointer<Swift.UnsafeBufferPointer<Element>.Iterator.Element>?, _end: Swift.UnsafePointer<Swift.UnsafeBufferPointer<Element>.Iterator.Element>?) {
        self._position = _position
        self._end = _end
    }
  }
}
#endif
@available(*, unavailable)
extension Swift.UnsafeBufferPointer.Iterator : Swift.Sendable {
}
extension Swift.UnsafeBufferPointer.Iterator : Swift.IteratorProtocol {
  @inlinable public mutating func next() -> Element? {
    guard let start = _position else {
      return nil
    }
    _internalInvariant(_end != nil, "inconsistent _position, _end pointers")

    if start == _end._unsafelyUnwrappedUnchecked { return nil }

    let result = start.pointee
    _position  = start + 1
    return result
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeBufferPointer : Swift.Sequence {
  @inlinable public func makeIterator() -> Swift.UnsafeBufferPointer<Element>.Iterator {
    guard let start = _position else {
      return Iterator(_position: nil, _end: nil)
    }
    return Iterator(_position: start, _end: start + count)
  }
  @inlinable public func _copyContents(initializing destination: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.UnsafeBufferPointer<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    guard !isEmpty && !destination.isEmpty else { return (makeIterator(), 0) }
    let s = self.baseAddress._unsafelyUnwrappedUnchecked
    let d = destination.baseAddress._unsafelyUnwrappedUnchecked
    let n = Swift.min(destination.count, self.count)
    d.initialize(from: s, count: n)
    return (Iterator(_position: s + n, _end: s + count), n)
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
 
    return try body(self)
 
  }
}
#else
extension Swift.UnsafeBufferPointer : Swift.Sequence {
  @inlinable public func makeIterator() -> Swift.UnsafeBufferPointer<Element>.Iterator {
    guard let start = _position else {
      return Iterator(_position: nil, _end: nil)
    }
    return Iterator(_position: start, _end: start + count)
  }
  @inlinable public func _copyContents(initializing destination: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.UnsafeBufferPointer<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    guard !isEmpty && !destination.isEmpty else { return (makeIterator(), 0) }
    let s = self.baseAddress._unsafelyUnwrappedUnchecked
    let d = destination.baseAddress._unsafelyUnwrappedUnchecked
    let n = Swift.min(destination.count, self.count)
    d.initialize(from: s, count: n)
    return (Iterator(_position: s + n, _end: s + count), n)
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
 
    return try body(self)
 
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeBufferPointer where Element : ~Copyable {
  public typealias Index = Swift.Int
  @_alwaysEmitIntoClient @_preInverseGenerics public var isEmpty: Swift.Bool {
    get { count == 0 }
  }
  @inlinable @_preInverseGenerics public var startIndex: Swift.Int {
    get { 0 }
  }
  @inlinable @_preInverseGenerics public var endIndex: Swift.Int {
    get { count }
  }
  @inlinable @_preInverseGenerics public func index(after i: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
     
     
     
     
    let result = i.addingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable @_preInverseGenerics public func formIndex(after i: inout Swift.Int) {
     
     
     
     
     
     
    let result = i.addingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    i = result.partialValue
  }
  @inlinable @_preInverseGenerics public func index(before i: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
    let result = i.subtractingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable @_preInverseGenerics public func formIndex(before i: inout Swift.Int) {
     
     
     
     
     
     
    let result = i.subtractingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    i = result.partialValue
  }
  @inlinable @_preInverseGenerics public func index(_ i: Swift.Int, offsetBy n: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
    let result = i.addingReportingOverflow(n)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable @_preInverseGenerics public func index(_ i: Swift.Int, offsetBy n: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
     
     
     
     
     
     
    let maxOffset = limit.subtractingReportingOverflow(i)
    _debugPrecondition(!maxOffset.overflow)
    let l = maxOffset.partialValue

    if n > 0 ? l >= 0 && l < n : l <= 0 && n < l {
      return nil
    }

    let result = i.addingReportingOverflow(n)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable @_preInverseGenerics public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
     
     
     
     
    let result = end.subtractingReportingOverflow(start)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @_alwaysEmitIntoClient public subscript(i: Swift.Int) -> Element {
    @_transparent unsafeAddress {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return UnsafePointer(_position._unsafelyUnwrappedUnchecked) + i
    }
  }
  @_alwaysEmitIntoClient internal subscript(_unchecked i: Swift.Int) -> Element {
    @_transparent unsafeAddress {
      _internalInvariant(i >= 0)
      _internalInvariant(i < endIndex)
      return UnsafePointer(_position._unsafelyUnwrappedUnchecked) + i
    }
  }
}
#else
extension Swift.UnsafeBufferPointer {
  public typealias Index = Swift.Int
  @_alwaysEmitIntoClient public var isEmpty: Swift.Bool {
    get { count == 0 }
  }
  @inlinable public var startIndex: Swift.Int {
    get { 0 }
  }
  @inlinable public var endIndex: Swift.Int {
    get { count }
  }
  @inlinable public func index(after i: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
     
     
     
     
    let result = i.addingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable public func formIndex(after i: inout Swift.Int) {
     
     
     
     
     
     
    let result = i.addingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    i = result.partialValue
  }
  @inlinable public func index(before i: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
    let result = i.subtractingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable public func formIndex(before i: inout Swift.Int) {
     
     
     
     
     
     
    let result = i.subtractingReportingOverflow(1)
    _debugPrecondition(!result.overflow)
    i = result.partialValue
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy n: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
    let result = i.addingReportingOverflow(n)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy n: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
     
     
     
     
     
     
    let maxOffset = limit.subtractingReportingOverflow(i)
    _debugPrecondition(!maxOffset.overflow)
    let l = maxOffset.partialValue

    if n > 0 ? l >= 0 && l < n : l <= 0 && n < l {
      return nil
    }

    let result = i.addingReportingOverflow(n)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
     
     
     
     
     
     
     
     
     
     
    let result = end.subtractingReportingOverflow(start)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @_alwaysEmitIntoClient public subscript(i: Swift.Int) -> Element {
    @_transparent unsafeAddress {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return UnsafePointer(_position._unsafelyUnwrappedUnchecked) + i
    }
  }
  @_alwaysEmitIntoClient internal subscript(_unchecked i: Swift.Int) -> Element {
    @_transparent unsafeAddress {
      _internalInvariant(i >= 0)
      _internalInvariant(i < endIndex)
      return UnsafePointer(_position._unsafelyUnwrappedUnchecked) + i
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeBufferPointer where Element : ~Copyable {
  @_alwaysEmitIntoClient public func extracting(_ bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeBufferPointer<Element> {
    _precondition(bounds.lowerBound >= 0 && bounds.upperBound <= count,
      "Index out of range")
    guard let start = self.baseAddress else {
      return Self(start: nil, count: 0)
    }
    return Self(start: start + bounds.lowerBound, count: bounds.count)
  }
  @_alwaysEmitIntoClient public func extracting(_ bounds: some RangeExpression<Int>) -> Swift.UnsafeBufferPointer<Element> {
    extracting(bounds.relative(to: Range(uncheckedBounds: (0, count))))
  }
  @_alwaysEmitIntoClient public func extracting(_ bounds: (Swift.UnboundedRange_) -> ()) -> Swift.UnsafeBufferPointer<Element> {
    self
  }
}
#else
extension Swift.UnsafeBufferPointer {
  @_alwaysEmitIntoClient public func extracting(_ bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeBufferPointer<Element> {
    _precondition(bounds.lowerBound >= 0 && bounds.upperBound <= count,
      "Index out of range")
    guard let start = self.baseAddress else {
      return Self(start: nil, count: 0)
    }
    return Self(start: start + bounds.lowerBound, count: bounds.count)
  }
  @_alwaysEmitIntoClient public func extracting(_ bounds: some RangeExpression<Int>) -> Swift.UnsafeBufferPointer<Element> {
    extracting(bounds.relative(to: Range(uncheckedBounds: (0, count))))
  }
  @_alwaysEmitIntoClient public func extracting(_ bounds: (Swift.UnboundedRange_) -> ()) -> Swift.UnsafeBufferPointer<Element> {
    self
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeBufferPointer {
  @inlinable public subscript(i: Swift.Int) -> Element {
    @_transparent get {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked[i]
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeBufferPointer : Swift.Collection, Swift.BidirectionalCollection, Swift.RandomAccessCollection {
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = Swift.Slice<Swift.UnsafeBufferPointer<Element>>
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
     
    _debugPrecondition(index >= bounds.lowerBound)
    _debugPrecondition(index < bounds.upperBound)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
     
    _debugPrecondition(range.lowerBound >= bounds.lowerBound)
    _debugPrecondition(range.upperBound <= bounds.upperBound)
  }
  @inlinable public var indices: Swift.UnsafeBufferPointer<Element>.Indices {
    get {
     
    return Indices(uncheckedBounds: (startIndex, endIndex))
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.Slice<Swift.UnsafeBufferPointer<Element>> {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(
        base: self, bounds: bounds)
    }
  }
}
#else
extension Swift.UnsafeBufferPointer : Swift.Collection, Swift.BidirectionalCollection, Swift.RandomAccessCollection {
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = Swift.Slice<Swift.UnsafeBufferPointer<Element>>
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
     
    _debugPrecondition(index >= bounds.lowerBound)
    _debugPrecondition(index < bounds.upperBound)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
     
    _debugPrecondition(range.lowerBound >= bounds.lowerBound)
    _debugPrecondition(range.upperBound <= bounds.upperBound)
  }
  @inlinable public var indices: Swift.UnsafeBufferPointer<Element>.Indices {
    get {
     
    return Indices(uncheckedBounds: (startIndex, endIndex))
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.Slice<Swift.UnsafeBufferPointer<Element>> {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(
        base: self, bounds: bounds)
    }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeBufferPointer {
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeBufferPointer<Element>>) {
     
     
     
     
     
     
     
     
    _debugPrecondition(
      slice.startIndex >= 0 && slice.endIndex <= slice.base.count,
      "Invalid slice")
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
}
#else
extension Swift.UnsafeBufferPointer {
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeBufferPointer<Element>>) {
     
     
     
     
     
     
     
     
    _debugPrecondition(
      slice.startIndex >= 0 && slice.endIndex <= slice.base.count,
      "Invalid slice")
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeBufferPointer where Element : ~Copyable {
  @inlinable @_preInverseGenerics public func deallocate() {
    _position?.deallocate()
  }
}
#else
extension Swift.UnsafeBufferPointer {
  @inlinable public func deallocate() {
    _position?.deallocate()
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeBufferPointer where Element : ~Copyable {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, _ body: (_ buffer: Swift.UnsafeBufferPointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
    guard let base = _position?._rawValue else {
      return try body(.init(start: nil, count: 0))
    }

    _debugPrecondition(
      Int(bitPattern: .init(base)) & (MemoryLayout<T>.alignment-1) == 0,
      "baseAddress must be a properly aligned pointer for types Element and T"
    )

    let newCount: Int
    if MemoryLayout<T>.stride == MemoryLayout<Element>.stride {
      newCount = count
    } else {
      newCount = count * MemoryLayout<Element>.stride / MemoryLayout<T>.stride
      _debugPrecondition(
        MemoryLayout<T>.stride > MemoryLayout<Element>.stride
        ? MemoryLayout<T>.stride % MemoryLayout<Element>.stride == 0
        : MemoryLayout<Element>.stride % MemoryLayout<T>.stride == 0,
        "Buffer must contain a whole number of Element instances"
      )
    }
    let binding = Builtin.bindMemory(base, newCount._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(base, binding) }
    return try body(.init(start: .init(base), count: newCount))
  }
  #endif
}
#else
extension Swift.UnsafeBufferPointer {
  #if compiler(>=5.3) && $TypedThrows
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, _ body: (_ buffer: Swift.UnsafeBufferPointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
    guard let base = _position?._rawValue else {
      return try body(.init(start: nil, count: 0))
    }

    _debugPrecondition(
      Int(bitPattern: .init(base)) & (MemoryLayout<T>.alignment-1) == 0,
      "baseAddress must be a properly aligned pointer for types Element and T"
    )

    let newCount: Int
    if MemoryLayout<T>.stride == MemoryLayout<Element>.stride {
      newCount = count
    } else {
      newCount = count * MemoryLayout<Element>.stride / MemoryLayout<T>.stride
      _debugPrecondition(
        MemoryLayout<T>.stride > MemoryLayout<Element>.stride
        ? MemoryLayout<T>.stride % MemoryLayout<Element>.stride == 0
        : MemoryLayout<Element>.stride % MemoryLayout<T>.stride == 0,
        "Buffer must contain a whole number of Element instances"
      )
    }
    let binding = Builtin.bindMemory(base, newCount._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(base, binding) }
    return try body(.init(start: .init(base), count: newCount))
  }
  #endif
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@_preInverseGenerics extension Swift.UnsafeBufferPointer : Swift.CustomDebugStringConvertible where Element : ~Copyable {
  @_preInverseGenerics public var debugDescription: Swift.String {
    get
  }
}
#else
extension Swift.UnsafeBufferPointer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
#endif
@frozen public struct UnsafeMutableRawBufferPointer {
  @usableFromInline
  internal let _position: Swift.UnsafeMutableRawPointer?, _end: Swift.UnsafeMutableRawPointer?
  @inlinable public init(@_nonEphemeral start: Swift.UnsafeMutableRawPointer?, count: Swift.Int) {
    _debugPrecondition(count >= 0, "UnsafeMutableRawBufferPointer with negative count")
    _debugPrecondition(count == 0 || start != nil,
      "UnsafeMutableRawBufferPointer has a nil start and nonzero count")
    _position = start
    _end = start.map { $0 + _assumeNonNegative(count) }
  }
}
@available(*, unavailable)
extension Swift.UnsafeMutableRawBufferPointer : Swift.Sendable {
}
extension Swift.UnsafeMutableRawBufferPointer {
  public typealias Iterator = Swift.UnsafeRawBufferPointer.Iterator
}
extension Swift.UnsafeMutableRawBufferPointer : Swift.Sequence {
  public typealias SubSequence = Swift.Slice<Swift.UnsafeMutableRawBufferPointer>
  @inlinable public func makeIterator() -> Swift.UnsafeMutableRawBufferPointer.Iterator {
    return Iterator(_position: _position, _end: _end)
  }
  @_alwaysEmitIntoClient public func _copyContents(initializing destination: Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> (Swift.UnsafeMutableRawBufferPointer.Iterator, Swift.UnsafeMutableBufferPointer<Swift.UInt8>.Index) {
    guard let s = _position, let e = _end, e > s, !destination.isEmpty else {
      return (makeIterator(), 0)
    }
    let destinationAddress = destination.baseAddress._unsafelyUnwrappedUnchecked
    let d = UnsafeMutableRawPointer(destinationAddress)
    let n = Swift.min(destination.count, s.distance(to: e))
    d.copyMemory(from: s, byteCount: n)
    return (Iterator(_position: s.advanced(by: n), _end: e), n)
  }
}
extension Swift.UnsafeMutableRawBufferPointer : Swift.MutableCollection {
  public typealias Element = Swift.UInt8
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable public var startIndex: Swift.UnsafeMutableRawBufferPointer.Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.UnsafeMutableRawBufferPointer.Index {
    get {
    return count
  }
  }
  @inlinable public var indices: Swift.UnsafeMutableRawBufferPointer.Indices {
    get {
     
    return Indices(uncheckedBounds: (startIndex, endIndex))
  }
  }
  @inlinable public subscript(i: Swift.Int) -> Swift.UnsafeMutableRawBufferPointer.Element {
    get {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked.load(fromByteOffset: i, as: UInt8.self)
    }
    nonmutating set {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      _position._unsafelyUnwrappedUnchecked.storeBytes(of: newValue, toByteOffset: i, as: UInt8.self)
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeMutableRawBufferPointer.SubSequence {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(base: self, bounds: bounds)
    }
    nonmutating set {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      _debugPrecondition(bounds.count == newValue.count)

      if !newValue.isEmpty {
        (baseAddress! + bounds.lowerBound).copyMemory(
          from: newValue.base.baseAddress! + newValue.startIndex,
          byteCount: newValue.count)
      }
    }
  }
  @inlinable public func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
    guard i != j else { return }
    _debugPrecondition(i >= 0 && j >= 0)
    _debugPrecondition(i < endIndex && j < endIndex)
    let pi = (_position! + i)
    let pj = (_position! + j)
    let tmp = pi.load(fromByteOffset: 0, as: UInt8.self)
    pi.copyMemory(from: pj, byteCount: MemoryLayout<UInt8>.size)
    pj.storeBytes(of: tmp, toByteOffset: 0, as: UInt8.self)
  }
  @inlinable public var count: Swift.Int {
    get {
    if let pos = _position {
       
       
      _internalInvariant(_end != nil)
      return _assumeNonNegative(_end._unsafelyUnwrappedUnchecked - pos)
    }
    return 0
  }
  }
}
extension Swift.UnsafeMutableRawBufferPointer : Swift.RandomAccessCollection {
}
extension Swift.UnsafeMutableRawBufferPointer {
  @inlinable public static func allocate(byteCount: Swift.Int, alignment: Swift.Int) -> Swift.UnsafeMutableRawBufferPointer {
    let base = UnsafeMutableRawPointer.allocate(
      byteCount: byteCount, alignment: alignment)
    return UnsafeMutableRawBufferPointer(start: base, count: byteCount)
  }
  @inlinable public func deallocate() {
    _position?.deallocate()
  }
  @inlinable public func load<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    _debugPrecondition(offset >= 0, "UnsafeMutableRawBufferPointer.load with negative offset")
    _debugPrecondition(offset + MemoryLayout<T>.size <= self.count,
      "UnsafeMutableRawBufferPointer.load out of bounds")
    return baseAddress!.load(fromByteOffset: offset, as: T.self)
  }
  @_alwaysEmitIntoClient public func loadUnaligned<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T where T : Swift.BitwiseCopyable {
    _debugPrecondition(offset >= 0, "UnsafeMutableRawBufferPointer.load with negative offset")
    _debugPrecondition(offset + MemoryLayout<T>.size <= self.count,
      "UnsafeMutableRawBufferPointer.load out of bounds")
    return baseAddress!.loadUnaligned(fromByteOffset: offset, as: T.self)
  }
  @_alwaysEmitIntoClient public func loadUnaligned<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    _debugPrecondition(offset >= 0, "UnsafeMutableRawBufferPointer.load with negative offset")
    _debugPrecondition(offset + MemoryLayout<T>.size <= self.count,
      "UnsafeMutableRawBufferPointer.load out of bounds")
    return baseAddress!.loadUnaligned(fromByteOffset: offset, as: T.self)
  }
  @_silgen_name("_swift_se0349_UnsafeMutableRawBufferPointer_storeBytes")
  @_alwaysEmitIntoClient public func storeBytes<T>(of value: T, toByteOffset offset: Swift.Int = 0, as type: T.Type) {
    _debugPrecondition(offset >= 0, "UnsafeMutableRawBufferPointer.storeBytes with negative offset")
    _debugPrecondition(offset + MemoryLayout<T>.size <= self.count,
      "UnsafeMutableRawBufferPointer.storeBytes out of bounds")

    let pointer = baseAddress._unsafelyUnwrappedUnchecked
    pointer.storeBytes(of: value, toByteOffset: offset, as: T.self)
  }
  @inlinable public func copyMemory(from source: Swift.UnsafeRawBufferPointer) {
    _debugPrecondition(source.count <= self.count,
      "UnsafeMutableRawBufferPointer.copyMemory source has too many elements")
    if let baseAddress = baseAddress, let sourceAddress = source.baseAddress {
      baseAddress.copyMemory(from: sourceAddress, byteCount: source.count)
    }
  }
  @inlinable public func copyBytes<C>(from source: C) where C : Swift.Collection, C.Element == Swift.UInt8 {
    guard let position = _position else {
      return
    }
    
    if source.withContiguousStorageIfAvailable({
      (buffer: UnsafeBufferPointer<UInt8>) -> Void in
      _debugPrecondition(source.count <= self.count,
        "UnsafeMutableRawBufferPointer.copyBytes source has too many elements")
      if let base = buffer.baseAddress {
        position.copyMemory(from: base, byteCount: buffer.count)
      }
    }) != nil {
      return
    }

    for (index, byteValue) in source.enumerated() {
      _debugPrecondition(index < self.count,
        "UnsafeMutableRawBufferPointer.copyBytes source has too many elements")
      position.storeBytes(
        of: byteValue, toByteOffset: index, as: UInt8.self)
    }
  }
  @inlinable public init(_ bytes: Swift.UnsafeMutableRawBufferPointer) {
    self.init(start: bytes.baseAddress, count: bytes.count)
  }
  @inlinable public init(mutating bytes: Swift.UnsafeRawBufferPointer) {
    self.init(start: UnsafeMutableRawPointer(mutating: bytes.baseAddress),
      count: bytes.count)
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  @inlinable @_preInverseGenerics public init<T>(_ buffer: Swift.UnsafeMutableBufferPointer<T>) where T : ~Copyable {
    self.init(start: buffer.baseAddress,
      count: buffer.count * MemoryLayout<T>.stride)
  }
  #else
  @inlinable public init<T>(_ buffer: Swift.UnsafeMutableBufferPointer<T>) {
    self.init(start: buffer.baseAddress,
      count: buffer.count * MemoryLayout<T>.stride)
  }
  #endif
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeMutableRawBufferPointer>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
  @inlinable public var baseAddress: Swift.UnsafeMutableRawPointer? {
    get {
    return _position
  }
  }
  @discardableResult
  @inlinable public func initializeMemory<T>(as type: T.Type, repeating repeatedValue: T) -> Swift.UnsafeMutableBufferPointer<T> {
    guard let base = _position else {
      return .init(start: nil, count: 0)
    }
    
    let count = (_end._unsafelyUnwrappedUnchecked-base) / MemoryLayout<T>.stride
    let initialized = base.initializeMemory(
      as: type, repeating: repeatedValue, count: count
    )
    return .init(start: initialized, count: count)
  }
  @inlinable public func initializeMemory<S>(as type: S.Element.Type, from source: S) -> (unwritten: S.Iterator, initialized: Swift.UnsafeMutableBufferPointer<S.Element>) where S : Swift.Sequence {
    var it = source.makeIterator()
    var idx = startIndex
    let elementStride = MemoryLayout<S.Element>.stride
    
     
    _debugPrecondition(source.underestimatedCount <= (count / elementStride),
      "insufficient space to accommodate source.underestimatedCount elements")
    guard let base = baseAddress else {
       
      _precondition(source.underestimatedCount == 0, 
        "no memory available to initialize from source")
      return (it, UnsafeMutableBufferPointer(start: nil, count: 0))
    }  

    _debugPrecondition(
      Int(bitPattern: base) & (MemoryLayout<S.Element>.alignment-1) == 0,
      "buffer base address must be properly aligned to access S.Element"
    )

    _internalInvariant(_end != nil)
    for p in stride(from: base, 
       
      to: _end._unsafelyUnwrappedUnchecked - elementStride + 1, 
      by: elementStride
    ) {
       
       
      guard let x = it.next() else { break }
      p.initializeMemory(as: S.Element.self, repeating: x, count: 1)
      formIndex(&idx, offsetBy: elementStride)
    }

    return (it, UnsafeMutableBufferPointer(
                  start: base.assumingMemoryBound(to: S.Element.self), 
                  count: idx / elementStride))
  }
  @_alwaysEmitIntoClient public func initializeMemory<C>(as type: C.Element.Type, fromContentsOf source: C) -> Swift.UnsafeMutableBufferPointer<C.Element> where C : Swift.Collection {
    let buffer: UnsafeMutableBufferPointer<C.Element>?
    buffer = source.withContiguousStorageIfAvailable {
      guard let sourceAddress = $0.baseAddress, !$0.isEmpty else {
        return .init(start: nil, count: 0)
      }
      _debugPrecondition(
        Int(bitPattern: baseAddress) & (MemoryLayout<C.Element>.alignment-1) == 0,
        "buffer base address must be properly aligned to access C.Element"
      )
      _precondition(
        $0.count * MemoryLayout<C.Element>.stride <= self.count,
        "buffer cannot contain every element from source collection."
      )
      let start = baseAddress?.initializeMemory(
        as: C.Element.self, from: sourceAddress, count: $0.count
      )
      return .init(start: start, count: $0.count)
    }
    if let buffer {
      return buffer
    }

    guard let base = baseAddress else {
      _precondition(
        source.isEmpty,
        "buffer cannot contain every element from source collection."
      )
      return .init(start: nil, count: 0)
    }
    _internalInvariant(_end != nil)
    _debugPrecondition(
      Int(bitPattern: baseAddress) & (MemoryLayout<C.Element>.alignment-1) == 0,
      "buffer base address must be properly aligned to access C.Element"
    )
    var iterator = source.makeIterator()
    var element = base
    var initialized = 0
    let end = _end._unsafelyUnwrappedUnchecked - MemoryLayout<C.Element>.stride
    while element <= end {
      guard let value = iterator.next() else {
        return .init(start: .init(base._rawValue), count: initialized)
      }
      element.initializeMemory(as: C.Element.self, to: value)
      element = element.advanced(by: MemoryLayout<C.Element>.stride)
      initialized += 1
    }
    _precondition(
      iterator.next() == nil,
      "buffer cannot contain every element from source collection."
    )
    return .init(start: .init(base._rawValue), count: initialized)
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @_alwaysEmitIntoClient public func moveInitializeMemory<T>(as type: T.Type, fromContentsOf source: Swift.UnsafeMutableBufferPointer<T>) -> Swift.UnsafeMutableBufferPointer<T> where T : ~Copyable {
    guard let sourceAddress = source.baseAddress, !source.isEmpty else {
      return .init(start: nil, count: 0)
    }
    _debugPrecondition(
      Int(bitPattern: baseAddress) & (MemoryLayout<T>.alignment-1) == 0,
      "buffer base address must be properly aligned to access T"
    )
    _precondition(
      source.count * MemoryLayout<T>.stride <= self.count,
      "buffer cannot contain every element from source."
    )
    let initialized = baseAddress?.moveInitializeMemory(
      as: T.self, from: sourceAddress, count: source.count
    )
    return .init(start: initialized, count: source.count)
  }
  #else
  @discardableResult
  @_alwaysEmitIntoClient public func moveInitializeMemory<T>(as type: T.Type, fromContentsOf source: Swift.UnsafeMutableBufferPointer<T>) -> Swift.UnsafeMutableBufferPointer<T> {
    guard let sourceAddress = source.baseAddress, !source.isEmpty else {
      return .init(start: nil, count: 0)
    }
    _debugPrecondition(
      Int(bitPattern: baseAddress) & (MemoryLayout<T>.alignment-1) == 0,
      "buffer base address must be properly aligned to access T"
    )
    _precondition(
      source.count * MemoryLayout<T>.stride <= self.count,
      "buffer cannot contain every element from source."
    )
    let initialized = baseAddress?.moveInitializeMemory(
      as: T.self, from: sourceAddress, count: source.count
    )
    return .init(start: initialized, count: source.count)
  }
  #endif
  @discardableResult
  @_alwaysEmitIntoClient public func moveInitializeMemory<T>(as type: T.Type, fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<T>>) -> Swift.UnsafeMutableBufferPointer<T> {
    let rebased = UnsafeMutableBufferPointer(rebasing: source)
    return moveInitializeMemory(as: T.self, fromContentsOf: rebased)
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @inlinable @_transparent @_preInverseGenerics public func bindMemory<T>(to type: T.Type) -> Swift.UnsafeMutableBufferPointer<T> where T : ~Copyable {
    guard let base = _position else {
      return UnsafeMutableBufferPointer<T>(start: nil, count: 0)
    }

    let capacity = count / MemoryLayout<T>.stride
    Builtin.bindMemory(base._rawValue, capacity._builtinWordValue, type)
    return UnsafeMutableBufferPointer<T>(
      start: UnsafeMutablePointer<T>(base._rawValue), count: capacity)
  }
  #else
  @discardableResult
  @inlinable @_transparent public func bindMemory<T>(to type: T.Type) -> Swift.UnsafeMutableBufferPointer<T> {
    guard let base = _position else {
      return UnsafeMutableBufferPointer<T>(start: nil, count: 0)
    }

    let capacity = count / MemoryLayout<T>.stride
    Builtin.bindMemory(base._rawValue, capacity._builtinWordValue, type)
    return UnsafeMutableBufferPointer<T>(
      start: UnsafeMutablePointer<T>(base._rawValue), count: capacity)
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, _ body: (_ buffer: Swift.UnsafeMutableBufferPointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
    guard let s = _position else {
      return try body(.init(start: nil, count: 0))
    }
    _debugPrecondition(
      Int(bitPattern: s) & (MemoryLayout<T>.alignment-1) == 0,
      "baseAddress must be a properly aligned pointer for type T"
    )
     
    _internalInvariant(_end != nil)
    let c = _assumeNonNegative(s.distance(to: _end._unsafelyUnwrappedUnchecked))
    let n = c / MemoryLayout<T>.stride
    let binding = Builtin.bindMemory(s._rawValue, n._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(s._rawValue, binding) }
    return try body(.init(start: .init(s._rawValue), count: n))
  }
  #else
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, _ body: (_ buffer: Swift.UnsafeMutableBufferPointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
    guard let s = _position else {
      return try body(.init(start: nil, count: 0))
    }
    _debugPrecondition(
      Int(bitPattern: s) & (MemoryLayout<T>.alignment-1) == 0,
      "baseAddress must be a properly aligned pointer for type T"
    )
     
    _internalInvariant(_end != nil)
    let c = _assumeNonNegative(s.distance(to: _end._unsafelyUnwrappedUnchecked))
    let n = c / MemoryLayout<T>.stride
    let binding = Builtin.bindMemory(s._rawValue, n._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(s._rawValue, binding) }
    return try body(.init(start: .init(s._rawValue), count: n))
  }
  #endif
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public func assumingMemoryBound<T>(to: T.Type) -> Swift.UnsafeMutableBufferPointer<T> where T : ~Copyable {
    guard let s = _position else {
      return .init(start: nil, count: 0)
    }
     
    _internalInvariant(_end != nil)
    let c = _assumeNonNegative(s.distance(to: _end._unsafelyUnwrappedUnchecked))
    let n = c / MemoryLayout<T>.stride
    return .init(start: .init(s._rawValue), count: n)
  }
  #else
  @_alwaysEmitIntoClient public func assumingMemoryBound<T>(to: T.Type) -> Swift.UnsafeMutableBufferPointer<T> {
    guard let s = _position else {
      return .init(start: nil, count: 0)
    }
     
    _internalInvariant(_end != nil)
    let c = _assumeNonNegative(s.distance(to: _end._unsafelyUnwrappedUnchecked))
    let n = c / MemoryLayout<T>.stride
    return .init(start: .init(s._rawValue), count: n)
  }
  #endif
  @_alwaysEmitIntoClient public func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Swift.UnsafeMutableRawBufferPointer.Element>) throws -> R) rethrows -> R? {
    #if $TypedThrows
    try withMemoryRebound(to: Element.self) { b in
      var buffer = b
      defer {
        _debugPrecondition(
          (b.baseAddress, b.count) == (buffer.baseAddress, buffer.count),
          "UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed"
        )
      }
      return try body(&buffer)
    }
    #else
    fatalError("unsupported compiler")
    #endif
  }
  @_alwaysEmitIntoClient public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UnsafeMutableRawBufferPointer.Element>) throws -> R) rethrows -> R? {
    #if $TypedThrows
    try withMemoryRebound(to: Element.self) {
      try body(UnsafeBufferPointer<Element>($0))
    }
    #else
    fatalError("unsupported compiler")
    #endif
  }
}
extension Swift.UnsafeMutableRawBufferPointer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.UnsafeMutableRawBufferPointer {
  @available(*, unavailable, message: "use 'UnsafeMutableRawBufferPointer(rebasing:)' to convert a slice into a zero-based raw buffer.")
  public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeMutableRawBufferPointer {
    get
    nonmutating set
  }
  @available(*, unavailable, message: "use 'UnsafeRawBufferPointer(rebasing:)' to convert a slice into a zero-based raw buffer.")
  public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeRawBufferPointer {
    get
    nonmutating set
  }
}
@frozen public struct UnsafeRawBufferPointer {
  @usableFromInline
  internal let _position: Swift.UnsafeRawPointer?, _end: Swift.UnsafeRawPointer?
  @inlinable public init(@_nonEphemeral start: Swift.UnsafeRawPointer?, count: Swift.Int) {
    _debugPrecondition(count >= 0, "UnsafeRawBufferPointer with negative count")
    _debugPrecondition(count == 0 || start != nil,
      "UnsafeRawBufferPointer has a nil start and nonzero count")
    _position = start
    _end = start.map { $0 + _assumeNonNegative(count) }
  }
}
@available(*, unavailable)
extension Swift.UnsafeRawBufferPointer : Swift.Sendable {
}
extension Swift.UnsafeRawBufferPointer {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _position: Swift.UnsafeRawPointer?, _end: Swift.UnsafeRawPointer?
    @inlinable internal init(_position: Swift.UnsafeRawPointer?, _end: Swift.UnsafeRawPointer?) {
      self._position = _position
      self._end = _end
    }
  }
}
@available(*, unavailable)
extension Swift.UnsafeRawBufferPointer.Iterator : Swift.Sendable {
}
extension Swift.UnsafeRawBufferPointer.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  @inlinable public mutating func next() -> Swift.UInt8? {
    if _position == _end { return nil }

     
     
     
     
     
     
     
     
     
     
     
    _debugPrecondition(_position! < _end!)
    let position = _position._unsafelyUnwrappedUnchecked
    let result = position.load(as: UInt8.self)
    _position = position + 1
    return result
  }
  public typealias Element = Swift.UInt8
  public typealias Iterator = Swift.UnsafeRawBufferPointer.Iterator
}
extension Swift.UnsafeRawBufferPointer : Swift.Sequence {
  public typealias SubSequence = Swift.Slice<Swift.UnsafeRawBufferPointer>
  @inlinable public func makeIterator() -> Swift.UnsafeRawBufferPointer.Iterator {
    return Iterator(_position: _position, _end: _end)
  }
  @_alwaysEmitIntoClient public func _copyContents(initializing destination: Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> (Swift.UnsafeRawBufferPointer.Iterator, Swift.UnsafeMutableBufferPointer<Swift.UInt8>.Index) {
    guard let s = _position, let e = _end, e > s, !destination.isEmpty else {
      return (makeIterator(), 0)
    }
    let destinationAddress = destination.baseAddress._unsafelyUnwrappedUnchecked
    let d = UnsafeMutableRawPointer(destinationAddress)
    let n = Swift.min(destination.count, s.distance(to: e))
    d.copyMemory(from: s, byteCount: n)
    return (Iterator(_position: s.advanced(by: n), _end: e), n)
  }
}
extension Swift.UnsafeRawBufferPointer : Swift.Collection {
  public typealias Element = Swift.UInt8
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable public var startIndex: Swift.UnsafeRawBufferPointer.Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.UnsafeRawBufferPointer.Index {
    get {
    return count
  }
  }
  @inlinable public var indices: Swift.UnsafeRawBufferPointer.Indices {
    get {
     
    return Indices(uncheckedBounds: (startIndex, endIndex))
  }
  }
  @inlinable public subscript(i: Swift.Int) -> Swift.UnsafeRawBufferPointer.Element {
    get {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked.load(fromByteOffset: i, as: UInt8.self)
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeRawBufferPointer.SubSequence {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(base: self, bounds: bounds)
    }
  }
  @inlinable public var count: Swift.Int {
    get {
    if let pos = _position {
       
       
      _internalInvariant(_end != nil)
      return _assumeNonNegative(_end._unsafelyUnwrappedUnchecked - pos)
    }
    return 0
  }
  }
}
extension Swift.UnsafeRawBufferPointer : Swift.RandomAccessCollection {
}
extension Swift.UnsafeRawBufferPointer {
  @inlinable public func deallocate() {
    _position?.deallocate()
  }
  @inlinable public func load<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    _debugPrecondition(offset >= 0, "UnsafeRawBufferPointer.load with negative offset")
    _debugPrecondition(offset + MemoryLayout<T>.size <= self.count,
      "UnsafeRawBufferPointer.load out of bounds")
    return baseAddress!.load(fromByteOffset: offset, as: T.self)
  }
  @_alwaysEmitIntoClient public func loadUnaligned<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T where T : Swift.BitwiseCopyable {
    _debugPrecondition(offset >= 0, "UnsafeRawBufferPointer.load with negative offset")
    _debugPrecondition(offset + MemoryLayout<T>.size <= self.count,
      "UnsafeRawBufferPointer.load out of bounds")
    return baseAddress!.loadUnaligned(fromByteOffset: offset, as: T.self)
  }
  @_alwaysEmitIntoClient public func loadUnaligned<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    _debugPrecondition(offset >= 0, "UnsafeRawBufferPointer.load with negative offset")
    _debugPrecondition(offset + MemoryLayout<T>.size <= self.count,
      "UnsafeRawBufferPointer.load out of bounds")
    return baseAddress!.loadUnaligned(fromByteOffset: offset, as: T.self)
  }
  @inlinable public init(_ bytes: Swift.UnsafeMutableRawBufferPointer) {
    self.init(start: bytes.baseAddress, count: bytes.count)
  }
  @inlinable public init(_ bytes: Swift.UnsafeRawBufferPointer) {
    self.init(start: bytes.baseAddress, count: bytes.count)
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  @inlinable @_preInverseGenerics public init<T>(_ buffer: Swift.UnsafeMutableBufferPointer<T>) where T : ~Copyable {
    self.init(start: buffer.baseAddress,
      count: buffer.count * MemoryLayout<T>.stride)
  }
  #else
  @inlinable public init<T>(_ buffer: Swift.UnsafeMutableBufferPointer<T>) {
    self.init(start: buffer.baseAddress,
      count: buffer.count * MemoryLayout<T>.stride)
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @inlinable @_preInverseGenerics public init<T>(_ buffer: Swift.UnsafeBufferPointer<T>) where T : ~Copyable {
    self.init(start: buffer.baseAddress,
      count: buffer.count * MemoryLayout<T>.stride)
  }
  #else
  @inlinable public init<T>(_ buffer: Swift.UnsafeBufferPointer<T>) {
    self.init(start: buffer.baseAddress,
      count: buffer.count * MemoryLayout<T>.stride)
  }
  #endif
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeRawBufferPointer>) {
     
     
     
     
     
     
     
     
    _debugPrecondition(
      slice.startIndex >= 0 && slice.endIndex <= slice.base.count,
      "Invalid slice")
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeMutableRawBufferPointer>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
  @inlinable public var baseAddress: Swift.UnsafeRawPointer? {
    get {
    return _position
  }
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @inlinable @_transparent @_preInverseGenerics public func bindMemory<T>(to type: T.Type) -> Swift.UnsafeBufferPointer<T> where T : ~Copyable {
    guard let base = _position else {
      return UnsafeBufferPointer<T>(start: nil, count: 0)
    }

    let capacity = count / MemoryLayout<T>.stride
    Builtin.bindMemory(base._rawValue, capacity._builtinWordValue, type)
    return UnsafeBufferPointer<T>(
      start: UnsafePointer<T>(base._rawValue), count: capacity)
  }
  #else
  @discardableResult
  @inlinable @_transparent public func bindMemory<T>(to type: T.Type) -> Swift.UnsafeBufferPointer<T> {
    guard let base = _position else {
      return UnsafeBufferPointer<T>(start: nil, count: 0)
    }

    let capacity = count / MemoryLayout<T>.stride
    Builtin.bindMemory(base._rawValue, capacity._builtinWordValue, type)
    return UnsafeBufferPointer<T>(
      start: UnsafePointer<T>(base._rawValue), count: capacity)
  }
  #endif
  #if compiler(>=5.3) && $TypedThrows
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, _ body: (_ buffer: Swift.UnsafeBufferPointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
    guard let s = _position else {
      return try body(.init(start: nil, count: 0))
    }
    _debugPrecondition(
      Int(bitPattern: s) & (MemoryLayout<T>.alignment-1) == 0,
      "baseAddress must be a properly aligned pointer for type T"
    )
     
    _internalInvariant(_end != nil)
    let c = _assumeNonNegative(s.distance(to: _end._unsafelyUnwrappedUnchecked))
    let n = c / MemoryLayout<T>.stride
    let binding = Builtin.bindMemory(s._rawValue, n._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(s._rawValue, binding) }
    return try body(.init(start: .init(s._rawValue), count: n))
  }
  #else
  @_alwaysEmitIntoClient public func withMemoryRebound<T, E, Result>(to type: T.Type, _ body: (_ buffer: Swift.UnsafeBufferPointer<T>) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
    guard let s = _position else {
      return try body(.init(start: nil, count: 0))
    }
    _debugPrecondition(
      Int(bitPattern: s) & (MemoryLayout<T>.alignment-1) == 0,
      "baseAddress must be a properly aligned pointer for type T"
    )
     
    _internalInvariant(_end != nil)
    let c = _assumeNonNegative(s.distance(to: _end._unsafelyUnwrappedUnchecked))
    let n = c / MemoryLayout<T>.stride
    let binding = Builtin.bindMemory(s._rawValue, n._builtinWordValue, T.self)
    defer { Builtin.rebindMemory(s._rawValue, binding) }
    return try body(.init(start: .init(s._rawValue), count: n))
  }
  #endif
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public func assumingMemoryBound<T>(to: T.Type) -> Swift.UnsafeBufferPointer<T> where T : ~Copyable {
    guard let s = _position else {
      return .init(start: nil, count: 0)
    }
     
    _internalInvariant(_end != nil)
    let c = _assumeNonNegative(s.distance(to: _end._unsafelyUnwrappedUnchecked))
    let n = c / MemoryLayout<T>.stride
    return .init(start: .init(s._rawValue), count: n)
  }
  #else
  @_alwaysEmitIntoClient public func assumingMemoryBound<T>(to: T.Type) -> Swift.UnsafeBufferPointer<T> {
    guard let s = _position else {
      return .init(start: nil, count: 0)
    }
     
    _internalInvariant(_end != nil)
    let c = _assumeNonNegative(s.distance(to: _end._unsafelyUnwrappedUnchecked))
    let n = c / MemoryLayout<T>.stride
    return .init(start: .init(s._rawValue), count: n)
  }
  #endif
  @_alwaysEmitIntoClient public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UnsafeRawBufferPointer.Element>) throws -> R) rethrows -> R? {
    #if $TypedThrows
    try withMemoryRebound(to: Element.self) {
      try body($0)
    }
    #else
    fatalError("unsupported compiler")
    #endif
  }
}
extension Swift.UnsafeRawBufferPointer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.UnsafeRawBufferPointer {
  @available(*, unavailable, message: "use 'UnsafeRawBufferPointer(rebasing:)' to convert a slice into a zero-based raw buffer.")
  public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeRawBufferPointer {
    get
  }
}
#if compiler(>=5.3) && $TypedThrows
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func withUnsafeMutableBytes<T, E, Result>(of value: inout T, _ body: (Swift.UnsafeMutableRawBufferPointer) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
  let pointer = UnsafeMutableRawPointer(Builtin.addressof(&value))
  return try body(.init(start: pointer, count: MemoryLayout<T>.size))
}
#else
@_alwaysEmitIntoClient public func withUnsafeMutableBytes<T, E, Result>(of value: inout T, _ body: (Swift.UnsafeMutableRawBufferPointer) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
  let pointer = UnsafeMutableRawPointer(Builtin.addressof(&value))
  return try body(.init(start: pointer, count: MemoryLayout<T>.size))
}
#endif
#endif
@_silgen_name("$ss22withUnsafeMutableBytes2of_q_xz_q_SwKXEtKr0_lF")
@usableFromInline
internal func __abi_se0413_withUnsafeMutableBytes<T, Result>(of value: inout T, _ body: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result
#if compiler(>=5.3) && $TypedThrows
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func _withUnprotectedUnsafeMutableBytes<T, E, Result>(of value: inout T, _ body: (Swift.UnsafeMutableRawBufferPointer) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
#if $BuiltinUnprotectedAddressOf
  let pointer = UnsafeMutableRawPointer(Builtin.unprotectedAddressOf(&value))
#else
  let pointer = UnsafeMutableRawPointer(Builtin.addressof(&value))
#endif
  return try body(.init(start: pointer, count: MemoryLayout<T>.size))
}
#else
@_alwaysEmitIntoClient public func _withUnprotectedUnsafeMutableBytes<T, E, Result>(of value: inout T, _ body: (Swift.UnsafeMutableRawBufferPointer) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
#if $BuiltinUnprotectedAddressOf
  let pointer = UnsafeMutableRawPointer(Builtin.unprotectedAddressOf(&value))
#else
  let pointer = UnsafeMutableRawPointer(Builtin.addressof(&value))
#endif
  return try body(.init(start: pointer, count: MemoryLayout<T>.size))
}
#endif
#endif
#if compiler(>=5.3) && $TypedThrows
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func withUnsafeBytes<T, E, Result>(of value: inout T, _ body: (Swift.UnsafeRawBufferPointer) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
  let address = UnsafeRawPointer(Builtin.addressof(&value))
  return try body(.init(start: address, count: MemoryLayout<T>.size))
}
#else
@_alwaysEmitIntoClient public func withUnsafeBytes<T, E, Result>(of value: inout T, _ body: (Swift.UnsafeRawBufferPointer) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
  let address = UnsafeRawPointer(Builtin.addressof(&value))
  return try body(.init(start: address, count: MemoryLayout<T>.size))
}
#endif
#endif
@_silgen_name("$ss15withUnsafeBytes2of_q_xz_q_SWKXEtKr0_lF")
@usableFromInline
internal func __abi_se0413_withUnsafeBytes<T, Result>(of value: inout T, _ body: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result
#if compiler(>=5.3) && $TypedThrows
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func _withUnprotectedUnsafeBytes<T, E, Result>(of value: inout T, _ body: (Swift.UnsafeRawBufferPointer) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
#if $BuiltinUnprotectedAddressOf
  let p = UnsafeRawPointer(Builtin.unprotectedAddressOf(&value))
#else
  let p = UnsafeRawPointer(Builtin.addressof(&value))
#endif
  return try body(.init(start: p, count: MemoryLayout<T>.size))
}
#else
@_alwaysEmitIntoClient public func _withUnprotectedUnsafeBytes<T, E, Result>(of value: inout T, _ body: (Swift.UnsafeRawBufferPointer) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
#if $BuiltinUnprotectedAddressOf
  let p = UnsafeRawPointer(Builtin.unprotectedAddressOf(&value))
#else
  let p = UnsafeRawPointer(Builtin.addressof(&value))
#endif
  return try body(.init(start: p, count: MemoryLayout<T>.size))
}
#endif
#endif
#if compiler(>=5.3) && $TypedThrows
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func withUnsafeBytes<T, E, Result>(of value: borrowing T, _ body: (Swift.UnsafeRawBufferPointer) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
  let addr = UnsafeRawPointer(Builtin.addressOfBorrow(value))
  return try body(.init(start: addr, count: MemoryLayout<T>.size))
}
#else
@_alwaysEmitIntoClient public func withUnsafeBytes<T, E, Result>(of value: borrowing T, _ body: (Swift.UnsafeRawBufferPointer) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
  let addr = UnsafeRawPointer(Builtin.addressOfBorrow(value))
  return try body(.init(start: addr, count: MemoryLayout<T>.size))
}
#endif
#endif
@_silgen_name("$ss15withUnsafeBytes2of_q_x_q_SWKXEtKr0_lF")
@usableFromInline
internal func __abi_se0413_withUnsafeBytes<T, Result>(of value: T, _ body: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result
#if compiler(>=5.3) && $TypedThrows
#if compiler(>=5.3) && $NoncopyableGenerics
@_alwaysEmitIntoClient public func _withUnprotectedUnsafeBytes<T, E, Result>(of value: borrowing T, _ body: (Swift.UnsafeRawBufferPointer) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, T : ~Copyable, Result : ~Copyable {
#if $BuiltinUnprotectedAddressOf
  let addr = UnsafeRawPointer(Builtin.unprotectedAddressOfBorrow(value))
#else
  let addr = UnsafeRawPointer(Builtin.addressOfBorrow(value))
#endif
  let buffer = UnsafeRawBufferPointer(start: addr, count: MemoryLayout<T>.size)
  return try body(buffer)
}
#else
@_alwaysEmitIntoClient public func _withUnprotectedUnsafeBytes<T, E, Result>(of value: borrowing T, _ body: (Swift.UnsafeRawBufferPointer) throws(E) -> Result) throws(E) -> Result where E : Swift.Error {
#if $BuiltinUnprotectedAddressOf
  let addr = UnsafeRawPointer(Builtin.unprotectedAddressOfBorrow(value))
#else
  let addr = UnsafeRawPointer(Builtin.addressOfBorrow(value))
#endif
  let buffer = UnsafeRawBufferPointer(start: addr, count: MemoryLayout<T>.size)
  return try body(buffer)
}
#endif
#endif
@inlinable public func == (lhs: (), rhs: ()) -> Swift.Bool {
  return true
}
@inlinable public func != (lhs: (), rhs: ()) -> Swift.Bool {
    return false
}
@inlinable public func < (lhs: (), rhs: ()) -> Swift.Bool {
    return false
}
@inlinable public func <= (lhs: (), rhs: ()) -> Swift.Bool {
    return true
}
@inlinable public func > (lhs: (), rhs: ()) -> Swift.Bool {
    return false
}
@inlinable public func >= (lhs: (), rhs: ()) -> Swift.Bool {
    return true
}
@inlinable public func == <A, B>(lhs: (A, B), rhs: (A, B)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
    return (
    lhs.1
  ) == (
    rhs.1
  )
}
@inlinable public func != <A, B>(lhs: (A, B), rhs: (A, B)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
    return (
    lhs.1
  ) != (
    rhs.1
  )
}
@inlinable public func < <A, B>(lhs: (A, B), rhs: (A, B)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
    return (
    lhs.1
  ) < (
    rhs.1
  )
}
@inlinable public func <= <A, B>(lhs: (A, B), rhs: (A, B)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
    return (
    lhs.1
  ) <= (
    rhs.1
  )
}
@inlinable public func > <A, B>(lhs: (A, B), rhs: (A, B)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
    return (
    lhs.1
  ) > (
    rhs.1
  )
}
@inlinable public func >= <A, B>(lhs: (A, B), rhs: (A, B)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
    return (
    lhs.1
  ) >= (
    rhs.1
  )
}
@inlinable public func == <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
    return (
    lhs.1, lhs.2
  ) == (
    rhs.1, rhs.2
  )
}
@inlinable public func != <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
    return (
    lhs.1, lhs.2
  ) != (
    rhs.1, rhs.2
  )
}
@inlinable public func < <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
    return (
    lhs.1, lhs.2
  ) < (
    rhs.1, rhs.2
  )
}
@inlinable public func <= <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
    return (
    lhs.1, lhs.2
  ) <= (
    rhs.1, rhs.2
  )
}
@inlinable public func > <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
    return (
    lhs.1, lhs.2
  ) > (
    rhs.1, rhs.2
  )
}
@inlinable public func >= <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
    return (
    lhs.1, lhs.2
  ) >= (
    rhs.1, rhs.2
  )
}
@inlinable public func == <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
    return (
    lhs.1, lhs.2, lhs.3
  ) == (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func != <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
    return (
    lhs.1, lhs.2, lhs.3
  ) != (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func < <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
    return (
    lhs.1, lhs.2, lhs.3
  ) < (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func <= <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
    return (
    lhs.1, lhs.2, lhs.3
  ) <= (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func > <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
    return (
    lhs.1, lhs.2, lhs.3
  ) > (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func >= <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
    return (
    lhs.1, lhs.2, lhs.3
  ) >= (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func == <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable, E : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
    return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) == (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func != <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable, E : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
    return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) != (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func < <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
    return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) < (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func <= <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
    return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) <= (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func > <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
    return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) > (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func >= <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
    return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) >= (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func == <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable, E : Swift.Equatable, F : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
    return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) == (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func != <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable, E : Swift.Equatable, F : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
    return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) != (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func < <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable, F : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
    return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) < (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func <= <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable, F : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
    return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) <= (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func > <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable, F : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
    return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) > (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func >= <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable, F : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
    return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) >= (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
extension Swift.SIMD2 where Scalar == Swift.UInt8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt8) {
    _storage = UInt8.SIMD2Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt8(
      Builtin.cmp_eq_Vec2xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt8(
      Builtin.cmp_ne_Vec2xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt8(
      Builtin.cmp_ult_Vec2xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt8(
      Builtin.cmp_ule_Vec2xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt8(
      Builtin.cmp_ugt_Vec2xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt8(
      Builtin.cmp_uge_Vec2xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.add_Vec2xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.sub_Vec2xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.mul_Vec2xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &* b }
}
extension Swift.SIMD4 where Scalar == Swift.UInt8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt8) {
    _storage = UInt8.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_eq_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_ne_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_ult_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_ule_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_ugt_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_uge_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.add_Vec4xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.sub_Vec4xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.mul_Vec4xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &* b }
}
extension Swift.SIMD8 where Scalar == Swift.UInt8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt8) {
    _storage = UInt8.SIMD8Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt8(
      Builtin.cmp_eq_Vec8xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt8(
      Builtin.cmp_ne_Vec8xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt8(
      Builtin.cmp_ult_Vec8xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt8(
      Builtin.cmp_ule_Vec8xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt8(
      Builtin.cmp_ugt_Vec8xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt8(
      Builtin.cmp_uge_Vec8xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.add_Vec8xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.sub_Vec8xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.mul_Vec8xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &* b }
}
extension Swift.SIMD16 where Scalar == Swift.UInt8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt8) {
    _storage = UInt8.SIMD16Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt8(
      Builtin.cmp_eq_Vec16xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt8(
      Builtin.cmp_ne_Vec16xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt8(
      Builtin.cmp_ult_Vec16xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt8(
      Builtin.cmp_ule_Vec16xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt8(
      Builtin.cmp_ugt_Vec16xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt8(
      Builtin.cmp_uge_Vec16xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.add_Vec16xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.sub_Vec16xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.mul_Vec16xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &* b }
}
extension Swift.SIMD32 where Scalar == Swift.UInt8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt8) {
    _storage = UInt8.SIMD32Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt8(
      Builtin.cmp_eq_Vec32xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt8(
      Builtin.cmp_ne_Vec32xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt8(
      Builtin.cmp_ult_Vec32xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt8(
      Builtin.cmp_ule_Vec32xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt8(
      Builtin.cmp_ugt_Vec32xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt8(
      Builtin.cmp_uge_Vec32xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.add_Vec32xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.sub_Vec32xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.mul_Vec32xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &* b }
}
extension Swift.SIMD64 where Scalar == Swift.UInt8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt8) {
    _storage = UInt8.SIMD64Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt8(
      Builtin.cmp_eq_Vec64xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt8(
      Builtin.cmp_ne_Vec64xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt8(
      Builtin.cmp_ult_Vec64xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt8(
      Builtin.cmp_ule_Vec64xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt8(
      Builtin.cmp_ugt_Vec64xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt8(
      Builtin.cmp_uge_Vec64xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.add_Vec64xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.sub_Vec64xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.mul_Vec64xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &* b }
}
extension Swift.SIMD3 where Scalar == Swift.UInt8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt8) {
    _storage = UInt8.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_eq_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_ne_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_ult_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_ule_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_ugt_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_uge_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.add_Vec4xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.sub_Vec4xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.mul_Vec4xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD2<Swift.Int8> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt8) {
    _storage = SIMD2<Int8>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD2<Swift.Int8>> {
    get {
    let zero = SIMD2<Int8>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int8>(Builtin.and_Vec2xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int8>(Builtin.xor_Vec2xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int8>(Builtin.or_Vec2xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD2 where Scalar == Swift.Int8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt8) {
    _storage = Int8.SIMD2Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt8(
      Builtin.cmp_eq_Vec2xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt8(
      Builtin.cmp_ne_Vec2xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt8(
      Builtin.cmp_slt_Vec2xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt8(
      Builtin.cmp_sle_Vec2xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt8(
      Builtin.cmp_sgt_Vec2xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt8(
      Builtin.cmp_sge_Vec2xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.add_Vec2xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.sub_Vec2xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.mul_Vec2xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD4<Swift.Int8> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt8) {
    _storage = SIMD4<Int8>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD4<Swift.Int8>> {
    get {
    let zero = SIMD4<Int8>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int8>(Builtin.and_Vec4xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int8>(Builtin.xor_Vec4xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int8>(Builtin.or_Vec4xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD4 where Scalar == Swift.Int8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt8) {
    _storage = Int8.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_eq_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_ne_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_slt_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_sle_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_sgt_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_sge_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.add_Vec4xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.sub_Vec4xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.mul_Vec4xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD8<Swift.Int8> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt8) {
    _storage = SIMD8<Int8>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD8<Swift.Int8>> {
    get {
    let zero = SIMD8<Int8>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int8>(Builtin.and_Vec8xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int8>(Builtin.xor_Vec8xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int8>(Builtin.or_Vec8xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD8 where Scalar == Swift.Int8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt8) {
    _storage = Int8.SIMD8Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt8(
      Builtin.cmp_eq_Vec8xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt8(
      Builtin.cmp_ne_Vec8xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt8(
      Builtin.cmp_slt_Vec8xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt8(
      Builtin.cmp_sle_Vec8xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt8(
      Builtin.cmp_sgt_Vec8xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt8(
      Builtin.cmp_sge_Vec8xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.add_Vec8xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.sub_Vec8xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.mul_Vec8xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD16<Swift.Int8> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt8) {
    _storage = SIMD16<Int8>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD16<Swift.Int8>> {
    get {
    let zero = SIMD16<Int8>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int8>(Builtin.and_Vec16xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int8>(Builtin.xor_Vec16xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int8>(Builtin.or_Vec16xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD16 where Scalar == Swift.Int8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt8) {
    _storage = Int8.SIMD16Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt8(
      Builtin.cmp_eq_Vec16xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt8(
      Builtin.cmp_ne_Vec16xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt8(
      Builtin.cmp_slt_Vec16xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt8(
      Builtin.cmp_sle_Vec16xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt8(
      Builtin.cmp_sgt_Vec16xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt8(
      Builtin.cmp_sge_Vec16xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.add_Vec16xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.sub_Vec16xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.mul_Vec16xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD32<Swift.Int8> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt8) {
    _storage = SIMD32<Int8>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD32<Swift.Int8>> {
    get {
    let zero = SIMD32<Int8>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int8>(Builtin.and_Vec32xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int8>(Builtin.xor_Vec32xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int8>(Builtin.or_Vec32xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD32 where Scalar == Swift.Int8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt8) {
    _storage = Int8.SIMD32Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt8(
      Builtin.cmp_eq_Vec32xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt8(
      Builtin.cmp_ne_Vec32xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt8(
      Builtin.cmp_slt_Vec32xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt8(
      Builtin.cmp_sle_Vec32xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt8(
      Builtin.cmp_sgt_Vec32xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt8(
      Builtin.cmp_sge_Vec32xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.add_Vec32xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.sub_Vec32xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.mul_Vec32xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD64<Swift.Int8> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt8) {
    _storage = SIMD64<Int8>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD64<Swift.Int8>> {
    get {
    let zero = SIMD64<Int8>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int8>(Builtin.and_Vec64xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int8>(Builtin.xor_Vec64xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int8>(Builtin.or_Vec64xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD64 where Scalar == Swift.Int8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt8) {
    _storage = Int8.SIMD64Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt8(
      Builtin.cmp_eq_Vec64xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt8(
      Builtin.cmp_ne_Vec64xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt8(
      Builtin.cmp_slt_Vec64xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt8(
      Builtin.cmp_sle_Vec64xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt8(
      Builtin.cmp_sgt_Vec64xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt8(
      Builtin.cmp_sge_Vec64xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.add_Vec64xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.sub_Vec64xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.mul_Vec64xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD3<Swift.Int8> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt8) {
    _storage = SIMD3<Int8>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD3<Swift.Int8>> {
    get {
    let zero = SIMD3<Int8>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int8>(Builtin.and_Vec4xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int8>(Builtin.xor_Vec4xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int8>(Builtin.or_Vec4xInt8(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD3 where Scalar == Swift.Int8 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt8) {
    _storage = Int8.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_eq_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_ne_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_slt_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_sle_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_sgt_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt8(
      Builtin.cmp_sge_Vec4xInt8(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.add_Vec4xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.sub_Vec4xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.mul_Vec4xInt8(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &* b }
}
extension Swift.SIMD2 where Scalar == Swift.UInt16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt16) {
    _storage = UInt16.SIMD2Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.cmp_eq_Vec2xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.cmp_ne_Vec2xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.cmp_ult_Vec2xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.cmp_ule_Vec2xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.cmp_ugt_Vec2xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.cmp_uge_Vec2xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.add_Vec2xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.sub_Vec2xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.mul_Vec2xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &* b }
}
extension Swift.SIMD4 where Scalar == Swift.UInt16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt16) {
    _storage = UInt16.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_eq_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_ne_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_ult_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_ule_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_ugt_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_uge_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.add_Vec4xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.sub_Vec4xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.mul_Vec4xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &* b }
}
extension Swift.SIMD8 where Scalar == Swift.UInt16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt16) {
    _storage = UInt16.SIMD8Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.cmp_eq_Vec8xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.cmp_ne_Vec8xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.cmp_ult_Vec8xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.cmp_ule_Vec8xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.cmp_ugt_Vec8xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.cmp_uge_Vec8xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.add_Vec8xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.sub_Vec8xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.mul_Vec8xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &* b }
}
extension Swift.SIMD16 where Scalar == Swift.UInt16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt16) {
    _storage = UInt16.SIMD16Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.cmp_eq_Vec16xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.cmp_ne_Vec16xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.cmp_ult_Vec16xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.cmp_ule_Vec16xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.cmp_ugt_Vec16xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.cmp_uge_Vec16xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.add_Vec16xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.sub_Vec16xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.mul_Vec16xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &* b }
}
extension Swift.SIMD32 where Scalar == Swift.UInt16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt16) {
    _storage = UInt16.SIMD32Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.cmp_eq_Vec32xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.cmp_ne_Vec32xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.cmp_ult_Vec32xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.cmp_ule_Vec32xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.cmp_ugt_Vec32xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.cmp_uge_Vec32xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.add_Vec32xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.sub_Vec32xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.mul_Vec32xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &* b }
}
extension Swift.SIMD64 where Scalar == Swift.UInt16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt16) {
    _storage = UInt16.SIMD64Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.cmp_eq_Vec64xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.cmp_ne_Vec64xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.cmp_ult_Vec64xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.cmp_ule_Vec64xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.cmp_ugt_Vec64xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.cmp_uge_Vec64xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.add_Vec64xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.sub_Vec64xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.mul_Vec64xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &* b }
}
extension Swift.SIMD3 where Scalar == Swift.UInt16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt16) {
    _storage = UInt16.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_eq_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_ne_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_ult_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_ule_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_ugt_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_uge_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.add_Vec4xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.sub_Vec4xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.mul_Vec4xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD2<Swift.Int16> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt16) {
    _storage = SIMD2<Int16>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD2<Swift.Int16>> {
    get {
    let zero = SIMD2<Int16>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int16>(Builtin.and_Vec2xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int16>(Builtin.xor_Vec2xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int16>(Builtin.or_Vec2xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD2 where Scalar == Swift.Int16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt16) {
    _storage = Int16.SIMD2Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.cmp_eq_Vec2xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.cmp_ne_Vec2xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.cmp_slt_Vec2xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.cmp_sle_Vec2xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.cmp_sgt_Vec2xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.cmp_sge_Vec2xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.add_Vec2xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.sub_Vec2xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.mul_Vec2xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD4<Swift.Int16> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt16) {
    _storage = SIMD4<Int16>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD4<Swift.Int16>> {
    get {
    let zero = SIMD4<Int16>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int16>(Builtin.and_Vec4xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int16>(Builtin.xor_Vec4xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int16>(Builtin.or_Vec4xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD4 where Scalar == Swift.Int16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt16) {
    _storage = Int16.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_eq_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_ne_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_slt_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_sle_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_sgt_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_sge_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.add_Vec4xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.sub_Vec4xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.mul_Vec4xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD8<Swift.Int16> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt16) {
    _storage = SIMD8<Int16>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD8<Swift.Int16>> {
    get {
    let zero = SIMD8<Int16>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int16>(Builtin.and_Vec8xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int16>(Builtin.xor_Vec8xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int16>(Builtin.or_Vec8xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD8 where Scalar == Swift.Int16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt16) {
    _storage = Int16.SIMD8Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.cmp_eq_Vec8xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.cmp_ne_Vec8xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.cmp_slt_Vec8xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.cmp_sle_Vec8xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.cmp_sgt_Vec8xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.cmp_sge_Vec8xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.add_Vec8xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.sub_Vec8xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.mul_Vec8xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD16<Swift.Int16> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt16) {
    _storage = SIMD16<Int16>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD16<Swift.Int16>> {
    get {
    let zero = SIMD16<Int16>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int16>(Builtin.and_Vec16xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int16>(Builtin.xor_Vec16xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int16>(Builtin.or_Vec16xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD16 where Scalar == Swift.Int16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt16) {
    _storage = Int16.SIMD16Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.cmp_eq_Vec16xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.cmp_ne_Vec16xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.cmp_slt_Vec16xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.cmp_sle_Vec16xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.cmp_sgt_Vec16xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.cmp_sge_Vec16xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.add_Vec16xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.sub_Vec16xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.mul_Vec16xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD32<Swift.Int16> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt16) {
    _storage = SIMD32<Int16>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD32<Swift.Int16>> {
    get {
    let zero = SIMD32<Int16>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int16>(Builtin.and_Vec32xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int16>(Builtin.xor_Vec32xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int16>(Builtin.or_Vec32xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD32 where Scalar == Swift.Int16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt16) {
    _storage = Int16.SIMD32Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.cmp_eq_Vec32xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.cmp_ne_Vec32xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.cmp_slt_Vec32xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.cmp_sle_Vec32xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.cmp_sgt_Vec32xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.cmp_sge_Vec32xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.add_Vec32xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.sub_Vec32xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.mul_Vec32xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD64<Swift.Int16> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt16) {
    _storage = SIMD64<Int16>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD64<Swift.Int16>> {
    get {
    let zero = SIMD64<Int16>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int16>(Builtin.and_Vec64xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int16>(Builtin.xor_Vec64xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int16>(Builtin.or_Vec64xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD64 where Scalar == Swift.Int16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt16) {
    _storage = Int16.SIMD64Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.cmp_eq_Vec64xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.cmp_ne_Vec64xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.cmp_slt_Vec64xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.cmp_sle_Vec64xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.cmp_sgt_Vec64xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.cmp_sge_Vec64xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.add_Vec64xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.sub_Vec64xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.mul_Vec64xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD3<Swift.Int16> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt16) {
    _storage = SIMD3<Int16>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD3<Swift.Int16>> {
    get {
    let zero = SIMD3<Int16>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int16>(Builtin.and_Vec4xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int16>(Builtin.xor_Vec4xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int16>(Builtin.or_Vec4xInt16(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD3 where Scalar == Swift.Int16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt16) {
    _storage = Int16.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_eq_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_ne_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_slt_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_sle_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_sgt_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.cmp_sge_Vec4xInt16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.add_Vec4xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.sub_Vec4xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.mul_Vec4xInt16(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &* b }
}
extension Swift.SIMD2 where Scalar == Swift.UInt32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt32) {
    _storage = UInt32.SIMD2Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.cmp_eq_Vec2xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.cmp_ne_Vec2xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.cmp_ult_Vec2xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.cmp_ule_Vec2xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.cmp_ugt_Vec2xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.cmp_uge_Vec2xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.add_Vec2xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.sub_Vec2xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.mul_Vec2xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &* b }
}
extension Swift.SIMD4 where Scalar == Swift.UInt32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt32) {
    _storage = UInt32.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_eq_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_ne_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_ult_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_ule_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_ugt_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_uge_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.add_Vec4xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.sub_Vec4xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.mul_Vec4xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &* b }
}
extension Swift.SIMD8 where Scalar == Swift.UInt32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt32) {
    _storage = UInt32.SIMD8Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.cmp_eq_Vec8xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.cmp_ne_Vec8xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.cmp_ult_Vec8xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.cmp_ule_Vec8xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.cmp_ugt_Vec8xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.cmp_uge_Vec8xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.add_Vec8xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.sub_Vec8xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.mul_Vec8xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &* b }
}
extension Swift.SIMD16 where Scalar == Swift.UInt32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt32) {
    _storage = UInt32.SIMD16Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.cmp_eq_Vec16xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.cmp_ne_Vec16xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.cmp_ult_Vec16xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.cmp_ule_Vec16xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.cmp_ugt_Vec16xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.cmp_uge_Vec16xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.add_Vec16xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.sub_Vec16xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.mul_Vec16xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &* b }
}
extension Swift.SIMD32 where Scalar == Swift.UInt32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt32) {
    _storage = UInt32.SIMD32Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.cmp_eq_Vec32xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.cmp_ne_Vec32xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.cmp_ult_Vec32xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.cmp_ule_Vec32xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.cmp_ugt_Vec32xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.cmp_uge_Vec32xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.add_Vec32xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.sub_Vec32xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.mul_Vec32xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &* b }
}
extension Swift.SIMD64 where Scalar == Swift.UInt32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt32) {
    _storage = UInt32.SIMD64Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.cmp_eq_Vec64xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.cmp_ne_Vec64xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.cmp_ult_Vec64xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.cmp_ule_Vec64xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.cmp_ugt_Vec64xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.cmp_uge_Vec64xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.add_Vec64xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.sub_Vec64xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.mul_Vec64xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &* b }
}
extension Swift.SIMD3 where Scalar == Swift.UInt32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt32) {
    _storage = UInt32.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_eq_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_ne_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_ult_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_ule_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_ugt_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_uge_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.add_Vec4xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.sub_Vec4xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.mul_Vec4xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD2<Swift.Int32> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt32) {
    _storage = SIMD2<Int32>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD2<Swift.Int32>> {
    get {
    let zero = SIMD2<Int32>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int32>(Builtin.and_Vec2xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int32>(Builtin.xor_Vec2xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int32>(Builtin.or_Vec2xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD2 where Scalar == Swift.Int32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt32) {
    _storage = Int32.SIMD2Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.cmp_eq_Vec2xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.cmp_ne_Vec2xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.cmp_slt_Vec2xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.cmp_sle_Vec2xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.cmp_sgt_Vec2xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.cmp_sge_Vec2xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.add_Vec2xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.sub_Vec2xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.mul_Vec2xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD4<Swift.Int32> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt32) {
    _storage = SIMD4<Int32>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD4<Swift.Int32>> {
    get {
    let zero = SIMD4<Int32>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int32>(Builtin.and_Vec4xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int32>(Builtin.xor_Vec4xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int32>(Builtin.or_Vec4xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD4 where Scalar == Swift.Int32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt32) {
    _storage = Int32.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_eq_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_ne_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_slt_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_sle_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_sgt_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_sge_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.add_Vec4xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.sub_Vec4xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.mul_Vec4xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD8<Swift.Int32> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt32) {
    _storage = SIMD8<Int32>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD8<Swift.Int32>> {
    get {
    let zero = SIMD8<Int32>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int32>(Builtin.and_Vec8xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int32>(Builtin.xor_Vec8xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int32>(Builtin.or_Vec8xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD8 where Scalar == Swift.Int32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt32) {
    _storage = Int32.SIMD8Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.cmp_eq_Vec8xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.cmp_ne_Vec8xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.cmp_slt_Vec8xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.cmp_sle_Vec8xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.cmp_sgt_Vec8xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.cmp_sge_Vec8xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.add_Vec8xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.sub_Vec8xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.mul_Vec8xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD16<Swift.Int32> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt32) {
    _storage = SIMD16<Int32>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD16<Swift.Int32>> {
    get {
    let zero = SIMD16<Int32>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int32>(Builtin.and_Vec16xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int32>(Builtin.xor_Vec16xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int32>(Builtin.or_Vec16xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD16 where Scalar == Swift.Int32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt32) {
    _storage = Int32.SIMD16Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.cmp_eq_Vec16xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.cmp_ne_Vec16xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.cmp_slt_Vec16xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.cmp_sle_Vec16xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.cmp_sgt_Vec16xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.cmp_sge_Vec16xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.add_Vec16xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.sub_Vec16xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.mul_Vec16xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD32<Swift.Int32> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt32) {
    _storage = SIMD32<Int32>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD32<Swift.Int32>> {
    get {
    let zero = SIMD32<Int32>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int32>(Builtin.and_Vec32xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int32>(Builtin.xor_Vec32xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int32>(Builtin.or_Vec32xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD32 where Scalar == Swift.Int32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt32) {
    _storage = Int32.SIMD32Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.cmp_eq_Vec32xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.cmp_ne_Vec32xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.cmp_slt_Vec32xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.cmp_sle_Vec32xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.cmp_sgt_Vec32xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.cmp_sge_Vec32xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.add_Vec32xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.sub_Vec32xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.mul_Vec32xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD64<Swift.Int32> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt32) {
    _storage = SIMD64<Int32>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD64<Swift.Int32>> {
    get {
    let zero = SIMD64<Int32>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int32>(Builtin.and_Vec64xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int32>(Builtin.xor_Vec64xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int32>(Builtin.or_Vec64xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD64 where Scalar == Swift.Int32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt32) {
    _storage = Int32.SIMD64Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.cmp_eq_Vec64xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.cmp_ne_Vec64xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.cmp_slt_Vec64xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.cmp_sle_Vec64xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.cmp_sgt_Vec64xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.cmp_sge_Vec64xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.add_Vec64xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.sub_Vec64xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.mul_Vec64xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD3<Swift.Int32> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt32) {
    _storage = SIMD3<Int32>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD3<Swift.Int32>> {
    get {
    let zero = SIMD3<Int32>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int32>(Builtin.and_Vec4xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int32>(Builtin.xor_Vec4xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int32>(Builtin.or_Vec4xInt32(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD3 where Scalar == Swift.Int32 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt32) {
    _storage = Int32.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_eq_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_ne_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_slt_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_sle_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_sgt_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.cmp_sge_Vec4xInt32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.add_Vec4xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.sub_Vec4xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.mul_Vec4xInt32(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &* b }
}
extension Swift.SIMD2 where Scalar == Swift.UInt64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt64) {
    _storage = UInt64.SIMD2Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_eq_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_ne_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_ult_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_ule_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_ugt_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_uge_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.add_Vec2xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.sub_Vec2xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.mul_Vec2xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &* b }
}
extension Swift.SIMD4 where Scalar == Swift.UInt64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
    _storage = UInt64.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_eq_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ne_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ult_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ule_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ugt_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_uge_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.add_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.sub_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.mul_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &* b }
}
extension Swift.SIMD8 where Scalar == Swift.UInt64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt64) {
    _storage = UInt64.SIMD8Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_eq_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_ne_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_ult_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_ule_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_ugt_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_uge_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.add_Vec8xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.sub_Vec8xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.mul_Vec8xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &* b }
}
extension Swift.SIMD16 where Scalar == Swift.UInt64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt64) {
    _storage = UInt64.SIMD16Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_eq_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_ne_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_ult_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_ule_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_ugt_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_uge_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.add_Vec16xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.sub_Vec16xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.mul_Vec16xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &* b }
}
extension Swift.SIMD32 where Scalar == Swift.UInt64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt64) {
    _storage = UInt64.SIMD32Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_eq_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_ne_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_ult_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_ule_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_ugt_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_uge_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.add_Vec32xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.sub_Vec32xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.mul_Vec32xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &* b }
}
extension Swift.SIMD64 where Scalar == Swift.UInt64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt64) {
    _storage = UInt64.SIMD64Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_eq_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_ne_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_ult_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_ule_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_ugt_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_uge_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.add_Vec64xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.sub_Vec64xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.mul_Vec64xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &* b }
}
extension Swift.SIMD3 where Scalar == Swift.UInt64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
    _storage = UInt64.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_eq_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ne_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ult_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ule_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ugt_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_uge_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.add_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.sub_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.mul_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD2<Swift.Int64> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt64) {
    _storage = SIMD2<Int64>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD2<Swift.Int64>> {
    get {
    let zero = SIMD2<Int64>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int64>(Builtin.and_Vec2xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int64>(Builtin.xor_Vec2xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int64>(Builtin.or_Vec2xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD2 where Scalar == Swift.Int64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt64) {
    _storage = Int64.SIMD2Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_eq_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_ne_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_slt_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_sle_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_sgt_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_sge_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.add_Vec2xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.sub_Vec2xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.mul_Vec2xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD4<Swift.Int64> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
    _storage = SIMD4<Int64>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD4<Swift.Int64>> {
    get {
    let zero = SIMD4<Int64>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int64>(Builtin.and_Vec4xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int64>(Builtin.xor_Vec4xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int64>(Builtin.or_Vec4xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD4 where Scalar == Swift.Int64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
    _storage = Int64.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_eq_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ne_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_slt_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_sle_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_sgt_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_sge_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.add_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.sub_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.mul_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD8<Swift.Int64> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt64) {
    _storage = SIMD8<Int64>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD8<Swift.Int64>> {
    get {
    let zero = SIMD8<Int64>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int64>(Builtin.and_Vec8xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int64>(Builtin.xor_Vec8xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int64>(Builtin.or_Vec8xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD8 where Scalar == Swift.Int64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt64) {
    _storage = Int64.SIMD8Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_eq_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_ne_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_slt_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_sle_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_sgt_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_sge_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.add_Vec8xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.sub_Vec8xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.mul_Vec8xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD16<Swift.Int64> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt64) {
    _storage = SIMD16<Int64>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD16<Swift.Int64>> {
    get {
    let zero = SIMD16<Int64>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int64>(Builtin.and_Vec16xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int64>(Builtin.xor_Vec16xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int64>(Builtin.or_Vec16xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD16 where Scalar == Swift.Int64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt64) {
    _storage = Int64.SIMD16Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_eq_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_ne_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_slt_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_sle_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_sgt_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_sge_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.add_Vec16xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.sub_Vec16xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.mul_Vec16xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD32<Swift.Int64> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt64) {
    _storage = SIMD32<Int64>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD32<Swift.Int64>> {
    get {
    let zero = SIMD32<Int64>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int64>(Builtin.and_Vec32xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int64>(Builtin.xor_Vec32xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int64>(Builtin.or_Vec32xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD32 where Scalar == Swift.Int64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt64) {
    _storage = Int64.SIMD32Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_eq_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_ne_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_slt_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_sle_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_sgt_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_sge_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.add_Vec32xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.sub_Vec32xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.mul_Vec32xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD64<Swift.Int64> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt64) {
    _storage = SIMD64<Int64>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD64<Swift.Int64>> {
    get {
    let zero = SIMD64<Int64>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int64>(Builtin.and_Vec64xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int64>(Builtin.xor_Vec64xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int64>(Builtin.or_Vec64xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD64 where Scalar == Swift.Int64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt64) {
    _storage = Int64.SIMD64Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_eq_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_ne_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_slt_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_sle_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_sgt_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_sge_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.add_Vec64xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.sub_Vec64xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.mul_Vec64xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD3<Swift.Int64> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
    _storage = SIMD3<Int64>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD3<Swift.Int64>> {
    get {
    let zero = SIMD3<Int64>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int64>(Builtin.and_Vec4xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int64>(Builtin.xor_Vec4xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int64>(Builtin.or_Vec4xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD3 where Scalar == Swift.Int64 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
    _storage = Int64.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_eq_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ne_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_slt_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_sle_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_sgt_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_sge_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.add_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.sub_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.mul_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &* b }
}
extension Swift.SIMD2 where Scalar == Swift.UInt {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt64) {
    _storage = UInt.SIMD2Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_eq_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_ne_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_ult_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_ule_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_ugt_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_uge_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.add_Vec2xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.sub_Vec2xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.mul_Vec2xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &* b }
}
extension Swift.SIMD4 where Scalar == Swift.UInt {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
    _storage = UInt.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_eq_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ne_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ult_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ule_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ugt_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_uge_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.add_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.sub_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.mul_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &* b }
}
extension Swift.SIMD8 where Scalar == Swift.UInt {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt64) {
    _storage = UInt.SIMD8Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_eq_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_ne_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_ult_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_ule_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_ugt_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_uge_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.add_Vec8xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.sub_Vec8xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.mul_Vec8xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &* b }
}
extension Swift.SIMD16 where Scalar == Swift.UInt {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt64) {
    _storage = UInt.SIMD16Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_eq_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_ne_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_ult_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_ule_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_ugt_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_uge_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.add_Vec16xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.sub_Vec16xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.mul_Vec16xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &* b }
}
extension Swift.SIMD32 where Scalar == Swift.UInt {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt64) {
    _storage = UInt.SIMD32Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_eq_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_ne_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_ult_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_ule_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_ugt_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_uge_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.add_Vec32xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.sub_Vec32xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.mul_Vec32xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &* b }
}
extension Swift.SIMD64 where Scalar == Swift.UInt {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt64) {
    _storage = UInt.SIMD64Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_eq_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_ne_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_ult_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_ule_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_ugt_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_uge_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.add_Vec64xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.sub_Vec64xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.mul_Vec64xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &* b }
}
extension Swift.SIMD3 where Scalar == Swift.UInt {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
    _storage = UInt.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_eq_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ne_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ult_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ule_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ugt_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_uge_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.add_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.sub_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.mul_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD2<Swift.Int> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt64) {
    _storage = SIMD2<Int>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD2<Swift.Int>> {
    get {
    let zero = SIMD2<Int>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int>(Builtin.and_Vec2xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int>(Builtin.xor_Vec2xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD2<Int>(Builtin.or_Vec2xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD2 where Scalar == Swift.Int {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt64) {
    _storage = Int.SIMD2Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_eq_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_ne_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_slt_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_sle_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_sgt_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.cmp_sge_Vec2xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.add_Vec2xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.sub_Vec2xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMD2<Scalar> {
    Self(Builtin.mul_Vec2xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD4<Swift.Int> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
    _storage = SIMD4<Int>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD4<Swift.Int>> {
    get {
    let zero = SIMD4<Int>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int>(Builtin.and_Vec4xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int>(Builtin.xor_Vec4xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD4<Int>(Builtin.or_Vec4xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD4 where Scalar == Swift.Int {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
    _storage = Int.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_eq_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ne_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_slt_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_sle_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_sgt_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_sge_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.add_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.sub_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMD4<Scalar> {
    Self(Builtin.mul_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD8<Swift.Int> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt64) {
    _storage = SIMD8<Int>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD8<Swift.Int>> {
    get {
    let zero = SIMD8<Int>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int>(Builtin.and_Vec8xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int>(Builtin.xor_Vec8xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD8<Int>(Builtin.or_Vec8xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD8 where Scalar == Swift.Int {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt64) {
    _storage = Int.SIMD8Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_eq_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_ne_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_slt_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_sle_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_sgt_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.cmp_sge_Vec8xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.add_Vec8xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.sub_Vec8xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMD8<Scalar> {
    Self(Builtin.mul_Vec8xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD16<Swift.Int> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt64) {
    _storage = SIMD16<Int>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD16<Swift.Int>> {
    get {
    let zero = SIMD16<Int>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int>(Builtin.and_Vec16xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int>(Builtin.xor_Vec16xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD16<Int>(Builtin.or_Vec16xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD16 where Scalar == Swift.Int {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt64) {
    _storage = Int.SIMD16Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_eq_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_ne_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_slt_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_sle_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_sgt_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.cmp_sge_Vec16xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.add_Vec16xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.sub_Vec16xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMD16<Scalar> {
    Self(Builtin.mul_Vec16xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD32<Swift.Int> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt64) {
    _storage = SIMD32<Int>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD32<Swift.Int>> {
    get {
    let zero = SIMD32<Int>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int>(Builtin.and_Vec32xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int>(Builtin.xor_Vec32xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD32<Int>(Builtin.or_Vec32xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD32 where Scalar == Swift.Int {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt64) {
    _storage = Int.SIMD32Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_eq_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_ne_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_slt_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_sle_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_sgt_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.cmp_sge_Vec32xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.add_Vec32xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.sub_Vec32xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMD32<Scalar> {
    Self(Builtin.mul_Vec32xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD64<Swift.Int> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt64) {
    _storage = SIMD64<Int>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD64<Swift.Int>> {
    get {
    let zero = SIMD64<Int>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int>(Builtin.and_Vec64xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int>(Builtin.xor_Vec64xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD64<Int>(Builtin.or_Vec64xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD64 where Scalar == Swift.Int {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt64) {
    _storage = Int.SIMD64Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_eq_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_ne_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_slt_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_sle_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_sgt_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.cmp_sge_Vec64xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.add_Vec64xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.sub_Vec64xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMD64<Scalar> {
    Self(Builtin.mul_Vec64xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) { a = a &* b }
}
extension Swift.SIMDMask where Storage == Swift.SIMD3<Swift.Int> {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
    _storage = SIMD3<Int>(_builtin)
  }
  @_alwaysEmitIntoClient internal static var allTrue: Swift.SIMDMask<Swift.SIMD3<Swift.Int>> {
    get {
    let zero = SIMD3<Int>()
    return zero .== zero
  }
  }
  @_alwaysEmitIntoClient prefix public static func .! (a: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ .allTrue
  }
  @_alwaysEmitIntoClient public static func .& (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int>(Builtin.and_Vec4xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .&= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .& b
  }
  @_alwaysEmitIntoClient public static func .^ (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int>(Builtin.xor_Vec4xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .^= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .^ b
  }
  @_alwaysEmitIntoClient public static func .| (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    Self(SIMD3<Int>(Builtin.or_Vec4xInt64(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
  @_alwaysEmitIntoClient public static func .|= (a: inout Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) {
    a = a .| b
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    .!(a .^ b)
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMDMask<Storage>, b: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    a .^ b
  }
  @_alwaysEmitIntoClient public mutating func replace(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) {
    self = replacing(with: other, where: mask)
  }
  @_alwaysEmitIntoClient public func replacing(with other: Swift.SIMDMask<Storage>, where mask: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    (self .& .!mask) .| (other .& mask)
  }
}
extension Swift.SIMD3 where Scalar == Swift.Int {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
    _storage = Int.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_eq_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_ne_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_slt_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_sle_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_sgt_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.cmp_sge_Vec4xInt64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func &+ (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.add_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &- (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.sub_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &* (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMD3<Scalar> {
    Self(Builtin.mul_Vec4xInt64(a._storage._value, b._storage._value))
  }
  @_alwaysEmitIntoClient public static func &+= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &+ b }
  @_alwaysEmitIntoClient public static func &-= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &- b }
  @_alwaysEmitIntoClient public static func &*= (a: inout Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) { a = a &* b }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.SIMD2 where Scalar == Swift.Float16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xFPIEEE16) {
    _storage = Float16.SIMD2Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.fcmp_oeq_Vec2xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.fcmp_une_Vec2xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.fcmp_olt_Vec2xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.fcmp_ole_Vec2xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.fcmp_ogt_Vec2xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt16(
      Builtin.fcmp_oge_Vec2xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.SIMD4 where Scalar == Swift.Float16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xFPIEEE16) {
    _storage = Float16.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.fcmp_oeq_Vec4xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.fcmp_une_Vec4xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.fcmp_olt_Vec4xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.fcmp_ole_Vec4xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.fcmp_ogt_Vec4xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.fcmp_oge_Vec4xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.SIMD8 where Scalar == Swift.Float16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xFPIEEE16) {
    _storage = Float16.SIMD8Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.fcmp_oeq_Vec8xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.fcmp_une_Vec8xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.fcmp_olt_Vec8xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.fcmp_ole_Vec8xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.fcmp_ogt_Vec8xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt16(
      Builtin.fcmp_oge_Vec8xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.SIMD16 where Scalar == Swift.Float16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xFPIEEE16) {
    _storage = Float16.SIMD16Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.fcmp_oeq_Vec16xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.fcmp_une_Vec16xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.fcmp_olt_Vec16xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.fcmp_ole_Vec16xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.fcmp_ogt_Vec16xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt16(
      Builtin.fcmp_oge_Vec16xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.SIMD32 where Scalar == Swift.Float16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xFPIEEE16) {
    _storage = Float16.SIMD32Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.fcmp_oeq_Vec32xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.fcmp_une_Vec32xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.fcmp_olt_Vec32xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.fcmp_ole_Vec32xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.fcmp_ogt_Vec32xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt16(
      Builtin.fcmp_oge_Vec32xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.SIMD64 where Scalar == Swift.Float16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xFPIEEE16) {
    _storage = Float16.SIMD64Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.fcmp_oeq_Vec64xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.fcmp_une_Vec64xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.fcmp_olt_Vec64xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.fcmp_ole_Vec64xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.fcmp_ogt_Vec64xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt16(
      Builtin.fcmp_oge_Vec64xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float16 {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xFPIEEE16) {
    _storage = Float16.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.fcmp_oeq_Vec4xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.fcmp_une_Vec4xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.fcmp_olt_Vec4xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.fcmp_ole_Vec4xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.fcmp_ogt_Vec4xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt16(
      Builtin.fcmp_oge_Vec4xFPIEEE16(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD2 where Scalar == Swift.Float {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xFPIEEE32) {
    _storage = Float.SIMD2Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.fcmp_oeq_Vec2xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.fcmp_une_Vec2xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.fcmp_olt_Vec2xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.fcmp_ole_Vec2xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.fcmp_ogt_Vec2xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt32(
      Builtin.fcmp_oge_Vec2xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD4 where Scalar == Swift.Float {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xFPIEEE32) {
    _storage = Float.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.fcmp_oeq_Vec4xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.fcmp_une_Vec4xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.fcmp_olt_Vec4xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.fcmp_ole_Vec4xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.fcmp_ogt_Vec4xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.fcmp_oge_Vec4xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD8 where Scalar == Swift.Float {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xFPIEEE32) {
    _storage = Float.SIMD8Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.fcmp_oeq_Vec8xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.fcmp_une_Vec8xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.fcmp_olt_Vec8xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.fcmp_ole_Vec8xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.fcmp_ogt_Vec8xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt32(
      Builtin.fcmp_oge_Vec8xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD16 where Scalar == Swift.Float {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xFPIEEE32) {
    _storage = Float.SIMD16Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.fcmp_oeq_Vec16xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.fcmp_une_Vec16xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.fcmp_olt_Vec16xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.fcmp_ole_Vec16xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.fcmp_ogt_Vec16xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt32(
      Builtin.fcmp_oge_Vec16xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD32 where Scalar == Swift.Float {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xFPIEEE32) {
    _storage = Float.SIMD32Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.fcmp_oeq_Vec32xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.fcmp_une_Vec32xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.fcmp_olt_Vec32xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.fcmp_ole_Vec32xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.fcmp_ogt_Vec32xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt32(
      Builtin.fcmp_oge_Vec32xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD64 where Scalar == Swift.Float {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xFPIEEE32) {
    _storage = Float.SIMD64Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.fcmp_oeq_Vec64xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.fcmp_une_Vec64xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.fcmp_olt_Vec64xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.fcmp_ole_Vec64xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.fcmp_ogt_Vec64xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt32(
      Builtin.fcmp_oge_Vec64xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD3 where Scalar == Swift.Float {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xFPIEEE32) {
    _storage = Float.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.fcmp_oeq_Vec4xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.fcmp_une_Vec4xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.fcmp_olt_Vec4xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.fcmp_ole_Vec4xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.fcmp_ogt_Vec4xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt32(
      Builtin.fcmp_oge_Vec4xFPIEEE32(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD2 where Scalar == Swift.Double {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xFPIEEE64) {
    _storage = Double.SIMD2Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.fcmp_oeq_Vec2xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.fcmp_une_Vec2xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.fcmp_olt_Vec2xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.fcmp_ole_Vec2xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.fcmp_ogt_Vec2xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD2<Scalar>, b: Swift.SIMD2<Scalar>) -> Swift.SIMDMask<Swift.SIMD2<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec2xInt1_Vec2xInt64(
      Builtin.fcmp_oge_Vec2xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD4 where Scalar == Swift.Double {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xFPIEEE64) {
    _storage = Double.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.fcmp_oeq_Vec4xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.fcmp_une_Vec4xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.fcmp_olt_Vec4xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.fcmp_ole_Vec4xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.fcmp_ogt_Vec4xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD4<Scalar>, b: Swift.SIMD4<Scalar>) -> Swift.SIMDMask<Swift.SIMD4<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.fcmp_oge_Vec4xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD8 where Scalar == Swift.Double {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xFPIEEE64) {
    _storage = Double.SIMD8Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.fcmp_oeq_Vec8xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.fcmp_une_Vec8xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.fcmp_olt_Vec8xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.fcmp_ole_Vec8xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.fcmp_ogt_Vec8xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD8<Scalar>, b: Swift.SIMD8<Scalar>) -> Swift.SIMDMask<Swift.SIMD8<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec8xInt1_Vec8xInt64(
      Builtin.fcmp_oge_Vec8xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD16 where Scalar == Swift.Double {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xFPIEEE64) {
    _storage = Double.SIMD16Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.fcmp_oeq_Vec16xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.fcmp_une_Vec16xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.fcmp_olt_Vec16xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.fcmp_ole_Vec16xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.fcmp_ogt_Vec16xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD16<Scalar>, b: Swift.SIMD16<Scalar>) -> Swift.SIMDMask<Swift.SIMD16<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec16xInt1_Vec16xInt64(
      Builtin.fcmp_oge_Vec16xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD32 where Scalar == Swift.Double {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xFPIEEE64) {
    _storage = Double.SIMD32Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.fcmp_oeq_Vec32xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.fcmp_une_Vec32xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.fcmp_olt_Vec32xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.fcmp_ole_Vec32xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.fcmp_ogt_Vec32xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD32<Scalar>, b: Swift.SIMD32<Scalar>) -> Swift.SIMDMask<Swift.SIMD32<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec32xInt1_Vec32xInt64(
      Builtin.fcmp_oge_Vec32xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD64 where Scalar == Swift.Double {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xFPIEEE64) {
    _storage = Double.SIMD64Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.fcmp_oeq_Vec64xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.fcmp_une_Vec64xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.fcmp_olt_Vec64xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.fcmp_ole_Vec64xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.fcmp_ogt_Vec64xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD64<Scalar>, b: Swift.SIMD64<Scalar>) -> Swift.SIMDMask<Swift.SIMD64<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec64xInt1_Vec64xInt64(
      Builtin.fcmp_oge_Vec64xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
}
extension Swift.SIMD3 where Scalar == Swift.Double {
  @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xFPIEEE64) {
    _storage = Double.SIMD4Storage(_builtin)
  }
  @_alwaysEmitIntoClient public static func .== (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.fcmp_oeq_Vec4xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .!= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.fcmp_une_Vec4xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .< (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.fcmp_olt_Vec4xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .<= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.fcmp_ole_Vec4xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .> (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.fcmp_ogt_Vec4xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
  @_alwaysEmitIntoClient public static func .>= (a: Swift.SIMD3<Scalar>, b: Swift.SIMD3<Scalar>) -> Swift.SIMDMask<Swift.SIMD3<Scalar>.MaskStorage> {
    SIMDMask<MaskStorage>(Builtin.sext_Vec4xInt1_Vec4xInt64(
      Builtin.fcmp_oge_Vec4xFPIEEE64(a._storage._value, b._storage._value)
    ))
  }
}
@frozen public struct SIMD2<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD2Storage
  public typealias MaskStorage = Swift.SIMD2<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 2
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD2Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar) {
    self.init()
 
    self[0] = v0
 
    self[1] = v1
 
  }
  @_transparent public init(x: Scalar, y: Scalar) {
    self.init(x, y)
  }
  @_transparent public var x: Scalar {
    @_transparent get { return self[0]}
    @_transparent set { self[0] = newValue }
  }
  @_transparent public var y: Scalar {
    @_transparent get { return self[1]}
    @_transparent set { self[1] = newValue }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.SIMD2 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD2<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD2<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD2<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
     
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension Swift.SIMD2 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.SIMD2 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD2<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD2<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
extension Swift.SIMD2 : Swift.Sendable where Scalar : Swift.Sendable, Scalar.SIMD2Storage : Swift.Sendable {
}
extension Swift.SIMD2 : Swift.BitwiseCopyable where Scalar.SIMD2Storage : Swift.BitwiseCopyable {
}
@frozen public struct SIMD4<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD4Storage
  public typealias MaskStorage = Swift.SIMD4<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 4
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD4Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar) {
    self.init()
 
    self[0] = v0
 
    self[1] = v1
 
    self[2] = v2
 
    self[3] = v3
 
  }
  @_transparent public init(x: Scalar, y: Scalar, z: Scalar, w: Scalar) {
    self.init(x, y, z, w)
  }
  @_transparent public var x: Scalar {
    @_transparent get { return self[0]}
    @_transparent set { self[0] = newValue }
  }
  @_transparent public var y: Scalar {
    @_transparent get { return self[1]}
    @_transparent set { self[1] = newValue }
  }
  @_transparent public var z: Scalar {
    @_transparent get { return self[2]}
    @_transparent set { self[2] = newValue }
  }
  @_transparent public var w: Scalar {
    @_transparent get { return self[3]}
    @_transparent set { self[3] = newValue }
  }
  @_transparent public init(lowHalf: Swift.SIMD2<Scalar>, highHalf: Swift.SIMD2<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: Swift.SIMD2<Scalar> {
    @inlinable get {
      var result = SIMD2<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: Swift.SIMD2<Scalar> {
    @inlinable get {
      var result = SIMD2<Scalar>()
      for i in result.indices { result[i] = self[2+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2+i] = newValue[i] }
    }
  }
  public var evenHalf: Swift.SIMD2<Scalar> {
    @inlinable get {
      var result = SIMD2<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: Swift.SIMD2<Scalar> {
    @inlinable get {
      var result = SIMD2<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.SIMD4 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD4<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD4<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD4<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
     
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension Swift.SIMD4 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.SIMD4 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD4<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD4<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
extension Swift.SIMD4 : Swift.Sendable where Scalar : Swift.Sendable, Scalar.SIMD4Storage : Swift.Sendable {
}
extension Swift.SIMD4 : Swift.BitwiseCopyable where Scalar.SIMD4Storage : Swift.BitwiseCopyable {
}
@frozen public struct SIMD8<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD8Storage
  public typealias MaskStorage = Swift.SIMD8<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 8
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD8Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar, _ v4: Scalar, _ v5: Scalar, _ v6: Scalar, _ v7: Scalar) {
    self.init()
 
    self[0] = v0
 
    self[1] = v1
 
    self[2] = v2
 
    self[3] = v3
 
    self[4] = v4
 
    self[5] = v5
 
    self[6] = v6
 
    self[7] = v7
 
  }
  @_transparent public init(lowHalf: Swift.SIMD4<Scalar>, highHalf: Swift.SIMD4<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: Swift.SIMD4<Scalar> {
    @inlinable get {
      var result = SIMD4<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: Swift.SIMD4<Scalar> {
    @inlinable get {
      var result = SIMD4<Scalar>()
      for i in result.indices { result[i] = self[4+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[4+i] = newValue[i] }
    }
  }
  public var evenHalf: Swift.SIMD4<Scalar> {
    @inlinable get {
      var result = SIMD4<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: Swift.SIMD4<Scalar> {
    @inlinable get {
      var result = SIMD4<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.SIMD8 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD8<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD8<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD8<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
     
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension Swift.SIMD8 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.SIMD8 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD8<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD8<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
extension Swift.SIMD8 : Swift.Sendable where Scalar : Swift.Sendable, Scalar.SIMD8Storage : Swift.Sendable {
}
extension Swift.SIMD8 : Swift.BitwiseCopyable where Scalar.SIMD8Storage : Swift.BitwiseCopyable {
}
@frozen public struct SIMD16<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD16Storage
  public typealias MaskStorage = Swift.SIMD16<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 16
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD16Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar, _ v4: Scalar, _ v5: Scalar, _ v6: Scalar, _ v7: Scalar, _ v8: Scalar, _ v9: Scalar, _ v10: Scalar, _ v11: Scalar, _ v12: Scalar, _ v13: Scalar, _ v14: Scalar, _ v15: Scalar) {
    self.init()
 
    self[0] = v0
 
    self[1] = v1
 
    self[2] = v2
 
    self[3] = v3
 
    self[4] = v4
 
    self[5] = v5
 
    self[6] = v6
 
    self[7] = v7
 
    self[8] = v8
 
    self[9] = v9
 
    self[10] = v10
 
    self[11] = v11
 
    self[12] = v12
 
    self[13] = v13
 
    self[14] = v14
 
    self[15] = v15
 
  }
  @_transparent public init(lowHalf: Swift.SIMD8<Scalar>, highHalf: Swift.SIMD8<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: Swift.SIMD8<Scalar> {
    @inlinable get {
      var result = SIMD8<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: Swift.SIMD8<Scalar> {
    @inlinable get {
      var result = SIMD8<Scalar>()
      for i in result.indices { result[i] = self[8+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[8+i] = newValue[i] }
    }
  }
  public var evenHalf: Swift.SIMD8<Scalar> {
    @inlinable get {
      var result = SIMD8<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: Swift.SIMD8<Scalar> {
    @inlinable get {
      var result = SIMD8<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.SIMD16 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD16<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD16<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD16<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
     
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension Swift.SIMD16 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.SIMD16 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD16<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD16<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
extension Swift.SIMD16 : Swift.Sendable where Scalar : Swift.Sendable, Scalar.SIMD16Storage : Swift.Sendable {
}
extension Swift.SIMD16 : Swift.BitwiseCopyable where Scalar.SIMD16Storage : Swift.BitwiseCopyable {
}
@frozen public struct SIMD32<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD32Storage
  public typealias MaskStorage = Swift.SIMD32<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 32
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD32Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar, _ v4: Scalar, _ v5: Scalar, _ v6: Scalar, _ v7: Scalar, _ v8: Scalar, _ v9: Scalar, _ v10: Scalar, _ v11: Scalar, _ v12: Scalar, _ v13: Scalar, _ v14: Scalar, _ v15: Scalar, _ v16: Scalar, _ v17: Scalar, _ v18: Scalar, _ v19: Scalar, _ v20: Scalar, _ v21: Scalar, _ v22: Scalar, _ v23: Scalar, _ v24: Scalar, _ v25: Scalar, _ v26: Scalar, _ v27: Scalar, _ v28: Scalar, _ v29: Scalar, _ v30: Scalar, _ v31: Scalar) {
    self.init()
 
    self[0] = v0
 
    self[1] = v1
 
    self[2] = v2
 
    self[3] = v3
 
    self[4] = v4
 
    self[5] = v5
 
    self[6] = v6
 
    self[7] = v7
 
    self[8] = v8
 
    self[9] = v9
 
    self[10] = v10
 
    self[11] = v11
 
    self[12] = v12
 
    self[13] = v13
 
    self[14] = v14
 
    self[15] = v15
 
    self[16] = v16
 
    self[17] = v17
 
    self[18] = v18
 
    self[19] = v19
 
    self[20] = v20
 
    self[21] = v21
 
    self[22] = v22
 
    self[23] = v23
 
    self[24] = v24
 
    self[25] = v25
 
    self[26] = v26
 
    self[27] = v27
 
    self[28] = v28
 
    self[29] = v29
 
    self[30] = v30
 
    self[31] = v31
 
  }
  @_transparent public init(lowHalf: Swift.SIMD16<Scalar>, highHalf: Swift.SIMD16<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: Swift.SIMD16<Scalar> {
    @inlinable get {
      var result = SIMD16<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: Swift.SIMD16<Scalar> {
    @inlinable get {
      var result = SIMD16<Scalar>()
      for i in result.indices { result[i] = self[16+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[16+i] = newValue[i] }
    }
  }
  public var evenHalf: Swift.SIMD16<Scalar> {
    @inlinable get {
      var result = SIMD16<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: Swift.SIMD16<Scalar> {
    @inlinable get {
      var result = SIMD16<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.SIMD32 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD32<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD32<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD32<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
     
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension Swift.SIMD32 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.SIMD32 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD32<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD32<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
extension Swift.SIMD32 : Swift.Sendable where Scalar : Swift.Sendable, Scalar.SIMD32Storage : Swift.Sendable {
}
extension Swift.SIMD32 : Swift.BitwiseCopyable where Scalar.SIMD32Storage : Swift.BitwiseCopyable {
}
@frozen public struct SIMD64<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD64Storage
  public typealias MaskStorage = Swift.SIMD64<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 64
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD64Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar, _ v4: Scalar, _ v5: Scalar, _ v6: Scalar, _ v7: Scalar, _ v8: Scalar, _ v9: Scalar, _ v10: Scalar, _ v11: Scalar, _ v12: Scalar, _ v13: Scalar, _ v14: Scalar, _ v15: Scalar, _ v16: Scalar, _ v17: Scalar, _ v18: Scalar, _ v19: Scalar, _ v20: Scalar, _ v21: Scalar, _ v22: Scalar, _ v23: Scalar, _ v24: Scalar, _ v25: Scalar, _ v26: Scalar, _ v27: Scalar, _ v28: Scalar, _ v29: Scalar, _ v30: Scalar, _ v31: Scalar, _ v32: Scalar, _ v33: Scalar, _ v34: Scalar, _ v35: Scalar, _ v36: Scalar, _ v37: Scalar, _ v38: Scalar, _ v39: Scalar, _ v40: Scalar, _ v41: Scalar, _ v42: Scalar, _ v43: Scalar, _ v44: Scalar, _ v45: Scalar, _ v46: Scalar, _ v47: Scalar, _ v48: Scalar, _ v49: Scalar, _ v50: Scalar, _ v51: Scalar, _ v52: Scalar, _ v53: Scalar, _ v54: Scalar, _ v55: Scalar, _ v56: Scalar, _ v57: Scalar, _ v58: Scalar, _ v59: Scalar, _ v60: Scalar, _ v61: Scalar, _ v62: Scalar, _ v63: Scalar) {
    self.init()
 
    self[0] = v0
 
    self[1] = v1
 
    self[2] = v2
 
    self[3] = v3
 
    self[4] = v4
 
    self[5] = v5
 
    self[6] = v6
 
    self[7] = v7
 
    self[8] = v8
 
    self[9] = v9
 
    self[10] = v10
 
    self[11] = v11
 
    self[12] = v12
 
    self[13] = v13
 
    self[14] = v14
 
    self[15] = v15
 
    self[16] = v16
 
    self[17] = v17
 
    self[18] = v18
 
    self[19] = v19
 
    self[20] = v20
 
    self[21] = v21
 
    self[22] = v22
 
    self[23] = v23
 
    self[24] = v24
 
    self[25] = v25
 
    self[26] = v26
 
    self[27] = v27
 
    self[28] = v28
 
    self[29] = v29
 
    self[30] = v30
 
    self[31] = v31
 
    self[32] = v32
 
    self[33] = v33
 
    self[34] = v34
 
    self[35] = v35
 
    self[36] = v36
 
    self[37] = v37
 
    self[38] = v38
 
    self[39] = v39
 
    self[40] = v40
 
    self[41] = v41
 
    self[42] = v42
 
    self[43] = v43
 
    self[44] = v44
 
    self[45] = v45
 
    self[46] = v46
 
    self[47] = v47
 
    self[48] = v48
 
    self[49] = v49
 
    self[50] = v50
 
    self[51] = v51
 
    self[52] = v52
 
    self[53] = v53
 
    self[54] = v54
 
    self[55] = v55
 
    self[56] = v56
 
    self[57] = v57
 
    self[58] = v58
 
    self[59] = v59
 
    self[60] = v60
 
    self[61] = v61
 
    self[62] = v62
 
    self[63] = v63
 
  }
  @_transparent public init(lowHalf: Swift.SIMD32<Scalar>, highHalf: Swift.SIMD32<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: Swift.SIMD32<Scalar> {
    @inlinable get {
      var result = SIMD32<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: Swift.SIMD32<Scalar> {
    @inlinable get {
      var result = SIMD32<Scalar>()
      for i in result.indices { result[i] = self[32+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[32+i] = newValue[i] }
    }
  }
  public var evenHalf: Swift.SIMD32<Scalar> {
    @inlinable get {
      var result = SIMD32<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: Swift.SIMD32<Scalar> {
    @inlinable get {
      var result = SIMD32<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.SIMD64 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD64<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD64<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD64<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
     
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension Swift.SIMD64 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.SIMD64 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD64<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD64<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
extension Swift.SIMD64 : Swift.Sendable where Scalar : Swift.Sendable, Scalar.SIMD64Storage : Swift.Sendable {
}
extension Swift.SIMD64 : Swift.BitwiseCopyable where Scalar.SIMD64Storage : Swift.BitwiseCopyable {
}
@frozen public struct SIMD3<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD4Storage
  public typealias MaskStorage = Swift.SIMD3<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 3
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD4Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar) {
    self.init()
 
    self[0] = v0
 
    self[1] = v1
 
    self[2] = v2
 
  }
  @_transparent public init(x: Scalar, y: Scalar, z: Scalar) {
    self.init(x, y, z)
  }
  @_transparent public var x: Scalar {
    @_transparent get { return self[0]}
    @_transparent set { self[0] = newValue }
  }
  @_transparent public var y: Scalar {
    @_transparent get { return self[1]}
    @_transparent set { self[1] = newValue }
  }
  @_transparent public var z: Scalar {
    @_transparent get { return self[2]}
    @_transparent set { self[2] = newValue }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.SIMD3 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD3<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD3<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD3<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
     
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension Swift.SIMD3 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.SIMD3 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD3<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD3<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
extension Swift.SIMD3 : Swift.Sendable where Scalar : Swift.Sendable, Scalar.SIMD4Storage : Swift.Sendable {
}
extension Swift.SIMD3 : Swift.BitwiseCopyable where Scalar.SIMD4Storage : Swift.BitwiseCopyable {
}
extension Swift.SIMD3 {
  @_alwaysEmitIntoClient public init(_ xy: Swift.SIMD2<Scalar>, _ z: Scalar) {
    self.init(xy.x, xy.y, z)
  }
}
extension Swift.SIMD4 {
  @_alwaysEmitIntoClient public init(_ xyz: Swift.SIMD3<Scalar>, _ w: Scalar) {
    self.init(xyz.x, xyz.y, xyz.z, w)
  }
}
extension Swift.UInt8 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int8
  @frozen @_alignment(2) public struct SIMD2Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec2xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt8) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec2xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @frozen @_alignment(4) public struct SIMD4Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec4xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt8) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec4xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @frozen @_alignment(8) public struct SIMD8Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec8xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt8) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec8xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec16xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt8) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec16xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec32xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt8) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec32xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec64xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt8) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec64xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
}
extension Swift.Int8 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int8
  @frozen @_alignment(2) public struct SIMD2Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec2xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt8) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec2xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @frozen @_alignment(4) public struct SIMD4Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec4xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt8) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec4xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @frozen @_alignment(8) public struct SIMD8Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec8xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt8) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec8xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec16xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt8) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec16xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec32xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt8) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec32xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec64xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt8) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec64xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
}
extension Swift.UInt16 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int16
  @frozen @_alignment(4) public struct SIMD2Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec2xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec2xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @frozen @_alignment(8) public struct SIMD4Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec4xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec4xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec8xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec8xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec16xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec16xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec32xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec32xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec64xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec64xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
}
extension Swift.Int16 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int16
  @frozen @_alignment(4) public struct SIMD2Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec2xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec2xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @frozen @_alignment(8) public struct SIMD4Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec4xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec4xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec8xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec8xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec16xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec16xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec32xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec32xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec64xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec64xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
}
extension Swift.UInt32 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int32
  @frozen @_alignment(8) public struct SIMD2Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec2xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec2xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec4xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec4xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec8xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec8xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec16xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec16xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec32xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec32xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec64xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec64xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
}
extension Swift.Int32 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int32
  @frozen @_alignment(8) public struct SIMD2Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec2xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec2xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec4xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec4xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec8xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec8xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec16xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec16xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec32xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec32xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec64xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec64xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
}
extension Swift.UInt64 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int64
  @frozen @_alignment(16) public struct SIMD2Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec2xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec2xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec4xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec4xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec8xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec8xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec16xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec16xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec32xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec32xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec64xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec64xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
}
extension Swift.Int64 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int64
  @frozen @_alignment(16) public struct SIMD2Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec2xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec2xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec4xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec4xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec8xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec8xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec16xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec16xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec32xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec32xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec64xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec64xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
}
extension Swift.UInt : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int
  @frozen @_alignment(16) public struct SIMD2Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec2xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec2xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec4xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec4xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec8xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec8xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec16xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec16xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec32xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec32xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec64xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec64xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
}
extension Swift.Int : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int
  @frozen @_alignment(16) public struct SIMD2Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec2xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec2xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec4xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec4xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec8xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec8xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec16xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec16xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec32xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec32xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec64xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xInt64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec64xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.Float16 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int16
  @frozen @_alignment(4) public struct SIMD2Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec2xFPIEEE16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xFPIEEE16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Float16 {
      @_transparent get {
        return Float16(Builtin.extractelement_Vec2xFPIEEE16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xFPIEEE16_FPIEEE16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Scalar = Swift.Float16
  }
  @frozen @_alignment(8) public struct SIMD4Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec4xFPIEEE16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xFPIEEE16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Float16 {
      @_transparent get {
        return Float16(Builtin.extractelement_Vec4xFPIEEE16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xFPIEEE16_FPIEEE16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Scalar = Swift.Float16
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec8xFPIEEE16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xFPIEEE16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Float16 {
      @_transparent get {
        return Float16(Builtin.extractelement_Vec8xFPIEEE16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xFPIEEE16_FPIEEE16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Scalar = Swift.Float16
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec16xFPIEEE16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xFPIEEE16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Float16 {
      @_transparent get {
        return Float16(Builtin.extractelement_Vec16xFPIEEE16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xFPIEEE16_FPIEEE16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Scalar = Swift.Float16
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec32xFPIEEE16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xFPIEEE16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Float16 {
      @_transparent get {
        return Float16(Builtin.extractelement_Vec32xFPIEEE16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xFPIEEE16_FPIEEE16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Scalar = Swift.Float16
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec64xFPIEEE16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xFPIEEE16) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Float16 {
      @_transparent get {
        return Float16(Builtin.extractelement_Vec64xFPIEEE16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xFPIEEE16_FPIEEE16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Scalar = Swift.Float16
  }
}
extension Swift.Float : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int32
  @frozen @_alignment(8) public struct SIMD2Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec2xFPIEEE32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xFPIEEE32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec2xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec4xFPIEEE32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xFPIEEE32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec4xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec8xFPIEEE32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xFPIEEE32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec8xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec16xFPIEEE32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xFPIEEE32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec16xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec32xFPIEEE32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xFPIEEE32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec32xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec64xFPIEEE32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xFPIEEE32) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec64xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
}
extension Swift.Double : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int64
  @frozen @_alignment(16) public struct SIMD2Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec2xFPIEEE64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec2xFPIEEE64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec2xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec4xFPIEEE64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec4xFPIEEE64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec4xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec8xFPIEEE64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec8xFPIEEE64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec8xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec16xFPIEEE64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec16xFPIEEE64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec16xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec32xFPIEEE64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec32xFPIEEE64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec32xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage, Swift.Sendable, Swift.BitwiseCopyable {
    public var _value: Builtin.Vec64xFPIEEE64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    @_alwaysEmitIntoClient internal init(_ _builtin: Builtin.Vec64xFPIEEE64) {
      _value = _builtin
    }
    public subscript(index: Swift.Int) -> Swift.Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec64xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
}
extension Swift._ArrayBody : Swift.Sendable {}
extension Swift._ArrayBody : Swift.BitwiseCopyable {}
extension Swift._DependenceToken : Swift.Sendable {}
extension Swift._DependenceToken : Swift.BitwiseCopyable {}
extension Swift.Unicode : Swift.Sendable {}
extension Swift.Unicode.ASCII : Swift.Sendable {}
extension Swift.Unicode.ASCII : Swift.BitwiseCopyable {}
extension Swift.Unicode.ASCII.Parser : Swift.Sendable {}
extension Swift.Unicode.ASCII.Parser : Swift.BitwiseCopyable {}
extension Swift._UnsafeBitset : Swift.BitwiseCopyable {}
extension Swift._UnsafeBitset.Iterator : Swift.BitwiseCopyable {}
extension Swift._UnsafeBitset.Word : Swift.BitwiseCopyable {}
extension Swift._UnsafeBitset.Word : Swift.Sendable {}
extension Swift.Bool : Swift.BitwiseCopyable {}
extension Swift._BridgeStorage : Swift.Sendable {}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.ManagedBufferPointer : Swift.Sendable {}
#else
extension Swift.ManagedBufferPointer : Swift.Sendable {}
#endif
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 : Swift.BitwiseCopyable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 : Swift.BitwiseCopyable {}
extension Swift.UnsafeRawBufferPointer : Swift.BitwiseCopyable {}
extension Swift.UnsafeMutableRawBufferPointer : Swift.BitwiseCopyable {}
extension Swift.OpaquePointer : Swift.BitwiseCopyable {}
extension Swift.CVaListPointer : Swift.BitwiseCopyable {}
extension Swift._DebuggerSupport : Swift.Sendable {}
extension Swift._DebuggerSupport : Swift.BitwiseCopyable {}
extension Swift._MergeError : Swift.Equatable {}
extension Swift._MergeError : Swift.Hashable {}
extension Swift._MergeError : Swift.BitwiseCopyable {}
extension Swift.__CocoaDictionary.Index : Swift.Sendable {}
extension Swift.Dictionary._Variant : Swift.Sendable {}
extension Swift.EmptyCollection : Swift.BitwiseCopyable {}
extension Swift.EmptyCollection.Iterator : Swift.BitwiseCopyable {}
extension Swift.FloatingPointSign : Swift.Equatable {}
extension Swift.FloatingPointSign : Swift.Hashable {}
extension Swift.FloatingPointSign : Swift.RawRepresentable {}
extension Swift.FloatingPointSign : Swift.BitwiseCopyable {}
extension Swift.FloatingPointClassification : Swift.Equatable {}
extension Swift.FloatingPointClassification : Swift.Hashable {}
extension Swift.FloatingPointClassification : Swift.BitwiseCopyable {}
extension Swift.FloatingPointRoundingRule : Swift.Equatable {}
extension Swift.FloatingPointRoundingRule : Swift.Hashable {}
extension Swift.Hasher : Swift.Sendable {}
extension Swift.Hasher : Swift.BitwiseCopyable {}
extension Swift.Hasher._TailBuffer : Swift.Sendable {}
extension Swift.Hasher._TailBuffer : Swift.BitwiseCopyable {}
extension Swift.Hasher._Core : Swift.Sendable {}
extension Swift.Hasher._Core : Swift.BitwiseCopyable {}
extension Swift._HashTable : Swift.BitwiseCopyable {}
extension Swift._HashTable.Bucket : Swift.Sendable {}
extension Swift._HashTable.Bucket : Swift.BitwiseCopyable {}
extension Swift._HashTable.Index : Swift.Sendable {}
extension Swift._HashTable.Index : Swift.BitwiseCopyable {}
extension Swift._HashTable.Iterator : Swift.BitwiseCopyable {}
extension Swift.JoinedSequence.Iterator._JoinIteratorState : Swift.Equatable {}
extension Swift.JoinedSequence.Iterator._JoinIteratorState : Swift.Hashable {}
extension Swift.JoinedSequence.Iterator._JoinIteratorState : Swift.Sendable {}
extension Swift.JoinedSequence.Iterator._JoinIteratorState : Swift.BitwiseCopyable {}
extension Swift.Unicode.UTF16 : Swift.BitwiseCopyable {}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.MemoryLayout : Swift.Sendable {}
#else
extension Swift.MemoryLayout : Swift.Sendable {}
#endif
extension Swift.Unicode.Scalar : Swift.BitwiseCopyable {}
extension Swift.Unicode.Scalar.UTF16View : Swift.BitwiseCopyable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.Unicode.Scalar.UTF8View : Swift.BitwiseCopyable {}
extension Swift.ObjectIdentifier : Swift.BitwiseCopyable {}
extension Swift._OptionalNilComparisonType : Swift.Sendable {}
extension Swift._OptionalNilComparisonType : Swift.BitwiseCopyable {}
extension Swift.Set._Variant : Swift.Sendable {}
extension Swift.SystemRandomNumberGenerator : Swift.BitwiseCopyable {}
extension Swift.UnboundedRange_ : Swift.Sendable {}
extension Swift.UnboundedRange_ : Swift.BitwiseCopyable {}
extension Swift.Hasher._State : Swift.Sendable {}
extension Swift.Hasher._State : Swift.BitwiseCopyable {}
extension Swift.Set.Index._Variant : Swift.Sendable {}
extension Swift.__CocoaSet.Index : Swift.Sendable {}
extension Swift._SmallString : Swift.Sendable {}
extension Swift._SmallString : Swift.BitwiseCopyable {}
extension Swift.StaticString : Swift.BitwiseCopyable {}
extension Swift._StringComparisonResult : Swift.Equatable {}
extension Swift._StringComparisonResult : Swift.Hashable {}
extension Swift._StringComparisonResult : Swift.Sendable {}
extension Swift._StringComparisonResult : Swift.BitwiseCopyable {}
extension Swift._StringObject : Swift.Sendable {}
extension Swift._StringObject.Nibbles : Swift.Sendable {}
extension Swift._StringObject.Nibbles : Swift.BitwiseCopyable {}
extension Swift._StringObject.CountAndFlags : Swift.Sendable {}
extension Swift._StringObject.CountAndFlags : Swift.BitwiseCopyable {}
extension Swift.String.Index : Swift.BitwiseCopyable {}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeBufferPointer : Swift.BitwiseCopyable {}
#else
extension Swift.UnsafeBufferPointer : Swift.BitwiseCopyable {}
#endif
extension Swift._OpaqueStringSwitchCache : Swift.Sendable {}
extension Swift._OpaqueStringSwitchCache : Swift.BitwiseCopyable {}
extension Swift._UIntBuffer : Swift.BitwiseCopyable {}
extension Swift._UIntBuffer.Iterator : Swift.BitwiseCopyable {}
extension Swift._UIntBuffer.Index : Swift.Sendable {}
extension Swift._UIntBuffer.Index : Swift.BitwiseCopyable {}
extension Swift.Unicode.GeneralCategory : Swift.Equatable {}
extension Swift.Unicode.GeneralCategory : Swift.Hashable {}
extension Swift.Unicode.NumericType : Swift.Equatable {}
extension Swift.Unicode.NumericType : Swift.Hashable {}
extension Swift.Unmanaged : Swift.BitwiseCopyable {}
extension Swift.Unicode.UTF8 : Swift.BitwiseCopyable {}
extension Swift.Unicode.UTF8.ForwardParser : Swift.BitwiseCopyable {}
extension Swift.Unicode.UTF8.ReverseParser : Swift.BitwiseCopyable {}
extension Swift.Unicode.UTF16.ForwardParser : Swift.BitwiseCopyable {}
extension Swift.Unicode.UTF16.ReverseParser : Swift.BitwiseCopyable {}
extension Swift.Unicode.UTF32 : Swift.Equatable {}
extension Swift.Unicode.UTF32 : Swift.Hashable {}
extension Swift.Unicode.UTF32 : Swift.BitwiseCopyable {}
extension Swift.Unicode.UTF32.Parser : Swift.BitwiseCopyable {}
extension Swift.UnicodeDecodingResult : Swift.BitwiseCopyable {}
extension Swift._ValidUTF8Buffer : Swift.Sendable {}
extension Swift._ValidUTF8Buffer : Swift.BitwiseCopyable {}
extension Swift._ValidUTF8Buffer.Iterator : Swift.Sendable {}
extension Swift._ValidUTF8Buffer.Iterator : Swift.BitwiseCopyable {}
extension Swift._ValidUTF8Buffer.Index : Swift.Sendable {}
extension Swift._ValidUTF8Buffer.Index : Swift.BitwiseCopyable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Swift.CollectionDifference.Index : Swift.BitwiseCopyable {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Duration : Swift.BitwiseCopyable {}
extension Swift.Mirror.DisplayStyle : Swift.Equatable {}
extension Swift.Mirror.DisplayStyle : Swift.Hashable {}
extension Swift.CommandLine : Swift.Sendable {}
@available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
extension Swift.StaticBigInt : Swift.BitwiseCopyable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128.Words : Swift.Sendable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128.Words : Swift.BitwiseCopyable {}
@available(*, unavailable, message: "Float80 is not available on target platform.")
extension Swift.Float80 : Swift.Sendable {}
@available(*, unavailable, message: "Float80 is not available on target platform.")
extension Swift.Float80 : Swift.BitwiseCopyable {}
extension Swift.UInt8.Words : Swift.BitwiseCopyable {}
extension Swift.Int8.Words : Swift.BitwiseCopyable {}
extension Swift.UInt16.Words : Swift.BitwiseCopyable {}
extension Swift.Int16.Words : Swift.BitwiseCopyable {}
extension Swift.UInt32.Words : Swift.BitwiseCopyable {}
extension Swift.Int32.Words : Swift.BitwiseCopyable {}
extension Swift.UInt64.Words : Swift.BitwiseCopyable {}
extension Swift.Int64.Words : Swift.BitwiseCopyable {}
extension Swift.UInt.Words : Swift.BitwiseCopyable {}
extension Swift.Int.Words : Swift.BitwiseCopyable {}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutableBufferPointer : Swift.BitwiseCopyable {}
#else
extension Swift.UnsafeMutableBufferPointer : Swift.BitwiseCopyable {}
#endif
extension Swift.UnsafeRawBufferPointer.Iterator : Swift.BitwiseCopyable {}
