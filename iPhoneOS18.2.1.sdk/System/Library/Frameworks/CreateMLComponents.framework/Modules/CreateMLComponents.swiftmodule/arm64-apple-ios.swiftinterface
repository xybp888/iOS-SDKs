// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.6 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios18.2 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Osize -library-level api -enable-upcoming-feature StrictConcurrency -enable-bare-slash-regex -user-module-version 1357.60.3 -module-name CreateMLComponents
import AVFAudio
import AVFoundation
import Accelerate
import Combine
import CoreGraphics
import CoreImage
import CoreML
import CoreMedia
import CoreVideo
import Foundation
import OSLog
import RegexBuilder
import SoundAnalysis
import Swift
import TabularData
import UniformTypeIdentifiers
import Vision
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os
extension CreateMLComponents.Transformer {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func adaptedAsRandomTransformer() -> some CreateMLComponents.RandomTransformer<Self.Input, Self.Output>
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.FullyConnectedNetworkClassifier {
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.FullyConnectedNetworkClassifierModel<Scalar, Label>
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.FullyConnectedNetworkClassifier<Scalar, Label>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.FullyConnectedNetworkClassifier<Scalar, Label>.Transformer
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct ApplyEachRandomly<Element> : CreateMLComponents.RandomTransformer {
  public let probability: Swift.Double
  public init<RandomTransformer>(probability: Swift.Double = 0.5, @CreateMLComponents.AugmentationBuilder<Element> _ augmentation: () -> RandomTransformer) where Element == RandomTransformer.Input, RandomTransformer : CreateMLComponents.RandomTransformer, RandomTransformer.Input == RandomTransformer.Output
  public func applied(to input: Element, generator: inout some RandomNumberGenerator, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Element
  @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
  public typealias Input = Element
  @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
  public typealias Output = Element
}
@available(*, unavailable)
extension CreateMLComponents.ApplyEachRandomly : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
public struct ImageRotator : CreateMLComponents.Transformer, Swift.Sendable {
  public var angle: Swift.Double
  public init(angle: Swift.Double)
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) -> CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Input = CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Output = CoreImage.CIImage
}
extension CreateMLComponents.UpdatableEstimator {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self.Transformer>, Other>> where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self.Transformer>, Other.Transformer>> where Other : CreateMLComponents.UpdatableTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.UpdatableTemporalEstimator {
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, CreateMLComponents.TransformerToTemporalAdaptor<Other>>> where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, CreateMLComponents.TransformerToTemporalAdaptor<Other.Transformer>>> where Other : CreateMLComponents.UpdatableEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, Other>> where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, Other.Transformer>> where Other : CreateMLComponents.UpdatableTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct AudioFeaturePrint : CreateMLComponents.TemporalTransformer, Swift.Sendable {
  public typealias Input = AVFAudio.AVAudioPCMBuffer
  public typealias Output = CoreML.MLShapedArray<Swift.Float>
  public let windowDuration: Foundation.TimeInterval
  public let overlapFactor: Swift.Double
  public init(windowDuration: Foundation.TimeInterval, overlapFactor: Swift.Double)
  public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.AudioFeaturePrint.FeatureSequence where S : CreateMLComponents.TemporalSequence, S.Feature == AVFAudio.AVAudioPCMBuffer
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias OutputSequence = CreateMLComponents.AudioFeaturePrint.FeatureSequence
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioFeaturePrint : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioFeaturePrint {
  public struct FeatureSequence : CreateMLComponents.TemporalSequence {
    public typealias Feature = CoreML.MLShapedArray<Swift.Float>
    public typealias AsyncIterator = CreateMLComponents.AudioFeaturePrint.FeatureSequence.Iterator
    public var count: Swift.Int? {
      get
    }
    public func makeAsyncIterator() -> CreateMLComponents.AudioFeaturePrint.FeatureSequence.AsyncIterator
    @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.AudioFeaturePrint.FeatureSequence.Feature>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncSequence_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
extension CreateMLComponents.AudioFeaturePrint.FeatureSequence : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioFeaturePrint.FeatureSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public mutating func next() async throws -> CreateMLComponents.TemporalFeature<CoreML.MLShapedArray<Swift.Float>>?
    @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
    public typealias Element = CreateMLComponents.TemporalFeature<CoreML.MLShapedArray<Swift.Float>>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
extension CreateMLComponents.AudioFeaturePrint.FeatureSequence.Iterator : Swift.Sendable {
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.TemporalEstimator {
  public func write(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func read(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.SupervisedTemporalEstimator {
  public func write(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func read(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.UpdatableSupervisedTemporalEstimator {
  public func writeWithOptimizer(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func readWithOptimizer(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.FullyConnectedNetworkMultiLabelClassifier {
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.FullyConnectedNetworkMultiLabelClassifierModel<Scalar, Label>
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.FullyConnectedNetworkMultiLabelClassifier<Scalar, Label>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.FullyConnectedNetworkMultiLabelClassifier<Scalar, Label>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct ComposedTemporalTransformer<Inner, Outer> : CreateMLComponents.TemporalTransformer where Inner : CreateMLComponents.TemporalTransformer, Outer : CreateMLComponents.TemporalTransformer, Inner.Output == Outer.Input {
  public typealias Input = Inner.Input
  public typealias Intermediate = Inner.Output
  public typealias Output = Outer.Output
  public typealias OutputSequence = Outer.OutputSequence
  public var inner: Inner
  public var outer: Outer
  public init(_ inner: Inner, _ outer: Outer)
  @inlinable public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ComposedTemporalTransformer<Inner, Outer>.OutputSequence where S : CreateMLComponents.TemporalSequence, Inner.Input == S.Feature {
        let o0 = try await inner.applied(to: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        let o1 = try await outer.applied(to: o0, eventHandler: eventHandler)
        return o1
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTemporalTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTemporalTransformer : Swift.Sendable where Inner : Swift.Sendable, Outer : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTemporalTransformer : Swift.Equatable where Inner : Swift.Equatable, Outer : Swift.Equatable {
  public static func == (a: CreateMLComponents.ComposedTemporalTransformer<Inner, Outer>, b: CreateMLComponents.ComposedTemporalTransformer<Inner, Outer>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTemporalTransformer : Swift.Encodable where Inner : Swift.Encodable, Outer : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTemporalTransformer : Swift.Decodable where Inner : Swift.Decodable, Outer : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension CreateMLComponents.Transformer {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  @_disfavoredOverload public func appending<Other>(_ other: Other) -> CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self>, Other> where Other : CreateMLComponents.TemporalTransformer, Self.Output == Other.Input
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TemporalAdaptor<Self>, Other> where Self : Swift.Sendable, Other : CreateMLComponents.TemporalTransformer, Self.Output == Other.Input
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  @_disfavoredOverload public func appending<Other>(_ other: Other) -> CreateMLComponents.ComposedTemporalTransformer<Self, CreateMLComponents.TransformerToTemporalAdaptor<Other>> where Other : CreateMLComponents.Transformer, Self.Output == Other.Input
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.ComposedTemporalTransformer<Self, CreateMLComponents.TemporalAdaptor<Other>> where Other : CreateMLComponents.Transformer, Other : Swift.Sendable, Self.Output == Other.Input
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.ComposedTemporalTransformer<Self, Other> where Other : CreateMLComponents.TemporalTransformer, Self.Output == Other.Input
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
public struct DetectedObject<Label> : Swift.Equatable where Label : Swift.Comparable, Label : Swift.Hashable {
  public var boundingBox: CoreFoundation.CGRect
  public var label: Label
  public var confidence: Swift.Float
  public init(boundingBox: CoreFoundation.CGRect, label: Label, probability: Swift.Float)
  public static func == (a: CreateMLComponents.DetectedObject<Label>, b: CreateMLComponents.DetectedObject<Label>) -> Swift.Bool
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.DetectedObject : Swift.Encodable where Label : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.DetectedObject : Swift.Decodable where Label : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.DetectedObject : Swift.Sendable where Label : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct EstimatorToSupervisedAdaptor<Estimator, Annotation> : CreateMLComponents.SupervisedEstimator where Estimator : CreateMLComponents.Estimator, Annotation : Swift.Equatable {
  public typealias Transformer = Estimator.Transformer
  public let estimator: Estimator
  public init(_ estimator: Estimator)
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.EstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.EstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>
  public func encode(_ transformer: CreateMLComponents.EstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.EstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.EstimatorToSupervisedAdaptor : Swift.Sendable where Estimator : Swift.Sendable, Annotation : Swift.Sendable {
}
extension CreateMLComponents.Estimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func adaptedAsSupervised<Annotation>(annotationType: Annotation.Type = Annotation.self) -> CreateMLComponents.EstimatorToSupervisedAdaptor<Self, Annotation> where Annotation : Swift.Equatable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation> : CreateMLComponents.UpdatableSupervisedEstimator where Estimator : CreateMLComponents.UpdatableEstimator, Annotation : Swift.Equatable {
  public typealias Transformer = Estimator.Transformer
  public let estimator: Estimator
  public init(_ estimator: Estimator)
  public func makeTransformer() -> Estimator.Transformer
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>
  public func update<InputSequence>(_ transformer: inout Estimator.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>
  public func update<InputSequence, Validation>(_ transformer: inout Estimator.Transformer, with input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Validation : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>
  public func encode(_ transformer: CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor : Swift.Sendable where Estimator : Swift.Sendable, Annotation : Swift.Sendable {
}
extension CreateMLComponents.UpdatableEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func adaptedAsSupervised<Annotation>(annotationType: Annotation.Type = Annotation.self) -> CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Self, Annotation> where Annotation : Swift.Equatable
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public struct TemporalEstimatorToSupervisedAdaptor<Estimator, Annotation> : CreateMLComponents.SupervisedTemporalEstimator where Estimator : CreateMLComponents.TemporalEstimator, Annotation : Swift.Equatable, Annotation : Swift.Sendable {
  public typealias Transformer = Estimator.Transformer
  public let estimator: Estimator
  public init(_ estimator: Estimator)
  public func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.TemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input
  public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.TemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input
  public func encode(_ transformer: CreateMLComponents.TemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.TemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.TemporalEstimatorToSupervisedAdaptor : Swift.Sendable where Estimator : Swift.Sendable {
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.TemporalEstimator {
  public func adaptedAsSupervised<Annotation>(annotationType: Annotation.Type = Annotation.self) -> CreateMLComponents.TemporalEstimatorToSupervisedAdaptor<Self, Annotation> where Annotation : Swift.Equatable, Annotation : Swift.Sendable
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public struct UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation> : CreateMLComponents.UpdatableSupervisedTemporalEstimator where Estimator : CreateMLComponents.UpdatableTemporalEstimator, Annotation : Swift.Equatable, Annotation : Swift.Sendable {
  public typealias Transformer = Estimator.Transformer
  public let estimator: Estimator
  public init(_ estimator: Estimator)
  public func makeTransformer() -> Estimator.Transformer
  public func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input
  public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input
  public func update<InputSequence, FeatureSequence>(_ transformer: inout CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input
  public func update<InputSequence, Validation, FeatureSequence>(_ transformer: inout CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, with input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input
  public func encode(_ transformer: CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor : Swift.Sendable where Estimator : Swift.Sendable {
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.UpdatableTemporalEstimator {
  public func adaptedAsSupervised<Annotation>(annotationType: Annotation.Type = Annotation.self) -> CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Self, Annotation> where Annotation : Swift.Equatable, Annotation : Swift.Sendable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct TabularEstimatorToSupervisedAdaptor<Estimator, Annotation> : CreateMLComponents.SupervisedTabularEstimator where Estimator : CreateMLComponents.TabularEstimator {
  public typealias Transformer = Estimator.Transformer
  public var annotationColumnID: TabularData.ColumnID<Annotation>
  public let estimator: Estimator
  public init(_ estimator: Estimator, annotationColumnID: TabularData.ColumnID<Annotation>)
  @inlinable public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame? = nil, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Estimator.Transformer {
        try await estimator.fitted(to: input, eventHandler: eventHandler)
    }
  public func encode(_ transformer: Estimator.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Estimator.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TabularEstimatorToSupervisedAdaptor : Swift.Sendable where Estimator : Swift.Sendable, Annotation : Swift.Sendable {
}
extension CreateMLComponents.TabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func adaptedAsSupervised<Annotation>(annotationColumnID: TabularData.ColumnID<Annotation>) -> CreateMLComponents.TabularEstimatorToSupervisedAdaptor<Self, Annotation>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation> : CreateMLComponents.UpdatableSupervisedTabularEstimator where Estimator : CreateMLComponents.UpdatableTabularEstimator, Annotation : Swift.Equatable {
  public typealias Transformer = Estimator.Transformer
  public var annotationColumnID: TabularData.ColumnID<Annotation>
  public let estimator: Estimator
  public init(_ estimator: Estimator, annotationColumnID: TabularData.ColumnID<Annotation>)
  public func makeTransformer() -> Estimator.Transformer
  public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame?, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
  public func update(_ transformer: inout CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws
  public func encode(_ transformer: CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor : Swift.Sendable where Estimator : Swift.Sendable, Annotation : Swift.Sendable {
}
extension CreateMLComponents.UpdatableTabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func adaptedAsSupervised<Annotation>(annotationColumnID: TabularData.ColumnID<Annotation>) -> CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Self, Annotation> where Annotation : Swift.Equatable
}
extension CreateMLComponents.UpdatableEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableEstimator<CreateMLComponents.ComposedTransformer<Self.Transformer, Other>> where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableEstimator<CreateMLComponents.ComposedTransformer<Self.Transformer, Other.Transformer>> where Other : CreateMLComponents.UpdatableEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct SlidingWindows<Scalar> : Swift.RandomAccessCollection, @unchecked Swift.Sendable where Scalar : CoreML.MLShapedArrayScalar {
  public let input: CoreML.MLShapedArray<Scalar>
  public let length: Swift.Int
  public let stride: Swift.Int
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public init(input: CoreML.MLShapedArray<Scalar>, length: Swift.Int, stride: Swift.Int = 1) throws
  public func index(before i: Swift.Int) -> Swift.Int
  public func index(after i: Swift.Int) -> Swift.Int
  public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int
  public subscript(position: Swift.Int) -> CoreML.MLShapedArray<Scalar> {
    get
  }
  public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.Slice<CreateMLComponents.SlidingWindows<Scalar>> {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Element = CoreML.MLShapedArray<Scalar>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Index = Swift.Int
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Indices = Swift.Range<Swift.Int>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Iterator = Swift.IndexingIterator<CreateMLComponents.SlidingWindows<Scalar>>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias SubSequence = Swift.Slice<CreateMLComponents.SlidingWindows<Scalar>>
}
extension CreateMLComponents.UpdatableTabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self.Transformer, Other.Transformer>, Other.Annotation> where Other : CreateMLComponents.UpdatableSupervisedTabularEstimator, Other.Annotation : Swift.Equatable
  
}
extension CreateMLComponents.UpdatableSupervisedTabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self.Transformer, Other>, Self.Annotation> where Other : CreateMLComponents.TabularTransformer, Self.Annotation : Swift.Equatable
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self.Transformer, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.UpdatableTabularEstimator, Self.Annotation : Swift.Equatable
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self.Transformer, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.UpdatableSupervisedTabularEstimator, Self.Annotation == Other.Annotation
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct ComposedTransformer<Inner, Outer> : CreateMLComponents.Transformer where Inner : CreateMLComponents.Transformer, Outer : CreateMLComponents.Transformer, Inner.Output == Outer.Input {
  public typealias Input = Inner.Input
  public typealias Intermediate = Inner.Output
  public typealias Output = Outer.Output
  public var inner: Inner
  public var outer: Outer
  public init(_ inner: Inner, _ outer: Outer)
  @inlinable public func applied(to input: CreateMLComponents.ComposedTransformer<Inner, Outer>.Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ComposedTransformer<Inner, Outer>.Output {
        let innerOutput = try await inner.applied(to: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        let outerOutput = try await outer.applied(to: innerOutput, eventHandler: eventHandler)
        return outerOutput
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTransformer : Swift.Sendable where Inner : Swift.Sendable, Outer : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTransformer : Swift.Equatable where Inner : Swift.Equatable, Outer : Swift.Equatable {
  public static func == (a: CreateMLComponents.ComposedTransformer<Inner, Outer>, b: CreateMLComponents.ComposedTransformer<Inner, Outer>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTransformer : Swift.Encodable where Inner : Swift.Encodable, Outer : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTransformer : Swift.Decodable where Inner : Swift.Decodable, Outer : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.ComposedTransformer<Self, Other> where Other : CreateMLComponents.Transformer, Self.Output == Other.Input
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func appending<Other, Annotation>(_ other: Other) -> some CreateMLComponents.Transformer<CreateMLComponents.AnnotatedFeature<Self.Input, Annotation>, Other.Output> where Other : CreateMLComponents.Transformer, Other.Input == CreateMLComponents.AnnotatedFeature<Self.Output, Annotation>
  
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func appending<Other, Annotation>(_ other: Other) -> some CreateMLComponents.Transformer<Self.Input, CreateMLComponents.AnnotatedFeature<Other.Output, Annotation>> where Other : CreateMLComponents.Transformer, Self.Output == CreateMLComponents.AnnotatedFeature<Other.Input, Annotation>
  
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func appending<Other, Annotation>(_ other: Other) -> some CreateMLComponents.Transformer<CreateMLComponents.AnnotatedPrediction<Self.Input, Annotation>, Other.Output> where Other : CreateMLComponents.Transformer, Other.Input == CreateMLComponents.AnnotatedPrediction<Self.Output, Annotation>
  
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func appending<Other, Annotation>(_ other: Other) -> some CreateMLComponents.Transformer<Self.Input, CreateMLComponents.AnnotatedPrediction<Other.Output, Annotation>> where Other : CreateMLComponents.Transformer, Self.Output == CreateMLComponents.AnnotatedPrediction<Other.Input, Annotation>
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct HumanBodyPoseExtractor : CreateMLComponents.Transformer, Swift.Sendable {
  public init()
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.Pose]
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Input = CoreImage.CIImage
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Output = [CreateMLComponents.Pose]
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyPoseExtractor : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
public struct ObjectDetectionAnnotation<Label> : Swift.Decodable, Swift.Equatable where Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  public struct Annotation : Swift.Equatable {
    public let boundingBox: CoreFoundation.CGRect
    public let label: Label
    public enum CodingKeys : Swift.String, Swift.CodingKey {
      case boundingBox
      case label
      public init?(rawValue: Swift.String)
      public init?(stringValue: Swift.String)
      public init?(intValue: Swift.Int)
      @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
      public typealias RawValue = Swift.String
      public var intValue: Swift.Int? {
        get
      }
      public var rawValue: Swift.String {
        get
      }
      public var stringValue: Swift.String {
        get
      }
    }
    public static func == (a: CreateMLComponents.ObjectDetectionAnnotation<Label>.Annotation, b: CreateMLComponents.ObjectDetectionAnnotation<Label>.Annotation) -> Swift.Bool
  }
  public let imageFileName: Swift.String
  public let objects: [CreateMLComponents.ObjectDetectionAnnotation<Label>.Annotation]
  public let prominentObject: Label
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case imageFileName
    case objects
    case prominentObject
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public static func == (a: CreateMLComponents.ObjectDetectionAnnotation<Label>, b: CreateMLComponents.ObjectDetectionAnnotation<Label>) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.ObjectDetectionAnnotation : Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias ID = Swift.String
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.ObjectDetectionAnnotation : Swift.Sendable where Label : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.ObjectDetectionAnnotation.Annotation : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.ObjectDetectionAnnotation.Annotation : Swift.Sendable where Label : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
public struct RandomImageCropper : CreateMLComponents.RandomTransformer, Swift.Sendable {
  public init(targetSize: CoreFoundation.CGSize)
  public init(targetWidth: Swift.Double, targetHeight: Swift.Double)
  public init(scale: Swift.ClosedRange<Swift.Double>, aspectRatio: Swift.Double? = nil)
  public func applied(to image: CoreImage.CIImage, generator: inout some RandomNumberGenerator, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Input = CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Output = CoreImage.CIImage
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.FullyConnectedNetworkClassifier : CreateMLComponents.UpdatableSupervisedEstimator {
  public func makeTransformer() -> CreateMLComponents.FullyConnectedNetworkClassifierModel<Scalar, Label>
  public func update<InputSequence>(_ transformer: inout CreateMLComponents.FullyConnectedNetworkClassifierModel<Scalar, Label>, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct PreprocessingEstimator<Preprocessor, Estimator> : CreateMLComponents.Estimator where Preprocessor : CreateMLComponents.Transformer, Estimator : CreateMLComponents.Estimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  @inlinable public func preprocessed<S>(from input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [Preprocessor.Output] where S : Swift.Sequence, Preprocessor.Input == S.Element {
        try await preprocessor.applied(to: input, eventHandler: eventHandler)
    }
  @inlinable public func fitted<S>(toPreprocessed preprocessed: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingEstimator<Preprocessor, Estimator>.Transformer where S : Swift.Sequence, Preprocessor.Output == S.Element, S.Element == Estimator.Transformer.Input {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingEstimator<Preprocessor, Estimator>.Transformer where S : Swift.Sequence, Preprocessor.Input == S.Element {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  public func encode(_ transformer: CreateMLComponents.PreprocessingEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.PreprocessingEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingEstimator<Self, Other> where Other : CreateMLComponents.Estimator, Self.Output == Other.Transformer.Input
}
@available(watchOS, unavailable)
extension CreateMLComponents.TimeSeriesClassifier {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, *)
  @available(watchOS, unavailable)
  public struct Model : CreateMLComponents.Transformer, @unchecked Swift.Sendable {
    public typealias Input = CoreML.MLShapedArray<Scalar>
    public typealias Output = CreateMLComponents.ClassificationDistribution<Label>
    public var stride: Swift.Int
    public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ClassificationDistribution<Label>
  }
}
@available(*, unavailable)
extension CreateMLComponents.TimeSeriesClassifier.Model : Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(watchOS, unavailable)
extension CreateMLComponents.TimeSeriesClassifier.Model : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension CreateMLComponents.AudioReader {
  @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  public struct MicrophoneAsyncBuffers : CreateMLComponents.TemporalSequence, Swift.Sendable {
    public typealias AsyncIterator = CreateMLComponents.AudioReader.MicrophoneAsyncBuffers.Iterator
    public typealias Feature = AVFAudio.AVAudioPCMBuffer
    public var count: Swift.Int? {
      get
    }
    public func makeAsyncIterator() -> CreateMLComponents.AudioReader.MicrophoneAsyncBuffers.Iterator
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable, introduced: 16.0)
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.AudioReader.MicrophoneAsyncBuffers.Feature>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @available(tvOS, unavailable, introduced: 18.0)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
    #else
    @available(iOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @available(tvOS, unavailable, introduced: 18.0)
    public typealias __AsyncSequence_Failure = any Swift.Error
    #endif
  }
}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.AudioReader.MicrophoneAsyncBuffers {
  @_hasMissingDesignatedInitializers @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  final public class Iterator : _Concurrency.AsyncIteratorProtocol {
    @objc deinit
    final public func next() async throws -> CreateMLComponents.TemporalFeature<CreateMLComponents.AudioReader.MicrophoneAsyncBuffers.Feature>?
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable, introduced: 16.0)
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.AudioReader.MicrophoneAsyncBuffers.Feature>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @available(tvOS, unavailable, introduced: 18.0)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @available(tvOS, unavailable, introduced: 18.0)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
@available(tvOS, unavailable)
extension CreateMLComponents.AudioReader.MicrophoneAsyncBuffers.Iterator : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct LinearTransformer<Element> : CreateMLComponents.Transformer, Swift.Hashable, Swift.Codable where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public var scale: Element
  public var offset: Element
  public init(scale: Element, offset: Element)
  @inlinable public func applied(to input: Element, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
        return input * scale + offset
    }
  @inlinable public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) -> [Element] where Element == S.Element, S : Swift.Sequence {
        input.map({ applied(to: $0, eventHandler: eventHandler) })
    }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.LinearTransformer<Element>, b: CreateMLComponents.LinearTransformer<Element>) -> Swift.Bool
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = Element
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = Element
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.LinearTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.LinearTransformer : Swift.Sendable where Element : Swift.Sendable {
}
extension CreateMLComponents.TimeSeriesClassifier.Model {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, *)
  @available(watchOS, unavailable)
  public func export(to url: Foundation.URL) throws
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, *)
  @available(watchOS, unavailable)
  public func export(to url: Foundation.URL, metadata: CreateMLComponents.ModelMetadata) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct OrdinalEncoder<Category> : CreateMLComponents.Estimator where Category : Swift.Comparable, Category : Swift.Decodable, Category : Swift.Encodable, Category : Swift.Hashable {
  public init()
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.OrdinalEncoder<Category>.Transformer where S : Swift.Sequence, S.Element == Category?
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.OrdinalEncoder : CreateMLComponents.UpdatableEstimator {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func makeTransformer() -> CreateMLComponents.OrdinalEncoder<Category>.Transformer
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func update(_ transformer: inout CreateMLComponents.OrdinalEncoder<Category>.Transformer, with input: some Sequence<Category?>, eventHandler: CreateMLComponents.EventHandler? = nil) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.OrdinalEncoder<Category>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.OrdinalEncoder<Category>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.OrdinalEncoder : Swift.Sendable where Category : Swift.Sendable {
}
extension CreateMLComponents.OrdinalEncoder {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public struct Transformer : CreateMLComponents.Transformer {
    public var categories: Swift.Set<Category?>
    public init(categories: Swift.Set<Category?>)
    public func applied(to input: Category?, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> Swift.Int
    public func applied<S>(_ input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> [Swift.Int] where S : Swift.Sequence, S.Element == Category?
    public func category(at index: Swift.Int) -> Category?
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Input = Category?
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Output = Swift.Int
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.OrdinalEncoder.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.OrdinalEncoder.Transformer : Swift.Sendable where Category : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.OrdinalEncoder.Transformer : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.OrdinalEncoder.Transformer : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct AnnotatedBatch<Scalar> where Scalar : CoreML.MLShapedArrayScalar {
  public var features: CoreML.MLShapedArray<Scalar>
  public var annotations: CoreML.MLShapedArray<Scalar>
  public var count: Swift.Int {
    get
  }
  public init(features: CoreML.MLShapedArray<Scalar>, annotations: CoreML.MLShapedArray<Scalar>)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedBatch : Swift.Encodable where Scalar : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedBatch : Swift.Decodable where Scalar : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedBatch : Swift.Equatable where Scalar : Swift.Equatable {
  public static func == (a: CreateMLComponents.AnnotatedBatch<Scalar>, b: CreateMLComponents.AnnotatedBatch<Scalar>) -> Swift.Bool
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedBatch : Swift.Sendable where Scalar : Swift.Sendable {
}
extension CreateMLComponents.MultiLabelClassificationMetrics {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public static func meanAveragePrecisionScore(classifications: some Sequence<ClassificationDistribution<Label>>, groundTruth: some Sequence<Set<Label>>, labels: Swift.Set<Label>) -> Swift.Float
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public static func meanAveragePrecisionScore(classifications: some Sequence<ClassificationDistribution<Label>>, groundTruth: some Sequence<Set<Label>>) -> Swift.Float
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public static func meanAveragePrecisionScore(_ pairs: some Sequence<(classification: ClassificationDistribution<Label>, labels: Set<Label>)>, labels: Swift.Set<Label>) -> Swift.Float
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public static func meanAveragePrecisionScore(_ pairs: some Sequence<(classification: ClassificationDistribution<Label>, labels: Set<Label>)>) -> Swift.Float
}
extension CreateMLComponents.MultiLabelClassificationMetrics {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func precisionScore(for label: Label) -> Swift.Float
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func recallScore(for label: Label) -> Swift.Float
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public struct PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator> : CreateMLComponents.UpdatableSupervisedTemporalEstimator where Preprocessor : CreateMLComponents.TemporalTransformer, Estimator : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTemporalTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public typealias Annotation = Estimator.Annotation
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ inner: Preprocessor, _ outer: Estimator)
  @inlinable public func preprocessed<InputSequence, FeatureSequence>(from input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>] where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        var preprocessed = [AnnotatedFeature<PreprocessedFeatureSequence<Preprocessor.Output>, Annotation>]()
        for item in input {
            let transformed = try await preprocessor.applied(to: item.feature, eventHandler: eventHandler)
            let stored = try await PreprocessedFeatureSequence(transformed)
            preprocessed.append(AnnotatedFeature(feature: stored, annotation: item.annotation))
        }
        return preprocessed
    }
  @inlinable public func fitted(toPreprocessed preprocessed: [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTemporalTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted(toPreprocessed preprocessedInput: [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>], validateOn preprocessedValidation: [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
        return ComposedTemporalTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  @inlinable public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        let preprocessedInput = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        let preprocessedValidation = try await preprocessed(from: validation, eventHandler: eventHandler)
        try Task.checkCancellation()

        return try await fitted(
            toPreprocessed: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
    }
  @inlinable public func makeTransformer() -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer {
        ComposedTemporalTransformer(preprocessor, estimator.makeTransformer())
    }
  @inlinable public func update<InputSequence, FeatureSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer, withPreprocessed preprocessed: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Output == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input {
        try await estimator.update(
            &transformer.outer,
            with: preprocessed,
            eventHandler: eventHandler
        )
    }
  @inlinable public func update<InputSequence, FeatureSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        try await estimator.update(
            &transformer.outer,
            with: preprocessed,
            eventHandler: eventHandler
        )
    }
  public func encode(_ transformer: CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<CreateMLComponents.TransformerToTemporalAdaptor<Self>, Other> where Other : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Self.Output == Other.Transformer.Input
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Self, CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Other>> where Other : CreateMLComponents.UpdatableSupervisedEstimator, Self.Output == Other.Transformer.Input, Other.Annotation : Swift.Sendable
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Self, Other> where Other : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Self.Output == Other.Transformer.Input
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public enum ColumnSelection : Swift.Codable, Swift.Sendable {
  case all
  case numeric
  case include(columnNames: [Swift.String])
  case exclude(columnNames: [Swift.String])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension TabularData.DataFrame {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func selecting(_ selection: CreateMLComponents.ColumnSelection) -> TabularData.DataFrame
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct MaxAbsScaler<Element> : CreateMLComponents.Estimator where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public init()
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.MaxAbsScaler<Element>.Transformer where Element == S.Element, S : Swift.Sequence
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MaxAbsScaler : Swift.Sendable where Element : Swift.Sendable {
}
extension CreateMLComponents.MaxAbsScaler {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public struct Transformer : CreateMLComponents.Transformer, Swift.Hashable {
    public var maximumAbsoluteValue: Element
    public init(maximumAbsoluteValue: Element)
    @inlinable public func applied(to input: Element, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
            input / maximumAbsoluteValue
        }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.MaxAbsScaler<Element>.Transformer, b: CreateMLComponents.MaxAbsScaler<Element>.Transformer) -> Swift.Bool
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Input = Element
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Output = Element
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MaxAbsScaler.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MaxAbsScaler.Transformer : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MaxAbsScaler.Transformer : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MaxAbsScaler.Transformer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct MinMaxScaler<Element> : CreateMLComponents.Estimator where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public var range: Swift.ClosedRange<Element>
  public init(range: Swift.ClosedRange<Element> = 0...1)
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.MinMaxScaler<Element>.Transformer where Element == S.Element, S : Swift.Sequence
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MinMaxScaler : Swift.Sendable where Element : Swift.Sendable {
}
extension CreateMLComponents.MinMaxScaler {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public struct Transformer : CreateMLComponents.Transformer, Swift.Hashable {
    public var desiredRange: Swift.ClosedRange<Element>
    public var fittedRange: Swift.ClosedRange<Element>
    public init(desiredRange: Swift.ClosedRange<Element>, fittedRange: Swift.ClosedRange<Element>)
    @inlinable public func applied(to input: Element, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
            if fittedRange.lowerBound == fittedRange.upperBound {
                return fittedRange.lowerBound
            }

             
            let unitScaledInput = (input - fittedRange.lowerBound) / (fittedRange.upperBound - fittedRange.lowerBound)

             
            return unitScaledInput * (desiredRange.upperBound - desiredRange.lowerBound) + desiredRange.lowerBound
        }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.MinMaxScaler<Element>.Transformer, b: CreateMLComponents.MinMaxScaler<Element>.Transformer) -> Swift.Bool
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Input = Element
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Output = Element
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MinMaxScaler.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MinMaxScaler.Transformer : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MinMaxScaler.Transformer : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MinMaxScaler.Transformer : Swift.Sendable where Element : Swift.Sendable {
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol SupervisedTabularEstimator<Transformer, Annotation> {
  associatedtype Transformer : CreateMLComponents.TabularTransformer
  associatedtype Annotation
  var annotationColumnID: TabularData.ColumnID<Self.Annotation> { get set }
  func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame?, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer
  func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol SupervisedTabularEstimator {
  associatedtype Transformer : CreateMLComponents.TabularTransformer
  associatedtype Annotation
  var annotationColumnID: TabularData.ColumnID<Self.Annotation> { get set }
  func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame?, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer
  func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.SupervisedTabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame? = nil) async throws -> Self.Transformer {
        try await fitted(to: input, validateOn: validation, eventHandler: nil)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.SupervisedTabularEstimator where Self.Transformer : Swift.Encodable {
  public func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.SupervisedTabularEstimator where Self.Transformer : Swift.Decodable {
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol UpdatableSupervisedTabularEstimator<Transformer, Annotation> : CreateMLComponents.SupervisedTabularEstimator {
  func makeTransformer() -> Self.Transformer
  func update(_ transformer: inout Self.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol UpdatableSupervisedTabularEstimator : CreateMLComponents.SupervisedTabularEstimator {
  func makeTransformer() -> Self.Transformer
  func update(_ transformer: inout Self.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.UpdatableSupervisedTabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func update(_ transformer: inout Self.Transformer, with input: TabularData.DataFrame) async throws {
        try await update(&transformer, with: input, eventHandler: nil)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct HumanBodyActionPeriodPredictor : CreateMLComponents.Transformer, Swift.Sendable {
  public typealias Input = [CreateMLComponents.Pose]
  public typealias Output = [CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction]
  public init()
  public func applied(to input: [CreateMLComponents.Pose], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction]
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionPeriodPredictor {
  public struct Prediction {
    public var period: Swift.Float
    public var periodicity: Swift.Float
    public init(period: Swift.Float, periodicity: Swift.Float)
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction : Swift.Equatable {
  public static func == (a: CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction, b: CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct MLModelTransformerAdaptor<Scalar> : CreateMLComponents.Transformer where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public let model: CoreML.MLModel
  public init(contentsOf url: Foundation.URL, configuration: CoreML.MLModelConfiguration) throws
  public init(model: CoreML.MLModel) throws
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CoreML.MLShapedArray<Scalar>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = CoreML.MLShapedArray<Scalar>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = CoreML.MLShapedArray<Scalar>
}
@available(*, unavailable)
extension CreateMLComponents.MLModelTransformerAdaptor : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct PreprocessedFeatureSequence<Feature> : CreateMLComponents.TemporalSequence {
  public var features: [CreateMLComponents.TemporalFeature<Feature>]
  @inlinable public var count: Swift.Int? {
    get {
        features.count
    }
  }
  public init<S>(_ sequence: S) async throws where Feature == S.Feature, S : CreateMLComponents.TemporalSequence
  public func makeAsyncIterator() -> CreateMLComponents.PreprocessedFeatureSequence<Feature>.AsyncIterator
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Element = CreateMLComponents.TemporalFeature<Feature>
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
}
extension CreateMLComponents.PreprocessedFeatureSequence {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal let features: [CreateMLComponents.TemporalFeature<Feature>]
    @usableFromInline
    internal var index: Swift.Int
    @inlinable public mutating func next() -> CreateMLComponents.TemporalFeature<Feature>? {
            if index >= features.count {
                return nil
            }
            defer {
                index += 1
            }
            return features[index]
        }
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Element = CreateMLComponents.TemporalFeature<Feature>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    #endif
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct AnnotatedFeature<Feature, Annotation> {
  public var feature: Feature
  public var annotation: Annotation
  public init(feature: Feature, annotation: Annotation)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedFeature : Swift.Encodable where Feature : Swift.Encodable, Annotation : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedFeature : Swift.Decodable where Feature : Swift.Decodable, Annotation : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedFeature : Swift.Equatable where Feature : Swift.Equatable, Annotation : Swift.Equatable {
  public static func == (a: CreateMLComponents.AnnotatedFeature<Feature, Annotation>, b: CreateMLComponents.AnnotatedFeature<Feature, Annotation>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedFeature : Swift.Hashable where Feature : Swift.Hashable, Annotation : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedFeature : Swift.Sendable where Feature : Swift.Sendable, Annotation : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public enum ModelUpdateError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case invalidState(debugDescription: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.ModelUpdateError, b: CreateMLComponents.ModelUpdateError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ModelUpdateError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct DataFrameTemporalAnnotationParameters<Annotation> where Annotation : Swift.Equatable, Annotation : Swift.Sendable {
  public enum FilePathType : Swift.Equatable, Swift.CustomStringConvertible, Swift.Sendable {
    case relative(baseURL: Foundation.URL)
    case absolute
    public var description: Swift.String {
      get
    }
    public static func == (a: CreateMLComponents.DataFrameTemporalAnnotationParameters<Annotation>.FilePathType, b: CreateMLComponents.DataFrameTemporalAnnotationParameters<Annotation>.FilePathType) -> Swift.Bool
  }
  public var filePathType: CreateMLComponents.DataFrameTemporalAnnotationParameters<Annotation>.FilePathType
  public var filePathColumnID: TabularData.ColumnID<Swift.String>
  public var annotationColumnID: TabularData.ColumnID<Annotation>
  public var startTimeColumnID: TabularData.ColumnID<Swift.Double>?
  public var endTimeColumnID: TabularData.ColumnID<Swift.Double>?
  public init()
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.DataFrameTemporalAnnotationParameters : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension TabularData.DataFrame {
  public func loadRangedAnnotations<Annotation>(parameters: CreateMLComponents.DataFrameTemporalAnnotationParameters<Annotation> = .init(), continueOnFailure: Swift.Bool = false) throws -> [CreateMLComponents.AnnotatedFeature<CreateMLComponents.TemporalFileSegment, Annotation>] where Annotation : Swift.Equatable, Annotation : Swift.Sendable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct BoostedTreeClassifier<Label> : CreateMLComponents.SupervisedTabularEstimator where Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  public typealias Transformer = CreateMLComponents.TreeClassifierModel<Label>
  public typealias Annotation = Label
  public var configuration: CreateMLComponents.BoostedTreeConfiguration {
    get
    set
  }
  public var annotationColumnID: TabularData.ColumnID<Label>
  public var featureColumnNames: [Swift.String]
  public var labels: Swift.Set<Label?>
  public init(labels: Swift.Set<Label?>, annotationColumnName: Swift.String, featureColumnNames: [Swift.String], configuration: CreateMLComponents.BoostedTreeConfiguration = BoostedTreeConfiguration())
  public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame? = nil, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.TreeClassifierModel<Label>
  public func encodeLabels(_ annotations: some Collection<Label?>) throws -> (labels: [Swift.String?], encoded: [Swift.Int])
  public func encode(_ transformer: CreateMLComponents.TreeClassifierModel<Label>, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.TreeClassifierModel<Label>
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.BoostedTreeClassifier : CreateMLComponents.UpdatableSupervisedTabularEstimator {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func makeTransformer() -> CreateMLComponents.TreeClassifierModel<Label>
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func update(_ transformer: inout CreateMLComponents.TreeClassifierModel<Label>, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.TreeClassifierModel<Label>, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.TreeClassifierModel<Label>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.BoostedTreeClassifier : Swift.Sendable where Label : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.Pose : Swift.Encodable {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.Pose : Swift.Decodable {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol Regressor : CreateMLComponents.Transformer where Self.Output : Swift.FloatingPoint {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Regressor {
  public func prediction(from input: Self.Input) async throws -> Self.Output
  public func prediction<S>(from input: S) async throws -> [Self.Output] where S : Swift.Sequence, Self.Input == S.Element
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct LinearTimeSeriesForecaster<Scalar> : CreateMLComponents.SupervisedEstimator, Swift.Sendable where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public typealias Annotation = CoreML.MLShapedArray<Scalar>
  public typealias Transformer = CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Model
  public let configuration: CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Configuration
  public var inputWindowSize: Swift.Int {
    get
  }
  public var forecastWindowSize: Swift.Int {
    get
  }
  public init(configuration: CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Configuration)
  public func fitted(to input: some Sequence<AnnotatedFeature<MLShapedArray<Scalar>, MLShapedArray<Scalar>>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Model
  public func fitted(to input: some Sequence<AnnotatedFeature<MLShapedArray<Scalar>, MLShapedArray<Scalar>>>, validateOn validation: some Sequence<AnnotatedFeature<MLShapedArray<Scalar>, MLShapedArray<Scalar>>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Model
  public func fitted(toWindows input: some Sequence<AnnotatedFeature<MLShapedArray<Scalar>, MLShapedArray<Scalar>>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Model
  public func fitted(toWindows input: some Sequence<AnnotatedFeature<MLShapedArray<Scalar>, MLShapedArray<Scalar>>>, validateOn validation: some Sequence<AnnotatedFeature<MLShapedArray<Scalar>, MLShapedArray<Scalar>>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Model
}
extension CreateMLComponents.VideoReader {
  @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  public struct CameraConfiguration : Swift.Sendable {
    public enum Position : Swift.Sendable {
      case front
      case back
      public static func == (a: CreateMLComponents.VideoReader.CameraConfiguration.Position, b: CreateMLComponents.VideoReader.CameraConfiguration.Position) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum PixelFormat : Swift.Sendable {
      case bgra32
      case yCbCr8BiPlanarFullRange420
      public static func == (a: CreateMLComponents.VideoReader.CameraConfiguration.PixelFormat, b: CreateMLComponents.VideoReader.CameraConfiguration.PixelFormat) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Resolution : Swift.Sendable {
      case low
      case medium
      case high
      public static func == (a: CreateMLComponents.VideoReader.CameraConfiguration.Resolution, b: CreateMLComponents.VideoReader.CameraConfiguration.Resolution) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @available(macOS, introduced: 13.0, deprecated: 14.0, message: "Use the position property instead.")
    @available(iOS, introduced: 16.0, deprecated: 17.0, message: "Use the position property instead.")
    @available(tvOS, unavailable)
    public var cameraPosition: CreateMLComponents.VideoReader.CameraConfiguration.Position {
      get
    }
    public var position: CreateMLComponents.VideoReader.CameraConfiguration.Position
    public var pixelFormat: CreateMLComponents.VideoReader.CameraConfiguration.PixelFormat
    public var resolution: CreateMLComponents.VideoReader.CameraConfiguration.Resolution
    public var frameRate: Swift.Double
    public init()
    public init(position: CreateMLComponents.VideoReader.CameraConfiguration.Position = .front, pixelFormat: CreateMLComponents.VideoReader.CameraConfiguration.PixelFormat = .bgra32, resolution: CreateMLComponents.VideoReader.CameraConfiguration.Resolution = .high, frameRate: Swift.Double = 30.0)
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public enum EstimatorEncodingError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case invalidState(debugDescription: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.EstimatorEncodingError, b: CreateMLComponents.EstimatorEncodingError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.EstimatorEncodingError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct TemporalSegmentIdentifier : Swift.Hashable, Swift.Sendable {
  public var source: Swift.String
  public var range: Swift.Range<Swift.Int>
  public var timescale: Swift.Int
  public var rangeInSeconds: Swift.Range<Foundation.TimeInterval> {
    get
  }
  public var durationInSeconds: Foundation.TimeInterval {
    get
  }
  public init(source: Swift.String, range: Swift.Range<Swift.Int>, timescale: Swift.Int)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.TemporalSegmentIdentifier, b: CreateMLComponents.TemporalSegmentIdentifier) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalSegmentIdentifier : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension CreateMLComponents.UpdatableEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedEstimator<CreateMLComponents.ComposedTransformer<Self.Transformer, Other.Transformer>, Other.Annotation> where Other : CreateMLComponents.UpdatableSupervisedEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.UpdatableSupervisedEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedEstimator<CreateMLComponents.ComposedTransformer<Self.Transformer, Other>, Self.Annotation> where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedEstimator<CreateMLComponents.ComposedTransformer<Self.Transformer, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.UpdatableEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedEstimator<CreateMLComponents.ComposedTransformer<Self.Transformer, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.UpdatableSupervisedEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct ChooseRandomly<Element> : CreateMLComponents.RandomTransformer {
  public init<RandomTransformer>(@CreateMLComponents.AugmentationBuilder<Element> _ augmentation: () -> RandomTransformer) where Element == RandomTransformer.Input, RandomTransformer : CreateMLComponents.RandomTransformer, RandomTransformer.Input == RandomTransformer.Output
  public func applied(to input: Element, generator: inout some RandomNumberGenerator, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Element
  @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
  public typealias Input = Element
  @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
  public typealias Output = Element
}
@available(*, unavailable)
extension CreateMLComponents.ChooseRandomly : Swift.Sendable {
}
extension CreateMLComponents.VideoReader {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct AsyncFrames : CreateMLComponents.TemporalSequence {
    public typealias AsyncIterator = CreateMLComponents.VideoReader.AsyncFrames.Iterator
    public typealias Feature = CoreImage.CIImage
    public var count: Swift.Int? {
      get
    }
    public let url: Foundation.URL
    public let timescale: CoreMedia.CMTimeScale
    public let nominalFrameRate: Swift.Float
    public let frameSize: CoreFoundation.CGSize
    public let videoDuration: CoreMedia.CMTime
    public func makeAsyncIterator() -> CreateMLComponents.VideoReader.AsyncFrames.Iterator
    @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.VideoReader.AsyncFrames.Feature>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncSequence_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
extension CreateMLComponents.VideoReader.AsyncFrames : Swift.Sendable {
}
extension CreateMLComponents.VideoReader.AsyncFrames {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public mutating func next() async throws -> CreateMLComponents.TemporalFeature<CoreImage.CIImage>?
    @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
    public typealias Element = CreateMLComponents.TemporalFeature<CoreImage.CIImage>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
extension CreateMLComponents.VideoReader.AsyncFrames.Iterator : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct MLModelImageFeatureExtractor : CreateMLComponents.ImageFeatureExtractor {
  public let model: CoreML.MLModel
  public let inputName: Swift.String
  public let outputName: Swift.String
  public init(model: CoreML.MLModel, inputName: Swift.String = "image", outputName: Swift.String, context: CoreImage.CIContext = CIContext()) throws
  public init(contentsOf url: Foundation.URL, configuration: CoreML.MLModelConfiguration, inputName: Swift.String = "image", outputName: Swift.String, context: CoreImage.CIContext = CIContext()) async throws
  public func applied(to input: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CoreML.MLShapedArray<Swift.Float>
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Input = CoreImage.CIImage
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Output = CoreML.MLShapedArray<Swift.Float>
}
extension CreateMLComponents.MLModelImageFeatureExtractor {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public enum Error : Swift.Error, Swift.Equatable, Swift.CustomDebugStringConvertible {
    case invalidInput(Swift.String)
    case invalidOutput(Swift.String)
    public var debugDescription: Swift.String {
      get
    }
    public static func == (a: CreateMLComponents.MLModelImageFeatureExtractor.Error, b: CreateMLComponents.MLModelImageFeatureExtractor.Error) -> Swift.Bool
  }
}
@available(*, unavailable)
extension CreateMLComponents.MLModelImageFeatureExtractor : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
public struct ImageFlipper : CreateMLComponents.Transformer, Swift.Sendable {
  public var orientation: CreateMLComponents.ImageFlipper.Orientation
  public init(orientation: CreateMLComponents.ImageFlipper.Orientation)
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) -> CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Input = CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Output = CoreImage.CIImage
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.ImageFlipper {
  public enum Orientation : Swift.Hashable, Swift.Sendable {
    case horizontal
    case vertical
    public static func == (a: CreateMLComponents.ImageFlipper.Orientation, b: CreateMLComponents.ImageFlipper.Orientation) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct DateFeatureExtractor<Scalar> : CreateMLComponents.Transformer, Swift.Sendable where Scalar : Swift.BinaryFloatingPoint {
  public let calendar: Foundation.Calendar
  public let features: CreateMLComponents.DateFeatures
  public init(features: CreateMLComponents.DateFeatures, calendar: Foundation.Calendar = Calendar.current)
  public func applied(to date: Foundation.Date, eventHandler: CreateMLComponents.EventHandler? = nil) -> [Scalar]
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Input = Foundation.Date
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Output = [Scalar]
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension CreateMLComponents.DateFeatureExtractor : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct DateFeatures : Swift.Hashable, Swift.OptionSet, Swift.RawRepresentable, Swift.Codable, Swift.Sendable {
  public var rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let second: CreateMLComponents.DateFeatures
  public static let minute: CreateMLComponents.DateFeatures
  public static let hour: CreateMLComponents.DateFeatures
  public static let weekday: CreateMLComponents.DateFeatures
  public static let day: CreateMLComponents.DateFeatures
  public static let dayOfYear: CreateMLComponents.DateFeatures
  public static let weekOfMonth: CreateMLComponents.DateFeatures
  public static let weekOfYear: CreateMLComponents.DateFeatures
  public static let month: CreateMLComponents.DateFeatures
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias ArrayLiteralElement = CreateMLComponents.DateFeatures
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Element = CreateMLComponents.DateFeatures
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias RawValue = Swift.Int
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
@available(watchOS, unavailable)
extension CreateMLComponents.TimeSeriesClassifier : CreateMLComponents.UpdatableSupervisedEstimator {
  public func makeTransformer() -> CreateMLComponents.TimeSeriesClassifier<Scalar, Label>.Model
  public func update(_ transformer: inout CreateMLComponents.TimeSeriesClassifier<Scalar, Label>.Model, with input: some Sequence<AnnotatedFeature<MLShapedArray<Scalar>, Annotation>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.TimeSeriesClassifier<Scalar, Label>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.TimeSeriesClassifier<Scalar, Label>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct StandardScaler<Element> : CreateMLComponents.Estimator where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public init()
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.StandardScaler<Element>.Transformer where Element == S.Element, S : Swift.Sequence
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.StandardScaler : CreateMLComponents.UpdatableEstimator {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func makeTransformer() -> CreateMLComponents.StandardScaler<Element>.Transformer
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func update(_ transformer: inout CreateMLComponents.StandardScaler<Element>.Transformer, with input: some Sequence<Element>, eventHandler: CreateMLComponents.EventHandler? = nil)
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.StandardScaler<Element>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.StandardScaler<Element>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.StandardScaler : Swift.Sendable where Element : Swift.Sendable {
}
extension CreateMLComponents.StandardScaler {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public struct Transformer : CreateMLComponents.Transformer, Swift.Hashable {
    public var mean: Element
    public var standardDeviation: Element
    public init(mean: Element, standardDeviation: Element)
    @inlinable public func applied(to input: Element, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
            var result = input

            if mean.isFinite {
                result -= mean
            }

            if standardDeviation.isFinite && !standardDeviation.isZero {
                result /= standardDeviation
            }

            return result
        }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.StandardScaler<Element>.Transformer, b: CreateMLComponents.StandardScaler<Element>.Transformer) -> Swift.Bool
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Input = Element
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Output = Element
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.StandardScaler.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.StandardScaler.Transformer : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.StandardScaler.Transformer : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.StandardScaler.Transformer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct TimeSeriesForecasterAnnotatedWindows<Scalar> : Swift.Sequence, @unchecked Swift.Sendable where Scalar : CoreML.MLShapedArrayScalar {
  public typealias Element = CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, CoreML.MLShapedArray<Scalar>>
  public let features: CoreML.MLShapedArray<Scalar>
  public let annotations: CoreML.MLShapedArray<Scalar>
  public let inputWindowSize: Swift.Int
  public let forecastWindowSize: Swift.Int
  public var stride: Swift.Int
  public var shufflesElements: Swift.Bool
  public init(features: CoreML.MLShapedArray<Scalar>, annotations: CoreML.MLShapedArray<Scalar>, inputWindowSize: Swift.Int, forecastWindowSize: Swift.Int, stride: Swift.Int = 1, shufflesElements: Swift.Bool = true) throws
  public var underestimatedCount: Swift.Int {
    get
  }
  public func makeIterator() -> CreateMLComponents.TimeSeriesForecasterAnnotatedWindows<Scalar>.Iterator
}
extension CreateMLComponents.TimeSeriesForecasterAnnotatedWindows {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
  public struct Iterator : Swift.IteratorProtocol, @unchecked Swift.Sendable {
    public mutating func next() -> CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, CoreML.MLShapedArray<Scalar>>?
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Element = CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, CoreML.MLShapedArray<Scalar>>
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol Transformer<Input, Output> {
  associatedtype Input
  associatedtype Output
  func applied(to input: Self.Input, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Output
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol Transformer {
  associatedtype Input
  associatedtype Output
  func applied(to input: Self.Input, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Output
}
#endif
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Transformer {
  @inlinable public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [Self.Output] where S : Swift.Sequence, Self.Input == S.Element {
        var result = [Output]()
        result.reserveCapacity(input.underestimatedCount)
        for example in input {
            try Task.checkCancellation()
            try await result.append(applied(to: example, eventHandler: eventHandler))
            if let eventHandler = eventHandler {
                let event = Event(
                    origin: String(describing: self),
                    itemCount: result.count,
                    totalItemCount: input.underestimatedCount,
                    metrics: [:]
                )
                eventHandler(event)
            }
        }
        return result
    }
  @inlinable public func applied<S, Annotation>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.AnnotatedFeature<Self.Output, Annotation>] where S : Swift.Sequence, S.Element == CreateMLComponents.AnnotatedFeature<Self.Input, Annotation> {
        var result = [AnnotatedFeature<Output, Annotation>]()
        result.reserveCapacity(input.underestimatedCount)
        for example in input {
            try Task.checkCancellation()
            let transformed = try await applied(to: example.feature, eventHandler: eventHandler)
            result.append(AnnotatedFeature(feature: transformed, annotation: example.annotation))
            if let eventHandler = eventHandler {
                let event = Event(
                    origin: String(describing: self),
                    itemCount: result.count,
                    totalItemCount: input.underestimatedCount,
                    metrics: [:]
                )
                eventHandler(event)
            }
        }
        return result
    }
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  @inlinable public func prediction<S, Annotation>(from input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.AnnotatedPrediction<Self.Output, Annotation>] where S : Swift.Sequence, S.Element == CreateMLComponents.AnnotatedFeature<Self.Input, Annotation> {
        var result = [AnnotatedPrediction<Output, Annotation>]()
        result.reserveCapacity(input.underestimatedCount)
        for example in input {
            try Task.checkCancellation()
            let transformed = try await applied(to: example.feature, eventHandler: eventHandler)
            result.append(AnnotatedPrediction(prediction: transformed, annotation: example.annotation))
            if let eventHandler = eventHandler {
                let event = Event(
                    origin: String(describing: self),
                    itemCount: result.count,
                    totalItemCount: input.underestimatedCount,
                    metrics: [:]
                )
                eventHandler(event)
            }
        }
        return result
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Transformer {
  @inlinable public func callAsFunction(_ input: Self.Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Self.Output {
        try await applied(to: input, eventHandler: eventHandler)
    }
  @inlinable public func callAsFunction<S>(_ input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [Self.Output] where S : Swift.Sequence, Self.Input == S.Element {
        try await applied(to: input, eventHandler: eventHandler)
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct AugmentationSequence<Base, RandomTransformer, RandomNumberGenerator, Annotation> : _Concurrency.AsyncSequence where Base : Swift.Sequence, RandomTransformer : CreateMLComponents.RandomTransformer, RandomNumberGenerator : Swift.RandomNumberGenerator, Base.Element == CreateMLComponents.AnnotatedFeature<RandomTransformer.Input, Annotation>, RandomTransformer.Input == RandomTransformer.Output {
  public typealias Element = Base.Element
  public var transformer: RandomTransformer
  public func makeAsyncIterator() -> CreateMLComponents.AugmentationSequence<Base, RandomTransformer, RandomNumberGenerator, Annotation>.AsyncIterator
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
@available(*, unavailable)
extension CreateMLComponents.AugmentationSequence : Swift.Sendable {
}
extension CreateMLComponents.AugmentationSequence {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    public mutating func next() async throws -> Base.Element?
    @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
    public typealias Element = CreateMLComponents.AnnotatedFeature<RandomTransformer.Input, Annotation>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
extension CreateMLComponents.AugmentationSequence {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func batches(ofSize size: Swift.Int, dropsLastPartialBatch: Swift.Bool) -> CreateMLComponents.AugmentationSequence<Base, RandomTransformer, RandomNumberGenerator, Annotation>.BatchedSequence
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public struct BatchedSequence : _Concurrency.AsyncSequence {
    public typealias Element = [CreateMLComponents.AugmentationSequence<Base, RandomTransformer, RandomNumberGenerator, Annotation>.Element]
    public func makeAsyncIterator() -> CreateMLComponents.AugmentationSequence<Base, RandomTransformer, RandomNumberGenerator, Annotation>.BatchedSequence.AsyncIterator
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncSequence_Failure = any Swift.Error
    #endif
  }
}
extension CreateMLComponents.AugmentationSequence.BatchedSequence {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    public mutating func next() async throws -> [CreateMLComponents.AugmentationSequence<Base, RandomTransformer, RandomNumberGenerator, Annotation>.Element]?
    @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
    public typealias Element = [CreateMLComponents.AugmentationSequence<Base, RandomTransformer, RandomNumberGenerator, Annotation>.Element]
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
extension CreateMLComponents.AugmentationSequence.AsyncIterator : Swift.Sendable {
}
@available(*, unavailable)
extension CreateMLComponents.AugmentationSequence.BatchedSequence : Swift.Sendable {
}
@available(*, unavailable)
extension CreateMLComponents.AugmentationSequence.BatchedSequence.AsyncIterator : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol EstimatorEncoder {
  mutating func encode<T>(_ value: T) throws where T : Swift.Encodable
  mutating func encodeOptimizer<T>(_ value: T) throws where T : Swift.Encodable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol EstimatorDecoder {
  mutating func decode<T>(_ type: T.Type) throws -> T where T : Swift.Decodable
  mutating func decodeOptimizer<T>(_ value: T.Type) throws -> T where T : Swift.Decodable
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public protocol TemporalEstimator<Transformer> {
  associatedtype Transformer : CreateMLComponents.TemporalTransformer
  func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Self.Transformer.Input == InputSequence.Element.Feature
  func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public protocol TemporalEstimator {
  associatedtype Transformer : CreateMLComponents.TemporalTransformer
  func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Self.Transformer.Input == InputSequence.Element.Feature
  func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.TemporalEstimator {
  @inlinable public func fitted<InputSequence>(to input: InputSequence) async throws -> Self.Transformer where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Self.Transformer.Input == InputSequence.Element.Feature {
        try await fitted(to: input, eventHandler: nil)
    }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public protocol UpdatableTemporalEstimator<Transformer> : CreateMLComponents.TemporalEstimator {
  func makeTransformer() -> Self.Transformer
  func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Self.Transformer.Input == InputSequence.Element.Feature
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public protocol UpdatableTemporalEstimator : CreateMLComponents.TemporalEstimator {
  func makeTransformer() -> Self.Transformer
  func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Self.Transformer.Input == InputSequence.Element.Feature
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.UpdatableTemporalEstimator {
  @inlinable public func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence) async throws where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Self.Transformer.Input == InputSequence.Element.Feature {
        try await update(&transformer, with: input, eventHandler: nil)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public enum DatasetError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case missingResource(Foundation.URL)
  case incompatibleDataFormat(Foundation.URL, debugDescription: Swift.String)
  case unreadableResource(Foundation.URL)
  case incorrectName(Foundation.URL, debugDescription: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.DatasetError, b: CreateMLComponents.DatasetError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.DatasetError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
public struct ImageBlur : CreateMLComponents.Transformer, Swift.Sendable {
  public var radius: Swift.Double
  public init(radius: Swift.Double)
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) -> CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Input = CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Output = CoreImage.CIImage
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol Estimator<Transformer> {
  associatedtype Transformer : CreateMLComponents.Transformer
  func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where S : Swift.Sequence, S.Element == Self.Transformer.Input
  func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol Estimator {
  associatedtype Transformer : CreateMLComponents.Transformer
  func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where S : Swift.Sequence, S.Element == Self.Transformer.Input
  func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.Estimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func fitted<S>(to input: S) async throws -> Self.Transformer where S : Swift.Sequence, S.Element == Self.Transformer.Input {
        try await fitted(to: input, eventHandler: nil)
    }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol UpdatableEstimator<Transformer> : CreateMLComponents.Estimator {
  func makeTransformer() -> Self.Transformer
  func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element == Self.Transformer.Input
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol UpdatableEstimator : CreateMLComponents.Estimator {
  func makeTransformer() -> Self.Transformer
  func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element == Self.Transformer.Input
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.UpdatableEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence) async throws where InputSequence : Swift.Sequence, InputSequence.Element == Self.Transformer.Input {
        try await update(&transformer, with: input, eventHandler: nil)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct AudioReader : CreateMLComponents.Transformer, Swift.Sendable {
  public var configuration: CreateMLComponents.AudioReader.Configuration
  public init(configuration: CreateMLComponents.AudioReader.Configuration = .init())
  public func applied(to url: Foundation.URL, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.AudioReader.AsyncBuffers
  public static func read(contentsOf url: Foundation.URL, configuration: CreateMLComponents.AudioReader.Configuration = .init()) throws -> CreateMLComponents.AudioReader.AsyncBuffers
  public static func read<S>(_ files: S, configuration: CreateMLComponents.AudioReader.Configuration = .init()) throws -> [CreateMLComponents.AudioReader.AsyncBuffers] where S : Swift.Sequence, S.Element == Foundation.URL
  public static func read<S, Annotation>(_ annotatedFiles: S, configuration: CreateMLComponents.AudioReader.Configuration = .init()) throws -> [CreateMLComponents.AnnotatedFeature<CreateMLComponents.AudioReader.AsyncBuffers, Annotation>] where S : Swift.Sequence, Annotation : Swift.Equatable, Annotation : Swift.Sendable, S.Element == CreateMLComponents.AnnotatedFeature<Foundation.URL, Annotation>
  @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  public static func readMicrophone(configuration: CreateMLComponents.AudioReader.Configuration = .init()) async throws -> CreateMLComponents.AudioReader.MicrophoneAsyncBuffers
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Input = Foundation.URL
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Output = CreateMLComponents.AudioReader.AsyncBuffers
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct AnyTemporalSequence<Feature> : CreateMLComponents.TemporalSequence {
  public typealias Element = CreateMLComponents.TemporalFeature<Feature>
  public typealias AsyncIterator = CreateMLComponents.AnyTemporalIterator<CreateMLComponents.AnyTemporalSequence<Feature>.Element>
  public let count: Swift.Int?
  public init<S>(_ sequence: S) where Feature == S.Feature, S : CreateMLComponents.TemporalSequence
  public init<S>(_ sequence: S, count: Swift.Int?) where S : _Concurrency.AsyncSequence, S.Element == CreateMLComponents.TemporalFeature<Feature>
  public func makeAsyncIterator() -> CreateMLComponents.AnyTemporalIterator<CreateMLComponents.AnyTemporalSequence<Feature>.Element>
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
@available(*, unavailable)
extension CreateMLComponents.AnyTemporalSequence : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct AnyTemporalIterator<Element> : _Concurrency.AsyncIteratorProtocol {
  public func next() async throws -> Element?
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
  #endif
}
@available(*, unavailable)
extension CreateMLComponents.AnyTemporalIterator : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct ModelMetadata : Swift.Hashable, Swift.Sendable {
  public var description: Swift.String
  public var version: Swift.String
  public var author: Swift.String
  public var license: Swift.String
  public var creatorDefined: [Swift.String : Swift.String]
  public init(description: Swift.String = "", version: Swift.String = "", author: Swift.String = "", license: Swift.String = "", creatorDefined: [Swift.String : Swift.String] = [:])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.ModelMetadata, b: CreateMLComponents.ModelMetadata) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func export(to url: Foundation.URL) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public func export(to url: Foundation.URL, metadata: CreateMLComponents.ModelMetadata) throws
}
extension Swift.Sequence where Self.Element : Swift.FloatingPoint {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, tvOS 17.0)
  @inlinable internal func mean() -> Self.Element? {
        var sum = 0 as Element
        var lowOrderCompensation: Element = .zero  
        var count = 0
        for element in self {
            let y = element - lowOrderCompensation
            let t = sum + y
            lowOrderCompensation = (t - sum) - y
            sum = t
            count += 1
        }
        if count == 0 {
            return nil
        }
        return sum / Element(count)
    }
}
extension Swift.Collection where Self.Element : Swift.FloatingPoint {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, tvOS 17.0)
  @inlinable internal func mean() -> Self.Element {
        if self.isEmpty {
            return Element.zero
        }
        return sum() / Element(count)
    }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, tvOS 17.0)
  @inlinable internal func sum() -> Self.Element {
         
        var sum: Element = .zero
        var lowOrderCompensation: Element = .zero  

        for element in self {
            let y = element - lowOrderCompensation
            let t = sum + y
            lowOrderCompensation = (t - sum) - y
            sum = t
        }
        return sum
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct ImputeTransformer<Element> : CreateMLComponents.Transformer, Swift.Codable where Element : Swift.Decodable, Element : Swift.Encodable {
  public var value: Element
  public init(value: Element)
  @inlinable public func applied(to input: Element?, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
        input ?? value
    }
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = Element?
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = Element
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ImputeTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ImputeTransformer : Swift.Equatable where Element : Swift.Equatable {
  public static func == (a: CreateMLComponents.ImputeTransformer<Element>, b: CreateMLComponents.ImputeTransformer<Element>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ImputeTransformer : Swift.Hashable where Element : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ImputeTransformer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
final public class UniformRandomIntegerParameter<RandomTransformer, Parameter> : CreateMLComponents.RandomTransformer where RandomTransformer : CreateMLComponents.RandomTransformer, Parameter : Swift.FixedWidthInteger, RandomTransformer.Input == RandomTransformer.Output {
  final public var range: Swift.Range<Parameter>
  public init<Input>(range: Swift.Range<Parameter>, @CreateMLComponents.AugmentationBuilder<Input> _ augmentation: @escaping (Parameter) -> RandomTransformer) where Input == RandomTransformer.Input
  public init<Input>(range: Swift.ClosedRange<Parameter>, @CreateMLComponents.AugmentationBuilder<Input> _ augmentation: @escaping (Parameter) -> RandomTransformer) where Input == RandomTransformer.Input
  final public func applied(to input: RandomTransformer.Input, generator: inout some RandomNumberGenerator, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> RandomTransformer.Output
  @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
  public typealias Input = RandomTransformer.Input
  @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
  public typealias Output = RandomTransformer.Input
  @objc deinit
}
@available(*, unavailable)
extension CreateMLComponents.UniformRandomIntegerParameter : Swift.Sendable {
}
extension CreateMLComponents.UpdatableTabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self.Transformer, Other>> where Other : CreateMLComponents.TabularTransformer
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self.Transformer, Other.Transformer>> where Other : CreateMLComponents.UpdatableTabularEstimator
  
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public struct PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator> : CreateMLComponents.UpdatableTemporalEstimator where Preprocessor : CreateMLComponents.TemporalTransformer, Estimator : CreateMLComponents.UpdatableTemporalEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTemporalTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  @inlinable public func preprocessed<InputSequence>(from input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>] where InputSequence : Swift.Sequence, Preprocessor.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        var preprocessed = [PreprocessedFeatureSequence<Preprocessor.Output>]()
        for item in input {
            let transformed = try await preprocessor.applied(to: item, eventHandler: eventHandler)
            let stored = try await PreprocessedFeatureSequence(transformed)
            preprocessed.append(stored)
        }
        return preprocessed
    }
  @inlinable public func fitted(toPreprocessed preprocessed: [CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTemporalTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Preprocessor.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  @inlinable public func makeTransformer() -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer {
        ComposedTemporalTransformer(preprocessor, estimator.makeTransformer())
    }
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer, withPreprocessed preprocessed: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Estimator.Transformer.Input == InputSequence.Element.Feature {
        try await estimator.update(&transformer.outer, with: preprocessed, eventHandler: eventHandler)
    }
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Preprocessor.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        try await estimator.update(&transformer.outer, with: preprocessed, eventHandler: eventHandler)
    }
  public func encode(_ transformer: CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.PreprocessingUpdatableTemporalEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<CreateMLComponents.TransformerToTemporalAdaptor<Self>, Other> where Other : CreateMLComponents.UpdatableTemporalEstimator, Self.Output == Other.Transformer.Input
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Self, CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Other>> where Other : CreateMLComponents.UpdatableEstimator, Self.Output == Other.Transformer.Input
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Self, Other> where Other : CreateMLComponents.UpdatableTemporalEstimator, Self.Output == Other.Transformer.Input
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension CreateMLComponents.LinearTimeSeriesForecaster {
  public func encode(_ model: CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Transformer
  public func encodeWithOptimizer(_ model: CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Transformer
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct UpsampledAugmentationSequence<Base, RandomTransformer, RandomNumberGenerator, Annotation> : _Concurrency.AsyncSequence where Base : Swift.Collection, RandomTransformer : CreateMLComponents.RandomTransformer, RandomNumberGenerator : Swift.RandomNumberGenerator, Base.Element == CreateMLComponents.AnnotatedFeature<RandomTransformer.Input, Annotation>, RandomTransformer.Input == RandomTransformer.Output {
  public typealias Element = Base.Element
  public let transformer: RandomTransformer
  public func makeAsyncIterator() -> CreateMLComponents.UpsampledAugmentationSequence<Base, RandomTransformer, RandomNumberGenerator, Annotation>.AsyncIterator
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
@available(*, unavailable)
extension CreateMLComponents.UpsampledAugmentationSequence : Swift.Sendable {
}
extension CreateMLComponents.UpsampledAugmentationSequence {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    public mutating func next() async throws -> Base.Element?
    @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
    public typealias Element = CreateMLComponents.AnnotatedFeature<RandomTransformer.Input, Annotation>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
extension CreateMLComponents.UpsampledAugmentationSequence.AsyncIterator : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct AnnotatedFiles : Swift.Collection {
  public typealias Element = CreateMLComponents.AnnotatedFeature<Foundation.URL, Swift.String>
  public typealias Index = Swift.Array<CreateMLComponents.AnnotatedFiles.Element>.Index
  public var startIndex: CreateMLComponents.AnnotatedFiles.Index {
    get
  }
  public var endIndex: CreateMLComponents.AnnotatedFiles.Index {
    get
  }
  public subscript(index: CreateMLComponents.AnnotatedFiles.Index) -> Swift.IndexingIterator<CreateMLComponents.AnnotatedFiles>.Element {
    get
  }
  public func index(after i: CreateMLComponents.AnnotatedFiles.Index) -> CreateMLComponents.AnnotatedFiles.Index
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Indices = Swift.DefaultIndices<CreateMLComponents.AnnotatedFiles>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Iterator = Swift.IndexingIterator<CreateMLComponents.AnnotatedFiles>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias SubSequence = Swift.Slice<CreateMLComponents.AnnotatedFiles>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedFiles {
  public init(labeledByNamesAt url: Foundation.URL, separator: Swift.Character = ".", index: Swift.Int = 0, type: UniformTypeIdentifiers.UTType, continueOnFailure: Swift.Bool = false) throws
  public init(labeledBySubdirectoryNamesAt url: Foundation.URL, type: UniformTypeIdentifiers.UTType, continueOnFailure: Swift.Bool = false) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedFiles : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedFiles : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedFiles : Swift.Equatable {
  public static func == (a: CreateMLComponents.AnnotatedFiles, b: CreateMLComponents.AnnotatedFiles) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedFiles : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedFiles : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct PreprocessingUpdatableTabularEstimator<Preprocessor, Estimator> : CreateMLComponents.UpdatableTabularEstimator where Preprocessor : CreateMLComponents.TabularTransformer, Estimator : CreateMLComponents.UpdatableTabularEstimator {
  public typealias Transformer = CreateMLComponents.ComposedTabularTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ inner: Preprocessor, _ outer: Estimator)
  @inlinable public func makeTransformer() -> CreateMLComponents.PreprocessingUpdatableTabularEstimator<Preprocessor, Estimator>.Transformer {
        ComposedTabularTransformer(preprocessor, estimator.makeTransformer())
    }
  @inlinable public func preprocessed(from input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame {
        try await preprocessor.applied(to: input, eventHandler: eventHandler)
    }
  @inlinable public func fitted(toPreprocessed preprocessed: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableTabularEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTabularTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableTabularEstimator<Preprocessor, Estimator>.Transformer {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  @inlinable public func update(_ transformer: inout CreateMLComponents.PreprocessingUpdatableTabularEstimator<Preprocessor, Estimator>.Transformer, withPreprocessed preprocessed: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws {
        try await estimator.update(&transformer.outer, with: preprocessed, eventHandler: eventHandler)
    }
  @inlinable public func update(_ transformer: inout CreateMLComponents.PreprocessingUpdatableTabularEstimator<Preprocessor, Estimator>.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        try await estimator.update(&transformer.outer, with: preprocessed, eventHandler: eventHandler)
    }
  public func encode(_ transformer: CreateMLComponents.PreprocessingUpdatableTabularEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableTabularEstimator<Preprocessor, Estimator>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.PreprocessingUpdatableTabularEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableTabularEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.PreprocessingUpdatableTabularEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableTabularEstimator<Self, Other> where Other : CreateMLComponents.UpdatableTabularEstimator
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public typealias EventHandler = @Sendable (CreateMLComponents.Event) -> Swift.Void
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct Event : Swift.Sendable {
  public var origin: Swift.String
  public var itemCount: Swift.Int
  public var totalItemCount: Swift.Int?
  public var metrics: [CreateMLComponents.MetricsKey : any Swift.Sendable]
  public init(origin: Swift.String, itemCount: Swift.Int, totalItemCount: Swift.Int? = nil, metrics: [CreateMLComponents.MetricsKey : any Swift.Sendable])
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Event : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct MetricsKey : Swift.Hashable, Swift.RawRepresentable, Swift.Sendable {
  public var rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let source: CreateMLComponents.MetricsKey
  public static let trainingAccuracy: CreateMLComponents.MetricsKey
  public static let validationAccuracy: CreateMLComponents.MetricsKey
  public static let trainingLoss: CreateMLComponents.MetricsKey
  public static let validationLoss: CreateMLComponents.MetricsKey
  public static let trainingMaximumError: CreateMLComponents.MetricsKey
  public static let validationMaximumError: CreateMLComponents.MetricsKey
  public static let trainingError: CreateMLComponents.MetricsKey
  public static let validationError: CreateMLComponents.MetricsKey
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public static let trainingMeanAveragePrecision: CreateMLComponents.MetricsKey
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public static let validationMeanAveragePrecision: CreateMLComponents.MetricsKey
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias RawValue = Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MetricsKey : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension CreateMLComponents.MultivariateLinearRegressor {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
  public typealias Configuration = CreateMLComponents.MultivariateLinearRegressorConfiguration
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct MultivariateLinearRegressorConfiguration : Swift.Hashable, Swift.Codable, Swift.Sendable {
  public var batchSize: Swift.Int
  public var maximumIterationCount: Swift.Int
  public var earlyStoppingTolerance: Swift.Float
  public var earlyStoppingIterationCount: Swift.Int
  public var learningRate: Swift.Float
  public var randomSeed: Swift.Int?
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.MultivariateLinearRegressorConfiguration, b: CreateMLComponents.MultivariateLinearRegressorConfiguration) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum PoseSelectionStrategy : Swift.Sendable {
  case maximumBoundingBoxArea
  case highestJointLocation
  case lowestJointLocation
  case leftmostJointLocation
  case rightmostJointLocation
  public static func == (a: CreateMLComponents.PoseSelectionStrategy, b: CreateMLComponents.PoseSelectionStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct PoseSelector : CreateMLComponents.Transformer, Swift.Sendable {
  public var strategy: CreateMLComponents.PoseSelectionStrategy
  public var confidenceThreshold: Swift.Float
  public init(strategy: CreateMLComponents.PoseSelectionStrategy, confidenceThreshold: Swift.Float)
  public init(strategy: CreateMLComponents.PoseSelectionStrategy)
  public init()
  public func applied(to input: [CreateMLComponents.Pose], eventHandler: CreateMLComponents.EventHandler? = nil) -> CreateMLComponents.Pose
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Input = [CreateMLComponents.Pose]
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Output = CreateMLComponents.Pose
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PoseSelector : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct AnnotatedFeatureProvider<Base, UnwrappedInput> : CreateMLComponents.SupervisedTabularEstimator where Base : CreateMLComponents.SupervisedEstimator, Base.Transformer.Input == UnwrappedInput? {
  public typealias Transformer = CreateMLComponents.ColumnSelectorTransformer<Base.Transformer, UnwrappedInput>
  public typealias Annotation = Base.Annotation
  public var base: Base
  public var annotationColumnID: TabularData.ColumnID<CreateMLComponents.AnnotatedFeatureProvider<Base, UnwrappedInput>.Annotation>
  public var featuresColumnName: Swift.String
  public var resultsColumnName: Swift.String
  public init(_ base: Base, annotationsColumnName: Swift.String = "targets", featuresColumnName: Swift.String = "features", resultsColumnName: Swift.String = "results")
  public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame? = nil, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ColumnSelectorTransformer<Base.Transformer, UnwrappedInput>
  public func encode(_ transformer: CreateMLComponents.AnnotatedFeatureProvider<Base, UnwrappedInput>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.AnnotatedFeatureProvider<Base, UnwrappedInput>.Transformer
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedFeatureProvider : CreateMLComponents.UpdatableSupervisedTabularEstimator where Base : CreateMLComponents.UpdatableSupervisedEstimator {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func makeTransformer() -> CreateMLComponents.AnnotatedFeatureProvider<Base, UnwrappedInput>.Transformer
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func update(_ transformer: inout CreateMLComponents.AnnotatedFeatureProvider<Base, UnwrappedInput>.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.AnnotatedFeatureProvider<Base, UnwrappedInput>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.AnnotatedFeatureProvider<Base, UnwrappedInput>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedFeatureProvider : Swift.Sendable where Base : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.FullyConnectedNetworkRegressor {
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar>
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.FullyConnectedNetworkRegressor<Scalar>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.FullyConnectedNetworkRegressor<Scalar>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct SlidingWindowTransformer<Input> : CreateMLComponents.TemporalTransformer, Swift.Codable, Swift.Sendable where Input : Swift.Sendable {
  public typealias Input = Input
  public typealias Output = [Input]
  public let stride: Swift.Int
  public let length: Swift.Int
  public init(stride: Swift.Int, length: Swift.Int)
  public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler?) throws -> CreateMLComponents.SlidingWindowTransformer<Input>.WindowSequence where Input == S.Feature, S : CreateMLComponents.TemporalSequence
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias OutputSequence = CreateMLComponents.SlidingWindowTransformer<Input>.WindowSequence
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.SlidingWindowTransformer {
  public struct WindowSequence : CreateMLComponents.TemporalSequence {
    public typealias Feature = [Input]
    public typealias AsyncIterator = CreateMLComponents.SlidingWindowTransformer<Input>.WindowSequence.Iterator
    public var count: Swift.Int? {
      get
    }
    public func makeAsyncIterator() -> CreateMLComponents.SlidingWindowTransformer<Input>.WindowSequence.Iterator
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.SlidingWindowTransformer<Input>.WindowSequence.Feature>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncSequence_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
extension CreateMLComponents.SlidingWindowTransformer.WindowSequence : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.SlidingWindowTransformer.WindowSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public mutating func next() async throws -> CreateMLComponents.TemporalFeature<CreateMLComponents.SlidingWindowTransformer<Input>.Output>?
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.SlidingWindowTransformer<Input>.Output>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
extension CreateMLComponents.SlidingWindowTransformer.WindowSequence.Iterator : Swift.Sendable {
}
extension CreateMLComponents.Estimator {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self.Transformer>, Other.Transformer>, Other.Annotation> where Other : CreateMLComponents.SupervisedTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.SupervisedEstimator {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  @preconcurrency public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self.Transformer>, Other>, Self.Annotation> where Other : CreateMLComponents.TemporalTransformer, Self.Annotation : Swift.Sendable, Other.Input == Self.Transformer.Output
  
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  @preconcurrency public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self.Transformer>, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.TemporalEstimator, Self.Annotation : Swift.Sendable, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self.Transformer>, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.SupervisedTemporalEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.TemporalEstimator {
  @preconcurrency public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, CreateMLComponents.TransformerToTemporalAdaptor<Other.Transformer>>, Other.Annotation> where Other : CreateMLComponents.SupervisedEstimator, Other.Annotation : Swift.Sendable, Self.Transformer.Output == Other.Transformer.Input
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, Other.Transformer>, Other.Annotation> where Other : CreateMLComponents.SupervisedTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.SupervisedTemporalEstimator {
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, CreateMLComponents.TransformerToTemporalAdaptor<Other>>, Self.Annotation> where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, CreateMLComponents.TransformerToTemporalAdaptor<Other.Transformer>>, Self.Annotation> where Other : CreateMLComponents.Estimator, Self.Transformer.Output == Other.Transformer.Input
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, CreateMLComponents.TransformerToTemporalAdaptor<Other.Transformer>>, Self.Annotation> where Other : CreateMLComponents.SupervisedEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, Other>, Self.Annotation> where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.TemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.SupervisedTemporalEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public enum ConcatenationError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case nonUniformShapes(columnName: Swift.String)
  case mismatchedShapes
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.ConcatenationError, b: CreateMLComponents.ConcatenationError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ConcatenationError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public enum SerializationError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case packageAlreadyExists(Foundation.URL)
  case packageNotFound(Foundation.URL)
  case notRepresentableAsCoreML(debugDescription: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.SerializationError, b: CreateMLComponents.SerializationError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.SerializationError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum AudioReaderError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case microphoneAuthorizationDenied
  case microphoneAuthorizationRestricted
  case sourceDeviceNotAvailable
  public var errorDescription: Swift.String? {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.AudioReaderError, b: CreateMLComponents.AudioReaderError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioReaderError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TabularEstimator {
  public func write(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func read(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.SupervisedTabularEstimator {
  public func write(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func read(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.UpdatableSupervisedTabularEstimator {
  public func writeWithOptimizer(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func readWithOptimizer(from url: Foundation.URL) throws -> Self.Transformer
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol TemporalSequence<Feature> : _Concurrency.AsyncSequence {
  associatedtype Feature where Self.Element == CreateMLComponents.TemporalFeature<Self.Feature>
  var count: Swift.Int? { get }
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol TemporalSequence : _Concurrency.AsyncSequence {
  associatedtype Feature where Self.Element == CreateMLComponents.TemporalFeature<Self.Feature>
  var count: Swift.Int? { get }
}
#endif
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct TemporalFeature<Feature> : Swift.Identifiable {
  public var id: CreateMLComponents.TemporalSegmentIdentifier
  public var feature: Feature
  public init(id: CreateMLComponents.TemporalSegmentIdentifier, feature: Feature)
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias ID = CreateMLComponents.TemporalSegmentIdentifier
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalFeature : Swift.Equatable where Feature : Swift.Equatable {
  public static func == (a: CreateMLComponents.TemporalFeature<Feature>, b: CreateMLComponents.TemporalFeature<Feature>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalFeature : Swift.Hashable where Feature : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalFeature : Swift.Encodable where Feature : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalFeature : Swift.Decodable where Feature : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalFeature : Swift.Sendable where Feature : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct LinearRegressorModel<Scalar> : CreateMLComponents.Regressor where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public typealias Input = CoreML.MLShapedArray<Scalar>
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var featureCount: Swift.Int {
    get
  }
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var coefficients: [Scalar] {
    get
  }
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public init(coefficients: some Sequence<Scalar>)
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Scalar
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = Scalar
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.LinearRegressorModel : Swift.Sendable where Scalar : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func adaptedAsAnnotatedPredictionTransformer<Annotation>(annotationType: Annotation.Type = Annotation.self) -> some CreateMLComponents.Transformer<CreateMLComponents.AnnotatedPrediction<Self.Input, Annotation>, CreateMLComponents.AnnotatedPrediction<Self.Output, Annotation>>
  
}
extension CreateMLComponents.MultiLabelClassificationMetrics {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public enum ThresholdSelectionStrategy : Swift.Hashable, Swift.Equatable {
    case balancedPrecisionAndRecall
    case precision(Swift.Float, minimumRecall: Swift.Float)
    case recall(Swift.Float, minimumPrecision: Swift.Float)
    case fixed([Label : Swift.Float])
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.MultiLabelClassificationMetrics<Label>.ThresholdSelectionStrategy, b: CreateMLComponents.MultiLabelClassificationMetrics<Label>.ThresholdSelectionStrategy) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.MultiLabelClassificationMetrics.ThresholdSelectionStrategy : Swift.Encodable where Label : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.MultiLabelClassificationMetrics.ThresholdSelectionStrategy : Swift.Decodable where Label : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.MultiLabelClassificationMetrics.ThresholdSelectionStrategy : Swift.Sendable where Label : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct ClassificationDistribution<Label> : Swift.Collection where Label : Swift.Hashable {
  public var mostLikelyLabel: Label? {
    get
  }
  public var labelsSortedByProbability: [Label] {
    get
  }
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public init<C>(_ classifications: C) where C : Swift.Collection, C.Element == CreateMLComponents.Classification<Label>
  public func topLabels(_ amount: Swift.Int) -> [Label]
  public subscript(index: Swift.Int) -> CreateMLComponents.Classification<Label> {
    get
  }
  public subscript(label: Label) -> Swift.Float? {
    get
  }
  public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.Slice<CreateMLComponents.ClassificationDistribution<Label>> {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public func index(before i: Swift.Int) -> Swift.Int
  public func map<T>(_ transform: (CreateMLComponents.Classification<Label>) throws -> CreateMLComponents.Classification<T>) rethrows -> CreateMLComponents.ClassificationDistribution<T> where T : Swift.Hashable
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Element = CreateMLComponents.Classification<Label>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Index = Swift.Int
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Indices = Swift.DefaultIndices<CreateMLComponents.ClassificationDistribution<Label>>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Iterator = Swift.IndexingIterator<CreateMLComponents.ClassificationDistribution<Label>>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias SubSequence = Swift.Slice<CreateMLComponents.ClassificationDistribution<Label>>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ClassificationDistribution : Swift.Equatable {
  public static func == (a: CreateMLComponents.ClassificationDistribution<Label>, b: CreateMLComponents.ClassificationDistribution<Label>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ClassificationDistribution : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ClassificationDistribution : Swift.Codable where Label : Swift.Decodable, Label : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ClassificationDistribution : Swift.Sendable where Label : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ImageScaler : CreateMLComponents.Transformer, Swift.Sendable {
  public var targetSize: CoreFoundation.CGSize {
    get
    set
  }
  public init(targetSize: CoreFoundation.CGSize)
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public init(targetWidth: Swift.Double)
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public init(targetHeight: Swift.Double)
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CoreImage.CIImage
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Input = CoreImage.CIImage
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Output = CoreImage.CIImage
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageScaler : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageScaler : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.Sequence {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func mapFeatures<Input, Output, Annotation>(_ transform: (Input) throws -> Output) rethrows -> [CreateMLComponents.AnnotatedFeature<Output, Annotation>] where Self.Element == CreateMLComponents.AnnotatedFeature<Input, Annotation> {
        try map {
            try AnnotatedFeature(feature: transform($0.feature), annotation: $0.annotation)
        }
    }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func mapFeatures<Input, Output, Annotation>(_ transform: (Input) async throws -> Output) async rethrows -> [CreateMLComponents.AnnotatedFeature<Output, Annotation>] where Self.Element == CreateMLComponents.AnnotatedFeature<Input, Annotation> {
        var result = [AnnotatedFeature<Output, Annotation>]()
        for value in self {
            let transformed = try await transform(value.feature)
            result.append(AnnotatedFeature(feature: transformed, annotation: value.annotation))
        }
        return result
    }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func mapAnnotations<Feature, Input, Output>(_ transform: (Input) throws -> Output) rethrows -> [CreateMLComponents.AnnotatedFeature<Feature, Output>] where Self.Element == CreateMLComponents.AnnotatedFeature<Feature, Input> {
        try map {
            try AnnotatedFeature(feature: $0.feature, annotation: transform($0.annotation))
        }
    }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func mapAnnotations<Feature, Input, Output>(_ transform: (Input) async throws -> Output) async rethrows -> [CreateMLComponents.AnnotatedFeature<Feature, Output>] where Self.Element == CreateMLComponents.AnnotatedFeature<Feature, Input> {
        var result = [AnnotatedFeature<Feature, Output>]()
        for value in self {
            let transformed = try await transform(value.annotation)
            result.append(AnnotatedFeature(feature: value.feature, annotation: transformed))
        }
        return result
    }
}
extension Swift.LazySequence {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func mapFeatures<Input, Output, Annotation>(_ transform: @escaping (Input) -> Output) -> Swift.LazyMapSequence<Base, CreateMLComponents.AnnotatedFeature<Output, Annotation>> where Base.Element == CreateMLComponents.AnnotatedFeature<Input, Annotation> {
        map {
            AnnotatedFeature(feature: transform($0.feature), annotation: $0.annotation)
        }
    }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func mapAnnotations<Feature, Input, Output>(_ transform: @escaping (Input) -> Output) -> Swift.LazyMapSequence<Base, CreateMLComponents.AnnotatedFeature<Feature, Output>> where Base.Element == CreateMLComponents.AnnotatedFeature<Feature, Input> {
        map {
            AnnotatedFeature(feature: $0.feature, annotation: transform($0.annotation))
        }
    }
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func export(to url: Foundation.URL) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public func export(to url: Foundation.URL, metadata: CreateMLComponents.ModelMetadata) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct Augmenter<RandomTransformer, RandomNumberGenerator> where RandomTransformer : CreateMLComponents.RandomTransformer, RandomNumberGenerator : Swift.RandomNumberGenerator, RandomTransformer.Input == RandomTransformer.Output {
  public init<Input>(generator: RandomNumberGenerator = SystemRandomNumberGenerator(), @CreateMLComponents.AugmentationBuilder<Input> _ builder: @escaping () -> RandomTransformer) where Input == RandomTransformer.Input
  public func applied<S, Annotation>(to base: S) -> CreateMLComponents.AugmentationSequence<S, RandomTransformer, RandomNumberGenerator, Annotation> where S : Swift.Sequence, Annotation : Swift.Equatable, S.Element == CreateMLComponents.AnnotatedFeature<RandomTransformer.Input, Annotation>
  public func applied<C, Annotation>(to elements: C, upsampledBy count: Swift.Int) -> CreateMLComponents.UpsampledAugmentationSequence<C, RandomTransformer, RandomNumberGenerator, Annotation> where C : Swift.Collection, Annotation : Swift.Equatable, C.Element == CreateMLComponents.AnnotatedFeature<RandomTransformer.Input, Annotation>
}
@available(*, unavailable)
extension CreateMLComponents.Augmenter : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionCounter {
  public struct CumulativeSumSequence : CreateMLComponents.TemporalSequence {
    public typealias AsyncIterator = CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence.Iterator
    public typealias Feature = Swift.Float
    public var count: Swift.Int? {
      get
    }
    public func makeAsyncIterator() -> CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence.Iterator
    @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence.Feature>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncSequence_Failure = any Swift.Error
    #endif
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public mutating func next() async throws -> CreateMLComponents.TemporalFeature<Swift.Float>?
    @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
    public typealias Element = CreateMLComponents.TemporalFeature<Swift.Float>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
extension CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence : Swift.Sendable {
}
@available(*, unavailable)
extension CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence.Iterator : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
public struct FullyConnectedNetworkMultiLabelClassifier<Scalar, Label> : CreateMLComponents.SupervisedEstimator where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint, Scalar : Swift.Decodable, Scalar : Swift.Encodable, Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  public typealias Transformer = CreateMLComponents.FullyConnectedNetworkMultiLabelClassifierModel<Scalar, Label>
  public typealias Annotation = Swift.Set<Label>
  public var configuration: CreateMLComponents.FullyConnectedNetworkConfiguration
  @available(macOS, unavailable)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public var networkConfiguration: CreateMLComponents.FullyConnectedNetworkConfiguration {
    get
    set
  }
  public var labels: Swift.Set<Label>
  public static var defaultConfiguration: CreateMLComponents.FullyConnectedNetworkConfiguration {
    get
  }
  @available(macOS, unavailable)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public init(labels: Swift.Set<Label>, networkConfiguration: CreateMLComponents.FullyConnectedNetworkConfiguration)
  public init(labels: Swift.Set<Label>, configuration: CreateMLComponents.FullyConnectedNetworkConfiguration = defaultConfiguration)
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.FullyConnectedNetworkMultiLabelClassifierModel<Scalar, Label> where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Swift.Set<Label>>
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.FullyConnectedNetworkMultiLabelClassifierModel<Scalar, Label> where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Swift.Set<Label>>, Validation.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Swift.Set<Label>>
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.FullyConnectedNetworkMultiLabelClassifier : Swift.Sendable where Scalar : Swift.Sendable, Label : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct JointsSelector : CreateMLComponents.Transformer, Swift.Sendable {
  public var ignoredJoints: [CreateMLComponents.JointKey]?
  public var selectedJoints: [CreateMLComponents.JointKey]?
  public init(ignoredJoints: [CreateMLComponents.JointKey])
  public init(selectedJoints: [CreateMLComponents.JointKey])
  public func applied(to input: CreateMLComponents.Pose, eventHandler: CreateMLComponents.EventHandler? = nil) -> CreateMLComponents.Pose
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Input = CreateMLComponents.Pose
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Output = CreateMLComponents.Pose
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.JointsSelector : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension CreateMLComponents.LinearTimeSeriesForecaster {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
  public typealias Configuration = CreateMLComponents.LinearTimeSeriesForecasterConfiguration
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct LinearTimeSeriesForecasterConfiguration : Swift.Hashable, Swift.Codable, Swift.Sendable {
  public var inputWindowSize: Swift.Int
  public var forecastWindowSize: Swift.Int
  public var batchSize: Swift.Int
  public var maximumIterationCount: Swift.Int
  public var earlyStoppingTolerance: Swift.Float
  public var earlyStoppingIterationCount: Swift.Int
  public var learningRate: Swift.Float
  public var randomSeed: Swift.Int?
  public init(inputWindowSize: Swift.Int, forecastWindowSize: Swift.Int)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.LinearTimeSeriesForecasterConfiguration, b: CreateMLComponents.LinearTimeSeriesForecasterConfiguration) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct TemporalFileSegment {
  public var url: Foundation.URL
  public var range: Swift.Range<Foundation.TimeInterval>
  public init(url: Foundation.URL, range: Swift.Range<Foundation.TimeInterval>)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalFileSegment : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalFileSegment : Swift.Equatable {
  public static func == (a: CreateMLComponents.TemporalFileSegment, b: CreateMLComponents.TemporalFileSegment) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalFileSegment : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalFileSegment : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalFileSegment : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
public struct ObjectDetectionMetrics<Label> where Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  public var labels: Swift.Set<Label>
  public var defaultConfidenceThreshold: Swift.Float
  public init()
  public static func extractLabels(from annotations: [CreateMLComponents.ObjectDetectionAnnotation<Label>]) -> Swift.Set<Label>
  public func averagePrecision<Scalar>(predictions: [[CreateMLComponents.DetectedObject<Label>]], annotations: [CreateMLComponents.ObjectDetectionAnnotation<Label>], confidenceThresholds: [Label : Swift.Float] = [:], overlapThreshold: Swift.Double = 0.5) -> [Label : Scalar] where Scalar : Swift.BinaryFloatingPoint
  public func meanAveragePrecision<Scalar>(predictions: [[CreateMLComponents.DetectedObject<Label>]], annotations: [CreateMLComponents.ObjectDetectionAnnotation<Label>], confidenceThresholds: [Label : Swift.Float] = [:], overlapThreshold: Swift.Double = 0.5) -> Scalar where Scalar : Swift.BinaryFloatingPoint
  public func averageOfAveragePrecisionAtVariedThresholds<Scalar>(predictions: [[CreateMLComponents.DetectedObject<Label>]], annotations: [CreateMLComponents.ObjectDetectionAnnotation<Label>], confidenceThresholds: [Label : Swift.Float] = [:]) -> [Label : Scalar] where Scalar : Swift.BinaryFloatingPoint
  public func averageOfMeanAveragePrecisionAtVariedThresholds<Scalar>(predictions: [[CreateMLComponents.DetectedObject<Label>]], annotations: [CreateMLComponents.ObjectDetectionAnnotation<Label>], confidenceThresholds: [Label : Swift.Float] = [:]) -> Scalar where Scalar : Swift.BinaryFloatingPoint
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.ObjectDetectionMetrics : Swift.Sendable where Label : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public enum TabularPipelineDataError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case missingColumn(operation: Swift.String, columnName: Swift.String)
  case incorrectType(operation: Swift.String, columnName: Swift.String, actual: Swift.String, expected: Swift.String)
  case missingValues(operation: Swift.String, columnName: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.TabularPipelineDataError, b: CreateMLComponents.TabularPipelineDataError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TabularPipelineDataError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.FullyConnectedNetworkMultiLabelClassifier : CreateMLComponents.UpdatableSupervisedEstimator {
  public func makeTransformer() -> CreateMLComponents.FullyConnectedNetworkMultiLabelClassifierModel<Scalar, Label>
  public func update<InputSequence>(_ transformer: inout CreateMLComponents.FullyConnectedNetworkMultiLabelClassifierModel<Scalar, Label>, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Swift.Set<Label>>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public enum PipelineDataError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case missingValue(operation: Swift.String)
  case missingAnnotation(operation: Swift.String)
  case emptyInput(operation: Swift.String)
  case unrecognizedCategory(operation: Swift.String, category: Swift.String)
  case incompatibleDataFormat(operation: Swift.String, debugDescription: Swift.String)
  case incompatibleConfiguration(operation: Swift.String, debugDescription: Swift.String)
  case incompatibleShape([Swift.Int], debugDescription: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.PipelineDataError, b: CreateMLComponents.PipelineDataError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.PipelineDataError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension CreateMLComponents.Estimator {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self.Transformer>, Other>> where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self.Transformer>, Other.Transformer>> where Other : CreateMLComponents.TemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.TemporalEstimator {
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, CreateMLComponents.TransformerToTemporalAdaptor<Other>>> where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, CreateMLComponents.TransformerToTemporalAdaptor<Other.Transformer>>> where Other : CreateMLComponents.Estimator, Self.Transformer.Output == Other.Transformer.Input
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, Other>> where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, Other.Transformer>> where Other : CreateMLComponents.TemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
@_functionBuilder public struct AugmentationBuilder<Element> : Swift.Sendable {
  public static func buildPartialBlock(first: some RandomTransformer<Element, Element>) -> some CreateMLComponents.RandomTransformer<Element, Element>
  
  public static func buildPartialBlock(first: some Transformer<Element, Element>) -> some CreateMLComponents.RandomTransformer<Element, Element>
  
  public static func buildPartialBlock(accumulated: some RandomTransformer<Element, Element>, next: some RandomTransformer<Element, Element>) -> some CreateMLComponents.RandomTransformer<Element, Element>
  
  public static func buildPartialBlock(accumulated: some RandomTransformer<Element, Element>, next: some Transformer<Element, Element>) -> some CreateMLComponents.RandomTransformer<Element, Element>
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct Downsampler<Input> : CreateMLComponents.TemporalTransformer, Swift.Codable, Swift.Sendable where Input : Swift.Sendable {
  public typealias Input = Input
  public typealias Output = Input
  public let factor: Swift.Int
  public init(factor: Swift.Int)
  public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler?) throws -> CreateMLComponents.Downsampler<Input>.DownStreamSequence where Input == S.Feature, S : CreateMLComponents.TemporalSequence
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias OutputSequence = CreateMLComponents.Downsampler<Input>.DownStreamSequence
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Downsampler {
  public struct DownStreamSequence : CreateMLComponents.TemporalSequence {
    public typealias Feature = Input
    public typealias AsyncIterator = CreateMLComponents.Downsampler<Input>.DownStreamSequence.Iterator
    public var count: Swift.Int? {
      get
    }
    public func makeAsyncIterator() -> CreateMLComponents.Downsampler<Input>.DownStreamSequence.Iterator
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.Downsampler<Input>.DownStreamSequence.Feature>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncSequence_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
extension CreateMLComponents.Downsampler.DownStreamSequence : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Downsampler.DownStreamSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public mutating func next() async throws -> CreateMLComponents.TemporalFeature<CreateMLComponents.Downsampler<Input>.Output>?
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.Downsampler<Input>.Output>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
extension CreateMLComponents.Downsampler.DownStreamSequence.Iterator : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
@inlinable internal func absoluteError<T>(_ annotatedPrediction: CreateMLComponents.AnnotatedPrediction<T, T>) -> T where T : Swift.FloatingPoint {
    abs(annotatedPrediction.prediction - annotatedPrediction.annotation)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
@backDeployed(before: macOS 14.0, iOS 17.0, tvOS 17.0)
@inlinable public func maximumAbsoluteError<T>(_ predicted: some Collection<T>, _ groundTruth: some Collection<T>) -> T where T : Swift.FloatingPoint {
    assert(
        predicted.count == groundTruth.count,
        "The collection of predicted values must have the same number of elements as the collection of ground truth values."
    )
    if predicted.isEmpty {
        return .nan
    }
    return zip(predicted, groundTruth).map({ abs($0 - $1) }).max() ?? .nan
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
@inlinable public func maximumAbsoluteError<T>(_ annotatedPredictions: [CreateMLComponents.AnnotatedPrediction<T, T>]) -> T where T : Swift.FloatingPoint {
    if let maximumAbsoluteError = annotatedPredictions.map({ absoluteError($0) }).max() {
        return maximumAbsoluteError
    }
    return .nan
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
@backDeployed(before: macOS 14.0, iOS 17.0, tvOS 17.0)
@inlinable public func meanAbsoluteError<T>(_ predicted: some Collection<T>, _ groundTruth: some Collection<T>) -> T where T : Swift.FloatingPoint {
    assert(
        predicted.count == groundTruth.count,
        "The collection of predicted values must have the same number of elements as the collection of ground truth values."
    )
    if predicted.isEmpty {
        return .nan
    }
    return zip(predicted, groundTruth).map({ abs($0 - $1) }).mean() ?? .nan
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
@inlinable public func meanAbsoluteError<T>(_ annotatedPredictions: [CreateMLComponents.AnnotatedPrediction<T, T>]) -> T where T : Swift.FloatingPoint {
    if annotatedPredictions.isEmpty {
        return .nan
    }
    return annotatedPredictions.map({ absoluteError($0) }).mean()
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, visionOS 1.0, watchOS 11.0, *)
@backDeployed(before: macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0)
@inlinable public func meanSquaredError<T>(_ predicted: some Collection<T>, _ groundTruth: some Collection<T>) -> T where T : Swift.FloatingPoint {
    assert(
        predicted.count == groundTruth.count,
        "The collection of predicted values must have the same number of elements as the collection of ground truth values."
    )
    if predicted.isEmpty {
        return .nan
    }
    return zip(predicted, groundTruth).map({ ($0 - $1) * ($0 - $1) }).mean()
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, visionOS 1.0, watchOS 11.0, *)
@backDeployed(before: macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0)
@inlinable public func meanSquaredError<T>(_ annotatedPredictions: [CreateMLComponents.AnnotatedPrediction<T, T>]) -> T where T : Swift.FloatingPoint {
    guard !annotatedPredictions.isEmpty else {
        return .nan
    }
    return annotatedPredictions.map({ ($0.prediction - $0.annotation) * ($0.prediction - $0.annotation) }).mean()
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
@backDeployed(before: macOS 14.0, iOS 17.0, tvOS 17.0)
@inlinable public func rootMeanSquaredError<T>(_ predicted: some Collection<T>, _ groundTruth: some Collection<T>) -> T where T : Swift.FloatingPoint {
    meanSquaredError(predicted, groundTruth).squareRoot()
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
@inlinable public func rootMeanSquaredError<T>(_ annotatedPredictions: [CreateMLComponents.AnnotatedPrediction<T, T>]) -> T where T : Swift.FloatingPoint {
    meanSquaredError(annotatedPredictions).squareRoot()
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
@inlinable public func meanAbsolutePercentageError<T>(_ annotatedPredictions: [CreateMLComponents.AnnotatedPrediction<T, T>]) -> T where T : Swift.FloatingPoint {
    if annotatedPredictions.isEmpty {
        return .nan
    }
    return annotatedPredictions.map({ abs(($0.annotation - $0.prediction) / $0.annotation) }).mean()
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioReader {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct AsyncBuffers : CreateMLComponents.TemporalSequence {
    public typealias AsyncIterator = CreateMLComponents.AudioReader.AsyncBuffers.Iterator
    public typealias Feature = AVFAudio.AVAudioPCMBuffer
    public let url: Foundation.URL
    public let count: Swift.Int?
    public func makeAsyncIterator() -> CreateMLComponents.AudioReader.AsyncBuffers.Iterator
    @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.AudioReader.AsyncBuffers.Feature>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncSequence_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
extension CreateMLComponents.AudioReader.AsyncBuffers : Swift.Sendable {
}
extension CreateMLComponents.AudioReader.AsyncBuffers {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public mutating func next() async throws -> CreateMLComponents.TemporalFeature<AVFAudio.AVAudioPCMBuffer>?
    @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
    public typealias Element = CreateMLComponents.TemporalFeature<AVFAudio.AVAudioPCMBuffer>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
extension CreateMLComponents.AudioReader.AsyncBuffers.Iterator : Swift.Sendable {
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public protocol RandomTransformer<Input, Output> {
  associatedtype Input
  associatedtype Output
  func applied(to input: Self.Input, generator: inout some RandomNumberGenerator, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Output
}
#else
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public protocol RandomTransformer {
  associatedtype Input
  associatedtype Output
  func applied(to input: Self.Input, generator: inout some RandomNumberGenerator, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Output
}
#endif
extension Swift.Sequence {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func randomSplit<Feature, Annotation>(by proportion: Swift.Double, seed: Swift.Int? = nil) -> ([CreateMLComponents.AnnotatedFeature<Feature, Annotation>], [CreateMLComponents.AnnotatedFeature<Feature, Annotation>]) where Annotation : Swift.Hashable, Self.Element == CreateMLComponents.AnnotatedFeature<Feature, Annotation>
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func randomSplit<T>(by proportion: Swift.Double, seed: Swift.Int? = nil) -> (Swift.ArraySlice<T>, Swift.ArraySlice<T>) where T == Self.Element
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func randomSplit<Feature, Annotation, Generator>(by proportion: Swift.Double, using generator: inout Generator) -> ([CreateMLComponents.AnnotatedFeature<Feature, Annotation>], [CreateMLComponents.AnnotatedFeature<Feature, Annotation>]) where Annotation : Swift.Hashable, Generator : Swift.RandomNumberGenerator, Self.Element == CreateMLComponents.AnnotatedFeature<Feature, Annotation>
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func randomSplit<T, Generator>(by proportion: Swift.Double, using generator: inout Generator) -> (Swift.ArraySlice<T>, Swift.ArraySlice<T>) where T == Self.Element, Generator : Swift.RandomNumberGenerator
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct PreprocessingUpdatableSupervisedTabularEstimator<Preprocessor, Estimator> : CreateMLComponents.UpdatableSupervisedTabularEstimator where Preprocessor : CreateMLComponents.TabularTransformer, Estimator : CreateMLComponents.UpdatableSupervisedTabularEstimator {
  public typealias Transformer = CreateMLComponents.ComposedTabularTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public typealias Annotation = Estimator.Annotation
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public var annotationColumnID: TabularData.ColumnID<Estimator.Annotation> {
    get
    set
  }
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  @inlinable public func makeTransformer() -> CreateMLComponents.PreprocessingUpdatableSupervisedTabularEstimator<Preprocessor, Estimator>.Transformer {
        ComposedTabularTransformer(preprocessor, estimator.makeTransformer())
    }
  @inlinable public func preprocessed(from input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame {
        try await preprocessor.applied(to: input, eventHandler: eventHandler)
    }
  @inlinable public func fitted(toPreprocessed preprocessedInput: TabularData.DataFrame, validateOn preprocessedValidation: TabularData.DataFrame?, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTabularEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
        return ComposedTabularTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame?, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTabularEstimator<Preprocessor, Estimator>.Transformer {
        let preprocessedInput = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        let preprocessedValidation: DataFrame?
        if let validation {
            preprocessedValidation = try await preprocessed(from: validation, eventHandler: eventHandler)
            try Task.checkCancellation()
        } else {
            preprocessedValidation = nil
        }

        return try await fitted(
            toPreprocessed: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
    }
  @inlinable public func update(_ transformer: inout CreateMLComponents.PreprocessingUpdatableSupervisedTabularEstimator<Preprocessor, Estimator>.Transformer, withPreprocessed preprocessed: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws {
        try await estimator.update(
            &transformer.outer,
            with: preprocessed,
            eventHandler: eventHandler
        )
    }
  @inlinable public func update(_ transformer: inout CreateMLComponents.PreprocessingUpdatableSupervisedTabularEstimator<Preprocessor, Estimator>.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        try await estimator.update(
            &transformer.outer,
            with: preprocessed,
            eventHandler: eventHandler
        )
    }
  public func encode(_ transformer: CreateMLComponents.PreprocessingUpdatableSupervisedTabularEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTabularEstimator<Preprocessor, Estimator>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.PreprocessingUpdatableSupervisedTabularEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTabularEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.PreprocessingUpdatableSupervisedTabularEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableSupervisedTabularEstimator<Self, Other> where Other : CreateMLComponents.UpdatableSupervisedTabularEstimator
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct FullyConnectedNetworkConfiguration : Swift.Hashable, Swift.Codable, Swift.Sendable {
  public var hiddenUnitCounts: [Swift.Int]
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public var learningRate: Swift.Float
  public var maximumIterations: Swift.Int
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public var dropoutProbability: Swift.Float
  public var batchSize: Swift.Int
  public var earlyStoppingTolerance: Swift.Double
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public var earlyStopIterationCount: Swift.Int
  public var randomSeed: Swift.Int
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.FullyConnectedNetworkConfiguration, b: CreateMLComponents.FullyConnectedNetworkConfiguration) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public struct PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator> : CreateMLComponents.SupervisedTemporalEstimator where Preprocessor : CreateMLComponents.TemporalTransformer, Estimator : CreateMLComponents.SupervisedTemporalEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTemporalTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public typealias Annotation = Estimator.Annotation
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  @inlinable public func preprocessed<InputSequence, FeatureSequence>(from input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>] where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        var preprocessed = [AnnotatedFeature<PreprocessedFeatureSequence<Preprocessor.Output>, Annotation>]()
        for item in input {
            let transformed = try await preprocessor.applied(to: item.feature, eventHandler: eventHandler)
            let stored = try await PreprocessedFeatureSequence(transformed)
            preprocessed.append(AnnotatedFeature(feature: stored, annotation: item.annotation))
        }
        return preprocessed
    }
  @inlinable public func fitted(toPreprocessed preprocessed: [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTemporalTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted(toPreprocessed preprocessedInput: [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>], validateOn preprocessedValidation: [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
        return ComposedTemporalTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  @inlinable public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        let preprocessedInput = try await preprocessed(from: input, eventHandler: eventHandler)
        let preprocessedValidation = try await preprocessed(from: validation, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(
            toPreprocessed: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
    }
  public func encode(_ transformer: CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.PreprocessingSupervisedTemporalEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<CreateMLComponents.TransformerToTemporalAdaptor<Self>, Other> where Other : CreateMLComponents.SupervisedTemporalEstimator, Self.Output == Other.Transformer.Input
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Self, CreateMLComponents.SupervisedEstimatorToTemporalAdaptor<Other>> where Other : CreateMLComponents.SupervisedEstimator, Self.Output == Other.Transformer.Input, Other.Annotation : Swift.Sendable
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Self, Other> where Other : CreateMLComponents.SupervisedTemporalEstimator, Self.Output == Other.Transformer.Input
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public enum OptimizationStrategy : Swift.Hashable, Swift.Codable, Swift.Sendable {
  case automatic
  case nonSmooth
  case lowMemory
  case fast
  public static func == (a: CreateMLComponents.OptimizationStrategy, b: CreateMLComponents.OptimizationStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension CreateMLComponents.VideoReader {
  @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  public struct CameraAsyncBuffers : CreateMLComponents.TemporalSequence {
    public typealias AsyncIterator = CreateMLComponents.VideoReader.CameraAsyncBuffers.Iterator
    public typealias Feature = CoreImage.CIImage
    public var count: Swift.Int? {
      get
    }
    @available(macOS 15.0, iOS 18.0, *)
    @available(tvOS, unavailable)
    public var captureSession: AVFoundation.AVCaptureSession {
      get
    }
    public consuming func makeAsyncIterator() -> CreateMLComponents.VideoReader.CameraAsyncBuffers.Iterator
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable, introduced: 16.0)
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.VideoReader.CameraAsyncBuffers.Feature>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @available(tvOS, unavailable, introduced: 18.0)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
    #else
    @available(iOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @available(tvOS, unavailable, introduced: 18.0)
    public typealias __AsyncSequence_Failure = any Swift.Error
    #endif
  }
}
@available(macOS 15.0, iOS 18.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraAsyncBuffers : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraAsyncBuffers {
  @_hasMissingDesignatedInitializers @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  final public class Iterator : _Concurrency.AsyncIteratorProtocol {
    @objc deinit
    final public func next() async throws -> CreateMLComponents.TemporalFeature<CoreImage.CIImage>?
    @available(iOS 16.0, macOS 13.0, *)
    @available(tvOS, unavailable, introduced: 16.0)
    public typealias Element = CreateMLComponents.TemporalFeature<CoreImage.CIImage>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @available(tvOS, unavailable, introduced: 18.0)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @available(tvOS, unavailable, introduced: 18.0)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
@available(*, unavailable)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraAsyncBuffers.Iterator : Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct TimeSeriesForecasterBatches<Scalar> : Swift.Sequence, @unchecked Swift.Sendable where Scalar : CoreML.MLShapedArrayScalar {
  public typealias Element = CreateMLComponents.AnnotatedBatch<Scalar>
  public let features: CoreML.MLShapedArray<Scalar>
  public let annotations: CoreML.MLShapedArray<Scalar>
  public let batchSize: Swift.Int
  public let inputWindowSize: Swift.Int
  public let forecastWindowSize: Swift.Int
  public var shufflesBatches: Swift.Bool
  public init(features: CoreML.MLShapedArray<Scalar>, annotations: CoreML.MLShapedArray<Scalar>, batchSize: Swift.Int, inputWindowSize: Swift.Int, forecastWindowSize: Swift.Int, shufflesBatches: Swift.Bool = true) throws
  public var underestimatedCount: Swift.Int {
    get
  }
  public func makeIterator() -> CreateMLComponents.TimeSeriesForecasterBatches<Scalar>.Iterator
}
extension CreateMLComponents.TimeSeriesForecasterBatches {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
  public struct Iterator : Swift.IteratorProtocol, @unchecked Swift.Sendable {
    public mutating func next() -> CreateMLComponents.AnnotatedBatch<Scalar>?
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Element = CreateMLComponents.AnnotatedBatch<Scalar>
  }
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func export(to url: Foundation.URL) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public func export(to url: Foundation.URL, metadata: CreateMLComponents.ModelMetadata) throws
}
extension CreateMLComponents.LinearTimeSeriesForecaster {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
  public struct Model : CreateMLComponents.Transformer, Swift.Sendable {
    public typealias Input = CoreML.MLShapedArray<Scalar>
    public typealias Output = CoreML.MLShapedArray<Scalar>
    public var featureSize: Swift.Int {
      get
    }
    public var annotationSize: Swift.Int {
      get
    }
    public var inputWindowSize: Swift.Int {
      get
    }
    public var forecastWindowSize: Swift.Int {
      get
    }
    public var stride: Swift.Int
    public var weight: CoreML.MLShapedArray<Scalar> {
      get
    }
    public var bias: CoreML.MLShapedArray<Scalar>? {
      get
    }
    public func applied(to input: some Sequence<MLShapedArray<Scalar>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CoreML.MLShapedArray<Scalar>]
    public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CoreML.MLShapedArray<Scalar>
    public func applied(toWindow input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CoreML.MLShapedArray<Scalar>
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct LogisticRegressionClassifierModel<Scalar, Label> : CreateMLComponents.Classifier where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint, Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  public typealias Input = CoreML.MLShapedArray<Scalar>
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var featureCount: Swift.Int {
    get
  }
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var coefficients: [Scalar] {
    get
  }
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public init(coefficients: some Sequence<Scalar>, labels: Swift.Set<Label>)
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ClassificationDistribution<Label>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = CreateMLComponents.ClassificationDistribution<Label>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.LogisticRegressionClassifierModel : Swift.Sendable where Scalar : Swift.Sendable, Label : Swift.Sendable {
}
extension CreateMLComponents.Estimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.Estimator<CreateMLComponents.ComposedTransformer<Self.Transformer, Other>> where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.Estimator<CreateMLComponents.ComposedTransformer<Self.Transformer, Other.Transformer>> where Other : CreateMLComponents.Estimator, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct JointKey : Swift.Hashable, Swift.RawRepresentable, Swift.Sendable {
  public var rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let leftEar: CreateMLComponents.JointKey
  public static let leftEye: CreateMLComponents.JointKey
  public static let rightEar: CreateMLComponents.JointKey
  public static let rightEye: CreateMLComponents.JointKey
  public static let neck: CreateMLComponents.JointKey
  public static let nose: CreateMLComponents.JointKey
  public static let leftShoulder: CreateMLComponents.JointKey
  public static let leftElbow: CreateMLComponents.JointKey
  public static let leftWrist: CreateMLComponents.JointKey
  public static let rightShoulder: CreateMLComponents.JointKey
  public static let rightElbow: CreateMLComponents.JointKey
  public static let rightWrist: CreateMLComponents.JointKey
  public static let root: CreateMLComponents.JointKey
  public static let leftHip: CreateMLComponents.JointKey
  public static let leftKnee: CreateMLComponents.JointKey
  public static let leftAnkle: CreateMLComponents.JointKey
  public static let rightHip: CreateMLComponents.JointKey
  public static let rightKnee: CreateMLComponents.JointKey
  public static let rightAnkle: CreateMLComponents.JointKey
  public static let thumbTip: CreateMLComponents.JointKey
  public static let thumbIP: CreateMLComponents.JointKey
  public static let thumbMP: CreateMLComponents.JointKey
  public static let thumbCMC: CreateMLComponents.JointKey
  public static let indexTip: CreateMLComponents.JointKey
  public static let indexDIP: CreateMLComponents.JointKey
  public static let indexPIP: CreateMLComponents.JointKey
  public static let indexMCP: CreateMLComponents.JointKey
  public static let middleTip: CreateMLComponents.JointKey
  public static let middleDIP: CreateMLComponents.JointKey
  public static let middlePIP: CreateMLComponents.JointKey
  public static let middleMCP: CreateMLComponents.JointKey
  public static let ringTip: CreateMLComponents.JointKey
  public static let ringDIP: CreateMLComponents.JointKey
  public static let ringPIP: CreateMLComponents.JointKey
  public static let ringMCP: CreateMLComponents.JointKey
  public static let littleTip: CreateMLComponents.JointKey
  public static let littleDIP: CreateMLComponents.JointKey
  public static let littlePIP: CreateMLComponents.JointKey
  public static let littleMCP: CreateMLComponents.JointKey
  public static let wrist: CreateMLComponents.JointKey
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias RawValue = Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.JointKey : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct JointPoint : Swift.Sendable {
  public let key: CreateMLComponents.JointKey
  public var location: CoreFoundation.CGPoint
  public var confidence: Swift.Float
  public init(_ key: CreateMLComponents.JointKey, location: CoreFoundation.CGPoint, confidence: Swift.Float)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct Pose : Swift.Sendable {
  public init(_ observation: Vision.VNRecognizedPointsObservation) throws
  public init(from points: [CreateMLComponents.JointKey : CreateMLComponents.JointPoint])
  public var keypoints: [CreateMLComponents.JointKey : CreateMLComponents.JointPoint]
  public func boundingBoxArea(confidenceThreshold: Swift.Float = 0.2) -> Swift.Float
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.JointPoint : Swift.Equatable {
  public static func == (a: CreateMLComponents.JointPoint, b: CreateMLComponents.JointPoint) -> Swift.Bool
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.Pose : Swift.Equatable {
  public static func == (a: CreateMLComponents.Pose, b: CreateMLComponents.Pose) -> Swift.Bool
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(watchOS, unavailable)
extension CreateMLComponents.TimeSeriesClassifier.Model : CreateMLComponents.TemporalTransformer {
  public typealias OutputSequence = CreateMLComponents.AnyTemporalSequence<CreateMLComponents.ClassificationDistribution<Label>>
  public func applied(to input: some TemporalSequence<MLShapedArray<Scalar>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.AnyTemporalSequence<CreateMLComponents.ClassificationDistribution<Label>>
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct TemporalAdaptor<Base> : CreateMLComponents.TemporalTransformer, Swift.Sendable where Base : CreateMLComponents.Transformer, Base : Swift.Sendable {
  public typealias Input = Base.Input
  public typealias Output = Base.Output
  public typealias OutputSequence = CreateMLComponents.AnyTemporalSequence<CreateMLComponents.TemporalAdaptor<Base>.Output>
  @usableFromInline
  internal var base: Base
  public init(_ transformer: Base)
  public func applied(to input: some TemporalSequence<Input>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.AnyTemporalSequence<CreateMLComponents.TemporalAdaptor<Base>.Output>
}
extension CreateMLComponents.Transformer {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
  @inlinable @preconcurrency public func adaptedAsTemporal() -> CreateMLComponents.TemporalAdaptor<Self> where Self : Swift.Sendable {
        TemporalAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct ColumnSelectorTransformer<Base, UnwrappedInput> : CreateMLComponents.TabularTransformer where Base : CreateMLComponents.Transformer, Base.Input == UnwrappedInput? {
  public var transformers: [Swift.String : Base]
  public var columnMapping: [Swift.String : Swift.String]
  public init(transformers: [Swift.String : Base], columnMapping: [Swift.String : Swift.String] = [:])
  public func applied(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = TabularData.DataFrame
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = TabularData.DataFrame
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ColumnSelectorTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ColumnSelectorTransformer : Swift.Sendable where Base : Swift.Sendable, UnwrappedInput : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ColumnSelectorTransformer : Swift.Codable where Base : Swift.Decodable, Base : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct LogisticRegressionClassifier<Scalar, Label> : CreateMLComponents.SupervisedEstimator where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint, Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  public typealias Transformer = CreateMLComponents.LogisticRegressionClassifierModel<Scalar, Label>
  public typealias Annotation = Label
  public var configuration: CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Configuration {
    get
    set
  }
  public var labels: Swift.Set<Label>
  public init(labels: Swift.Set<Label>, configuration: CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Configuration = Configuration())
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.LogisticRegressionClassifierModel<Scalar, Label> where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>, Validation.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>
  public func encode(_ transformer: CreateMLComponents.LogisticRegressionClassifierModel<Scalar, Label>, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.LogisticRegressionClassifierModel<Scalar, Label>
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.LogisticRegressionClassifier : CreateMLComponents.UpdatableSupervisedEstimator {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func makeTransformer() -> CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Transformer
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func update<InputSequence>(_ transformer: inout CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.LogisticRegressionClassifier : Swift.Sendable where Scalar : Swift.Sendable, Label : Swift.Sendable {
}
extension CreateMLComponents.LogisticRegressionClassifier {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public struct Configuration : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var l2Penalty: Swift.Double
    public var l1Penalty: Swift.Double
    public var maximumIterations: Swift.Int
    public var stepSize: Swift.Double
    public var convergenceThreshold: Swift.Double
    @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
    public var earlyStopIterationCount: Swift.Int
    @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
    public var scaleFeatures: Swift.Bool
    @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
    public var optimizationStrategy: CreateMLComponents.OptimizationStrategy {
      get
      set
    }
    public init()
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Configuration, b: CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Configuration) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol TemporalTransformer<Input, Output> {
  associatedtype Input
  associatedtype Output where Self.Output == Self.OutputSequence.Feature
  associatedtype OutputSequence : CreateMLComponents.TemporalSequence
  func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.OutputSequence where S : CreateMLComponents.TemporalSequence, Self.Input == S.Feature
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol TemporalTransformer {
  associatedtype Input
  associatedtype Output where Self.Output == Self.OutputSequence.Feature
  associatedtype OutputSequence : CreateMLComponents.TemporalSequence
  func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.OutputSequence where S : CreateMLComponents.TemporalSequence, Self.Input == S.Feature
}
#endif
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalTransformer {
  @inlinable public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [Self.OutputSequence] where S : Swift.Sequence, Self.Input == S.Element.Feature, S.Element : CreateMLComponents.TemporalSequence {
        var result = [OutputSequence]()
        result.reserveCapacity(input.underestimatedCount)
        for example in input {
            try Task.checkCancellation()
            try await result.append(applied(to: example, eventHandler: eventHandler))
            if let eventHandler = eventHandler {
                let event = Event(
                    origin: String(describing: self),
                    itemCount: result.count,
                    totalItemCount: input.underestimatedCount,
                    metrics: [:]
                )
                eventHandler(event)
            }
        }
        return result
    }
  @inlinable public func applied<S, TS, Annotation>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.AnnotatedFeature<Self.OutputSequence, Annotation>] where S : Swift.Sequence, TS : CreateMLComponents.TemporalSequence, Self.Input == TS.Feature, S.Element == CreateMLComponents.AnnotatedFeature<TS, Annotation> {
        var result = [AnnotatedFeature<OutputSequence, Annotation>]()
        result.reserveCapacity(input.underestimatedCount)
        for example in input {
            try Task.checkCancellation()
            let transformed = try await applied(to: example.feature, eventHandler: eventHandler)
            result.append(AnnotatedFeature(feature: transformed, annotation: example.annotation))
            if let eventHandler = eventHandler {
                let event = Event(
                    origin: String(describing: self),
                    itemCount: result.count,
                    totalItemCount: input.underestimatedCount,
                    metrics: [:]
                )
                eventHandler(event)
            }
        }
        return result
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalTransformer {
  @inlinable public func callAsFunction<S>(_ input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Self.OutputSequence where S : CreateMLComponents.TemporalSequence, Self.Input == S.Feature {
        try await applied(to: input, eventHandler: eventHandler)
    }
  @inlinable public func callAsFunction<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [Self.OutputSequence] where S : Swift.Sequence, Self.Input == S.Element.Feature, S.Element : CreateMLComponents.TemporalSequence {
        try await applied(to: input, eventHandler: eventHandler)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct ComposedTabularTransformer<Inner, Outer> : CreateMLComponents.TabularTransformer where Inner : CreateMLComponents.TabularTransformer, Outer : CreateMLComponents.TabularTransformer {
  public var inner: Inner
  public var outer: Outer
  public init(_ inner: Inner, _ outer: Outer)
  @inlinable public func applied(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame {
        let innerOutput = try await inner.applied(to: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        let outerOutput = try await outer.applied(to: innerOutput, eventHandler: eventHandler)
        return outerOutput
    }
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = TabularData.DataFrame
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = TabularData.DataFrame
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTabularTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTabularTransformer : Swift.Sendable where Inner : Swift.Sendable, Outer : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTabularTransformer : Swift.Equatable where Inner : Swift.Equatable, Outer : Swift.Equatable {
  public static func == (a: CreateMLComponents.ComposedTabularTransformer<Inner, Outer>, b: CreateMLComponents.ComposedTabularTransformer<Inner, Outer>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTabularTransformer : Swift.Encodable where Inner : Swift.Encodable, Outer : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ComposedTabularTransformer : Swift.Decodable where Inner : Swift.Decodable, Outer : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.ComposedTabularTransformer<Self, Other> where Other : CreateMLComponents.TabularTransformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct FullyConnectedNetworkClassifierModel<Scalar, Label> : CreateMLComponents.Classifier where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint, Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ClassificationDistribution<Label>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = CoreML.MLShapedArray<Scalar>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = CreateMLComponents.ClassificationDistribution<Label>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.FullyConnectedNetworkClassifierModel : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.FullyConnectedNetworkClassifierModel : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(*, unavailable)
extension CreateMLComponents.FullyConnectedNetworkClassifierModel : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
public struct ImageColorTransformer : CreateMLComponents.Transformer, Swift.Sendable {
  public var brightness: Swift.Float?
  public var contrast: Swift.Float?
  public var hue: Swift.Float?
  public var saturation: Swift.Float?
  public init(brightness: Swift.Float? = nil, contrast: Swift.Float? = nil, hue: Swift.Float? = nil, saturation: Swift.Float? = nil)
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) -> CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Input = CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Output = CoreImage.CIImage
}
extension CreateMLComponents.Transformer {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func adaptedAsAnnotatedFeatureTransformer<Annotation>(annotationType: Annotation.Type = Annotation.self) -> some CreateMLComponents.Transformer<CreateMLComponents.AnnotatedFeature<Self.Input, Annotation>, CreateMLComponents.AnnotatedFeature<Self.Output, Annotation>>
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct HumanBodyActionCounter : CreateMLComponents.TemporalTransformer, Swift.Sendable {
  public typealias Input = [CreateMLComponents.Pose]
  public typealias Output = Swift.Float
  public typealias OutputSequence = CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence
  public init()
  public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.HumanBodyActionCounter.OutputSequence where S : CreateMLComponents.TemporalSequence, S.Feature == [CreateMLComponents.Pose]
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct PreprocessingSupervisedEstimator<Preprocessor, Estimator> : CreateMLComponents.SupervisedEstimator where Preprocessor : CreateMLComponents.Transformer, Estimator : CreateMLComponents.SupervisedEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public typealias Annotation = Estimator.Annotation
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  @inlinable public func preprocessed<S>(from input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Swift.AnySequence<CreateMLComponents.AnnotatedFeature<Preprocessor.Output, CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Annotation>> where S : Swift.Sequence, S.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let inputFeatures = input.lazy.map(\.feature)
        let preprocessedFeatures = try await preprocessor.applied(to: inputFeatures, eventHandler: eventHandler)
        return AnySequence(zip(preprocessedFeatures, input.lazy.map(\.annotation)).lazy.map(AnnotatedFeature.init))
    }
  @inlinable public func fitted<S>(toPreprocessed preprocessed: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Transformer where S : Swift.Sequence, S.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation> {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessed,
            eventHandler: eventHandler
        )
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted<Input, Validation>(toPreprocessed preprocessedInput: Input, validateOn preprocessedValidation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Transformer where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation> {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let inputFeatures = input.lazy.map(\.feature)
        let inputAnnotations = input.lazy.map(\.annotation)

        let preprocessed = try await preprocessor.applied(to: inputFeatures, eventHandler: eventHandler)
        try Task.checkCancellation()

        let fittedTransformer = try await estimator.fitted(
            to: zip(preprocessed, inputAnnotations).lazy.map(AnnotatedFeature.init),
            eventHandler: eventHandler
        )
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted<InputSequence, Validation>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let inputFeatures = input.lazy.map(\.feature)
        let inputAnnotations = input.lazy.map(\.annotation)

        let validationFeatures = validation.lazy.map(\.feature)
        let validationAnnotations = validation.lazy.map(\.annotation)

        let preprocessedInput = try await preprocessor.applied(to: inputFeatures, eventHandler: eventHandler)
        try Task.checkCancellation()

        let preprocessedValidation = try await preprocessor.applied(to: validationFeatures, eventHandler: eventHandler)
        try Task.checkCancellation()

        let fittedTransformer = try await estimator.fitted(
            to: zip(preprocessedInput, inputAnnotations).lazy.map(AnnotatedFeature.init),
            validateOn: zip(preprocessedValidation, validationAnnotations).lazy.map(AnnotatedFeature.init),
            eventHandler: eventHandler
        )
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  public func encode(_ transformer: CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.PreprocessingSupervisedEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingSupervisedEstimator<Self, Other> where Other : CreateMLComponents.SupervisedEstimator, Self.Output == Other.Transformer.Input
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension CreateMLComponents.LinearTimeSeriesForecaster.Model : CreateMLComponents.TemporalTransformer {
  public typealias OutputSequence = CreateMLComponents.AnyTemporalSequence<CoreML.MLShapedArray<Scalar>>
  public func applied(to input: some TemporalSequence<MLShapedArray<Scalar>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.AnyTemporalSequence<CoreML.MLShapedArray<Scalar>>
}
extension CreateMLComponents.UpdatableEstimator {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self.Transformer>, Other.Transformer>, Other.Annotation> where Other : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.UpdatableSupervisedEstimator {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  @preconcurrency public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self.Transformer>, Other>, Self.Annotation> where Other : CreateMLComponents.TemporalTransformer, Self.Annotation : Swift.Sendable, Other.Input == Self.Transformer.Output
  
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  @preconcurrency public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self.Transformer>, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.UpdatableTemporalEstimator, Self.Annotation : Swift.Sendable, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self.Transformer>, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.UpdatableTemporalEstimator {
  @preconcurrency public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, CreateMLComponents.TransformerToTemporalAdaptor<Other.Transformer>>, Other.Annotation> where Other : CreateMLComponents.UpdatableSupervisedEstimator, Other.Annotation : Swift.Sendable, Self.Transformer.Output == Other.Transformer.Input
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, Other.Transformer>, Other.Annotation> where Other : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.UpdatableSupervisedTemporalEstimator {
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, CreateMLComponents.TransformerToTemporalAdaptor<Other>>, Self.Annotation> where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, CreateMLComponents.TransformerToTemporalAdaptor<Other.Transformer>>, Self.Annotation> where Other : CreateMLComponents.UpdatableEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, CreateMLComponents.TransformerToTemporalAdaptor<Other.Transformer>>, Self.Annotation> where Other : CreateMLComponents.UpdatableSupervisedEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, Other>, Self.Annotation> where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.UpdatableTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator<CreateMLComponents.ComposedTemporalTransformer<Self.Transformer, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.MultiLabelClassificationMetrics {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func count(of label: Label) -> Swift.Int
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func truePositiveCount(of label: Label) -> Swift.Int
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func trueNegativeCount(of label: Label) -> Swift.Int
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func falsePositiveCount(of label: Label) -> Swift.Int
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func falseNegativeCount(of label: Label) -> Swift.Int
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func f1Score(for label: Label) -> Swift.Float
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct ShuffleRandomly<Element> : CreateMLComponents.RandomTransformer {
  public init<RandomTransformer>(@CreateMLComponents.AugmentationBuilder<Element> _ augmentation: () -> RandomTransformer) where Element == RandomTransformer.Input, RandomTransformer : CreateMLComponents.RandomTransformer, RandomTransformer.Input == RandomTransformer.Output
  public func applied(to input: Element, generator: inout some RandomNumberGenerator, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Element
  @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
  public typealias Input = Element
  @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
  public typealias Output = Element
}
@available(*, unavailable)
extension CreateMLComponents.ShuffleRandomly : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ImageReader : CreateMLComponents.Transformer, Swift.Sendable {
  public init()
  public func applied(to url: Foundation.URL, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CoreImage.CIImage
  public static func read(url: Foundation.URL) throws -> CoreImage.CIImage
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Input = Foundation.URL
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Output = CoreImage.CIImage
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageReader : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct CategoricalImputer<Element> : CreateMLComponents.Estimator where Element : Swift.Decodable, Element : Swift.Encodable, Element : Swift.Hashable {
  public typealias Transformer = CreateMLComponents.ImputeTransformer<Element>
  public enum Strategy {
    case mode
    case constant(Element)
  }
  public var strategy: CreateMLComponents.CategoricalImputer<Element>.Strategy
  public init(_ strategy: CreateMLComponents.CategoricalImputer<Element>.Strategy)
  public init(constant: Element)
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) -> CreateMLComponents.CategoricalImputer<Element>.Transformer where S : Swift.Sequence, S.Element == Element?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.CategoricalImputer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.CategoricalImputer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.CategoricalImputer.Strategy : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct HumanHandPoseExtractor : CreateMLComponents.Transformer, Swift.Sendable {
  public init()
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.Pose]
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Input = CoreImage.CIImage
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Output = [CreateMLComponents.Pose]
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanHandPoseExtractor : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS, introduced: 13.0, deprecated: 15.0, renamed: "TemporalAdaptor")
@available(iOS, introduced: 16.0, deprecated: 18.0, renamed: "TemporalAdaptor")
@available(tvOS, introduced: 16.0, deprecated: 18.0, renamed: "TemporalAdaptor")
@available(visionOS, introduced: 1.0, deprecated: 2.0, renamed: "TemporalAdaptor")
@available(watchOS, unavailable)
public struct TransformerToTemporalAdaptor<Base> : CreateMLComponents.TemporalTransformer where Base : CreateMLComponents.Transformer {
  public typealias Input = Base.Input
  public typealias Output = Base.Output
  public typealias OutputSequence = CreateMLComponents.AnyTemporalSequence<CreateMLComponents.TransformerToTemporalAdaptor<Base>.Output>
  @usableFromInline
  internal var base: Base
  public init(_ transformer: Base)
  @inlinable public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.AnyTemporalSequence<CreateMLComponents.TransformerToTemporalAdaptor<Base>.Output> where S : CreateMLComponents.TemporalSequence, Base.Input == S.Feature {
        nonisolated(unsafe) let base = self.base
        let sequence = input.map {
            try await TemporalFeature(id: $0.id, feature: base.applied(to: $0.feature, eventHandler: eventHandler))
        }
        return AnyTemporalSequence(sequence, count: input.count)
    }
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.TransformerToTemporalAdaptor : Swift.Sendable where Base : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  @_disfavoredOverload @inlinable public func adaptedAsTemporal() -> CreateMLComponents.TransformerToTemporalAdaptor<Self> {
        TransformerToTemporalAdaptor(self)
    }
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public struct EstimatorToTemporalAdaptor<Base> : CreateMLComponents.TemporalEstimator where Base : CreateMLComponents.Estimator {
  public typealias Transformer = CreateMLComponents.TransformerToTemporalAdaptor<Base.Transformer>
  public typealias Input = Base.Transformer.Input
  public typealias Output = Base.Transformer.Output
  @usableFromInline
  internal var base: Base
  public init(_ base: Base)
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.EstimatorToTemporalAdaptor<Base>.Transformer where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Base.Transformer.Input == InputSequence.Element.Feature {
        var collected = [Input]()
        for sequence in input {
            for try await item in sequence {
                collected.append(item.feature)
            }
        }
        return try await Transformer(base.fitted(to: collected, eventHandler: eventHandler))
    }
  @inlinable public func encode(_ transformer: CreateMLComponents.EstimatorToTemporalAdaptor<Base>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
        try base.encode(transformer.base, to: &encoder)
    }
  @inlinable public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.EstimatorToTemporalAdaptor<Base>.Transformer {
        try Transformer(base.decode(from: &decoder))
    }
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.EstimatorToTemporalAdaptor : Swift.Sendable where Base : Swift.Sendable {
}
extension CreateMLComponents.Estimator {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  @inlinable public func adaptedAsTemporal() -> CreateMLComponents.EstimatorToTemporalAdaptor<Self> {
        EstimatorToTemporalAdaptor(self)
    }
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public struct UpdatableEstimatorToTemporalAdaptor<Base> : CreateMLComponents.UpdatableTemporalEstimator where Base : CreateMLComponents.UpdatableEstimator {
  public typealias Transformer = CreateMLComponents.TransformerToTemporalAdaptor<Base.Transformer>
  public typealias Input = Base.Transformer.Input
  public typealias Output = Base.Transformer.Output
  @usableFromInline
  internal var base: Base
  public init(_ base: Base)
  @inlinable public func makeTransformer() -> CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer {
        TransformerToTemporalAdaptor(base.makeTransformer())
    }
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Base.Transformer.Input == InputSequence.Element.Feature {
        var collected = [Input]()
        for sequence in input {
            for try await item in sequence {
                collected.append(item.feature)
            }
        }
        return try await Transformer(base.fitted(to: collected, eventHandler: eventHandler))
    }
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Base.Transformer.Input == InputSequence.Element.Feature {
        var collected = [Input]()
        for sequence in input {
            for try await item in sequence {
                collected.append(item.feature)
            }
        }
        return try await base.update(&transformer.base, with: collected, eventHandler: eventHandler)
    }
  @inlinable public func encode(_ transformer: CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
        try base.encode(transformer.base, to: &encoder)
    }
  @inlinable public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer {
        try Transformer(base.decode(from: &decoder))
    }
  @inlinable public func encodeWithOptimizer(_ transformer: CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
        try base.encodeWithOptimizer(transformer.base, to: &encoder)
    }
  @inlinable public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer {
        try Transformer(base.decodeWithOptimizer(from: &decoder))
    }
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.UpdatableEstimatorToTemporalAdaptor : Swift.Sendable where Base : Swift.Sendable {
}
extension CreateMLComponents.UpdatableEstimator {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  @inlinable public func adaptedAsTemporal() -> CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Self> {
        UpdatableEstimatorToTemporalAdaptor(self)
    }
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public struct SupervisedEstimatorToTemporalAdaptor<Base> : CreateMLComponents.SupervisedTemporalEstimator where Base : CreateMLComponents.SupervisedEstimator, Base.Annotation : Swift.Sendable {
  public typealias Transformer = CreateMLComponents.TransformerToTemporalAdaptor<Base.Transformer>
  public typealias Input = Base.Transformer.Input
  public typealias Output = Base.Transformer.Output
  public typealias Annotation = Base.Annotation
  @usableFromInline
  internal var base: Base
  public init(_ base: Base)
  @inlinable public func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.SupervisedEstimatorToTemporalAdaptor<Base>.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, FeatureSequence.Feature == Base.Transformer.Input {
        var collected = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collected.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        let transformer = try await base.fitted(
            to: collected,
            eventHandler: eventHandler
        )
        return TransformerToTemporalAdaptor(transformer)
    }
  @inlinable public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.SupervisedEstimatorToTemporalAdaptor<Base>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, FeatureSequence.Feature == Base.Transformer.Input {
        var collectedInput = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collectedInput.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        var collectedValidation = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collectedValidation.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        let transformer = try await base.fitted(
            to: collectedInput,
            validateOn: collectedValidation,
            eventHandler: eventHandler
        )
        return TransformerToTemporalAdaptor(transformer)
    }
  @inlinable public func encode(_ transformer: CreateMLComponents.SupervisedEstimatorToTemporalAdaptor<Base>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
        try base.encode(transformer.base, to: &encoder)
    }
  @inlinable public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.SupervisedEstimatorToTemporalAdaptor<Base>.Transformer {
        try Transformer(base.decode(from: &decoder))
    }
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.SupervisedEstimatorToTemporalAdaptor : Swift.Sendable where Base : Swift.Sendable {
}
extension CreateMLComponents.SupervisedEstimator where Self.Annotation : Swift.Sendable {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  @inlinable public func adaptedAsTemporal() -> CreateMLComponents.SupervisedEstimatorToTemporalAdaptor<Self> {
        SupervisedEstimatorToTemporalAdaptor(self)
    }
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public struct UpdatableSupervisedEstimatorToTemporalAdaptor<Base> : CreateMLComponents.UpdatableSupervisedTemporalEstimator where Base : CreateMLComponents.UpdatableSupervisedEstimator, Base.Annotation : Swift.Sendable {
  public typealias Transformer = CreateMLComponents.TransformerToTemporalAdaptor<Base.Transformer>
  public typealias Input = Base.Transformer.Input
  public typealias Output = Base.Transformer.Output
  public typealias Annotation = Base.Annotation
  @usableFromInline
  internal var base: Base
  public init(_ base: Base)
  @inlinable public func makeTransformer() -> CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer {
        TransformerToTemporalAdaptor(base.makeTransformer())
    }
  @inlinable public func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, FeatureSequence.Feature == Base.Transformer.Input {
        var collected = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collected.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        let transformer = try await base.fitted(
            to: collected,
            eventHandler: eventHandler
        )
        return TransformerToTemporalAdaptor(transformer)
    }
  @inlinable public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, FeatureSequence.Feature == Base.Transformer.Input {
        var collectedInput = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collectedInput.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        var collectedValidation = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collectedValidation.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        let transformer = try await base.fitted(
            to: collectedInput,
            validateOn: collectedValidation,
            eventHandler: eventHandler
        )
        return TransformerToTemporalAdaptor(transformer)
    }
  @inlinable public func update<InputSequence, FeatureSequence>(_ transformer: inout CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, FeatureSequence.Feature == Base.Transformer.Input {
        var collected = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collected.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        try await base.update(
            &transformer.base,
            with: collected,
            eventHandler: eventHandler
        )
    }
  @inlinable public func encode(_ transformer: CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
        try base.encode(transformer.base, to: &encoder)
    }
  @inlinable public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer {
        try Transformer(base.decode(from: &decoder))
    }
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor : Swift.Sendable where Base : Swift.Sendable {
}
extension CreateMLComponents.UpdatableSupervisedEstimator where Self.Annotation : Swift.Sendable {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  @inlinable public func adaptedAsTemporal() -> CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Self> {
        UpdatableSupervisedEstimatorToTemporalAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum AudioPreprocessingError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case incompatibleTargetFormatForConversion(inputFormat: AVFAudio.AVAudioFormat, targetFormat: AVFAudio.AVAudioFormat)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.AudioPreprocessingError, b: CreateMLComponents.AudioPreprocessingError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioPreprocessingError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct Classification<Label> : Swift.Hashable where Label : Swift.Hashable {
  public var label: Label
  public var probability: Swift.Float
  public init(label: Label, probability: Swift.Float)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.Classification<Label>, b: CreateMLComponents.Classification<Label>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Classification : Swift.Codable where Label : Swift.Decodable, Label : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Classification : Swift.Sendable where Label : Swift.Sendable {
}
extension CreateMLComponents.Estimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedEstimator<CreateMLComponents.ComposedTransformer<Self.Transformer, Other.Transformer>, Other.Annotation> where Other : CreateMLComponents.SupervisedEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.SupervisedEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedEstimator<CreateMLComponents.ComposedTransformer<Self.Transformer, Other>, Self.Annotation> where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedEstimator<CreateMLComponents.ComposedTransformer<Self.Transformer, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.Estimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedEstimator<CreateMLComponents.ComposedTransformer<Self.Transformer, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.SupervisedEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct ColumnConcatenator<Scalar> : CreateMLComponents.TabularTransformer where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public var columnSelection: CreateMLComponents.ColumnSelection
  public var concatenatedColumnName: Swift.String
  public init(columnSelection: CreateMLComponents.ColumnSelection = .all, concatenatedColumnName: Swift.String = "features")
  public func applied(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> TabularData.DataFrame
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = TabularData.DataFrame
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = TabularData.DataFrame
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ColumnConcatenator : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ColumnConcatenator : Swift.Sendable where Scalar : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct ColumnSelector<Estimator, UnwrappedInput> : CreateMLComponents.TabularEstimator where Estimator : CreateMLComponents.Estimator, Estimator.Transformer.Input == UnwrappedInput? {
  public var columnSelection: CreateMLComponents.ColumnSelection
  public var estimator: Estimator
  public typealias Transformer = CreateMLComponents.ColumnSelectorTransformer<Estimator.Transformer, UnwrappedInput>
  public typealias Input = Estimator.Transformer.Input
  public typealias Output = Estimator.Transformer.Output
  public init(_ columnSelection: CreateMLComponents.ColumnSelection, estimator: Estimator)
  public init<T>(_ columnSelection: CreateMLComponents.ColumnSelection, transformer: T) where Estimator == CreateMLComponents.TransformerToEstimatorAdaptor<T>, T : CreateMLComponents.Transformer, T.Input == UnwrappedInput?
  public init(columns: [Swift.String], estimator: Estimator)
  public func fitted(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ColumnSelector<Estimator, UnwrappedInput>.Transformer
  public func encode(_ transformer: CreateMLComponents.ColumnSelector<Estimator, UnwrappedInput>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.ColumnSelector<Estimator, UnwrappedInput>.Transformer
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.ColumnSelector : CreateMLComponents.UpdatableTabularEstimator where Estimator : CreateMLComponents.UpdatableEstimator {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func makeTransformer() -> CreateMLComponents.ColumnSelectorTransformer<Estimator.Transformer, UnwrappedInput>
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func update(_ transformer: inout CreateMLComponents.ColumnSelector<Estimator, UnwrappedInput>.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.ColumnSelector<Estimator, UnwrappedInput>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.ColumnSelector<Estimator, UnwrappedInput>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ColumnSelector : Swift.Sendable where Estimator : Swift.Sendable, UnwrappedInput : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioReader {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Configuration : Swift.Sendable {
    public var frameCount: Swift.Int
    public init()
    public init(frameCount: Swift.Int)
  }
}
extension CreateMLComponents.LinearTimeSeriesForecaster.Model {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, *)
  @available(watchOS, unavailable)
  public func export(to url: Foundation.URL) throws
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, *)
  @available(watchOS, unavailable)
  public func export(to url: Foundation.URL, metadata: CreateMLComponents.ModelMetadata) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct AnnotatedPrediction<Prediction, Annotation> {
  public var prediction: Prediction
  public var annotation: Annotation
  public init(prediction: Prediction, annotation: Annotation)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedPrediction : Swift.Encodable where Prediction : Swift.Encodable, Annotation : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedPrediction : Swift.Decodable where Prediction : Swift.Decodable, Annotation : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedPrediction : Swift.Equatable where Prediction : Swift.Equatable, Annotation : Swift.Equatable {
  public static func == (a: CreateMLComponents.AnnotatedPrediction<Prediction, Annotation>, b: CreateMLComponents.AnnotatedPrediction<Prediction, Annotation>) -> Swift.Bool
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedPrediction : Swift.Hashable where Prediction : Swift.Hashable, Annotation : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.AnnotatedPrediction : Swift.Sendable where Prediction : Swift.Sendable, Annotation : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct PreprocessingUpdatableEstimator<Preprocessor, Estimator> : CreateMLComponents.UpdatableEstimator where Preprocessor : CreateMLComponents.Transformer, Estimator : CreateMLComponents.UpdatableEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ inner: Preprocessor, _ outer: Estimator)
  @inlinable public func makeTransformer() -> CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer {
        ComposedTransformer(preprocessor, estimator.makeTransformer())
    }
  @inlinable public func preprocessed<S>(from input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [Preprocessor.Output] where S : Swift.Sequence, Preprocessor.Input == S.Element {
        try await preprocessor.applied(to: input, eventHandler: eventHandler)
    }
  @inlinable public func fitted<S>(toPreprocessed preprocessed: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer where S : Swift.Sequence, Preprocessor.Output == S.Element, S.Element == Estimator.Transformer.Input {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer where S : Swift.Sequence, Preprocessor.Input == S.Element {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer, withPreprocessed preprocessed: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Preprocessor.Output == InputSequence.Element, InputSequence.Element == Estimator.Transformer.Input {
        try await estimator.update(&transformer.outer, with: preprocessed, eventHandler: eventHandler)
    }
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Preprocessor.Input == InputSequence.Element {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        try await estimator.update(&transformer.outer, with: preprocessed, eventHandler: eventHandler)
    }
  public func encode(_ transformer: CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.PreprocessingUpdatableEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableEstimator<Self, Other> where Other : CreateMLComponents.UpdatableEstimator, Self.Output == Other.Transformer.Input
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct ClassificationMetrics<Label> where Label : Swift.Hashable {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var exampleCount: Swift.Int {
    get
  }
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var labels: Swift.Set<Label>
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var restrictToKnownLabels: Swift.Bool
  public var accuracy: Swift.Double {
    get
    @available(macOS, introduced: 13.0, deprecated: 14.0)
    @available(iOS, introduced: 16.0, deprecated: 17.0)
    @available(tvOS, introduced: 16.0, deprecated: 17.0)
    set
  }
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public init()
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public init<Predicted, Correct>(predicted: Predicted, groundTruth: Correct, labels: Swift.Set<Label>) where Label == Predicted.Element, Predicted : Swift.Sequence, Correct : Swift.Sequence, Predicted.Element == Correct.Element
  public init<Predicted, Correct>(_ predicted: Predicted, _ groundTruth: Correct) where Label == Predicted.Element, Predicted : Swift.Collection, Correct : Swift.Collection, Predicted.Element == Correct.Element
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public init(_ pairs: some Sequence<(predicted: Label, label: Label)>, labels: Swift.Set<Label>)
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public init(_ pairs: some Sequence<(predicted: Label, label: Label)>)
  public init<S, Inner>(_ predicted: S) async throws where S : Swift.Sequence, Inner : CreateMLComponents.TemporalSequence, S.Element == CreateMLComponents.AnnotatedFeature<Inner, Label>, Inner.Feature == CreateMLComponents.ClassificationDistribution<Label>
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public mutating func add(predicted: some Sequence<Label>, groundTruth: some Sequence<Label>)
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public mutating func add(_ pairs: some Sequence<(predicted: Label, label: Label)>)
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func count(label: Label) -> Swift.Int
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func count(predicted: Label) -> Swift.Int
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func count(predicted: Label, label: Label) -> Swift.Int
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func truePositiveCount(of label: Label) -> Swift.Int
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func falsePositiveCount(of label: Label) -> Swift.Int
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func trueNegativeCount(of label: Label) -> Swift.Int
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func falseNegativeCount(of label: Label) -> Swift.Int
  public func makeConfusionMatrix() -> CoreML.MLShapedArray<Swift.Float> where Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func mapLabels<T>(_ transform: (Label) throws -> T) rethrows -> CreateMLComponents.ClassificationMetrics<T> where T : Swift.Hashable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ClassificationMetrics {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func precisionScore(label: Label) -> Swift.Double
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func recallScore(label: Label) -> Swift.Double
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func f1Score(label: Label) -> Swift.Double
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ClassificationMetrics : Swift.Sendable where Label : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
public struct FullyConnectedNetworkMultiLabelClassifierModel<Scalar, Label> : CreateMLComponents.Transformer where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint, Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  public mutating func updatePrecisionRecallCurves(_ input: some Collection<AnnotatedFeature<MLShapedArray<Scalar>, Set<Label>>>) async throws
  public func prediction(from input: CreateMLComponents.FullyConnectedNetworkMultiLabelClassifierModel<Scalar, Label>.Input, confidenceThresholds: [Label : Scalar]) throws -> CreateMLComponents.ClassificationDistribution<Label>
  public func prediction<S>(from input: S, confidenceThresholds: [Label : Scalar]) throws -> [CreateMLComponents.ClassificationDistribution<Label>] where S : Swift.Sequence, S.Element == CoreML.MLShapedArray<Scalar>
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.ClassificationDistribution<Label>
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Input = CoreML.MLShapedArray<Scalar>
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Output = CreateMLComponents.ClassificationDistribution<Label>
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.FullyConnectedNetworkMultiLabelClassifierModel : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.FullyConnectedNetworkMultiLabelClassifierModel : Swift.Sendable where Scalar : Swift.Sendable, Label : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.FullyConnectedNetworkMultiLabelClassifierModel : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.FullyConnectedNetworkMultiLabelClassifierModel {
  public func evaluation(on input: some Collection<AnnotatedFeature<Input, Set<Label>>>, confidenceThresholds: [Label : Swift.Float]) throws -> CreateMLComponents.MultiLabelClassificationMetrics<Label>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Estimator where Self.Transformer : Swift.Encodable {
  public func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Estimator where Self.Transformer : Swift.Decodable {
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.SupervisedEstimator where Self.Transformer : Swift.Encodable {
  public func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.SupervisedEstimator where Self.Transformer : Swift.Decodable {
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Estimator {
  public func write(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func read(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.SupervisedEstimator {
  public func write(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func read(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.UpdatableSupervisedEstimator {
  public func writeWithOptimizer(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func readWithOptimizer(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public enum ModelCompatibilityError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case missingLabel
  case missingLabelProbabilities
  case missingPredictedFeature
  case incompatibleLabelType
  case incompatibleInputDataFormat(expected: CoreML.MLFeatureType, actual: CoreML.MLFeatureType)
  case incompatibleInputMultiArrayDataType(CoreML.MLMultiArrayDataType)
  case incompatibleOutputDataFormat(expected: CoreML.MLFeatureType, actual: CoreML.MLFeatureType)
  case incompatibleInputCount(expected: Swift.Int, actual: Swift.Int)
  case incompatibleOutputCount(expected: Swift.Int, actual: Swift.Int)
  case missingInput(name: Swift.String)
  case missingOutput(name: Swift.String)
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  case incompatibleMetadataKey(name: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.ModelCompatibilityError, b: CreateMLComponents.ModelCompatibilityError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.ModelCompatibilityError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
public struct ImageExposureAdjuster : CreateMLComponents.Transformer, Swift.Sendable {
  public var amount: Swift.Double
  public init(amount: Swift.Double)
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) -> CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Input = CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Output = CoreImage.CIImage
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(watchOS, unavailable)
extension CreateMLComponents.TimeSeriesClassifier {
  public typealias Configuration = CreateMLComponents.TimeSeriesClassifierConfiguration
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(watchOS, unavailable)
public struct TimeSeriesClassifierConfiguration : Swift.Hashable, Swift.Codable, Swift.Sendable {
  public var minimumSequenceLength: Swift.Int
  public var maximumSequenceLength: Swift.Int
  public var batchSize: Swift.Int
  public var maximumIterationCount: Swift.Int
  public var earlyStoppingTolerance: Swift.Float
  public var earlyStoppingIterationCount: Swift.Int
  public var learningRate: Swift.Float
  public var randomSeed: Swift.Int?
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.TimeSeriesClassifierConfiguration, b: CreateMLComponents.TimeSeriesClassifierConfiguration) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct MultiLabelClassificationMetrics<Label> where Label : Swift.Hashable {
  public var exampleCount: Swift.Int {
    get
  }
  public var labels: Swift.Set<Label> {
    get
  }
  public var confidenceThresholds: [Label : Swift.Float] {
    get
  }
  public var meanAveragePrecision: Swift.Float {
    get
  }
  public init(classifications: some Sequence<ClassificationDistribution<Label>>, groundTruth: some Sequence<Set<Label>>, strategy: CreateMLComponents.MultiLabelClassificationMetrics<Label>.ThresholdSelectionStrategy, labels: Swift.Set<Label>) throws
  public init(classifications: some Sequence<ClassificationDistribution<Label>>, groundTruth: some Sequence<Set<Label>>, strategy: CreateMLComponents.MultiLabelClassificationMetrics<Label>.ThresholdSelectionStrategy) throws
  public init(_ pairs: some Sequence<(classification: ClassificationDistribution<Label>, labels: Set<Label>)>, strategy: CreateMLComponents.MultiLabelClassificationMetrics<Label>.ThresholdSelectionStrategy, labels: Swift.Set<Label>) throws
  public init(_ pairs: some Sequence<(classification: ClassificationDistribution<Label>, labels: Set<Label>)>, strategy: CreateMLComponents.MultiLabelClassificationMetrics<Label>.ThresholdSelectionStrategy) throws
}
extension CreateMLComponents.MultiLabelClassificationMetrics {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public init(confidenceThresholds: [Label : Swift.Float])
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public mutating func add(classifications: some Sequence<ClassificationDistribution<Label>>, groundTruth: some Sequence<Set<Label>>)
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public mutating func add(_ pairs: some Sequence<(classification: ClassificationDistribution<Label>, labels: Set<Label>)>)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.MultiLabelClassificationMetrics : Swift.Sendable where Label : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct NumericImputer<Element> : CreateMLComponents.Estimator where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public typealias Transformer = CreateMLComponents.ImputeTransformer<Element>
  public enum Strategy {
    case median
    case mean
    case constant(Element)
  }
  public var strategy: CreateMLComponents.NumericImputer<Element>.Strategy
  public init(_ strategy: CreateMLComponents.NumericImputer<Element>.Strategy)
  public init(constant: Element)
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) -> CreateMLComponents.NumericImputer<Element>.Transformer where S : Swift.Sequence, S.Element == Element?
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.NumericImputer : CreateMLComponents.UpdatableEstimator {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func makeTransformer() -> CreateMLComponents.NumericImputer<Element>.Transformer
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func update(_ transformer: inout CreateMLComponents.ImputeTransformer<Element>, with input: some Sequence<Element?>, eventHandler: CreateMLComponents.EventHandler? = nil) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.NumericImputer<Element>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.NumericImputer<Element>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.NumericImputer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.NumericImputer.Strategy : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct VideoReader : CreateMLComponents.Transformer, Swift.Sendable {
  public init()
  public func applied(to url: Foundation.URL, eventHandler: CreateMLComponents.EventHandler?) async throws -> CreateMLComponents.VideoReader.AsyncFrames
  public static func read(contentsOf url: Foundation.URL) async throws -> CreateMLComponents.VideoReader.AsyncFrames
  public static func read<S>(_ files: S) async throws -> [CreateMLComponents.VideoReader.AsyncFrames] where S : Swift.Sequence, S.Element == Foundation.URL
  public static func read<S, Annotation>(_ annotatedFiles: S) async throws -> [CreateMLComponents.AnnotatedFeature<CreateMLComponents.VideoReader.AsyncFrames, Annotation>] where S : Swift.Sequence, Annotation : Swift.Equatable, Annotation : Swift.Sendable, S.Element == CreateMLComponents.AnnotatedFeature<Foundation.URL, Annotation>
  @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  public static func readCamera(configuration: CreateMLComponents.VideoReader.CameraConfiguration) async throws -> CreateMLComponents.VideoReader.CameraAsyncBuffers
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Input = Foundation.URL
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Output = CreateMLComponents.VideoReader.AsyncFrames
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol Classifier : CreateMLComponents.Transformer {
  associatedtype Label : Swift.Hashable where Self.Output == CreateMLComponents.ClassificationDistribution<Self.Label>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Transformer {
  public func prediction<Label>(from input: Self.Input) async throws -> CreateMLComponents.ClassificationDistribution<Label> where Label : Swift.Hashable, Self.Output == CreateMLComponents.ClassificationDistribution<Label>
  public func prediction<S, Label>(from input: S) async throws -> [CreateMLComponents.ClassificationDistribution<Label>] where S : Swift.Sequence, Label : Swift.Hashable, Self.Input == S.Element, Self.Output == CreateMLComponents.ClassificationDistribution<Label>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TemporalTransformer {
  public func prediction<S, Label>(from input: S) async throws -> Self.OutputSequence where S : CreateMLComponents.TemporalSequence, Label : Swift.Hashable, Self.Input == S.Feature, Self.Output == CreateMLComponents.ClassificationDistribution<Label>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct AudioConvertingTransformer : CreateMLComponents.Transformer, Swift.Sendable {
  public let targetFormat: AVFAudio.AVAudioFormat
  public init(targetFormat: AVFAudio.AVAudioFormat)
  public func applied(to input: AVFAudio.AVAudioPCMBuffer, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> AVFAudio.AVAudioPCMBuffer
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Input = AVFAudio.AVAudioPCMBuffer
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Output = AVFAudio.AVAudioPCMBuffer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioConvertingTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct FullyConnectedNetworkRegressorModel<Scalar> : CreateMLComponents.Regressor where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public typealias Target = Swift.Float
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar>.Target
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = CoreML.MLShapedArray<Scalar>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar>.Target
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.FullyConnectedNetworkRegressorModel : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.FullyConnectedNetworkRegressorModel : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(*, unavailable)
extension CreateMLComponents.FullyConnectedNetworkRegressorModel : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct TreeRegressorModel : CreateMLComponents.TabularTransformer, Swift.Sendable {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var featureColumnNames: [Swift.String] {
    get
  }
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var predictionColumnName: Swift.String
  public func applied(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = TabularData.DataFrame
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = TabularData.DataFrame
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TreeRegressorModel : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct MLModelClassifierAdaptor<Scalar> : CreateMLComponents.Classifier where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public enum Label : Swift.Hashable, Swift.Sendable {
    case string(Swift.String)
    case int(Swift.Int)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.MLModelClassifierAdaptor<Scalar>.Label, b: CreateMLComponents.MLModelClassifierAdaptor<Scalar>.Label) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let model: CoreML.MLModel
  public init(contentsOf url: Foundation.URL, configuration: CoreML.MLModelConfiguration) throws
  public init(model: CoreML.MLModel) throws
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ClassificationDistribution<CreateMLComponents.MLModelClassifierAdaptor<Scalar>.Label>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = CoreML.MLShapedArray<Scalar>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = CreateMLComponents.ClassificationDistribution<CreateMLComponents.MLModelClassifierAdaptor<Scalar>.Label>
}
@available(*, unavailable)
extension CreateMLComponents.MLModelClassifierAdaptor : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MLModelClassifierAdaptor.Label : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MLModelClassifierAdaptor.Label : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias StringLiteralType = Swift.String
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.MLModelClassifierAdaptor.Label : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias IntegerLiteralType = Swift.Int
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct TreeClassifierModel<Label> : CreateMLComponents.TabularTransformer, Swift.Sendable where Label : Swift.Hashable {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var featureColumnNames: [Swift.String] {
    get
  }
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var predictionColumnName: Swift.String
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var classCount: Swift.Int {
    get
  }
  public func applied(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame
  public func buildDataFrame(_ distributions: [CreateMLComponents.ClassificationDistribution<Label>]) -> TabularData.DataFrame
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = TabularData.DataFrame
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = TabularData.DataFrame
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TreeClassifierModel : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension CreateMLComponents.LinearTimeSeriesForecaster : CreateMLComponents.UpdatableSupervisedEstimator {
  public func makeTransformer() -> CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Model
  public func update(_ model: inout CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Model, with input: some Sequence<AnnotatedFeature<MLShapedArray<Scalar>, MLShapedArray<Scalar>>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws
  public func update(_ model: inout CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Model, withWindows windows: some Sequence<AnnotatedFeature<MLShapedArray<Scalar>, MLShapedArray<Scalar>>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws
  public func update(_ model: inout CreateMLComponents.LinearTimeSeriesForecaster<Scalar>.Transformer, with input: CreateMLComponents.AnnotatedBatch<Scalar>) async throws -> Scalar
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public enum OptimizationError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case numericUnderflow
  case numericOverflow
  case unsupportedPlatform
  public var errorDescription: Swift.String? {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.OptimizationError, b: CreateMLComponents.OptimizationError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.OptimizationError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self, Other.Transformer>> where Other : CreateMLComponents.TabularEstimator
  
}
extension CreateMLComponents.TabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self.Transformer, Other>> where Other : CreateMLComponents.TabularTransformer
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self.Transformer, Other.Transformer>> where Other : CreateMLComponents.TabularEstimator
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct OneHotEncoder<Category> : CreateMLComponents.Estimator where Category : Swift.Comparable, Category : Swift.Decodable, Category : Swift.Encodable, Category : Swift.Hashable {
  public init()
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.OneHotEncoder<Category>.Transformer where S : Swift.Sequence, S.Element == Category?
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.OneHotEncoder : CreateMLComponents.UpdatableEstimator {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func makeTransformer() -> CreateMLComponents.OneHotEncoder<Category>.Transformer
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func update(_ transformer: inout CreateMLComponents.OneHotEncoder<Category>.Transformer, with input: some Sequence<Category?>, eventHandler: CreateMLComponents.EventHandler? = nil) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.OneHotEncoder<Category>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.OneHotEncoder<Category>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.OneHotEncoder : Swift.Sendable where Category : Swift.Sendable {
}
extension CreateMLComponents.OneHotEncoder {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public struct Transformer : CreateMLComponents.Transformer {
    public var categories: Swift.Set<Category?>
    public init(categories: Swift.Set<Category?>)
    public func applied(to input: Category?, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> [Swift.Int]
    public func applied<S>(_ input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> [[Swift.Int]] where S : Swift.Sequence, S.Element == Category?
    public func category(at index: Swift.Int) -> Category?
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Input = Category?
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Output = [Swift.Int]
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.OneHotEncoder.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.OneHotEncoder.Transformer : Swift.Sendable where Category : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.OneHotEncoder.Transformer : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.OneHotEncoder.Transformer : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct OptionalUnwrapper<Element> : CreateMLComponents.Transformer {
  public init()
  @inlinable public func applied(to input: Element?, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> Element {
        guard let unwrapped = input else {
            throw PipelineDataError.missingValue(operation: "OptionalUnwrapper")
        }
        return unwrapped
    }
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = Element?
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = Element
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.OptionalUnwrapper : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public enum CompatibilityError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case unsupportedRevision(Swift.Int)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.CompatibilityError, b: CreateMLComponents.CompatibilityError) -> Swift.Bool
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.CompatibilityError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct UniformRandomFloatingPointParameter<RandomTransformer, Parameter> : CreateMLComponents.RandomTransformer where RandomTransformer : CreateMLComponents.RandomTransformer, Parameter : Swift.BinaryFloatingPoint, RandomTransformer.Input == RandomTransformer.Output, Parameter.RawSignificand : Swift.FixedWidthInteger {
  public var range: Swift.ClosedRange<Parameter>
  public init<Input>(range: Swift.ClosedRange<Parameter>, @CreateMLComponents.AugmentationBuilder<Input> _ augmentation: @escaping (Parameter) -> RandomTransformer) where Input == RandomTransformer.Input
  public func applied(to input: RandomTransformer.Input, generator: inout some RandomNumberGenerator, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> RandomTransformer.Output
  @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
  public typealias Input = RandomTransformer.Input
  @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
  public typealias Output = RandomTransformer.Input
}
@available(*, unavailable)
extension CreateMLComponents.UniformRandomFloatingPointParameter : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct PreprocessingSupervisedTabularEstimator<Preprocessor, Estimator> : CreateMLComponents.SupervisedTabularEstimator where Preprocessor : CreateMLComponents.TabularTransformer, Estimator : CreateMLComponents.SupervisedTabularEstimator {
  public typealias Transformer = CreateMLComponents.ComposedTabularTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public typealias Annotation = Estimator.Annotation
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public var annotationColumnID: TabularData.ColumnID<Estimator.Annotation> {
    get
    set
  }
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  @inlinable public func preprocessed(from input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame {
        try await preprocessor.applied(to: input, eventHandler: eventHandler)
    }
  @inlinable public func fitted(toPreprocessed preprocessedInput: TabularData.DataFrame, validateOn preprocessedValidation: TabularData.DataFrame?, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedTabularEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
        return ComposedTabularTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame?, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedTabularEstimator<Preprocessor, Estimator>.Transformer {
        let preprocessedInput = try await preprocessed(from: input, eventHandler: eventHandler)
        let preprocessedValidation: DataFrame?
        if let validation {
            preprocessedValidation = try await preprocessed(from: validation, eventHandler: eventHandler)
        } else {
            preprocessedValidation = nil
        }
        try Task.checkCancellation()
        return try await fitted(
            toPreprocessed: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
    }
  public func encode(_ transformer: CreateMLComponents.PreprocessingSupervisedTabularEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingSupervisedTabularEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.PreprocessingSupervisedTabularEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingSupervisedTabularEstimator<Self, Other> where Other : CreateMLComponents.SupervisedTabularEstimator
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct TransformerToEstimatorAdaptor<Transformer> : CreateMLComponents.Estimator where Transformer : CreateMLComponents.Transformer {
  public let transformer: Transformer
  public init(_ transformer: Transformer)
  @inlinable public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Transformer where S : Swift.Sequence, Transformer.Input == S.Element {
        transformer
    }
  @inlinable public func encode(_ transformer: Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
         
    }
  @inlinable public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TransformerToEstimatorAdaptor : Swift.Sendable where Transformer : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func adaptedAsEstimator() -> CreateMLComponents.TransformerToEstimatorAdaptor<Self> {
        TransformerToEstimatorAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct TransformerToUpdatableEstimatorAdaptor<Transformer> : CreateMLComponents.UpdatableEstimator where Transformer : CreateMLComponents.Transformer {
  public let transformer: Transformer
  public init(_ transformer: Transformer)
  @inlinable public func makeTransformer() -> Transformer {
        transformer
    }
  @inlinable public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Transformer where S : Swift.Sequence, Transformer.Input == S.Element {
        transformer
    }
  @inlinable public func update<InputSequence>(_ transformer: inout Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Transformer.Input == InputSequence.Element {
         
    }
  @inlinable public func encode(_ transformer: Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
         
    }
  @inlinable public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
  @inlinable public func encodeWithOptimizer(_ transformer: Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
         
    }
  @inlinable public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TransformerToUpdatableEstimatorAdaptor : Swift.Sendable where Transformer : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func adaptedAsUpdatableEstimator() -> CreateMLComponents.TransformerToUpdatableEstimatorAdaptor<Self> {
        TransformerToUpdatableEstimatorAdaptor(self)
    }
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public struct TemporalTransformerToEstimatorAdaptor<Transformer> : CreateMLComponents.TemporalEstimator where Transformer : CreateMLComponents.TemporalTransformer {
  public let transformer: Transformer
  public init(_ transformer: Transformer)
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Transformer where InputSequence : Swift.Sequence, Transformer.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        transformer
    }
  @inlinable public func encode(_ transformer: Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
         
    }
  @inlinable public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.TemporalTransformerToEstimatorAdaptor : Swift.Sendable where Transformer : Swift.Sendable {
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  @inlinable public func adaptedAsEstimator() -> CreateMLComponents.TemporalTransformerToEstimatorAdaptor<Self> {
        TemporalTransformerToEstimatorAdaptor(self)
    }
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public struct TemporalTransformerToUpdatableEstimatorAdaptor<Transformer> : CreateMLComponents.UpdatableTemporalEstimator where Transformer : CreateMLComponents.TemporalTransformer {
  public let transformer: Transformer
  public init(_ transformer: Transformer)
  @inlinable public func makeTransformer() -> Transformer {
        transformer
    }
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Transformer where InputSequence : Swift.Sequence, Transformer.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        transformer
    }
  @inlinable public func update<InputSequence>(_ transformer: inout Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Transformer.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
         
    }
  @inlinable public func encode(_ transformer: Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
         
    }
  @inlinable public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
  @inlinable public func encodeWithOptimizer(_ transformer: Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
         
    }
  @inlinable public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.TemporalTransformerToUpdatableEstimatorAdaptor : Swift.Sendable where Transformer : Swift.Sendable {
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  @inlinable public func adaptedAsUpdatableEstimator() -> CreateMLComponents.TemporalTransformerToUpdatableEstimatorAdaptor<Self> {
        TemporalTransformerToUpdatableEstimatorAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct TabularTransformerToEstimatorAdaptor<Transformer> : CreateMLComponents.TabularEstimator where Transformer : CreateMLComponents.TabularTransformer {
  public let transformer: Transformer
  public init(_ transformer: Transformer)
  @inlinable public func fitted(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Transformer {
        transformer
    }
  @inlinable public func encode(_ transformer: Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
         
    }
  @inlinable public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TabularTransformerToEstimatorAdaptor : Swift.Sendable where Transformer : Swift.Sendable {
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func adaptedAsEstimator() -> CreateMLComponents.TabularTransformerToEstimatorAdaptor<Self> {
        TabularTransformerToEstimatorAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct TabularTransformerToUpdatableEstimatorAdaptor<Transformer> : CreateMLComponents.UpdatableTabularEstimator where Transformer : CreateMLComponents.TabularTransformer {
  public let transformer: Transformer
  public init(_ transformer: Transformer)
  @inlinable public func makeTransformer() -> Transformer {
        transformer
    }
  @inlinable public func fitted(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Transformer {
        transformer
    }
  @inlinable public func update(_ transformer: inout Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws {
         
    }
  @inlinable public func encode(_ transformer: Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
         
    }
  @inlinable public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
  @inlinable public func encodeWithOptimizer(_ transformer: Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
         
    }
  @inlinable public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TabularTransformerToUpdatableEstimatorAdaptor : Swift.Sendable where Transformer : Swift.Sendable {
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func adaptedAsUpdatableEstimator() -> CreateMLComponents.TabularTransformerToUpdatableEstimatorAdaptor<Self> {
        TabularTransformerToUpdatableEstimatorAdaptor(self)
    }
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self, Other.Transformer>, Other.Annotation> where Other : CreateMLComponents.SupervisedTabularEstimator
  
}
extension CreateMLComponents.TabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self.Transformer, Other.Transformer>, Other.Annotation> where Other : CreateMLComponents.SupervisedTabularEstimator
  
}
extension CreateMLComponents.SupervisedTabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self.Transformer, Other>, Self.Annotation> where Other : CreateMLComponents.TabularTransformer
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self.Transformer, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.TabularEstimator
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTabularEstimator<CreateMLComponents.ComposedTabularTransformer<Self.Transformer, Other.Transformer>, Self.Annotation> where Other : CreateMLComponents.SupervisedTabularEstimator, Self.Annotation == Other.Annotation
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol TabularTransformer : CreateMLComponents.Transformer where Self.Input == TabularData.DataFrame, Self.Output == TabularData.DataFrame {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TabularTransformer {
  @inlinable public func callAsFunction(_ input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame {
        try await applied(to: input, eventHandler: eventHandler)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct BoostedTreeConfiguration : Swift.Hashable, Swift.Codable, Swift.Sendable {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var learningRate: Swift.Double {
    get
    set
  }
  public var maximumDepth: Swift.Int
  public var maximumIterations: Swift.Int
  public var minimumLossReduction: Swift.Double
  public var minimumChildWeight: Swift.Double
  public var randomSeed: Swift.Int
  @available(macOS, introduced: 13.0, deprecated: 14.0, renamed: "learningRate")
  @available(iOS, introduced: 16.0, deprecated: 17.0, renamed: "learningRate")
  @available(tvOS, introduced: 16.0, deprecated: 17.0, renamed: "learningRate")
  public var stepSize: Swift.Double {
    get
    set
  }
  public var earlyStoppingIterationCount: Swift.Int?
  public var rowSubsample: Swift.Double
  public var columnSubsample: Swift.Double
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public var parallelTreeCount: Swift.Int
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.BoostedTreeConfiguration, b: CreateMLComponents.BoostedTreeConfiguration) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol SupervisedEstimator<Transformer, Annotation> {
  associatedtype Transformer : CreateMLComponents.Transformer
  associatedtype Annotation : Swift.Equatable
  func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
  func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
  func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol SupervisedEstimator {
  associatedtype Transformer : CreateMLComponents.Transformer
  associatedtype Annotation : Swift.Equatable
  func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
  func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
  func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.SupervisedEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func fitted<Input>(to input: Input) async throws -> Self.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation> {
        try await fitted(to: input, eventHandler: nil)
    }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation) async throws -> Self.Transformer where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation> {
        try await fitted(to: input, validateOn: validation, eventHandler: nil)
    }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol UpdatableSupervisedEstimator<Transformer, Annotation> : CreateMLComponents.SupervisedEstimator {
  func makeTransformer() -> Self.Transformer
  func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol UpdatableSupervisedEstimator : CreateMLComponents.SupervisedEstimator {
  func makeTransformer() -> Self.Transformer
  func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.UpdatableSupervisedEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation> {
        try await update(&transformer, with: input, eventHandler: nil)
    }
}
extension CreateMLComponents.SupervisedEstimator {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where Input : _Concurrency.AsyncSequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where Input : _Concurrency.AsyncSequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
}
extension CreateMLComponents.UpdatableSupervisedEstimator {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func update<Input>(_ transformer: inout Self.Transformer, with input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where Input : _Concurrency.AsyncSequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct ApplyRandomly<RandomTransformer> : CreateMLComponents.RandomTransformer where RandomTransformer : CreateMLComponents.RandomTransformer, RandomTransformer.Input == RandomTransformer.Output {
  public let probability: Swift.Double
  public init<Input>(probability: Swift.Double = 0.5, @CreateMLComponents.AugmentationBuilder<Input> _ augmentation: () -> RandomTransformer) where Input == RandomTransformer.Input
  public func applied(to input: RandomTransformer.Input, generator: inout some RandomNumberGenerator, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> RandomTransformer.Output
  @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
  public typealias Input = RandomTransformer.Input
  @available(iOS 17.0, tvOS 17.0, watchOS 11.0, macOS 14.0, *)
  public typealias Output = RandomTransformer.Input
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.ApplyRandomly : Swift.Sendable where RandomTransformer : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct NormalizationScaler<Element> : CreateMLComponents.Estimator where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public enum NormalizationStrategy : Swift.Sendable {
    case l1
    case l2
    public static func == (a: CreateMLComponents.NormalizationScaler<Element>.NormalizationStrategy, b: CreateMLComponents.NormalizationScaler<Element>.NormalizationStrategy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var norm: CreateMLComponents.NormalizationScaler<Element>.NormalizationStrategy
  public init(norm: CreateMLComponents.NormalizationScaler<Element>.NormalizationStrategy = .l2)
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.NormalizationScaler<Element>.Transformer where Element == S.Element, S : Swift.Sequence
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.NormalizationScaler : Swift.Sendable where Element : Swift.Sendable {
}
extension CreateMLComponents.NormalizationScaler {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public struct Transformer : CreateMLComponents.Transformer, Swift.Hashable {
    public var scale: Element
    public init(scale: Element)
    @inlinable public func applied(to input: Element, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
            input / scale
        }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.NormalizationScaler<Element>.Transformer, b: CreateMLComponents.NormalizationScaler<Element>.Transformer) -> Swift.Bool
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Input = Element
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Output = Element
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.NormalizationScaler.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.NormalizationScaler.Transformer : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.NormalizationScaler.Transformer : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.NormalizationScaler.Transformer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct FullyConnectedNetworkRegressor<Scalar> : CreateMLComponents.SupervisedEstimator where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public typealias Transformer = CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar>
  public typealias Annotation = Swift.Float
  public var configuration: CreateMLComponents.FullyConnectedNetworkConfiguration
  public init(configuration: CreateMLComponents.FullyConnectedNetworkConfiguration = .init())
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.FullyConnectedNetworkRegressor<Scalar>.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Swift.Float>
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar> where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Swift.Float>, Validation.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Swift.Float>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.FullyConnectedNetworkRegressor : Swift.Sendable where Scalar : Swift.Sendable {
}
extension TabularData.DataFrame {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public init<S, Feature, Annotation>(_ sequence: S, featuresColumnID: TabularData.ColumnID<Feature>, annotationsColumnID: TabularData.ColumnID<Annotation>) throws where S : Swift.Sequence, S.Element == CreateMLComponents.AnnotatedFeature<Feature, Annotation>
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
public struct PreprocessingTabularEstimator<Preprocessor, Estimator> : CreateMLComponents.TabularEstimator where Preprocessor : CreateMLComponents.TabularTransformer, Estimator : CreateMLComponents.TabularEstimator {
  public typealias Transformer = CreateMLComponents.ComposedTabularTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  @inlinable public func preprocessed(from input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame {
        try await preprocessor.applied(to: input, eventHandler: eventHandler)
    }
  @inlinable public func fitted(toPreprocessed preprocessed: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingTabularEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTabularTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingTabularEstimator<Preprocessor, Estimator>.Transformer {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  public func encode(_ transformer: CreateMLComponents.PreprocessingTabularEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingTabularEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.PreprocessingTabularEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingTabularEstimator<Self, Other> where Other : CreateMLComponents.TabularEstimator
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
public struct MultivariateLinearRegressor<Scalar> : CreateMLComponents.SupervisedEstimator, Swift.Sendable where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public typealias Transformer = CreateMLComponents.MultivariateLinearRegressor<Scalar>.Model
  public typealias Feature = CoreML.MLShapedArray<Scalar>
  public typealias Annotation = CoreML.MLShapedArray<Scalar>
  public var configuration: CreateMLComponents.MultivariateLinearRegressor<Scalar>.Configuration
  public init(configuration: CreateMLComponents.MultivariateLinearRegressor<Scalar>.Configuration = Configuration())
  public func fitted(to input: some Sequence<AnnotatedFeature<Feature, Annotation>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.MultivariateLinearRegressor<Scalar>.Model
  public func fitted(to input: some Sequence<AnnotatedFeature<Feature, Annotation>>, validateOn validation: some Sequence<AnnotatedFeature<Feature, Annotation>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.MultivariateLinearRegressor<Scalar>.Model
  public func fitted(to input: CreateMLComponents.AnnotatedBatch<Scalar>, validateOn validation: CreateMLComponents.AnnotatedBatch<Scalar>?, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.MultivariateLinearRegressor<Scalar>.Model
  public func encode(_ model: CreateMLComponents.MultivariateLinearRegressor<Scalar>.Model, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.MultivariateLinearRegressor<Scalar>.Model
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
extension CreateMLComponents.MultivariateLinearRegressor : CreateMLComponents.UpdatableSupervisedEstimator {
  public func makeTransformer() -> CreateMLComponents.MultivariateLinearRegressor<Scalar>.Model
  public func update(_ model: inout CreateMLComponents.MultivariateLinearRegressor<Scalar>.Model, with input: some Sequence<AnnotatedFeature<MLShapedArray<Scalar>, MLShapedArray<Scalar>>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws
  public func update(_ model: inout CreateMLComponents.MultivariateLinearRegressor<Scalar>.Model, with input: CreateMLComponents.AnnotatedBatch<Scalar>) async throws -> Scalar
  public func encodeWithOptimizer(_ model: CreateMLComponents.MultivariateLinearRegressor<Scalar>.Model, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.MultivariateLinearRegressor<Scalar>.Model
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct FullyConnectedNetworkClassifier<Scalar, Label> : CreateMLComponents.SupervisedEstimator where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint, Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  public typealias Transformer = CreateMLComponents.FullyConnectedNetworkClassifierModel<Scalar, Label>
  public typealias Annotation = Label
  public var configuration: CreateMLComponents.FullyConnectedNetworkConfiguration
  public var labels: Swift.Set<Label>
  public init(labels: Swift.Set<Label>, configuration: CreateMLComponents.FullyConnectedNetworkConfiguration = .init())
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.FullyConnectedNetworkClassifierModel<Scalar, Label> where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.FullyConnectedNetworkClassifierModel<Scalar, Label> where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>, Validation.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.FullyConnectedNetworkClassifier : Swift.Sendable where Scalar : Swift.Sendable, Label : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator> : CreateMLComponents.UpdatableSupervisedEstimator where Preprocessor : CreateMLComponents.Transformer, Estimator : CreateMLComponents.UpdatableSupervisedEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public typealias Annotation = Estimator.Annotation
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  @inlinable public func makeTransformer() -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer {
        ComposedTransformer(preprocessor, estimator.makeTransformer())
    }
  @inlinable public func preprocessed<S>(from input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Swift.AnySequence<CreateMLComponents.AnnotatedFeature<Preprocessor.Output, CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Annotation>> where S : Swift.Sequence, S.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let inputFeatures = input.lazy.map(\.feature)
        let preprocessedFeatures = try await preprocessor.applied(to: inputFeatures, eventHandler: eventHandler)
        return AnySequence(zip(preprocessedFeatures, input.lazy.map(\.annotation)).lazy.map(AnnotatedFeature.init))
    }
  @inlinable public func fitted<S>(toPreprocessed preprocessed: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer where S : Swift.Sequence, S.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation> {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessed,
            eventHandler: eventHandler
        )
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted<InputSequence, Validation>(toPreprocessed preprocessedInput: InputSequence, validateOn preprocessedValidation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation> {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  @inlinable public func fitted<InputSequence, Validation>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let preprocessedInput = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        let preprocessedValidation = try await preprocessed(from: validation, eventHandler: eventHandler)
        try Task.checkCancellation()

        return try await fitted(
            toPreprocessed: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
    }
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer, withPreprocessed preprocessed: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation> {
        try await estimator.update(
            &transformer.outer,
            with: preprocessed,
            eventHandler: eventHandler
        )
    }
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        try await estimator.update(
            &transformer.outer,
            with: preprocessed,
            eventHandler: eventHandler
        )
    }
  public func encode(_ transformer: CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.PreprocessingUpdatableSupervisedEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Self, Other> where Other : CreateMLComponents.UpdatableSupervisedEstimator, Self.Output == Other.Transformer.Input
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.FullyConnectedNetworkRegressor : CreateMLComponents.UpdatableSupervisedEstimator {
  public func makeTransformer() -> CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar>
  public func update<InputSequence>(_ transformer: inout CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar>, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Swift.Float>
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public protocol SupervisedTemporalEstimator<Transformer, Annotation> {
  associatedtype Transformer : CreateMLComponents.TemporalTransformer
  associatedtype Annotation : Swift.Equatable, Swift.Sendable
  func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input
  func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input
  func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public protocol SupervisedTemporalEstimator {
  associatedtype Transformer : CreateMLComponents.TemporalTransformer
  associatedtype Annotation : Swift.Equatable, Swift.Sendable
  func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input
  func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input
  func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.SupervisedTemporalEstimator {
  @inlinable public func fitted<InputSequence, FeatureSequence>(to input: InputSequence) async throws -> Self.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input {
        try await fitted(to: input, eventHandler: nil)
    }
  @inlinable public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation) async throws -> Self.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input {
        try await fitted(to: input, validateOn: validation, eventHandler: nil)
    }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public protocol UpdatableSupervisedTemporalEstimator<Transformer, Annotation> : CreateMLComponents.SupervisedTemporalEstimator {
  func makeTransformer() -> Self.Transformer
  func update<InputSequence, FeatureSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public protocol UpdatableSupervisedTemporalEstimator : CreateMLComponents.SupervisedTemporalEstimator {
  func makeTransformer() -> Self.Transformer
  func update<InputSequence, FeatureSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.UpdatableSupervisedTemporalEstimator {
  @inlinable public func update<InputSequence, FeatureSequence>(_ transformer: inout Self.Transformer, with input: InputSequence) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input {
        try await update(&transformer, with: input, eventHandler: nil)
    }
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
public struct PreprocessingTemporalEstimator<Preprocessor, Estimator> : CreateMLComponents.TemporalEstimator where Preprocessor : CreateMLComponents.TemporalTransformer, Estimator : CreateMLComponents.TemporalEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTemporalTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  @inlinable public func preprocessed<InputSequence>(from input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>] where InputSequence : Swift.Sequence, Preprocessor.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        var preprocessed = [PreprocessedFeatureSequence<Preprocessor.Output>]()
        for item in input {
            let transformed = try await preprocessor.applied(to: item, eventHandler: eventHandler)
            let stored = try await PreprocessedFeatureSequence(transformed)
            preprocessed.append(stored)
        }
        return preprocessed
    }
  @inlinable public func fitted(toPreprocessed preprocessed: [CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingTemporalEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTemporalTransformer(preprocessor, fittedTransformer)
    }
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingTemporalEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Preprocessor.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  public func encode(_ transformer: CreateMLComponents.PreprocessingTemporalEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingTemporalEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS, introduced: 13.0, deprecated: 15.0)
@available(iOS, introduced: 16.0, deprecated: 18.0)
@available(tvOS, introduced: 16.0, deprecated: 18.0)
@available(visionOS, introduced: 1.0, deprecated: 2.0)
@available(watchOS, unavailable)
extension CreateMLComponents.PreprocessingTemporalEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingTemporalEstimator<CreateMLComponents.TransformerToTemporalAdaptor<Self>, Other> where Other : CreateMLComponents.TemporalEstimator, Self.Output == Other.Transformer.Input
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingTemporalEstimator<Self, CreateMLComponents.EstimatorToTemporalAdaptor<Other>> where Other : CreateMLComponents.Estimator, Self.Output == Other.Transformer.Input
  @available(macOS, introduced: 13.0, deprecated: 15.0)
  @available(iOS, introduced: 16.0, deprecated: 18.0)
  @available(tvOS, introduced: 16.0, deprecated: 18.0)
  @available(visionOS, introduced: 1.0, deprecated: 2.0)
  @available(watchOS, unavailable)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingTemporalEstimator<Self, Other> where Other : CreateMLComponents.TemporalEstimator, Self.Output == Other.Transformer.Input
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(watchOS, unavailable)
public struct TimeSeriesClassifier<Scalar, Label> : CreateMLComponents.SupervisedEstimator where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint, Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  public typealias Transformer = CreateMLComponents.TimeSeriesClassifier<Scalar, Label>.Model
  public typealias Annotation = Label
  public var configuration: CreateMLComponents.TimeSeriesClassifierConfiguration
  public var labels: Swift.Set<Label>
  public init(labels: Swift.Set<Label>, configuration: CreateMLComponents.TimeSeriesClassifierConfiguration = .init())
  public func fitted(to input: some Sequence<AnnotatedFeature<MLShapedArray<Scalar>, Annotation>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.TimeSeriesClassifier<Scalar, Label>.Model
  public func fitted(to input: some Sequence<AnnotatedFeature<MLShapedArray<Scalar>, Annotation>>, validateOn validation: some Sequence<AnnotatedFeature<MLShapedArray<Scalar>, Annotation>>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.TimeSeriesClassifier<Scalar, Label>.Model
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, *)
@available(watchOS, unavailable)
extension CreateMLComponents.TimeSeriesClassifier : Swift.Sendable where Scalar : Swift.Sendable, Label : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol ImageFeatureExtractor : CreateMLComponents.Transformer where Self.Input == CoreImage.CIImage, Self.Output == CoreML.MLShapedArray<Swift.Float> {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct RobustScaler<Element> : CreateMLComponents.Estimator where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public var quantileRange: Swift.ClosedRange<Element>
  public init(quantileRange: Swift.ClosedRange<Element> = 0.25...0.75)
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.RobustScaler<Element>.Transformer where Element == S.Element, S : Swift.Sequence
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.RobustScaler : Swift.Sendable where Element : Swift.Sendable {
}
extension CreateMLComponents.RobustScaler {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public struct Transformer : CreateMLComponents.Transformer, Swift.Hashable {
    public var median: Element
    public var interQuartileRange: Element
    public init(median: Element, interQuartileRange: Element)
    @inlinable public func applied(to input: Element, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
            var result = input

            if median.isFinite {
                result -= median
            }

            if interQuartileRange.isFinite && !interQuartileRange.isZero {
                result /= interQuartileRange
            }

            return result
        }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.RobustScaler<Element>.Transformer, b: CreateMLComponents.RobustScaler<Element>.Transformer) -> Swift.Bool
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Input = Element
    @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
    public typealias Output = Element
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.RobustScaler.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.RobustScaler.Transformer : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.RobustScaler.Transformer : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.RobustScaler.Transformer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct BoostedTreeRegressor<Annotation> : CreateMLComponents.SupervisedTabularEstimator {
  public typealias Transformer = CreateMLComponents.TreeRegressorModel
  public var configuration: CreateMLComponents.BoostedTreeConfiguration {
    get
    set
  }
  public var annotationColumnID: TabularData.ColumnID<Annotation>
  public var featureColumnNames: [Swift.String]
  public init(annotationColumnName: Swift.String, featureColumnNames: [Swift.String], configuration: CreateMLComponents.BoostedTreeConfiguration = BoostedTreeConfiguration())
  public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame? = nil, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.TreeRegressorModel
  public func encode(_ transformer: CreateMLComponents.TreeRegressorModel, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.TreeRegressorModel
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.BoostedTreeRegressor : CreateMLComponents.UpdatableSupervisedTabularEstimator {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func makeTransformer() -> CreateMLComponents.TreeRegressorModel
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func update(_ transformer: inout CreateMLComponents.TreeRegressorModel, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.TreeRegressorModel, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.TreeRegressorModel
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.BoostedTreeRegressor : Swift.Sendable where Annotation : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
public struct RandomImageNoiseGenerator : CreateMLComponents.Transformer, Swift.Sendable {
  public var intensity: Swift.Double
  public init(intensity: Swift.Double)
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) -> CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Input = CoreImage.CIImage
  @available(iOS 17.0, tvOS 17.0, macOS 14.0, *)
  public typealias Output = CoreImage.CIImage
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct LinearRegressor<Scalar> : CreateMLComponents.SupervisedEstimator where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public typealias Transformer = CreateMLComponents.LinearRegressorModel<Scalar>
  public typealias Annotation = Scalar
  public var configuration: CreateMLComponents.LinearRegressor<Scalar>.Configuration {
    get
    set
  }
  public init(configuration: CreateMLComponents.LinearRegressor<Scalar>.Configuration = Configuration())
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.LinearRegressorModel<Scalar> where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Scalar>
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.LinearRegressorModel<Scalar> where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Scalar>, Validation.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Scalar>
  public func encode(_ transformer: CreateMLComponents.LinearRegressorModel<Scalar>, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.LinearRegressorModel<Scalar>
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.LinearRegressor : CreateMLComponents.UpdatableSupervisedEstimator {
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func makeTransformer() -> CreateMLComponents.LinearRegressorModel<Scalar>
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func update<InputSequence>(_ transformer: inout CreateMLComponents.LinearRegressor<Scalar>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Scalar>
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.LinearRegressorModel<Scalar>, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
  public func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.LinearRegressorModel<Scalar>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.LinearRegressor : Swift.Sendable where Scalar : Swift.Sendable {
}
extension CreateMLComponents.LinearRegressor {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  public struct Configuration : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var l2Penalty: Swift.Double
    public var l1Penalty: Swift.Double
    public var maximumIterations: Swift.Int
    public var stepSize: Swift.Double
    public var convergenceThreshold: Swift.Double
    @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
    public var earlyStopIterationCount: Swift.Int
    @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
    public var scaleFeatures: Swift.Bool
    @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
    public var optimizationStrategy: CreateMLComponents.OptimizationStrategy {
      get
      set
    }
    public init()
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.LinearRegressor<Scalar>.Configuration, b: CreateMLComponents.LinearRegressor<Scalar>.Configuration) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol TabularEstimator<Transformer> {
  associatedtype Transformer : CreateMLComponents.TabularTransformer
  func fitted(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer
  func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol TabularEstimator {
  associatedtype Transformer : CreateMLComponents.TabularTransformer
  func fitted(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer
  func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.TabularEstimator where Self.Transformer : Swift.Encodable {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func fitted(to input: TabularData.DataFrame) async throws -> Self.Transformer {
        try await fitted(to: input, eventHandler: nil)
    }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func encode(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws {
        try encoder.encode(transformer)
    }
}
extension CreateMLComponents.TabularEstimator {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
  @inlinable public func fitted(to input: TabularData.DataFrame) async throws -> Self.Transformer {
        try await fitted(to: input, eventHandler: nil)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.TabularEstimator where Self.Transformer : Swift.Decodable {
  @inlinable public func decode(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer {
        try decoder.decode(Transformer.self)
    }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol UpdatableTabularEstimator<Transformer> : CreateMLComponents.TabularEstimator {
  func makeTransformer() -> Self.Transformer
  func update(_ transformer: inout Self.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public protocol UpdatableTabularEstimator : CreateMLComponents.TabularEstimator {
  func makeTransformer() -> Self.Transformer
  func update(_ transformer: inout Self.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout any CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout any CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.UpdatableTabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
  @inlinable public func update(_ transformer: inout Self.Transformer, with input: TabularData.DataFrame) async throws {
        try await update(&transformer, with: input, eventHandler: nil)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct MLModelRegressorAdaptor<Scalar> : CreateMLComponents.Regressor where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public let model: CoreML.MLModel
  public init(contentsOf url: Foundation.URL, configuration: CoreML.MLModelConfiguration) throws
  public init(model: CoreML.MLModel) throws
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Swift.Double
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = CoreML.MLShapedArray<Scalar>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = Swift.Double
}
@available(*, unavailable)
extension CreateMLComponents.MLModelRegressorAdaptor : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum VideoReaderError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case missingVideoTrack(Foundation.URL)
  case cameraAuthorizationDenied
  case cameraAuthorizationRestricted
  case sourceCameraNotAvailable
  case frameRateNotSupported(Swift.Double)
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, *)
  case captureSessionStopped
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.VideoReaderError, b: CreateMLComponents.VideoReaderError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.VideoReaderError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
public struct Reshaper<Scalar> : CreateMLComponents.Transformer, Swift.Equatable, Swift.Codable where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.Decodable, Scalar : Swift.Encodable {
  public var shape: [Swift.Int]
  public init(shape: [Swift.Int])
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CoreML.MLShapedArray<Scalar>
  public func applied<S>(_ input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> [CoreML.MLShapedArray<Scalar>] where S : Swift.Sequence, S.Element == CoreML.MLShapedArray<Scalar>
  public static func == (a: CreateMLComponents.Reshaper<Scalar>, b: CreateMLComponents.Reshaper<Scalar>) -> Swift.Bool
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Input = CoreML.MLShapedArray<Scalar>
  @available(iOS 16.0, tvOS 16.0, watchOS 11.0, macOS 13.0, *)
  public typealias Output = CoreML.MLShapedArray<Scalar>
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Reshaper : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.Reshaper : Swift.Sendable where Scalar : Swift.Sendable {
}
extension CreateMLComponents.MultivariateLinearRegressor {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, visionOS 2.0, watchOS 11.0, *)
  public struct Model : CreateMLComponents.Transformer, Swift.Sendable {
    public typealias Input = CoreML.MLShapedArray<Scalar>
    public var inputSize: Swift.Int {
      get
    }
    public var outputSize: Swift.Int {
      get
    }
    public var weight: CoreML.MLShapedArray<Scalar> {
      get
    }
    public var bias: CoreML.MLShapedArray<Scalar>? {
      get
    }
    public init(weight: CoreML.MLShapedArray<Scalar>, bias: CoreML.MLShapedArray<Scalar>?)
    public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CoreML.MLShapedArray<Scalar>
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias Output = CoreML.MLShapedArray<Scalar>
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ImageCropper : CreateMLComponents.Transformer, Swift.Sendable {
  public var cropRectangle: CoreFoundation.CGRect
  public init(cropRectangle: CoreFoundation.CGRect)
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CoreImage.CIImage
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Input = CoreImage.CIImage
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Output = CoreImage.CIImage
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageCropper : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageCropper : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ImageFeaturePrint : CreateMLComponents.ImageFeatureExtractor {
  public let cropAndScale: Vision.VNImageCropAndScaleOption
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public static let latestRevision: Swift.Int
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public var revision: Swift.Int {
    get
    set
  }
  public init(cropAndScale: Vision.VNImageCropAndScaleOption = .centerCrop, context: CoreImage.CIContext = CIContext())
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public init(revision: Swift.Int, cropAndScale: Vision.VNImageCropAndScaleOption = .centerCrop, context: CoreImage.CIContext = CIContext())
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CoreML.MLShapedArray<Swift.Float>
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Input = CoreImage.CIImage
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Output = CoreML.MLShapedArray<Swift.Float>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageFeaturePrint : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageFeaturePrint : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(*, unavailable)
extension CreateMLComponents.ImageFeaturePrint : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.ObjectDetectionAnnotation.Annotation.CodingKeys : Swift.Equatable {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.ObjectDetectionAnnotation.Annotation.CodingKeys : Swift.Hashable {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.ObjectDetectionAnnotation.Annotation.CodingKeys : Swift.RawRepresentable {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.ObjectDetectionAnnotation.CodingKeys : Swift.Equatable {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.ObjectDetectionAnnotation.CodingKeys : Swift.Hashable {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension CreateMLComponents.ObjectDetectionAnnotation.CodingKeys : Swift.RawRepresentable {}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraConfiguration.Position : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraConfiguration.Position : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraConfiguration.PixelFormat : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraConfiguration.PixelFormat : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraConfiguration.Resolution : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraConfiguration.Resolution : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PoseSelectionStrategy : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PoseSelectionStrategy : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioReaderError : Swift.Hashable {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 11.0, *)
extension CreateMLComponents.OptimizationError : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.NormalizationScaler.NormalizationStrategy : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 11.0, *)
extension CreateMLComponents.NormalizationScaler.NormalizationStrategy : Swift.Hashable {}
