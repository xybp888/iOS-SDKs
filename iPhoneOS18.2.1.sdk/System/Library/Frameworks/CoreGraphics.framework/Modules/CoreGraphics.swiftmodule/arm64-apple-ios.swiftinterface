// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.6 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios18.2 -enable-objc-interop -autolink-force-load -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-bare-slash-regex -user-module-version 1889.2.7.1.1 -module-name CoreGraphics
@_exported import CoreFoundation
@_exported import CoreGraphics
import Foundation
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGColorSpace {
  public var colorTable: [Swift.UInt8]? {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGColorSpace : @unchecked Swift.Sendable {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint {
  public static var zero: CoreFoundation.CGPoint {
    @_transparent get { return CGPoint(x: 0, y: 0) }
  }
  @_transparent public init(x: Swift.Int, y: Swift.Int) {
        self.init(x: CGFloat(x), y: CGFloat(y))
    }
  @_transparent public init(x: Swift.Double, y: Swift.Double) {
        self.init(x: CGFloat(x), y: CGFloat(y))
    }
  public init?(dictionaryRepresentation dict: CoreFoundation.CFDictionary)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGPoint.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint : Swift.Equatable {
  @_transparent public static func == (lhs: CoreFoundation.CGPoint, rhs: CoreFoundation.CGPoint) -> Swift.Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y
    }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint {
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(x)
        hasher.combine(y)
    }
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
        var hasher = Hasher()
        hash(into: &hasher)
        return hasher.finalize()
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreFoundation.CGPoint : Swift.Hashable {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGImage {
  public func copy(maskingColorComponents components: [CoreFoundation.CGFloat]) -> CoreGraphics.CGImage?
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGImage : @unchecked Swift.Sendable {
}
@available(*, unavailable, message: "Use == instead")
public func CGAffineTransformEqualToTransform(_ t1: CoreFoundation.CGAffineTransform, _ t2: CoreFoundation.CGAffineTransform) -> Swift.Bool
@available(*, unavailable, message: "Use class var white/black/clear instead")
public func CGColorGetConstantColor(_ colorName: CoreFoundation.CFString?) -> CoreGraphics.CGColor?
@available(*, unavailable, message: "Use == instead")
public func CGColorEqualToColor(_ color1: CoreGraphics.CGColor?, _ color2: CoreGraphics.CGColor?) -> Swift.Bool
@available(*, unavailable, renamed: "getter:CGColor.components(self:)")
public func CGColorGetComponents(_ color: CoreGraphics.CGColor?) -> Swift.UnsafePointer<CoreFoundation.CGFloat>
@available(*, unavailable, message: "Use colorTable.count instead")
public func CGColorSpaceGetColorTableCount(_ space: CoreGraphics.CGColorSpace?) -> Swift.Int
@available(*, unavailable, renamed: "CGColorSpace.colorTable(self:_:)")
public func CGColorSpaceGetColorTable(_ space: CoreGraphics.CGColorSpace?, _ table: Swift.UnsafeMutablePointer<Swift.UInt8>)
@available(*, unavailable, message: "Use setLineDash(self:phase:lengths:)")
public func CGContextSetLineDash(_ c: CoreGraphics.CGContext?, _ phase: CoreFoundation.CGFloat, _ lengths: Swift.UnsafePointer<CoreFoundation.CGFloat>, _ count: Swift.Int)
@available(*, unavailable, message: "Use move(to:) instead")
public func CGContextMoveToPoint(_ c: CoreGraphics.CGContext?, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
@available(*, unavailable, message: "Use addLine(to:) instead")
public func CGContextAddLineToPoint(_ c: CoreGraphics.CGContext?, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
@available(*, unavailable, message: "Use addCurve(to:control1:control2:) instead")
public func CGContextAddCurveToPoint(_ c: CoreGraphics.CGContext?, _ cp1x: CoreFoundation.CGFloat, _ cp1y: CoreFoundation.CGFloat, _ cp2x: CoreFoundation.CGFloat, _ cp2y: CoreFoundation.CGFloat, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
@available(*, unavailable, message: "Use addQuadCurve(to:control:)")
public func CGContextAddQuadCurveToPoint(_ c: CoreGraphics.CGContext?, _ cpx: CoreFoundation.CGFloat, _ cpy: CoreFoundation.CGFloat, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
@available(*, unavailable, message: "Use addRects(_:)")
public func CGContextAddRects(_ c: CoreGraphics.CGContext?, _ rects: Swift.UnsafePointer<CoreFoundation.CGRect>, _ count: Swift.Int)
@available(*, unavailable, message: "Use addLines(between:)")
public func CGContextAddLines(_ c: CoreGraphics.CGContext?, _ points: Swift.UnsafePointer<CoreFoundation.CGPoint>, _ count: Swift.Int)
@available(*, unavailable, message: "Use addArc(center:radius:startAngle:endAngle:clockwise:)")
public func CGContextAddArc(_ c: CoreGraphics.CGContext?, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat, _ radius: CoreFoundation.CGFloat, _ startAngle: CoreFoundation.CGFloat, _ endAngle: CoreFoundation.CGFloat, _ clockwise: Swift.Int32)
@available(*, unavailable, message: "Use addArc(self:x1:y1:x2:y2:radius:)")
public func CGContextAddArcToPoint(_ c: CoreGraphics.CGContext?, _ x1: CoreFoundation.CGFloat, _ y1: CoreFoundation.CGFloat, _ x2: CoreFoundation.CGFloat, _ y2: CoreFoundation.CGFloat, _ radius: CoreFoundation.CGFloat)
@available(*, unavailable, message: "Use fill(self:_:count:)")
public func CGContextFillRects(_ c: CoreGraphics.CGContext?, _ rects: Swift.UnsafePointer<CoreFoundation.CGRect>, _ count: Swift.Int)
@available(*, unavailable, message: "Use strokeLineSegments(self:between:count:)")
public func CGContextStrokeLineSegments(_ c: CoreGraphics.CGContext?, _ points: Swift.UnsafePointer<CoreFoundation.CGPoint>, _ count: Swift.Int)
@available(*, unavailable, message: "Use clip(to:)")
public func CGContextClipToRects(_ c: CoreGraphics.CGContext?, _ rects: Swift.UnsafePointer<CoreFoundation.CGRect>, _ count: Swift.Int)
@available(*, unavailable, message: "Use draw(_:in:)")
public func CGContextDrawImage(_ c: CoreGraphics.CGContext?, _ rect: CoreFoundation.CGRect, _ image: CoreGraphics.CGImage?)
@available(*, unavailable, message: "Use draw(_:in:byTiling:)")
public func CGContextDrawTiledImage(_ c: CoreGraphics.CGContext?, _ rect: CoreFoundation.CGRect, _ image: CoreGraphics.CGImage?)
@available(*, unavailable, message: "Use draw(_:in:by:options:)")
public func CGContextDrawImageApplyingToneMapping(_ c: CoreGraphics.CGContext?, _ rect: CoreFoundation.CGRect, _ image: CoreGraphics.CGImage?, applying: CoreGraphics.CGToneMapping, options: CoreFoundation.CFDictionary?) -> Swift.Bool
@available(*, unavailable, renamed: "getter:CGContext.textPosition(self:)")
public func CGContextGetTextPosition(_ c: CoreGraphics.CGContext?) -> CoreFoundation.CGPoint
@available(*, unavailable, message: "Use var textPosition")
public func CGContextSetTextPosition(_ c: CoreGraphics.CGContext?, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
@available(*, unavailable, message: "Use showGlyphs(_:at:)")
public func CGContextShowGlyphsAtPositions(_ c: CoreGraphics.CGContext?, _ glyphs: Swift.UnsafePointer<CoreGraphics.CGGlyph>, _ Lpositions: Swift.UnsafePointer<CoreFoundation.CGPoint>, _ count: Swift.Int)
@available(*, unavailable, renamed: "CGContext.fillPath(self:)")
public func CGContextFillPath(_ c: CoreGraphics.CGContext?)
@available(*, unavailable, message: "Use fillPath(using:)")
public func CGContextEOFillPath(_ c: CoreGraphics.CGContext?)
@available(*, unavailable, renamed: "CGContext.clip(self:)")
public func CGContextClip(_ c: CoreGraphics.CGContext?)
@available(*, unavailable, message: "Use clip(using:)")
public func CGContextEOClip(_ c: CoreGraphics.CGContext?)
@available(*, unavailable, renamed: "CGGetLastMouseDelta")
public func CGGetLastMouseDelta(_ deltaX: Swift.UnsafeMutablePointer<Swift.Int32>?, _ deltaY: Swift.UnsafeMutablePointer<Swift.Int32>?)
@available(*, unavailable, message: "Use divided(atDistance:from:)")
public func CGRectDivide(_ rect: CoreFoundation.CGRect, _ slice: Swift.UnsafeMutablePointer<CoreFoundation.CGRect>, _ remainder: Swift.UnsafeMutablePointer<CoreFoundation.CGRect>, _ amount: CoreFoundation.CGFloat, _ edge: CoreFoundation.CGRectEdge)
@available(*, unavailable, message: "Use CGPoint.init(dictionaryRepresentation:)")
public func CGPointMakeWithDictionaryRepresentation(_ dict: CoreFoundation.CFDictionary?, _ point: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>) -> Swift.Bool
@available(*, unavailable, message: "Use CGSize.init(dictionaryRepresentation:)")
public func CGSizeMakeWithDictionaryRepresentation(_ dict: CoreFoundation.CFDictionary?, _ size: Swift.UnsafeMutablePointer<CoreFoundation.CGSize>) -> Swift.Bool
@available(*, unavailable, message: "Use CGRect.init(dictionaryRepresentation:)")
public func CGRectMakeWithDictionaryRepresentation(_ dict: CoreFoundation.CFDictionary?, _ rect: Swift.UnsafeMutablePointer<CoreFoundation.CGRect>) -> Swift.Bool
@available(*, unavailable, renamed: "CGImage.copy(self:maskingColorComponents:)")
public func CGImageCreateWithMaskingColors(_ image: CoreGraphics.CGImage?, _ components: Swift.UnsafePointer<CoreFoundation.CGFloat>) -> CoreGraphics.CGImage?
@available(*, unavailable, message: "Use draw(_:in:)")
public func CGContextDrawLayerInRect(_ context: CoreGraphics.CGContext?, _ rect: CoreFoundation.CGRect, _ layer: CoreGraphics.CGLayer?)
@available(*, unavailable, message: "Use draw(_:at:)")
public func CGContextDrawLayerAtPoint(_ context: CoreGraphics.CGContext?, _ point: CoreFoundation.CGPoint, _ layer: CoreGraphics.CGLayer?)
@available(*, unavailable, message: "Use copy(byDashingWithPhase:lengths:transform:)")
public func CGPathCreateCopyByDashingPath(_ path: CoreGraphics.CGPath?, _ transform: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ phase: CoreFoundation.CGFloat, _ lengths: Swift.UnsafePointer<CoreFoundation.CGFloat>, _ count: Swift.Int) -> CoreGraphics.CGPath?
@available(*, unavailable, message: "Use copy(byStroking:lineWidth:lineCap:lineJoin:miterLimit:transform:)")
public func CGPathCreateCopyByStrokingPath(_ path: CoreGraphics.CGPath?, _ transform: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ lineWidth: CoreFoundation.CGFloat, _ lineCap: CoreGraphics.CGLineCap, _ lineJoin: CoreGraphics.CGLineJoin, _ miterLimit: CoreFoundation.CGFloat) -> CoreGraphics.CGPath?
@available(*, unavailable, message: "Use == instead")
public func CGPathEqualToPath(_ path1: CoreGraphics.CGPath?, _ path2: CoreGraphics.CGPath?) -> Swift.Bool
@available(*, unavailable, message: "Use move(to:transform:)")
public func CGPathMoveToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
@available(*, unavailable, message: "Use addLine(to:transform:)")
public func CGPathAddLineToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
@available(*, unavailable, message: "Use addCurve(to:control1:control2:transform:)")
public func CGPathAddCurveToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ cp1x: CoreFoundation.CGFloat, _ cp1y: CoreFoundation.CGFloat, _ cp2x: CoreFoundation.CGFloat, _ cp2y: CoreFoundation.CGFloat, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
@available(*, unavailable, message: "Use addQuadCurve(to:control:transform:)")
public func CGPathAddQuadCurveToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ cpx: CoreFoundation.CGFloat, _ cpy: CoreFoundation.CGFloat, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
@available(*, unavailable, message: "Use addRect(_:transform:)")
public func CGPathAddRect(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ rect: CoreFoundation.CGRect)
@available(*, unavailable, message: "Use addRects(_:transform:)")
public func CGPathAddRects(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ rects: Swift.UnsafePointer<CoreFoundation.CGRect>, _ count: Swift.Int)
@available(*, unavailable, message: "Use addLines(between:transform:)")
public func CGPathAddLines(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ points: Swift.UnsafePointer<CoreFoundation.CGPoint>, _ count: Swift.Int)
@available(*, unavailable, message: "Use addEllipse(rect:transform:)")
public func CGPathAddEllipseInRect(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ rect: CoreFoundation.CGRect)
@available(*, unavailable, message: "Use addRelativeArc(center:radius:startAngle:delta:transform:)")
public func CGPathAddRelativeArc(_ path: CoreGraphics.CGMutablePath?, _ matrix: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat, _ radius: CoreFoundation.CGFloat, _ startAngle: CoreFoundation.CGFloat, _ delta: CoreFoundation.CGFloat)
@available(*, unavailable, message: "Use addArc(center:radius:startAngle:endAngle:clockwise:transform:)")
public func CGPathAddArc(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat, _ radius: CoreFoundation.CGFloat, _ startAngle: CoreFoundation.CGFloat, _ endAngle: CoreFoundation.CGFloat, _ clockwise: Swift.Bool)
@available(*, unavailable, message: "Use addArc(tangent1End:tangent2End:radius:transform:)")
public func CGPathAddArcToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ x1: CoreFoundation.CGFloat, _ y1: CoreFoundation.CGFloat, _ x2: CoreFoundation.CGFloat, _ y2: CoreFoundation.CGFloat, _ radius: CoreFoundation.CGFloat)
@available(*, unavailable, message: "Use addPath(_:transform:)")
public func CGPathAddPath(_ path1: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ path2: CoreGraphics.CGPath?)
@available(*, unavailable, message: "Use CGColor.white")
public var kCGColorWhite: CoreFoundation.CFString {
  get
}
@available(*, unavailable, message: "Use CGColor.black")
public var kCGColorBlack: CoreFoundation.CFString {
  get
}
@available(*, unavailable, message: "Use CGColor.clear")
public var kCGColorClear: CoreFoundation.CFString {
  get
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGColor {
  public var components: [CoreFoundation.CGFloat]? {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
public protocol _CGColorInitTrampoline {
  init?(colorSpace space: CoreGraphics.CGColorSpace, components: Swift.UnsafePointer<CoreFoundation.CGFloat>)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics._CGColorInitTrampoline {
  public init(_colorLiteralRed red: Swift.Float, green: Swift.Float, blue: Swift.Float, alpha: Swift.Float)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGColor : CoreGraphics._CGColorInitTrampoline, Swift._ExpressibleByColorLiteral {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGColor : @unchecked Swift.Sendable {
}
extension CoreFoundation.CGAffineTransform {
  @_alwaysEmitIntoClient public init(translationX tx: CoreFoundation.CGFloat, y ty: CoreFoundation.CGFloat) {
        self = CGAffineTransformMakeTranslation(tx, ty)
    }
  @_alwaysEmitIntoClient public init(scaleX sx: CoreFoundation.CGFloat, y sy: CoreFoundation.CGFloat) {
        self = CGAffineTransformMakeScale(sx, sy)
    }
  @_alwaysEmitIntoClient public init(rotationAngle angle: CoreFoundation.CGFloat) {
        self = CGAffineTransformMakeRotation(angle)
    }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init(_ components: CoreFoundation.CGAffineTransformComponents) {
        self = __CGAffineTransformMakeWithComponents(components)
    }
  @_alwaysEmitIntoClient public var isIdentity: Swift.Bool {
    get { CGAffineTransformIsIdentity(self) }
  }
  @_alwaysEmitIntoClient public func translatedBy(x tx: CoreFoundation.CGFloat, y ty: CoreFoundation.CGFloat) -> CoreFoundation.CGAffineTransform {
        CGAffineTransformTranslate(self, tx, ty)
    }
  @_alwaysEmitIntoClient public func scaledBy(x sx: CoreFoundation.CGFloat, y sy: CoreFoundation.CGFloat) -> CoreFoundation.CGAffineTransform {
        CGAffineTransformScale(self, sx, sy)
    }
  @_alwaysEmitIntoClient public func rotated(by angle: CoreFoundation.CGFloat) -> CoreFoundation.CGAffineTransform {
        CGAffineTransformRotate(self, angle)
    }
  @_alwaysEmitIntoClient public func inverted() -> CoreFoundation.CGAffineTransform {
        CGAffineTransformInvert(self)
    }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public func decomposed() -> CoreFoundation.CGAffineTransformComponents {
        __CGAffineTransformDecompose(self)
    }
  @_alwaysEmitIntoClient public func concatenating(_ t2: CoreFoundation.CGAffineTransform) -> CoreFoundation.CGAffineTransform {
        CGAffineTransformConcat(self, t2)
    }
}
extension CoreFoundation.CGAffineTransformComponents {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init(scale: CoreFoundation.CGSize = .init(width: 1, height: 1), horizontalShear: CoreFoundation.CGFloat = 0, rotation: CoreFoundation.CGFloat = 0, translation: CoreFoundation.CGVector = .zero) {
        self.init()
        self.scale = scale
        self.horizontalShear = horizontalShear
        self.rotation = rotation
        self.translation = translation
    }
}
extension CoreFoundation.CGPoint {
  @_alwaysEmitIntoClient public func applying(_ t: CoreFoundation.CGAffineTransform) -> CoreFoundation.CGPoint {
        CGPointApplyAffineTransform(self, t)
    }
}
extension CoreFoundation.CGSize {
  @_alwaysEmitIntoClient public func applying(_ t: CoreFoundation.CGAffineTransform) -> CoreFoundation.CGSize {
        CGSizeApplyAffineTransform(self, t)
    }
}
extension CoreFoundation.CGRect {
  @_alwaysEmitIntoClient public func applying(_ t: CoreFoundation.CGAffineTransform) -> CoreFoundation.CGRect {
        CGRectApplyAffineTransform(self, t)
    }
}
extension CoreFoundation.CGAffineTransform {
  @_alwaysEmitIntoClient public init(_ a: CoreFoundation.CGFloat, _ b: CoreFoundation.CGFloat, _ c: CoreFoundation.CGFloat, _ d: CoreFoundation.CGFloat, _ tx: CoreFoundation.CGFloat, _ ty: CoreFoundation.CGFloat) {
        self = CGAffineTransformMake(a, b, c, d, tx, ty)
    }
}
extension CoreFoundation.CGPoint {
  @_alwaysEmitIntoClient public func equalTo(_ point2: CoreFoundation.CGPoint) -> Swift.Bool {
        CGPointEqualToPoint(self, point2)
    }
  @_alwaysEmitIntoClient public var dictionaryRepresentation: CoreFoundation.CFDictionary {
    get {
        CGPointCreateDictionaryRepresentation(self)
    }
  }
}
extension CoreFoundation.CGSize {
  @_alwaysEmitIntoClient public func equalTo(_ size2: CoreFoundation.CGSize) -> Swift.Bool {
        CGSizeEqualToSize(self, size2)
    }
  @_alwaysEmitIntoClient public var dictionaryRepresentation: CoreFoundation.CFDictionary {
    get {
        CGSizeCreateDictionaryRepresentation(self)
    }
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect {
  @_transparent public func __divided(slice: Swift.UnsafeMutablePointer<CoreFoundation.CGRect>, remainder: Swift.UnsafeMutablePointer<CoreFoundation.CGRect>, atDistance: CoreFoundation.CGFloat, from: CoreFoundation.CGRectEdge) {
        __CGRectDivide(self, slice, remainder, atDistance, from)
    }
  @_alwaysEmitIntoClient public static var null: CoreFoundation.CGRect {
    get { CGRectNull }
  }
  @_alwaysEmitIntoClient public static var infinite: CoreFoundation.CGRect {
    get { CGRectInfinite }
  }
  @_alwaysEmitIntoClient public var minX: CoreFoundation.CGFloat {
    get { CGRectGetMinX(self) }
  }
  @_alwaysEmitIntoClient public var midX: CoreFoundation.CGFloat {
    get { CGRectGetMidX(self) }
  }
  @_alwaysEmitIntoClient public var maxX: CoreFoundation.CGFloat {
    get { CGRectGetMaxX(self) }
  }
  @_alwaysEmitIntoClient public var minY: CoreFoundation.CGFloat {
    get { CGRectGetMinY(self) }
  }
  @_alwaysEmitIntoClient public var midY: CoreFoundation.CGFloat {
    get { CGRectGetMidY(self) }
  }
  @_alwaysEmitIntoClient public var maxY: CoreFoundation.CGFloat {
    get { CGRectGetMaxY(self) }
  }
  @_alwaysEmitIntoClient public var width: CoreFoundation.CGFloat {
    get { CGRectGetWidth(self) }
  }
  @_alwaysEmitIntoClient public var height: CoreFoundation.CGFloat {
    get { CGRectGetHeight(self) }
  }
  @_alwaysEmitIntoClient public func equalTo(_ rect2: CoreFoundation.CGRect) -> Swift.Bool {
        CGRectEqualToRect(self, rect2)
    }
  @_alwaysEmitIntoClient public var standardized: CoreFoundation.CGRect {
    get { CGRectStandardize(self) }
  }
  @_alwaysEmitIntoClient public var isEmpty: Swift.Bool {
    get { CGRectIsEmpty(self) }
  }
  @_alwaysEmitIntoClient public var isNull: Swift.Bool {
    get { CGRectIsNull(self) }
  }
  @_alwaysEmitIntoClient public var isInfinite: Swift.Bool {
    get { CGRectIsInfinite(self) }
  }
  @_alwaysEmitIntoClient public func insetBy(dx: CoreFoundation.CGFloat, dy: CoreFoundation.CGFloat) -> CoreFoundation.CGRect {
        CGRectInset(self, dx, dy)
    }
  @_alwaysEmitIntoClient public var integral: CoreFoundation.CGRect {
    get { CGRectIntegral(self) }
  }
  @_alwaysEmitIntoClient public func union(_ r2: CoreFoundation.CGRect) -> CoreFoundation.CGRect {
        CGRectUnion(self, r2)
    }
  @_alwaysEmitIntoClient public func intersection(_ r2: CoreFoundation.CGRect) -> CoreFoundation.CGRect {
        CGRectIntersection(self, r2)
    }
  @_alwaysEmitIntoClient public func offsetBy(dx: CoreFoundation.CGFloat, dy: CoreFoundation.CGFloat) -> CoreFoundation.CGRect {
        CGRectOffset(self, dx, dy)
    }
  @_alwaysEmitIntoClient public func contains(_ point: CoreFoundation.CGPoint) -> Swift.Bool {
        CGRectContainsPoint(self, point)
    }
  @_alwaysEmitIntoClient public func contains(_ rect2: CoreFoundation.CGRect) -> Swift.Bool {
        CGRectContainsRect(self, rect2)
    }
  @_alwaysEmitIntoClient public func intersects(_ rect2: CoreFoundation.CGRect) -> Swift.Bool {
        CGRectIntersectsRect(self, rect2)
    }
  @_alwaysEmitIntoClient public var dictionaryRepresentation: CoreFoundation.CFDictionary {
    get {
        CGRectCreateDictionaryRepresentation(self)
    }
  }
}
@_alwaysEmitIntoClient public func __CGAffineTransformMake(_ a: CoreFoundation.CGFloat, _ b: CoreFoundation.CGFloat, _ c: CoreFoundation.CGFloat, _ d: CoreFoundation.CGFloat, _ tx: CoreFoundation.CGFloat, _ ty: CoreFoundation.CGFloat) -> CoreFoundation.CGAffineTransform {
    CGAffineTransformMake(a, b, c, d, tx, ty)
}
@_alwaysEmitIntoClient public func __CGPointApplyAffineTransform(_ point: CoreFoundation.CGPoint, _ t: CoreFoundation.CGAffineTransform) -> CoreFoundation.CGPoint {
    CGPointApplyAffineTransform(point, t)
}
@_alwaysEmitIntoClient public func __CGSizeApplyAffineTransform(_ size: CoreFoundation.CGSize, _ t: CoreFoundation.CGAffineTransform) -> CoreFoundation.CGSize {
    CGSizeApplyAffineTransform(size, t)
}
extension CoreFoundation.CGFloat {
  @available(*, unavailable, renamed: "leastNormalMagnitude")
  public static var min: CoreFoundation.CGFloat {
    get
  }
  @available(*, unavailable, renamed: "greatestFiniteMagnitude")
  public static var max: CoreFoundation.CGFloat {
    get
  }
}
@available(*, unavailable, renamed: "CGFloat.leastNormalMagnitude")
public var CGFLOAT_MIN: CoreFoundation.CGFloat {
  get
}
@available(*, unavailable, renamed: "CGFloat.greatestFiniteMagnitude")
public var CGFLOAT_MAX: CoreFoundation.CGFloat {
  get
}
@available(*, unavailable, message: "Use truncatingRemainder instead")
@_transparent public func % (lhs: CoreFoundation.CGFloat, rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    fatalError("% is not available.")
}
@available(*, unavailable, message: "Use formTruncatingRemainder instead")
@_transparent public func %= (lhs: inout CoreFoundation.CGFloat, rhs: CoreFoundation.CGFloat) {
    fatalError("%= is not available.")
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func acos(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(acos(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func asin(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(asin(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func atan(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(atan(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func cos(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(cos(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func sin(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(sin(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func tan(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(tan(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func acosh(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(acosh(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func asinh(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(asinh(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func atanh(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(atanh(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func cosh(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(cosh(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func sinh(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(sinh(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func tanh(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(tanh(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func exp(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(exp(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func exp2(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(exp2(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func expm1(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(expm1(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func log(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(log(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func log10(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(log10(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func log1p(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(log1p(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func log2(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(log2(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func logb(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(logb(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func cbrt(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(cbrt(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func erf(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(erf(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func erfc(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(erfc(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func tgamma(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(tgamma(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func nearbyint(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(nearbyint(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func rint(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(rint(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func atan2(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(atan2(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func hypot(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(hypot(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func pow(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(pow(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func copysign(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(copysign(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func nextafter(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(nextafter(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func fdim(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(fdim(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func fmax(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(fmax(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func fmin(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(fmin(lhs.native, rhs.native))
}
@available(*, unavailable, message: "use the floatingPointClass property.")
@_transparent public func fpclassify(_ x: CoreFoundation.CGFloat) -> Swift.Int {
    fatalError("unavailable")
}
@available(*, unavailable, message: "use the isNormal property.")
public func isnormal(_ value: CoreFoundation.CGFloat) -> Swift.Bool
@available(*, unavailable, message: "use the isFinite property.")
public func isfinite(_ value: CoreFoundation.CGFloat) -> Swift.Bool
@available(*, unavailable, message: "use the isInfinite property.")
public func isinf(_ value: CoreFoundation.CGFloat) -> Swift.Bool
@available(*, unavailable, message: "use the isNaN property.")
public func isnan(_ value: CoreFoundation.CGFloat) -> Swift.Bool
@available(*, unavailable, message: "use the sign property.")
public func signbit(_ value: CoreFoundation.CGFloat) -> Swift.Int
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@available(swift, deprecated: 4.2, renamed: "scalbn")
@_transparent public func ldexp(_ x: CoreFoundation.CGFloat, _ n: Swift.Int) -> CoreFoundation.CGFloat {
    return CGFloat(ldexp(x.native, n))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@available(swift, deprecated: 4.2, message: "use the exponent property.")
@_transparent public func ilogb(_ x: CoreFoundation.CGFloat) -> Swift.Int {
    return Int(x.exponent)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func lgamma(_ x: CoreFoundation.CGFloat) -> (CoreFoundation.CGFloat, Swift.Int) {
    let (value, sign) = lgamma(x.native)
    return (CGFloat(value), sign)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func remquo(_ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat) -> (CoreFoundation.CGFloat, Swift.Int) {
    let (rem, quo) = remquo(x.native, y.native)
    return (CGFloat(rem), quo)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@available(swift, deprecated: 4.2, message: "use CGFloat(nan: CGFloat.RawSignificand) instead.")
@_transparent public func nan(_ tag: Swift.String) -> CoreFoundation.CGFloat {
    return CGFloat(nan(tag) as CGFloat.NativeType)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func j0(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(j0(Double(x.native)))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func j1(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(j1(Double(x.native)))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func jn(_ n: Swift.Int, _ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(jn(n, Double(x.native)))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func y0(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(y0(Double(x.native)))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func y1(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(y1(Double(x.native)))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func yn(_ n: Swift.Int, _ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(yn(n, Double(x.native)))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect {
  public static var zero: CoreFoundation.CGRect {
    @_transparent get { return CGRect(x: 0, y: 0, width: 0, height: 0) }
  }
  @_transparent public init(x: CoreFoundation.CGFloat, y: CoreFoundation.CGFloat, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat) {
        self.init(origin: CGPoint(x: x, y: y), size: CGSize(width: width, height: height))
    }
  @_transparent public init(x: Swift.Double, y: Swift.Double, width: Swift.Double, height: Swift.Double) {
        self.init(origin: CGPoint(x: x, y: y), size: CGSize(width: width, height: height))
    }
  @_transparent public init(x: Swift.Int, y: Swift.Int, width: Swift.Int, height: Swift.Int) {
        self.init(origin: CGPoint(x: x, y: y), size: CGSize(width: width, height: height))
    }
  public init?(dictionaryRepresentation dict: CoreFoundation.CFDictionary)
  @_transparent public func divided(atDistance: CoreFoundation.CGFloat, from fromEdge: CoreFoundation.CGRectEdge) -> (slice: CoreFoundation.CGRect, remainder: CoreFoundation.CGRect) {
        var slice = CGRect.zero
        var remainder = CGRect.zero
        self.__divided(
            slice: &slice, remainder: &remainder, atDistance: atDistance,
            from: fromEdge)
        return (slice, remainder)
    }
  @available(*, unavailable, renamed: "minX")
  public var x: CoreFoundation.CGFloat {
    get
  }
  @available(*, unavailable, renamed: "minY")
  public var y: CoreFoundation.CGFloat {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGRect.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect : Swift.Equatable {
  @_transparent public static func == (lhs: CoreFoundation.CGRect, rhs: CoreFoundation.CGRect) -> Swift.Bool {
        return lhs.equalTo(rhs)
    }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect {
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
        let standard = standardized
        hasher.combine(standard.origin.x)
        hasher.combine(standard.origin.y)
        hasher.combine(standard.size.width)
        hasher.combine(standard.size.height)
    }
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
        var hasher = Hasher()
        hash(into: &hasher)
        return hasher.finalize()
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreFoundation.CGRect : Swift.Hashable {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGVector {
  public static var zero: CoreFoundation.CGVector {
    @_transparent get { return CGVector(dx: 0, dy: 0) }
  }
  @_transparent public init(dx: Swift.Int, dy: Swift.Int) {
        self.init(dx: CGFloat(dx), dy: CGFloat(dy))
    }
  @_transparent public init(dx: Swift.Double, dy: Swift.Double) {
        self.init(dx: CGFloat(dx), dy: CGFloat(dy))
    }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGVector : Swift.Equatable {
  @_transparent public static func == (lhs: CoreFoundation.CGVector, rhs: CoreFoundation.CGVector) -> Swift.Bool {
        return lhs.dx == rhs.dx && lhs.dy == rhs.dy
    }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGVector {
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(dx)
        hasher.combine(dy)
    }
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
        var hasher = Hasher()
        hash(into: &hasher)
        return hasher.finalize()
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreFoundation.CGVector : Swift.Hashable {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGVector : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGVector : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize {
  public static var zero: CoreFoundation.CGSize {
    @_transparent get { return CGSize(width: 0, height: 0) }
  }
  @_transparent public init(width: Swift.Int, height: Swift.Int) {
        self.init(width: CGFloat(width), height: CGFloat(height))
    }
  @_transparent public init(width: Swift.Double, height: Swift.Double) {
        self.init(width: CGFloat(width), height: CGFloat(height))
    }
  public init?(dictionaryRepresentation dict: CoreFoundation.CFDictionary)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGSize.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize : Swift.Equatable {
  @_transparent public static func == (lhs: CoreFoundation.CGSize, rhs: CoreFoundation.CGSize) -> Swift.Bool {
        return lhs.width == rhs.width && lhs.height == rhs.height
    }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize {
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(width)
        hasher.combine(height)
    }
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
        var hasher = Hasher()
        hash(into: &hasher)
        return hasher.finalize()
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreFoundation.CGSize : Swift.Hashable {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGAffineTransform {
  public static var identity: CoreFoundation.CGAffineTransform {
    @_transparent get { return CGAffineTransform(a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0) }
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGAffineTransform : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGAffineTransform : Swift.Equatable {
  public static func == (lhs: CoreFoundation.CGAffineTransform, rhs: CoreFoundation.CGAffineTransform) -> Swift.Bool
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGAffineTransform {
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(a)
        hasher.combine(b)
        hasher.combine(c)
        hasher.combine(d)
        hasher.combine(tx)
        hasher.combine(ty)
    }
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
        var hasher = Hasher()
        hash(into: &hasher)
        return hasher.finalize()
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreFoundation.CGAffineTransform : Swift.Hashable {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
public enum CGPathFillRule : Swift.Int {
  case winding
  case evenOdd
  public init?(rawValue: Swift.Int)
  @available(iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, macOS 10.9, *)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGPath {
  public func copy(dashingWithPhase phase: CoreFoundation.CGFloat, lengths: [CoreFoundation.CGFloat], transform: CoreFoundation.CGAffineTransform = .identity) -> CoreGraphics.CGPath
  public func copy(strokingWithWidth lineWidth: CoreFoundation.CGFloat, lineCap: CoreGraphics.CGLineCap, lineJoin: CoreGraphics.CGLineJoin, miterLimit: CoreFoundation.CGFloat, transform: CoreFoundation.CGAffineTransform = .identity) -> CoreGraphics.CGPath
  public func contains(_ point: CoreFoundation.CGPoint, using rule: CoreGraphics.CGPathFillRule = .winding, transform: CoreFoundation.CGAffineTransform = .identity) -> Swift.Bool
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGMutablePath {
  public func addRoundedRect(in rect: CoreFoundation.CGRect, cornerWidth: CoreFoundation.CGFloat, cornerHeight: CoreFoundation.CGFloat, transform: CoreFoundation.CGAffineTransform = .identity)
  public func move(to point: CoreFoundation.CGPoint, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addLine(to point: CoreFoundation.CGPoint, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addQuadCurve(to end: CoreFoundation.CGPoint, control: CoreFoundation.CGPoint, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addCurve(to end: CoreFoundation.CGPoint, control1: CoreFoundation.CGPoint, control2: CoreFoundation.CGPoint, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addRect(_ rect: CoreFoundation.CGRect, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addRects(_ rects: [CoreFoundation.CGRect], transform: CoreFoundation.CGAffineTransform = .identity)
  public func addLines(between points: [CoreFoundation.CGPoint], transform: CoreFoundation.CGAffineTransform = .identity)
  public func addEllipse(in rect: CoreFoundation.CGRect, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addRelativeArc(center: CoreFoundation.CGPoint, radius: CoreFoundation.CGFloat, startAngle: CoreFoundation.CGFloat, delta: CoreFoundation.CGFloat, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addArc(center: CoreFoundation.CGPoint, radius: CoreFoundation.CGFloat, startAngle: CoreFoundation.CGFloat, endAngle: CoreFoundation.CGFloat, clockwise: Swift.Bool, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addArc(tangent1End: CoreFoundation.CGPoint, tangent2End: CoreFoundation.CGPoint, radius: CoreFoundation.CGFloat, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addPath(_ path: CoreGraphics.CGPath, transform: CoreFoundation.CGAffineTransform = .identity)
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension CoreGraphics.CGPath {
  public func union(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func intersection(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func subtracting(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func symmetricDifference(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func lineSubtracting(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func lineIntersection(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func normalized(using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func flattened(threshold: CoreFoundation.CGFloat) -> CoreGraphics.CGPath
  public func intersects(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> Swift.Bool
  public func componentsSeparated(using rule: CoreGraphics.CGPathFillRule = .winding) -> [CoreGraphics.CGPath]
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGContext {
  public func setLineDash(phase: CoreFoundation.CGFloat, lengths: [CoreFoundation.CGFloat])
  public func move(to point: CoreFoundation.CGPoint)
  public func addLine(to point: CoreFoundation.CGPoint)
  public func addCurve(to end: CoreFoundation.CGPoint, control1: CoreFoundation.CGPoint, control2: CoreFoundation.CGPoint)
  public func addQuadCurve(to end: CoreFoundation.CGPoint, control: CoreFoundation.CGPoint)
  public func addRects(_ rects: [CoreFoundation.CGRect])
  public func addLines(between points: [CoreFoundation.CGPoint])
  public func addArc(center: CoreFoundation.CGPoint, radius: CoreFoundation.CGFloat, startAngle: CoreFoundation.CGFloat, endAngle: CoreFoundation.CGFloat, clockwise: Swift.Bool)
  public func addArc(tangent1End: CoreFoundation.CGPoint, tangent2End: CoreFoundation.CGPoint, radius: CoreFoundation.CGFloat)
  public func fillPath(using rule: CoreGraphics.CGPathFillRule = .winding)
  public func clip(using rule: CoreGraphics.CGPathFillRule = .winding)
  public func fill(_ rects: [CoreFoundation.CGRect])
  public func strokeLineSegments(between points: [CoreFoundation.CGPoint])
  public func clip(to rects: [CoreFoundation.CGRect])
  public func draw(_ image: CoreGraphics.CGImage, in rect: CoreFoundation.CGRect, byTiling: Swift.Bool = false)
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public func draw(_ image: CoreGraphics.CGImage, in rect: CoreFoundation.CGRect, by toneMapping: CoreGraphics.CGToneMapping = .default, options: CoreFoundation.CFDictionary?) -> Swift.Bool
  public var textPosition: CoreFoundation.CGPoint {
    get
    set
  }
  public func showGlyphs(_ glyphs: [CoreGraphics.CGGlyph], at positions: [CoreFoundation.CGPoint])
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGContext {
  public func draw(_ layer: CoreGraphics.CGLayer, in rect: CoreFoundation.CGRect)
  public func draw(_ layer: CoreGraphics.CGLayer, at point: CoreFoundation.CGPoint)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGPathFillRule : Swift.Equatable {}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGPathFillRule : Swift.Hashable {}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGPathFillRule : Swift.RawRepresentable {}
