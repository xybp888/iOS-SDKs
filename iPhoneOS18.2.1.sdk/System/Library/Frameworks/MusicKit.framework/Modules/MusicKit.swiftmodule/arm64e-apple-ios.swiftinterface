// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.6 clang-1600.0.30.1)
// swift-module-flags: -target arm64e-apple-ios18.2 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Osize -library-level api -enable-experimental-concurrency -enable-bare-slash-regex -user-module-version 4024.300.23 -module-name MusicKit
import Combine
import CoreGraphics
import DeveloperToolsSupport
import Foundation
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer {
  public class Queue : Combine.ObservableObject, Swift.ExpressibleByArrayLiteral {
    required public init<S, PlayableMusicItemType>(for playableItems: S, startingAt startPlayableItem: S.Element? = nil) where S : Swift.Sequence, PlayableMusicItemType : MusicKit.PlayableMusicItem, PlayableMusicItemType == S.Element
    required public init<S>(_ entries: S, startingAt startEntry: S.Element? = nil) where S : Swift.Sequence, S.Element == MusicKit.MusicPlayer.Queue.Entry
    @available(iOS 16.4, tvOS 16.4, visionOS 1.0, macOS 14.0, *)
    required public init(album: MusicKit.Album, startingAt startTrack: MusicKit.Track)
    @available(iOS 16.4, tvOS 16.4, visionOS 1.0, macOS 14.0, *)
    required public init(playlist: MusicKit.Playlist, startingAt startPlaylistEntry: MusicKit.Playlist.Entry)
    public var currentEntry: MusicKit.MusicPlayer.Queue.Entry? {
      get
      set
    }
    public func insert<S, PlayableMusicItemType>(_ playableItems: S, position: MusicKit.MusicPlayer.Queue.EntryInsertionPosition) async throws where S : Swift.Sequence, PlayableMusicItemType : MusicKit.PlayableMusicItem, PlayableMusicItemType == S.Element
    public func insert<S>(_ entries: S, position: MusicKit.MusicPlayer.Queue.EntryInsertionPosition) async throws where S : Swift.Sequence, S.Element == MusicKit.MusicPlayer.Queue.Entry
    public func insert<PlayableMusicItemType>(_ playableItem: PlayableMusicItemType, position: MusicKit.MusicPlayer.Queue.EntryInsertionPosition) async throws where PlayableMusicItemType : MusicKit.PlayableMusicItem
    public func insert(_ entry: MusicKit.MusicPlayer.Queue.Entry, position: MusicKit.MusicPlayer.Queue.EntryInsertionPosition) async throws
    public var objectWillChange: Combine.AnyPublisher<Swift.Void, Swift.Never> {
      get
    }
    convenience required public init(arrayLiteral elements: any MusicKit.PlayableMusicItem...)
    @available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
    @available(watchOS, unavailable)
    public typealias ArrayLiteralElement = any MusicKit.PlayableMusicItem
    @available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
    @available(watchOS, unavailable)
    public typealias ObjectWillChangePublisher = Combine.AnyPublisher<Swift.Void, Swift.Never>
    @objc deinit
  }
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue : Swift.Equatable {
  public static func == (left: MusicKit.MusicPlayer.Queue, right: MusicKit.MusicPlayer.Queue) -> Swift.Bool
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue {
  public enum EntryInsertionPosition : Swift.Sendable {
    case afterCurrentEntry
    case tail
    public static func == (a: MusicKit.MusicPlayer.Queue.EntryInsertionPosition, b: MusicKit.MusicPlayer.Queue.EntryInsertionPosition) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol MusicLibrarySearchable : MusicKit.MusicItem {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public struct MusicLibrarySectionedRequest<SectionType, MusicItemType> where SectionType : MusicKit.MusicLibrarySectionRequestable, MusicItemType : MusicKit.MusicLibraryRequestable {
  public init()
  public var limit: Swift.Int
  public var offset: Swift.Int
  public var includeOnlyDownloadedContent: Swift.Bool
  public mutating func filterItems<RelatedMusicItemType>(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, MusicKit.MusicItemCollection<RelatedMusicItemType>?>, contains relatedItem: RelatedMusicItemType) where RelatedMusicItemType : MusicKit.MusicItem
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  public mutating func filterItems(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, Swift.String>, contains text: Swift.String)
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  public mutating func filterItems(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, Swift.String?>, contains text: Swift.String)
  public mutating func filterItems<Value>(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, Value>, equalTo value: Value) where Value : MusicKit.MusicLibraryRequestFilterValueEquatable
  public mutating func filterItems<Value>(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, Value?>, equalTo value: Value?) where Value : MusicKit.MusicLibraryRequestFilterValueEquatable
  public mutating func filterItems<Value>(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, Value>, memberOf values: [Value]) where Value : MusicKit.MusicLibraryRequestFilterValueMembershipComparable
  public mutating func filterItems<Value>(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, Value?>, memberOf values: [Value?]) where Value : MusicKit.MusicLibraryRequestFilterValueMembershipComparable
  public mutating func filterItems(text: Swift.String)
  public mutating func sortItems<Value>(by keyPath: Swift.KeyPath<MusicItemType.LibrarySortProperties, Value>, ascending: Swift.Bool)
  public mutating func filterSections(matching keyPath: Swift.KeyPath<SectionType.LibraryFilter, Swift.String>, contains text: Swift.String) where SectionType : MusicKit.MusicLibraryRequestable
  public mutating func filterSections(matching keyPath: Swift.KeyPath<SectionType.LibraryFilter, Swift.String?>, contains text: Swift.String) where SectionType : MusicKit.MusicLibraryRequestable
  public mutating func filterSections<Value>(matching keyPath: Swift.KeyPath<SectionType.LibraryFilter, Value>, equalTo value: Value) where SectionType : MusicKit.MusicLibraryRequestable, Value : MusicKit.MusicLibraryRequestFilterValueEquatable
  public mutating func filterSections<Value>(matching keyPath: Swift.KeyPath<SectionType.LibraryFilter, Value?>, equalTo value: Value?) where SectionType : MusicKit.MusicLibraryRequestable, Value : MusicKit.MusicLibraryRequestFilterValueEquatable
  public mutating func filterSections<Value>(matching keyPath: Swift.KeyPath<SectionType.LibraryFilter, Value>, memberOf values: [Value]) where SectionType : MusicKit.MusicLibraryRequestable, Value : MusicKit.MusicLibraryRequestFilterValueMembershipComparable
  public mutating func filterSections<Value>(matching keyPath: Swift.KeyPath<SectionType.LibraryFilter, Value?>, memberOf values: [Value?]) where SectionType : MusicKit.MusicLibraryRequestable, Value : MusicKit.MusicLibraryRequestFilterValueMembershipComparable
  public mutating func filterSections(text: Swift.String) where SectionType : MusicKit.MusicLibraryRequestable
  public mutating func sortSections<Value>(by keyPath: Swift.KeyPath<SectionType.LibrarySortProperties, Value>, ascending: Swift.Bool) where SectionType : MusicKit.MusicLibraryRequestable
  public func response() async throws -> MusicKit.MusicLibrarySectionedResponse<SectionType, MusicItemType>
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct MusicCatalogResourceRequest<MusicItemType> : Swift.Sendable where MusicItemType : MusicKit.MusicItem, MusicItemType : Swift.Decodable {
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public init() where MusicItemType : MusicKit.MusicCatalogTopLevelResourceRequesting
  public init<Value>(matching keyPath: Swift.KeyPath<MusicItemType.FilterType, Value>, equalTo value: Value) where MusicItemType : MusicKit.FilterableMusicItem
  public init<Value>(matching keyPath: Swift.KeyPath<MusicItemType.FilterType, Value>, memberOf values: [Value]) where MusicItemType : MusicKit.FilterableMusicItem
  public var limit: Swift.Int?
  public var properties: [MusicKit.PartialMusicAsyncProperty<MusicItemType>]
  public func response() async throws -> MusicKit.MusicCatalogResourceResponse<MusicItemType>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public protocol MusicCatalogTopLevelResourceRequesting : MusicKit.MusicItem {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicItem where Self : MusicKit.MusicPropertyContainer, Self : Swift.Decodable {
  public func with(_ properties: [MusicKit.PartialMusicAsyncProperty<Self>]) async throws -> Self
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public func with(_ properties: [MusicKit.PartialMusicAsyncProperty<Self>], preferredSource: MusicKit.MusicPropertySource) async throws -> Self
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public func with(_ properties: MusicKit.PartialMusicAsyncProperty<Self>..., preferredSource: MusicKit.MusicPropertySource) async throws -> Self
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
public struct Curator : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var kind: MusicKit.Curator.Kind {
    get
  }
  public var name: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var playlists: MusicKit.MusicItemCollection<MusicKit.Playlist>? {
    get
  }
  public static func == (a: MusicKit.Curator, b: MusicKit.Curator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 15.4, tvOS 15.4, watchOS 9.0, visionOS 1.0, macOS 12.3, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Curator : MusicKit.MusicPropertyContainer {
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Curator, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Curator, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Curator, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.Curator {
  public static let playlists: MusicKit.MusicRelationshipProperty<MusicKit.Curator, MusicKit.Playlist>
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Curator : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
public protocol CuratorFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Curator : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.CuratorFilter
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Curator : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Curator : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Curator {
  public enum Kind : Swift.Codable, Swift.Equatable, Swift.Hashable, Swift.Sendable {
    case editorial
    case external
    public static func == (a: MusicKit.Curator.Kind, b: MusicKit.Curator.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public struct MusicLibrarySearchResponse : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public let albums: MusicKit.MusicItemCollection<MusicKit.Album>
  public let artists: MusicKit.MusicItemCollection<MusicKit.Artist>
  public let musicVideos: MusicKit.MusicItemCollection<MusicKit.MusicVideo>
  public let playlists: MusicKit.MusicItemCollection<MusicKit.Playlist>
  public let songs: MusicKit.MusicItemCollection<MusicKit.Song>
  public let topResults: MusicKit.MusicItemCollection<MusicKit.MusicLibrarySearchResponse.TopResult>
  public static func == (a: MusicKit.MusicLibrarySearchResponse, b: MusicKit.MusicLibrarySearchResponse) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrarySearchResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogSearchSuggestionsResponse {
  public struct Suggestion : Swift.Codable, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
    public var id: Swift.String {
      get
    }
    public let displayTerm: Swift.String
    public let searchTerm: Swift.String
    public static func == (a: MusicKit.MusicCatalogSearchSuggestionsResponse.Suggestion, b: MusicKit.MusicCatalogSearchSuggestionsResponse.Suggestion) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 13.0, *)
    public typealias ID = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogSearchSuggestionsResponse.Suggestion : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public protocol FilterableMusicItem : MusicKit.MusicItem {
  associatedtype FilterType
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct MusicDataRequest : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public init(urlRequest: Foundation.URLRequest)
  public let urlRequest: Foundation.URLRequest
  public func response() async throws -> MusicKit.MusicDataResponse
  public static var currentCountryCode: Swift.String {
    get async throws
  }
  public static func == (a: MusicKit.MusicDataRequest, b: MusicKit.MusicDataRequest) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicDataRequest : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol MusicLibraryRequestable : MusicKit.MusicItem {
  associatedtype LibraryFilter
  associatedtype LibrarySortProperties
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol MusicLibrarySectionRequestable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol MusicLibraryRequestFilterValueEquatable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension Swift.Bool : MusicKit.MusicLibraryRequestFilterValueEquatable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicItemID : MusicKit.MusicLibraryRequestFilterValueEquatable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension Swift.String : MusicKit.MusicLibraryRequestFilterValueEquatable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol MusicLibraryRequestFilterValueMembershipComparable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicItemID : MusicKit.MusicLibraryRequestFilterValueMembershipComparable {
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer {
  public enum PlaybackStatus : Swift.Equatable, Swift.Hashable, Swift.Sendable {
    case stopped
    case playing
    case paused
    case interrupted
    case seekingForward
    case seekingBackward
    public static func == (a: MusicKit.MusicPlayer.PlaybackStatus, b: MusicKit.MusicPlayer.PlaybackStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer {
  public enum RepeatMode : Swift.Sendable {
    case none
    case one
    case all
    public static func == (a: MusicKit.MusicPlayer.RepeatMode, b: MusicKit.MusicPlayer.RepeatMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer {
  public enum ShuffleMode : Swift.Sendable {
    case off
    case songs
    public static func == (a: MusicKit.MusicPlayer.ShuffleMode, b: MusicKit.MusicPlayer.ShuffleMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer {
  @_hasMissingDesignatedInitializers public class State : Combine.ObservableObject {
    @objc deinit
    public var playbackStatus: MusicKit.MusicPlayer.PlaybackStatus {
      get
    }
    public var playbackRate: Swift.Float {
      get
      set
    }
    public var repeatMode: MusicKit.MusicPlayer.RepeatMode? {
      get
      set
    }
    public var shuffleMode: MusicKit.MusicPlayer.ShuffleMode? {
      get
      set
    }
    @available(iOS 16.0, tvOS 16.0, visionOS 1.0, *)
    public var audioVariant: MusicKit.AudioVariant? {
      get
    }
    public var objectWillChange: Combine.AnyPublisher<Swift.Void, Swift.Never> {
      get
    }
    @available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
    @available(watchOS, unavailable)
    public typealias ObjectWillChangePublisher = Combine.AnyPublisher<Swift.Void, Swift.Never>
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct Station : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var contentRating: MusicKit.ContentRating? {
    get
  }
  public var duration: Foundation.TimeInterval? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var episodeNumber: Swift.Int? {
    get
  }
  public var isLive: Swift.Bool {
    get
  }
  public var name: Swift.String {
    get
  }
  public var playParameters: MusicKit.PlayParameters? {
    get
  }
  public var stationProviderName: Swift.String? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public static func == (a: MusicKit.Station, b: MusicKit.Station) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Station : MusicKit.MusicPropertyContainer {
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Station, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Station, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Station, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.Station : MusicKit.PlayableMusicItem {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Station : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public protocol StationFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Station : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.StationFilter
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Station : MusicKit.MusicPersonalRecommendationItem {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Station : MusicKit.MusicRecentlyPlayedRequestable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Station : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Station : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct RecordLabel : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var shortDescription: Swift.String? {
    get
  }
  public var standardDescription: Swift.String? {
    get
  }
  public var name: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var latestReleases: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var topReleases: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public static func == (a: MusicKit.RecordLabel, b: MusicKit.RecordLabel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.RecordLabel : MusicKit.MusicPropertyContainer {
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.RecordLabel, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.RecordLabel, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.RecordLabel, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.RecordLabel {
  @_alwaysEmitIntoClient public static var latestReleases: MusicKit.MusicRelationshipProperty<MusicKit.RecordLabel, MusicKit.Album> {
    get {
        MusicRelationshipProperty("latest-releases", kind: .association)
    }
  }
  @_alwaysEmitIntoClient public static var topReleases: MusicKit.MusicRelationshipProperty<MusicKit.RecordLabel, MusicKit.Album> {
    get {
        MusicRelationshipProperty("top-releases", kind: .association)
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.RecordLabel : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public protocol RecordLabelFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.RecordLabel : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.RecordLabelFilter
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.RecordLabel : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.RecordLabel : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public enum ContentRating : Swift.Codable, Swift.Equatable, Swift.Hashable, Swift.Sendable {
  case clean
  case explicit
  public static func == (a: MusicKit.ContentRating, b: MusicKit.ContentRating) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
public protocol MusicLibraryAddable : MusicKit.MusicItem {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
public protocol MusicPlaylistAddable : MusicKit.MusicItem {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public enum MusicPropertySource : Swift.CaseIterable, Swift.Codable, Swift.Equatable, Swift.Hashable, Swift.Sendable {
  case catalog
  @available(macOS 14.0, macCatalyst 17.0, *)
  case library
  public static var allCases: [MusicKit.MusicPropertySource] {
    get
  }
  public static func == (a: MusicKit.MusicPropertySource, b: MusicKit.MusicPropertySource) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 13.0, *)
  public typealias AllCases = [MusicKit.MusicPropertySource]
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public struct MusicRecentlyPlayedResponse<MusicItemType> where MusicItemType : MusicKit.MusicRecentlyPlayedRequestable {
  public let items: MusicKit.MusicItemCollection<MusicItemType>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicRecentlyPlayedResponse : Swift.Equatable where MusicItemType : Swift.Equatable {
  public static func == (a: MusicKit.MusicRecentlyPlayedResponse<MusicItemType>, b: MusicKit.MusicRecentlyPlayedResponse<MusicItemType>) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicRecentlyPlayedResponse : Swift.Hashable where MusicItemType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicRecentlyPlayedResponse : Swift.Sendable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicRecentlyPlayedResponse : Swift.Decodable where MusicItemType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicRecentlyPlayedResponse : Swift.Encodable where MusicItemType : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicRecentlyPlayedResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public protocol MusicItem : Swift.Sendable {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public struct MusicCatalogSearchSuggestionsRequest {
  public init(term: Swift.String, includingTopResultsOfTypes types: [any MusicKit.MusicCatalogSearchable.Type] = [])
  public let term: Swift.String
  public var typesForTopResults: [any MusicKit.MusicCatalogSearchable.Type] {
    get
  }
  public var limit: Swift.Int?
  public func response() async throws -> MusicKit.MusicCatalogSearchSuggestionsResponse
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct MusicAuthorization {
  public static var currentStatus: MusicKit.MusicAuthorization.Status {
    get
  }
  public static func request() async -> MusicKit.MusicAuthorization.Status
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public struct MusicCatalogChart<MusicItemType> : Swift.Identifiable where MusicItemType : MusicKit.MusicCatalogChartRequestable {
  public let id: Swift.String
  public let kind: MusicKit.MusicCatalogChartKind
  public let title: Swift.String
  public let items: MusicKit.MusicItemCollection<MusicItemType>
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 13.0, *)
  public typealias ID = Swift.String
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogChart : Swift.Equatable where MusicItemType : Swift.Equatable {
  public static func == (a: MusicKit.MusicCatalogChart<MusicItemType>, b: MusicKit.MusicCatalogChart<MusicItemType>) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogChart : Swift.Hashable where MusicItemType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogChart : Swift.Sendable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogChart : Swift.Decodable where MusicItemType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogChart : Swift.Encodable where MusicItemType : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogChart : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public struct MusicCatalogChartsRequest : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public init(genre: MusicKit.Genre? = nil, kinds: [MusicKit.MusicCatalogChartKind] = [.mostPlayed], types: [any MusicKit.MusicCatalogChartRequestable.Type])
  public var genre: MusicKit.Genre? {
    get
  }
  public var kinds: [MusicKit.MusicCatalogChartKind] {
    get
  }
  public var types: [any MusicKit.MusicCatalogChartRequestable.Type] {
    get
  }
  public var limit: Swift.Int?
  public var offset: Swift.Int?
  public func response() async throws -> MusicKit.MusicCatalogChartsResponse
  public static func == (a: MusicKit.MusicCatalogChartsRequest, b: MusicKit.MusicCatalogChartsRequest) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public class AnyMusicProperty : Swift.Equatable, Swift.Hashable, @unchecked Swift.Sendable {
  public static func == (left: MusicKit.AnyMusicProperty, right: MusicKit.AnyMusicProperty) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public class PartialMusicProperty<Root> : MusicKit.AnyMusicProperty, @unchecked Swift.Sendable {
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public class PartialMusicAsyncProperty<Root> : MusicKit.PartialMusicProperty<Root>, @unchecked Swift.Sendable {
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public class MusicAttributeProperty<Root, Value> : MusicKit.PartialMusicProperty<Root>, Swift.CustomStringConvertible, @unchecked Swift.Sendable where Value : Swift.Decodable {
  @usableFromInline
  internal init(_ name: Swift.String)
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public class MusicExtendedAttributeProperty<Root, Value> : MusicKit.PartialMusicAsyncProperty<Root>, Swift.CustomStringConvertible, @unchecked Swift.Sendable where Value : Swift.Decodable {
  @usableFromInline
  internal init(_ name: Swift.String)
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  @usableFromInline
  internal init(_ name: Swift.String, supportedSources: [MusicKit.MusicPropertySource])
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public class MusicRelationshipProperty<Root, RelatedMusicItemType> : MusicKit.PartialMusicAsyncProperty<Root>, Swift.CustomStringConvertible, @unchecked Swift.Sendable where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
  @usableFromInline
  internal init(_ name: Swift.String, kind: MusicKit.MusicRelationshipPropertyKind = .model)
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  @usableFromInline
  internal init(_ name: Swift.String, kind: MusicKit.MusicRelationshipPropertyKind = .model, supportedSources: [MusicKit.MusicPropertySource])
  @usableFromInline
  final internal let kind: MusicKit.MusicRelationshipPropertyKind
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
@usableFromInline
internal enum MusicRelationshipPropertyKind : Swift.Sendable {
  case model
  case association
  @usableFromInline
  internal static func == (a: MusicKit.MusicRelationshipPropertyKind, b: MusicKit.MusicRelationshipPropertyKind) -> Swift.Bool
  @usableFromInline
  internal func hash(into hasher: inout Swift.Hasher)
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public protocol MusicPropertyContainer {
  func with(_ properties: [MusicKit.PartialMusicAsyncProperty<Self>]) async throws -> Self
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  func with(_ properties: [MusicKit.PartialMusicAsyncProperty<Self>], preferredSource: MusicKit.MusicPropertySource) async throws -> Self
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  func with(_ properties: MusicKit.PartialMusicAsyncProperty<Self>..., preferredSource: MusicKit.MusicPropertySource) async throws -> Self
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicPropertyContainer {
  @_alwaysEmitIntoClient public func with(_ properties: MusicKit.PartialMusicAsyncProperty<Self>...) async throws -> Self {
        let arrayOfProperties: [PartialMusicAsyncProperty<Self>] = properties
        return try await self.with(arrayOfProperties)
    }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public struct MusicRecentlyPlayedRequest<MusicItemType> where MusicItemType : MusicKit.MusicRecentlyPlayedRequestable, MusicItemType : Swift.Decodable {
  public init()
  public var limit: Swift.Int?
  public var offset: Swift.Int?
  public func response() async throws -> MusicKit.MusicRecentlyPlayedResponse<MusicItemType>
}
@_hasMissingDesignatedInitializers @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public class MusicLibrary {
  public static let shared: MusicKit.MusicLibrary
  @objc deinit
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  public func add<MusicItemType>(_ item: MusicItemType) async throws where MusicItemType : MusicKit.MusicLibraryAddable
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  @discardableResult
  public func add<MusicItemType>(_ item: MusicItemType, to playlist: MusicKit.Playlist) async throws -> MusicKit.Playlist where MusicItemType : MusicKit.MusicPlaylistAddable
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  @discardableResult
  public func createPlaylist(name: Swift.String, description: Swift.String? = nil, authorDisplayName: Swift.String? = nil) async throws -> MusicKit.Playlist
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  @discardableResult
  public func createPlaylist<S, MusicPlaylistAddableType>(name: Swift.String, description: Swift.String? = nil, authorDisplayName: Swift.String? = nil, items: S) async throws -> MusicKit.Playlist where S : Swift.Sequence, MusicPlaylistAddableType : MusicKit.MusicPlaylistAddable, MusicPlaylistAddableType == S.Element
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  @discardableResult
  public func edit(_ playlist: MusicKit.Playlist, name: Swift.String? = nil, description: Swift.String? = nil, authorDisplayName: Swift.String? = nil) async throws -> MusicKit.Playlist
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  @discardableResult
  public func edit<S, MusicPlaylistAddableType>(_ playlist: MusicKit.Playlist, name: Swift.String? = nil, description: Swift.String? = nil, authorDisplayName: Swift.String? = nil, items: S) async throws -> MusicKit.Playlist where S : Swift.Sequence, MusicPlaylistAddableType : MusicKit.MusicPlaylistAddable, MusicPlaylistAddableType == S.Element
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
public protocol PlayableMusicItem : MusicKit.MusicItem {
  var playParameters: MusicKit.PlayParameters? { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicSubscription {
  public struct Updates : _Concurrency.AsyncSequence {
    public struct Iterator : _Concurrency.AsyncIteratorProtocol {
      public mutating func next() async -> MusicKit.MusicSubscription?
      @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
      public typealias Element = MusicKit.MusicSubscription
      #if compiler(>=5.3) && $AssociatedTypeImplements
      @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
      @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
      #else
      @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
      public typealias __AsyncIteratorProtocol_Failure = Swift.Never
      #endif
    }
    public typealias Element = MusicKit.MusicSubscription
    public func makeAsyncIterator() -> MusicKit.MusicSubscription.Updates.Iterator
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
    public typealias AsyncIterator = MusicKit.MusicSubscription.Updates.Iterator
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncSequence_Failure = Swift.Never
    #endif
  }
  public static var subscriptionUpdates: MusicKit.MusicSubscription.Updates {
    get
  }
}
@available(visionOS, unavailable, introduced: 1.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(*, unavailable)
extension MusicKit.MusicSubscription.Updates.Iterator : @unchecked Swift.Sendable {
}
@available(visionOS, unavailable, introduced: 1.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(*, unavailable)
extension MusicKit.MusicSubscription.Updates : @unchecked Swift.Sendable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public struct MusicPersonalRecommendationsRequest : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public init()
  public init<S>(refreshing recommendations: S) where S : Swift.Sequence, S.Element == MusicKit.MusicPersonalRecommendation
  public var limit: Swift.Int?
  public var offset: Swift.Int?
  public func response() async throws -> MusicKit.MusicPersonalRecommendationsResponse
  public static func == (a: MusicKit.MusicPersonalRecommendationsRequest, b: MusicKit.MusicPersonalRecommendationsRequest) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension MusicKit.MusicPlayer.Transition {
  public struct CrossfadeOptions : Swift.Equatable, Swift.Hashable, Swift.Sendable {
    public init(duration: Foundation.TimeInterval? = nil)
    public static func == (a: MusicKit.MusicPlayer.Transition.CrossfadeOptions, b: MusicKit.MusicPlayer.Transition.CrossfadeOptions) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension MusicKit.MusicPlayer.Transition.CrossfadeOptions : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public typealias MusicRecentlyPlayedContainerRequest = MusicKit.MusicRecentlyPlayedRequest<MusicKit.RecentlyPlayedMusicItem>
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public struct MusicLibrarySectionedResponse<SectionType, MusicItemType> where SectionType : MusicKit.MusicLibrarySectionRequestable, MusicItemType : MusicKit.MusicLibraryRequestable {
  public let sections: [MusicKit.MusicLibrarySection<SectionType, MusicItemType>]
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrarySectionedResponse : Swift.Equatable where SectionType : Swift.Equatable, MusicItemType : Swift.Equatable {
  public static func == (a: MusicKit.MusicLibrarySectionedResponse<SectionType, MusicItemType>, b: MusicKit.MusicLibrarySectionedResponse<SectionType, MusicItemType>) -> Swift.Bool
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrarySectionedResponse : Swift.Hashable where SectionType : Swift.Hashable, MusicItemType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrarySectionedResponse : Swift.Sendable where SectionType : Swift.Sendable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrarySectionedResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public protocol MusicRecentlyPlayedRequestable : MusicKit.MusicItem {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public struct MusicLibraryResponse<MusicItemType> where MusicItemType : MusicKit.MusicItem {
  public let items: MusicKit.MusicItemCollection<MusicItemType>
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibraryResponse : Swift.Equatable where MusicItemType : Swift.Equatable {
  public static func == (a: MusicKit.MusicLibraryResponse<MusicItemType>, b: MusicKit.MusicLibraryResponse<MusicItemType>) -> Swift.Bool
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibraryResponse : Swift.Hashable where MusicItemType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibraryResponse : Swift.Sendable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibraryResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public struct MusicCatalogSearchSuggestionsResponse : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public typealias TopResult = MusicKit.MusicCatalogSearchResponse.TopResult
  public let suggestions: [MusicKit.MusicCatalogSearchSuggestionsResponse.Suggestion]
  public let topResults: MusicKit.MusicItemCollection<MusicKit.MusicCatalogSearchSuggestionsResponse.TopResult>
  public static func == (a: MusicKit.MusicCatalogSearchSuggestionsResponse, b: MusicKit.MusicCatalogSearchSuggestionsResponse) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogSearchSuggestionsResponse : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogSearchSuggestionsResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct MusicTokenRequestOptions : Swift.OptionSet, Swift.Sendable {
  public init(rawValue: Swift.Int)
  public let rawValue: Swift.Int
  public static let ignoreCache: MusicKit.MusicTokenRequestOptions
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias ArrayLiteralElement = MusicKit.MusicTokenRequestOptions
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias Element = MusicKit.MusicTokenRequestOptions
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias RawValue = Swift.Int
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public protocol MusicDeveloperTokenProvider : Swift.Sendable {
  func developerToken(options: MusicKit.MusicTokenRequestOptions) async throws -> Swift.String
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public typealias MusicTokenProvider = MusicKit.MusicUserTokenProvider & MusicKit.MusicDeveloperTokenProvider
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicDataRequest {
  public static var tokenProvider: any MusicKit.MusicUserTokenProvider & MusicKit.MusicDeveloperTokenProvider
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
public struct RadioShow : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var hostName: Swift.String? {
    get
  }
  public var name: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var playlists: MusicKit.MusicItemCollection<MusicKit.Playlist>? {
    get
  }
  public static func == (a: MusicKit.RadioShow, b: MusicKit.RadioShow) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 15.4, tvOS 15.4, watchOS 9.0, visionOS 1.0, macOS 12.3, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.RadioShow : MusicKit.MusicPropertyContainer {
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.RadioShow, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.RadioShow, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.RadioShow, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.RadioShow {
  public static let playlists: MusicKit.MusicRelationshipProperty<MusicKit.RadioShow, MusicKit.Playlist>
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.RadioShow : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
public protocol RadioShowFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.RadioShow : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.RadioShowFilter
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.RadioShow : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.RadioShow : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public struct TitledSection : Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  public let title: Swift.String
  public var id: MusicKit.MusicItemID {
    get
  }
  public static func == (a: MusicKit.TitledSection, b: MusicKit.TitledSection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.TitledSection : MusicKit.MusicLibrarySectionRequestable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public enum MusicCatalogChartKind : Swift.CaseIterable, Swift.Equatable, Swift.Hashable, Swift.Sendable {
  case mostPlayed
  case cityTop
  case dailyGlobalTop
  public static func == (a: MusicKit.MusicCatalogChartKind, b: MusicKit.MusicCatalogChartKind) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 13.0, *)
  public typealias AllCases = [MusicKit.MusicCatalogChartKind]
  nonisolated public static var allCases: [MusicKit.MusicCatalogChartKind] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogChartKind : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogChartKind : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public protocol MusicCatalogSearchable : MusicKit.MusicItem {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogSearchResponse {
  public enum TopResult : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
    case album(MusicKit.Album)
    case artist(MusicKit.Artist)
    case curator(MusicKit.Curator)
    case musicVideo(MusicKit.MusicVideo)
    case playlist(MusicKit.Playlist)
    case radioShow(MusicKit.RadioShow)
    case recordLabel(MusicKit.RecordLabel)
    case song(MusicKit.Song)
    case station(MusicKit.Station)
    public var id: MusicKit.MusicItemID {
      get
    }
    public var artwork: MusicKit.Artwork? {
      get
    }
    public var title: Swift.String {
      get
    }
    public static func == (a: MusicKit.MusicCatalogSearchResponse.TopResult, b: MusicKit.MusicCatalogSearchResponse.TopResult) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 13.0, *)
    public typealias ID = MusicKit.MusicItemID
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogSearchResponse.TopResult : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogSearchResponse.TopResult : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public struct MusicPersonalRecommendationsResponse : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public let recommendations: MusicKit.MusicItemCollection<MusicKit.MusicPersonalRecommendation>
  public static func == (a: MusicKit.MusicPersonalRecommendationsResponse, b: MusicKit.MusicPersonalRecommendationsResponse) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicPersonalRecommendationsResponse : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicPersonalRecommendationsResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicSubscription {
  public enum Error : Swift.String, Foundation.LocalizedError, Swift.Sendable {
    case unknown
    case permissionDenied
    case privacyAcknowledgementRequired
    public var errorDescription: Swift.String? {
      get
    }
    public var failureReason: Swift.String? {
      get
    }
    public var recoverySuggestion: Swift.String? {
      get
    }
    public var helpAnchor: Swift.String? {
      get
    }
    public init?(rawValue: Swift.String)
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicSubscription.Error : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public struct MusicPersonalRecommendation : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  public let id: MusicKit.MusicItemID
  public let title: Swift.String?
  public let reason: Swift.String?
  public let nextRefreshDate: Foundation.Date?
  public var types: [any MusicKit.MusicPersonalRecommendationItem.Type] {
    get
  }
  public var albums: MusicKit.MusicItemCollection<MusicKit.Album> {
    get
  }
  public var playlists: MusicKit.MusicItemCollection<MusicKit.Playlist> {
    get
  }
  public var stations: MusicKit.MusicItemCollection<MusicKit.Station> {
    get
  }
  public var items: MusicKit.MusicItemCollection<MusicKit.MusicPersonalRecommendation.Item> {
    get
  }
  public static func == (a: MusicKit.MusicPersonalRecommendation, b: MusicKit.MusicPersonalRecommendation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 13.0, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicPersonalRecommendation : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicPersonalRecommendation : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
open class MusicUserTokenProvider {
  public init()
  public func userToken(for developerToken: Swift.String, options: MusicKit.MusicTokenRequestOptions) async throws -> Swift.String
  @objc deinit
}
@_inheritsConvenienceInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public class DefaultMusicTokenProvider : MusicKit.MusicTokenProvider, @unchecked Swift.Sendable {
  public func developerToken(options: MusicKit.MusicTokenRequestOptions) async throws -> Swift.String
  override public init()
  @objc deinit
}
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension MusicKit.MusicPlayer {
  public enum Transition : Swift.Equatable, Swift.Hashable, Swift.Sendable {
    case none
    case crossfade(options: MusicKit.MusicPlayer.Transition.CrossfadeOptions)
    public static let crossfade: MusicKit.MusicPlayer.Transition
    public static func crossfade(duration: Foundation.TimeInterval?) -> MusicKit.MusicPlayer.Transition
    public static func == (a: MusicKit.MusicPlayer.Transition, b: MusicKit.MusicPlayer.Transition) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 18.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension MusicKit.MusicPlayer.Transition : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicAuthorization {
  public enum Status : Swift.String, Swift.Sendable {
    case notDetermined
    case denied
    case restricted
    case authorized
    public init?(rawValue: Swift.String)
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicAuthorization.Status : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct MusicDataResponse : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public let data: Foundation.Data
  public let urlResponse: Foundation.HTTPURLResponse
  public static func == (a: MusicKit.MusicDataResponse, b: MusicKit.MusicDataResponse) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicDataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue {
  public struct Entry : Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.CustomStringConvertible {
    public init(_ playableMusicItem: any MusicKit.PlayableMusicItem, startTime: Foundation.TimeInterval? = nil, endTime: Foundation.TimeInterval? = nil)
    public let id: Swift.String
    public var title: Swift.String {
      get
    }
    public var subtitle: Swift.String? {
      get
    }
    public var artwork: MusicKit.Artwork? {
      get
    }
    public var item: MusicKit.MusicPlayer.Queue.Entry.Item? {
      get
    }
    public var transientItem: (any MusicKit.PlayableMusicItem)? {
      get
    }
    public var isTransient: Swift.Bool {
      get
    }
    public var startTime: Foundation.TimeInterval? {
      get
    }
    public var endTime: Foundation.TimeInterval? {
      get
    }
    public var description: Swift.String {
      get
    }
    public static func == (a: MusicKit.MusicPlayer.Queue.Entry, b: MusicKit.MusicPlayer.Queue.Entry) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
    @available(watchOS, unavailable)
    public typealias ID = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public enum Track : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  case song(MusicKit.Song)
  case musicVideo(MusicKit.MusicVideo)
  public var id: MusicKit.MusicItemID {
    get
  }
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var albumTitle: Swift.String? {
    get
  }
  public var artistName: Swift.String {
    get
  }
  public var artistURL: Foundation.URL? {
    get
  }
  public var contentRating: MusicKit.ContentRating? {
    get
  }
  @_alwaysEmitIntoClient public var discNumber: Swift.Int? {
    get {
        let discNumber: Int?
        switch self {
            case .song(let song):
                discNumber = song.discNumber
            case .musicVideo:
                discNumber = nil
            default:
                return nil
        }
        return discNumber
    }
  }
  public var duration: Foundation.TimeInterval? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var genreNames: [Swift.String] {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var lastPlayedDate: Foundation.Date? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var libraryAddedDate: Foundation.Date? {
    get
  }
  public var isrc: Swift.String? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var playCount: Swift.Int? {
    get
  }
  public var playParameters: MusicKit.PlayParameters? {
    get
  }
  public var previewAssets: [MusicKit.PreviewAsset]? {
    get
  }
  public var releaseDate: Foundation.Date? {
    get
  }
  public var title: Swift.String {
    get
  }
  public var trackNumber: Swift.Int? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var workName: Swift.String? {
    get
  }
  public var albums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var artists: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? {
    get
  }
  public static func == (a: MusicKit.Track, b: MusicKit.Track) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Track : MusicKit.MusicPropertyContainer {
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Track, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Track, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Track, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.Track : MusicKit.PlayableMusicItem {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
extension MusicKit.Track : MusicKit.MusicLibraryAddable, MusicKit.MusicPlaylistAddable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Track : MusicKit.MusicLibraryRequestable {
  public typealias LibraryFilter = MusicKit.LibraryTrackFilter
  public typealias LibrarySortProperties = MusicKit.LibraryTrackSortProperties
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryTrackFilter {
  var id: MusicKit.MusicItemID { get }
  var albums: MusicKit.MusicItemCollection<MusicKit.Album>? { get }
  var artists: MusicKit.MusicItemCollection<MusicKit.Artist>? { get }
  var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? { get }
  var albumTitle: Swift.String? { get }
  var artistName: Swift.String? { get }
  var title: Swift.String { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryTrackSortProperties {
  var albumTitle: Swift.String? { get }
  var artistName: Swift.String? { get }
  var discNumber: Swift.Int? { get }
  var duration: Foundation.TimeInterval? { get }
  var lastPlayedDate: Foundation.Date? { get }
  var libraryAddedDate: Foundation.Date? { get }
  var playCount: Swift.Int? { get }
  var title: Swift.String { get }
  var trackNumber: Swift.Int? { get }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Track : MusicKit.MusicRecentlyPlayedRequestable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Track : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Track : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct Artwork : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public let maximumWidth: Swift.Int
  public let maximumHeight: Swift.Int
  public let alternateText: Swift.String?
  public let backgroundColor: CoreGraphics.CGColor?
  public let primaryTextColor: CoreGraphics.CGColor?
  public let secondaryTextColor: CoreGraphics.CGColor?
  public let tertiaryTextColor: CoreGraphics.CGColor?
  public let quaternaryTextColor: CoreGraphics.CGColor?
  public func url(width: Swift.Int, height: Swift.Int) -> Foundation.URL?
  public static func == (a: MusicKit.Artwork, b: MusicKit.Artwork) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Artwork : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Artwork : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Playlist.Entry {
  public enum Item : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
    case musicVideo(MusicKit.MusicVideo)
    case song(MusicKit.Song)
    public var id: MusicKit.MusicItemID {
      get
    }
    public var artwork: MusicKit.Artwork? {
      get
    }
    public var albumTitle: Swift.String? {
      get
    }
    public var artistName: Swift.String {
      get
    }
    public var artistURL: Foundation.URL? {
      get
    }
    public var contentRating: MusicKit.ContentRating? {
      get
    }
    public var duration: Foundation.TimeInterval? {
      get
    }
    public var editorialNotes: MusicKit.EditorialNotes? {
      get
    }
    public var genreNames: [Swift.String] {
      get
    }
    @available(macOS 14.0, macCatalyst 17.0, *)
    public var lastPlayedDate: Foundation.Date? {
      get
    }
    @available(macOS 14.0, macCatalyst 17.0, *)
    public var libraryAddedDate: Foundation.Date? {
      get
    }
    public var isrc: Swift.String? {
      get
    }
    @available(macOS 14.0, macCatalyst 17.0, *)
    public var playCount: Swift.Int? {
      get
    }
    public var playParameters: MusicKit.PlayParameters? {
      get
    }
    public var previewAssets: [MusicKit.PreviewAsset]? {
      get
    }
    public var releaseDate: Foundation.Date? {
      get
    }
    public var title: Swift.String {
      get
    }
    public var url: Foundation.URL? {
      get
    }
    public static func == (a: MusicKit.Playlist.Entry.Item, b: MusicKit.Playlist.Entry.Item) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 13.0, *)
    public typealias ID = MusicKit.MusicItemID
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Playlist.Entry.Item : MusicKit.MusicPropertyContainer {
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Playlist.Entry.Item, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Playlist.Entry.Item, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Playlist.Entry.Item, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
}
@available(iOS 16.0, tvOS 16.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.Playlist.Entry.Item : MusicKit.PlayableMusicItem {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Playlist.Entry.Item : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Playlist.Entry.Item : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public protocol MusicPersonalRecommendationItem : MusicKit.MusicItem {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicPersonalRecommendation {
  public enum Item : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
    case album(MusicKit.Album)
    case playlist(MusicKit.Playlist)
    case station(MusicKit.Station)
    public var id: MusicKit.MusicItemID {
      get
    }
    public var artwork: MusicKit.Artwork? {
      get
    }
    public var title: Swift.String {
      get
    }
    public var subtitle: Swift.String? {
      get
    }
    public static func == (a: MusicKit.MusicPersonalRecommendation.Item, b: MusicKit.MusicPersonalRecommendation.Item) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 13.0, *)
    public typealias ID = MusicKit.MusicItemID
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicPersonalRecommendation.Item : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicPersonalRecommendation.Item : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public struct MusicCatalogChartsResponse : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public let albumCharts: [MusicKit.MusicCatalogChart<MusicKit.Album>]
  public let musicVideoCharts: [MusicKit.MusicCatalogChart<MusicKit.MusicVideo>]
  public let playlistCharts: [MusicKit.MusicCatalogChart<MusicKit.Playlist>]
  public let songCharts: [MusicKit.MusicCatalogChart<MusicKit.Song>]
  public static func == (a: MusicKit.MusicCatalogChartsResponse, b: MusicKit.MusicCatalogChartsResponse) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogChartsResponse : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogChartsResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct MusicCatalogSearchResponse : Swift.Equatable, Swift.Hashable {
  public let albums: MusicKit.MusicItemCollection<MusicKit.Album>
  public let artists: MusicKit.MusicItemCollection<MusicKit.Artist>
  @available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
  public let curators: MusicKit.MusicItemCollection<MusicKit.Curator>
  @available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
  public let musicVideos: MusicKit.MusicItemCollection<MusicKit.MusicVideo>
  public let playlists: MusicKit.MusicItemCollection<MusicKit.Playlist>
  @available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
  public let radioShows: MusicKit.MusicItemCollection<MusicKit.RadioShow>
  public let recordLabels: MusicKit.MusicItemCollection<MusicKit.RecordLabel>
  public let songs: MusicKit.MusicItemCollection<MusicKit.Song>
  public let stations: MusicKit.MusicItemCollection<MusicKit.Station>
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public let topResults: MusicKit.MusicItemCollection<MusicKit.MusicCatalogSearchResponse.TopResult>
  public static func == (a: MusicKit.MusicCatalogSearchResponse, b: MusicKit.MusicCatalogSearchResponse) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogSearchResponse : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogSearchResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct EditorialNotes : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public let short: Swift.String?
  public let standard: Swift.String?
  public let name: Swift.String?
  public let tagline: Swift.String?
  public static func == (a: MusicKit.EditorialNotes, b: MusicKit.EditorialNotes) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.EditorialNotes : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.EditorialNotes : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 15.0, tvOS 15.0, visionOS 1.0, *)
@available(watchOS, unavailable)
@available(macOS, unavailable)
public class SystemMusicPlayer : MusicKit.MusicPlayer {
  public static let shared: MusicKit.SystemMusicPlayer
  public var queue: MusicKit.MusicPlayer.Queue {
    get
    set
  }
  @objc deinit
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct PreviewAsset : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public let artwork: MusicKit.Artwork?
  public let url: Foundation.URL?
  public let hlsURL: Foundation.URL?
  public static func == (a: MusicKit.PreviewAsset, b: MusicKit.PreviewAsset) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.PreviewAsset : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.PreviewAsset : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
public class MusicPlayer {
  @objc deinit
  final public let state: MusicKit.MusicPlayer.State
  public var isPreparedToPlay: Swift.Bool {
    get
  }
  public func prepareToPlay() async throws
  public func play() async throws
  public func pause()
  public func stop()
  public var playbackTime: Foundation.TimeInterval {
    get
    set
  }
  public func beginSeekingForward()
  public func beginSeekingBackward()
  public func endSeeking()
  public func skipToNextEntry() async throws
  public func restartCurrentEntry()
  public func skipToPreviousEntry() async throws
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.ApplicationMusicPlayer {
  @_inheritsConvenienceInitializers public class Queue : MusicKit.MusicPlayer.Queue {
    required public init<S, PlayableMusicItemType>(for playableItems: S, startingAt startPlayableItem: S.Element? = nil) where S : Swift.Sequence, PlayableMusicItemType : MusicKit.PlayableMusicItem, PlayableMusicItemType == S.Element
    required public init<S>(_ entries: S, startingAt startEntry: S.Element? = nil) where S : Swift.Sequence, S.Element == MusicKit.MusicPlayer.Queue.Entry
    required public init(arrayLiteral elements: any MusicKit.PlayableMusicItem...)
    @available(iOS 16.4, tvOS 16.4, visionOS 1.0, macOS 14.0, *)
    required public init(album: MusicKit.Album, startingAt startTrack: MusicKit.Track)
    @available(iOS 16.4, tvOS 16.4, visionOS 1.0, macOS 14.0, *)
    required public init(playlist: MusicKit.Playlist, startingAt startPlaylistEntry: MusicKit.Playlist.Entry)
    public var entries: MusicKit.ApplicationMusicPlayer.Queue.Entries {
      get
      set
    }
    public struct Entries : Swift.Equatable, Swift.Hashable, Swift.Sequence, Swift.Collection, Swift.BidirectionalCollection, Swift.RandomAccessCollection, Swift.MutableCollection, Swift.RangeReplaceableCollection, Swift.ExpressibleByArrayLiteral {
      public init()
      public static func == (left: MusicKit.ApplicationMusicPlayer.Queue.Entries, right: MusicKit.ApplicationMusicPlayer.Queue.Entries) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public __consuming func makeIterator() -> MusicKit.ApplicationMusicPlayer.Queue.Entries.Iterator
      public typealias Element = MusicKit.MusicPlayer.Queue.Entry
      public typealias Iterator = Swift.Array<MusicKit.MusicPlayer.Queue.Entry>.Iterator
      public var startIndex: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index {
        get
      }
      public var endIndex: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index {
        get
      }
      public var indices: MusicKit.ApplicationMusicPlayer.Queue.Entries.Indices {
        get
      }
      public func index(_ i: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index, offsetBy distance: Swift.Int) -> MusicKit.ApplicationMusicPlayer.Queue.Entries.Index
      public func index(_ i: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index, offsetBy distance: Swift.Int, limitedBy limit: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index) -> MusicKit.ApplicationMusicPlayer.Queue.Entries.Index?
      public func index(after i: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index) -> MusicKit.ApplicationMusicPlayer.Queue.Entries.Index
      public func formIndex(after i: inout MusicKit.ApplicationMusicPlayer.Queue.Entries.Index)
      public func distance(from start: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index, to end: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index) -> Swift.Int
      public subscript(bounds: Swift.Range<MusicKit.ApplicationMusicPlayer.Queue.Entries.Index>) -> MusicKit.ApplicationMusicPlayer.Queue.Entries.SubSequence {
        get
        set
      }
      public subscript(position: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index) -> MusicKit.ApplicationMusicPlayer.Queue.Entries.Element {
        get
        set
      }
      public typealias Index = Swift.Array<MusicKit.MusicPlayer.Queue.Entry>.Index
      public typealias Indices = Swift.Array<MusicKit.MusicPlayer.Queue.Entry>.Indices
      public typealias SubSequence = Swift.Array<MusicKit.MusicPlayer.Queue.Entry>.SubSequence
      public func index(before i: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index) -> MusicKit.ApplicationMusicPlayer.Queue.Entries.Index
      public func formIndex(before i: inout MusicKit.ApplicationMusicPlayer.Queue.Entries.Index)
      public mutating func replaceSubrange<C>(_ subrange: Swift.Range<MusicKit.ApplicationMusicPlayer.Queue.Entries.Index>, with newElements: C) where C : Swift.Collection, C.Element == MusicKit.MusicPlayer.Queue.Entry
      public init(arrayLiteral elements: MusicKit.MusicPlayer.Queue.Entry...)
      @available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
      @available(watchOS, unavailable)
      public typealias ArrayLiteralElement = MusicKit.MusicPlayer.Queue.Entry
      public var hashValue: Swift.Int {
        get
      }
    }
    @objc deinit
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
public class ApplicationMusicPlayer : MusicKit.MusicPlayer {
  public static let shared: MusicKit.ApplicationMusicPlayer
  public var queue: MusicKit.ApplicationMusicPlayer.Queue {
    get
    set
  }
  @available(iOS 18.0, *)
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @available(visionOS, unavailable)
  public var transition: MusicKit.MusicPlayer.Transition {
    get
    set
  }
  @objc deinit
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
@frozen public struct MusicItemID : Swift.Equatable, Swift.Hashable, Swift.Sendable, Swift.RawRepresentable, Swift.ExpressibleByStringLiteral {
  public init(_ rawValue: Swift.String)
  public init(rawValue: Swift.String)
  public init(stringLiteral value: Swift.String)
  public let rawValue: Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias RawValue = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias StringLiteralType = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicItemID : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicItemID : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 16.1, tvOS 16.1, watchOS 9.1, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrary {
  public enum Error : Swift.String, Foundation.LocalizedError, Swift.Sendable, Swift.CustomStringConvertible {
    case unknown
    case permissionDenied
    case unableToAddItem
    case itemAlreadyAdded
    case playlistNotInLibrary
    case addToPlaylistFailed
    case createPlaylistFailed
    case editPlaylistFailed
    public var errorDescription: Swift.String? {
      get
    }
    public var failureReason: Swift.String? {
      get
    }
    public var recoverySuggestion: Swift.String? {
      get
    }
    public var helpAnchor: Swift.String? {
      get
    }
    public var description: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    @available(iOS 16.1, tvOS 16.1, watchOS 9.1, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public enum MusicTokenRequestError : Swift.String, Foundation.LocalizedError, Swift.Sendable, Swift.CustomStringConvertible {
  case unknown
  case permissionDenied
  case userTokenRevoked
  case userNotSignedIn
  case privacyAcknowledgementRequired
  case developerTokenRequestFailed
  case userTokenRequestFailed
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
  public var recoverySuggestion: Swift.String? {
    get
  }
  public var helpAnchor: Swift.String? {
    get
  }
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct MusicVideo : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var albumTitle: Swift.String? {
    get
  }
  public var artistName: Swift.String {
    get
  }
  public var artistURL: Foundation.URL? {
    get
  }
  public var contentRating: MusicKit.ContentRating? {
    get
  }
  public var duration: Foundation.TimeInterval? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var genreNames: [Swift.String] {
    get
  }
  public var has4K: Swift.Bool? {
    get
  }
  public var hasHDR: Swift.Bool? {
    get
  }
  public var isPreview: Swift.Bool {
    get
  }
  public var isrc: Swift.String? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var lastPlayedDate: Foundation.Date? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var libraryAddedDate: Foundation.Date? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var playCount: Swift.Int? {
    get
  }
  public var playParameters: MusicKit.PlayParameters? {
    get
  }
  public var previewAssets: [MusicKit.PreviewAsset]? {
    get
  }
  public var releaseDate: Foundation.Date? {
    get
  }
  public var title: Swift.String {
    get
  }
  public var trackNumber: Swift.Int? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var workName: Swift.String? {
    get
  }
  public var albums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var artists: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? {
    get
  }
  public var songs: MusicKit.MusicItemCollection<MusicKit.Song>? {
    get
  }
  public var moreByArtist: MusicKit.MusicItemCollection<MusicKit.MusicVideo>? {
    get
  }
  public var moreInGenre: MusicKit.MusicItemCollection<MusicKit.MusicVideo>? {
    get
  }
  public static func == (a: MusicKit.MusicVideo, b: MusicKit.MusicVideo) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicVideo : MusicKit.MusicPropertyContainer {
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.MusicVideo, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.MusicVideo, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.MusicVideo {
  @_alwaysEmitIntoClient public static var artistURL: MusicKit.MusicExtendedAttributeProperty<MusicKit.MusicVideo, Foundation.URL> {
    get {
        MusicExtendedAttributeProperty("artistUrl")
    }
  }
  public static let albums: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, MusicKit.Album>
  public static let artists: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, MusicKit.Artist>
  public static let genres: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, MusicKit.Genre>
  public static let songs: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, MusicKit.Song>
  public static let moreByArtist: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, MusicKit.MusicVideo>
  public static let moreInGenre: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, MusicKit.MusicVideo>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicVideo : MusicKit.MusicCatalogChartRequestable {
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicVideo : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public protocol MusicVideoFilter {
  var id: MusicKit.MusicItemID { get }
  var isrc: Swift.String? { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicVideo : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.MusicVideoFilter
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
extension MusicKit.MusicVideo : MusicKit.MusicLibraryAddable, MusicKit.MusicPlaylistAddable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicVideo : MusicKit.MusicLibraryRequestable {
  public typealias LibraryFilter = MusicKit.LibraryMusicVideoFilter
  public typealias LibrarySortProperties = MusicKit.LibraryMusicVideoSortProperties
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryMusicVideoFilter {
  var id: MusicKit.MusicItemID { get }
  var albums: MusicKit.MusicItemCollection<MusicKit.Album>? { get }
  var artists: MusicKit.MusicItemCollection<MusicKit.Artist>? { get }
  var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? { get }
  var albumTitle: Swift.String? { get }
  var artistName: Swift.String? { get }
  var title: Swift.String { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryMusicVideoSortProperties {
  var albumTitle: Swift.String? { get }
  var artistName: Swift.String? { get }
  var duration: Foundation.TimeInterval? { get }
  var lastPlayedDate: Foundation.Date? { get }
  var libraryAddedDate: Foundation.Date? { get }
  var playCount: Swift.Int? { get }
  var title: Swift.String { get }
  var trackNumber: Swift.Int? { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicVideo : MusicKit.MusicLibrarySearchable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.MusicVideo : MusicKit.MusicRecentlyPlayedRequestable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicVideo : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicVideo : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public enum AudioVariant : Swift.CaseIterable, Swift.Equatable, Swift.Hashable, Swift.Sendable {
  case dolbyAtmos
  case dolbyAudio
  case lossless
  case highResolutionLossless
  case lossyStereo
  @available(iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2, visionOS 1.1, *)
  case spatialAudio
  public static var allCases: [MusicKit.AudioVariant] {
    get
  }
  public static func == (a: MusicKit.AudioVariant, b: MusicKit.AudioVariant) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 13.0, *)
  public typealias AllCases = [MusicKit.AudioVariant]
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.AudioVariant : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.AudioVariant : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
@dynamicMemberLookup public struct MusicLibrarySection<SectionType, MusicItemType> where SectionType : MusicKit.MusicLibrarySectionRequestable, MusicItemType : MusicKit.MusicLibraryRequestable {
  public let items: MusicKit.MusicItemCollection<MusicItemType>
  public subscript<T>(dynamicMember keyPath: Swift.KeyPath<SectionType, T>) -> T {
    get
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrarySection : Swift.Identifiable {
  public var id: MusicKit.MusicItemID {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public typealias ID = MusicKit.MusicItemID
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrarySection : Swift.Equatable where SectionType : Swift.Equatable, MusicItemType : Swift.Equatable {
  public static func == (a: MusicKit.MusicLibrarySection<SectionType, MusicItemType>, b: MusicKit.MusicLibrarySection<SectionType, MusicItemType>) -> Swift.Bool
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrarySection : Swift.Hashable where SectionType : Swift.Hashable, MusicItemType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrarySection : Swift.Sendable where SectionType : Swift.Sendable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrarySection : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct Genre : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  public let id: MusicKit.MusicItemID
  public var name: Swift.String {
    get
  }
  public var parent: MusicKit.Genre? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 15.2, macCatalyst 18.2, *)
  public var libraryAddedDate: Foundation.Date? {
    get
  }
  public static func == (a: MusicKit.Genre, b: MusicKit.Genre) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Genre : MusicKit.MusicPropertyContainer {
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Genre, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Genre, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Genre, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public protocol GenreFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Genre : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.GenreFilter
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Genre : MusicKit.MusicCatalogTopLevelResourceRequesting {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Genre : MusicKit.MusicLibraryRequestable {
  public typealias LibraryFilter = MusicKit.LibraryGenreFilter
  public typealias LibrarySortProperties = MusicKit.LibraryGenreSortProperties
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryGenreFilter {
  var id: MusicKit.MusicItemID { get }
  var name: Swift.String { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryGenreSortProperties {
  var libraryAddedDate: Foundation.Date? { get }
  var name: Swift.String { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.2, macCatalyst 17.2, *)
extension MusicKit.Genre : MusicKit.MusicLibrarySectionRequestable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Genre : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Genre : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct Artist : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  public let id: MusicKit.MusicItemID
  @_alwaysEmitIntoClient public var artwork: MusicKit.Artwork? {
    get {
        return try? self[property: .artwork]
    }
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var genreNames: [Swift.String]? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var libraryAddedDate: Foundation.Date? {
    get
  }
  public var name: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var albums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? {
    get
  }
  public var musicVideos: MusicKit.MusicItemCollection<MusicKit.MusicVideo>? {
    get
  }
  public var playlists: MusicKit.MusicItemCollection<MusicKit.Playlist>? {
    get
  }
  public var station: MusicKit.Station? {
    get
  }
  public var appearsOnAlbums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var compilationAlbums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var featuredAlbums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var featuredPlaylists: MusicKit.MusicItemCollection<MusicKit.Playlist>? {
    get
  }
  public var fullAlbums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var latestRelease: MusicKit.Album? {
    get
  }
  public var liveAlbums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var similarArtists: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var singles: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var topMusicVideos: MusicKit.MusicItemCollection<MusicKit.MusicVideo>? {
    get
  }
  public var topSongs: MusicKit.MusicItemCollection<MusicKit.Song>? {
    get
  }
  public static func == (a: MusicKit.Artist, b: MusicKit.Artist) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Artist : MusicKit.MusicPropertyContainer {
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Artist, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Artist, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Artist, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.Artist {
  @_alwaysEmitIntoClient internal static var artwork: MusicKit.MusicAttributeProperty<MusicKit.Artist, MusicKit.Artwork> {
    get {
        MusicAttributeProperty("artwork")
    }
  }
  public static let albums: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let genres: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Genre>
  public static let musicVideos: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.MusicVideo>
  public static let playlists: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Playlist>
  public static let station: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Station>
  public static let appearsOnAlbums: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let compilationAlbums: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let featuredAlbums: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let featuredPlaylists: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Playlist>
  public static let fullAlbums: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let latestRelease: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let liveAlbums: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let similarArtists: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Artist>
  public static let singles: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let topMusicVideos: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.MusicVideo>
  public static let topSongs: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Song>
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Artist : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public protocol ArtistFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Artist : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.ArtistFilter
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Artist : MusicKit.MusicLibraryRequestable {
  public typealias LibraryFilter = MusicKit.LibraryArtistFilter
  public typealias LibrarySortProperties = MusicKit.LibraryArtistSortProperties
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryArtistFilter {
  var id: MusicKit.MusicItemID { get }
  var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? { get }
  var playlists: MusicKit.MusicItemCollection<MusicKit.Playlist>? { get }
  var name: Swift.String { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryArtistSortProperties {
  var albumCount: Swift.Int? { get }
  var libraryAddedDate: Foundation.Date? { get }
  var name: Swift.String { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Artist : MusicKit.MusicLibrarySectionRequestable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Artist : MusicKit.MusicLibrarySearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Artist : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Artist : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrarySearchResponse {
  public enum TopResult : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
    case album(MusicKit.Album)
    case artist(MusicKit.Artist)
    case musicVideo(MusicKit.MusicVideo)
    case playlist(MusicKit.Playlist)
    case song(MusicKit.Song)
    public var id: MusicKit.MusicItemID {
      get
    }
    public var artwork: MusicKit.Artwork? {
      get
    }
    public var title: Swift.String {
      get
    }
    public static func == (a: MusicKit.MusicLibrarySearchResponse.TopResult, b: MusicKit.MusicLibrarySearchResponse.TopResult) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
    public typealias ID = MusicKit.MusicItemID
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrarySearchResponse.TopResult : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrarySearchResponse.TopResult : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public enum RecentlyPlayedMusicItem : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  case album(MusicKit.Album)
  case playlist(MusicKit.Playlist)
  case station(MusicKit.Station)
  public var id: MusicKit.MusicItemID {
    get
  }
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var playParameters: MusicKit.PlayParameters? {
    get
  }
  public var title: Swift.String {
    get
  }
  public var subtitle: Swift.String? {
    get
  }
  public static func == (a: MusicKit.RecentlyPlayedMusicItem, b: MusicKit.RecentlyPlayedMusicItem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 13.0, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.RecentlyPlayedMusicItem : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.RecentlyPlayedMusicItem : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, tvOS 16.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.RecentlyPlayedMusicItem : MusicKit.PlayableMusicItem {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.RecentlyPlayedMusicItem : MusicKit.MusicRecentlyPlayedRequestable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct Playlist : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var curatorName: Swift.String? {
    get
  }
  public var isChart: Swift.Bool? {
    get
  }
  public var kind: MusicKit.Playlist.Kind? {
    get
  }
  public var lastModifiedDate: Foundation.Date? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var lastPlayedDate: Foundation.Date? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var libraryAddedDate: Foundation.Date? {
    get
  }
  public var name: Swift.String {
    get
  }
  public var playParameters: MusicKit.PlayParameters? {
    get
  }
  public var shortDescription: Swift.String? {
    get
  }
  public var standardDescription: Swift.String? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public var curator: MusicKit.Curator? {
    get
  }
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public var entries: MusicKit.MusicItemCollection<MusicKit.Playlist.Entry>? {
    get
  }
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public var radioShow: MusicKit.RadioShow? {
    get
  }
  public var tracks: MusicKit.MusicItemCollection<MusicKit.Track>? {
    get
  }
  public var featuredArtists: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var moreByCurator: MusicKit.MusicItemCollection<MusicKit.Playlist>? {
    get
  }
  public static func == (a: MusicKit.Playlist, b: MusicKit.Playlist) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Playlist : MusicKit.MusicPropertyContainer {
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Playlist, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Playlist, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Playlist, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.Playlist {
  public static let tracks: MusicKit.MusicRelationshipProperty<MusicKit.Playlist, MusicKit.Track>
  public static let featuredArtists: MusicKit.MusicRelationshipProperty<MusicKit.Playlist, MusicKit.Artist>
  public static let moreByCurator: MusicKit.MusicRelationshipProperty<MusicKit.Playlist, MusicKit.Playlist>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.Playlist {
  public static let curator: MusicKit.MusicRelationshipProperty<MusicKit.Playlist, MusicKit.Curator>
  public static let entries: MusicKit.MusicRelationshipProperty<MusicKit.Playlist, MusicKit.Playlist.Entry>
  public static let radioShow: MusicKit.MusicRelationshipProperty<MusicKit.Playlist, MusicKit.RadioShow>
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.Playlist : MusicKit.PlayableMusicItem {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Playlist : MusicKit.MusicCatalogChartRequestable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Playlist : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public protocol PlaylistFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Playlist : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.PlaylistFilter
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
extension MusicKit.Playlist : MusicKit.MusicLibraryAddable, MusicKit.MusicPlaylistAddable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Playlist : MusicKit.MusicLibraryRequestable {
  public typealias LibraryFilter = MusicKit.LibraryPlaylistFilter
  public typealias LibrarySortProperties = MusicKit.LibraryPlaylistSortProperties
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryPlaylistFilter {
  var id: MusicKit.MusicItemID { get }
  var name: Swift.String { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryPlaylistSortProperties {
  var lastPlayedDate: Foundation.Date? { get }
  var libraryAddedDate: Foundation.Date? { get }
  var name: Swift.String { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Playlist : MusicKit.MusicLibrarySectionRequestable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Playlist : MusicKit.MusicLibrarySearchable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Playlist : MusicKit.MusicPersonalRecommendationItem {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Playlist : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Playlist : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Playlist {
  public enum Kind : Swift.Codable, Swift.Equatable, Swift.Hashable, Swift.Sendable {
    case editorial
    case external
    case personalMix
    case replay
    case userShared
    public static func == (a: MusicKit.Playlist.Kind, b: MusicKit.Playlist.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.Entry {
  public enum Item : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
    case song(MusicKit.Song)
    case musicVideo(MusicKit.MusicVideo)
    public var id: MusicKit.MusicItemID {
      get
    }
    public var playParameters: MusicKit.PlayParameters? {
      get
    }
    public static func == (a: MusicKit.MusicPlayer.Queue.Entry.Item, b: MusicKit.MusicPlayer.Queue.Entry.Item) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
    @available(watchOS, unavailable)
    public typealias ID = MusicKit.MusicItemID
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.Entry.Item : MusicKit.MusicPropertyContainer {
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.MusicPlayer.Queue.Entry.Item, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.MusicPlayer.Queue.Entry.Item, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.MusicPlayer.Queue.Entry.Item, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.Entry.Item : MusicKit.PlayableMusicItem {
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.Entry.Item : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.Entry.Item : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public struct MusicLibrarySearchRequest : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public init(term: Swift.String, types: [any MusicKit.MusicLibrarySearchable.Type])
  public let term: Swift.String
  public var types: [any MusicKit.MusicLibrarySearchable.Type] {
    get
  }
  public var includeTopResults: Swift.Bool
  public var limit: Swift.Int
  public func response() async throws -> MusicKit.MusicLibrarySearchResponse
  public static func == (a: MusicKit.MusicLibrarySearchRequest, b: MusicKit.MusicLibrarySearchRequest) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public protocol MusicCatalogChartRequestable : MusicKit.MusicItem {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Playlist {
  public struct Entry : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
    public let id: MusicKit.MusicItemID
    public var artwork: MusicKit.Artwork? {
      get
    }
    public var albumTitle: Swift.String? {
      get
    }
    public var artistName: Swift.String {
      get
    }
    public var artistURL: Foundation.URL? {
      get
    }
    public var contentRating: MusicKit.ContentRating? {
      get
    }
    public var duration: Foundation.TimeInterval? {
      get
    }
    public var editorialNotes: MusicKit.EditorialNotes? {
      get
    }
    public var genreNames: [Swift.String] {
      get
    }
    @available(macOS 14.0, macCatalyst 17.0, *)
    public var lastPlayedDate: Foundation.Date? {
      get
    }
    @available(macOS 14.0, macCatalyst 17.0, *)
    public var libraryAddedDate: Foundation.Date? {
      get
    }
    @available(macOS 14.0, macCatalyst 17.0, *)
    public var playCount: Swift.Int? {
      get
    }
    public var isrc: Swift.String? {
      get
    }
    public var item: MusicKit.Playlist.Entry.Item? {
      get
    }
    public var playParameters: MusicKit.PlayParameters? {
      get
    }
    public var position: Swift.Int {
      get
    }
    public var previewAssets: [MusicKit.PreviewAsset]? {
      get
    }
    public var releaseDate: Foundation.Date? {
      get
    }
    public var title: Swift.String {
      get
    }
    public var url: Foundation.URL? {
      get
    }
    public static func == (a: MusicKit.Playlist.Entry, b: MusicKit.Playlist.Entry) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 13.0, *)
    public typealias ID = MusicKit.MusicItemID
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Playlist.Entry : MusicKit.MusicPropertyContainer {
}
@available(iOS 16.0, tvOS 16.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.Playlist.Entry : MusicKit.PlayableMusicItem {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
extension MusicKit.Playlist.Entry : MusicKit.MusicLibraryAddable, MusicKit.MusicPlaylistAddable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Playlist.Entry : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Playlist.Entry : MusicKit.MusicLibraryRequestable {
  public typealias LibraryFilter = MusicKit.LibraryPlaylistEntryFilter
  public typealias LibrarySortProperties = MusicKit.LibraryPlaylistEntrySortProperties
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryPlaylistEntryFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryPlaylistEntrySortProperties {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Playlist.Entry : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct MusicCatalogSearchRequest {
  public init(term: Swift.String, types: [any MusicKit.MusicCatalogSearchable.Type])
  public let term: Swift.String
  public var types: [any MusicKit.MusicCatalogSearchable.Type] {
    get
  }
  public var limit: Swift.Int?
  public var offset: Swift.Int?
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public var includeTopResults: Swift.Bool
  public func response() async throws -> MusicKit.MusicCatalogSearchResponse
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public struct MusicLibraryRequest<MusicItemType> where MusicItemType : MusicKit.MusicLibraryRequestable {
  public init()
  public var limit: Swift.Int
  public var offset: Swift.Int
  public var includeOnlyDownloadedContent: Swift.Bool
  public mutating func filter<RelatedMusicItemType>(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, MusicKit.MusicItemCollection<RelatedMusicItemType>?>, contains relatedItem: RelatedMusicItemType) where RelatedMusicItemType : MusicKit.MusicItem
  public mutating func filter(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, Swift.String>, contains text: Swift.String)
  public mutating func filter(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, Swift.String?>, contains text: Swift.String)
  public mutating func filter<Value>(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, Value>, equalTo value: Value) where Value : MusicKit.MusicLibraryRequestFilterValueEquatable
  public mutating func filter<Value>(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, Value?>, equalTo value: Value?) where Value : MusicKit.MusicLibraryRequestFilterValueEquatable
  public mutating func filter<Value>(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, Value>, memberOf values: [Value]) where Value : MusicKit.MusicLibraryRequestFilterValueMembershipComparable
  public mutating func filter<Value>(matching keyPath: Swift.KeyPath<MusicItemType.LibraryFilter, Value?>, memberOf values: [Value?]) where Value : MusicKit.MusicLibraryRequestFilterValueMembershipComparable
  public mutating func filter(text: Swift.String)
  public mutating func sort<Value>(by keyPath: Swift.KeyPath<MusicItemType.LibrarySortProperties, Value>, ascending: Swift.Bool)
  public func response() async throws -> MusicKit.MusicLibraryResponse<MusicItemType>
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct MusicCatalogResourceResponse<MusicItemType> where MusicItemType : MusicKit.MusicItem {
  public let items: MusicKit.MusicItemCollection<MusicItemType>
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogResourceResponse : Swift.Equatable where MusicItemType : Swift.Equatable {
  public static func == (a: MusicKit.MusicCatalogResourceResponse<MusicItemType>, b: MusicKit.MusicCatalogResourceResponse<MusicItemType>) -> Swift.Bool
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogResourceResponse : Swift.Hashable where MusicItemType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogResourceResponse : Swift.Sendable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogResourceResponse : Swift.Decodable where MusicItemType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogResourceResponse : Swift.Encodable where MusicItemType : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicCatalogResourceResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct MusicSubscription : Swift.Equatable, Swift.Hashable, Swift.Sendable, Swift.CustomStringConvertible {
  public let canPlayCatalogContent: Swift.Bool
  public let canBecomeSubscriber: Swift.Bool
  public let hasCloudLibraryEnabled: Swift.Bool
  public static var current: MusicKit.MusicSubscription {
    get async throws
  }
  public var description: Swift.String {
    get
  }
  public static func == (a: MusicKit.MusicSubscription, b: MusicKit.MusicSubscription) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct Song : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var albumTitle: Swift.String? {
    get
  }
  public var artistName: Swift.String {
    get
  }
  public var artistURL: Foundation.URL? {
    get
  }
  public var attribution: Swift.String? {
    get
  }
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public var audioVariants: [MusicKit.AudioVariant]? {
    get
  }
  public var composerName: Swift.String? {
    get
  }
  public var contentRating: MusicKit.ContentRating? {
    get
  }
  public var discNumber: Swift.Int? {
    get
  }
  public var duration: Foundation.TimeInterval? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var genreNames: [Swift.String] {
    get
  }
  public var hasLyrics: Swift.Bool {
    get
  }
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public var isAppleDigitalMaster: Swift.Bool? {
    get
  }
  public var isrc: Swift.String? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var lastPlayedDate: Foundation.Date? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var libraryAddedDate: Foundation.Date? {
    get
  }
  public var movementCount: Swift.Int? {
    get
  }
  public var movementName: Swift.String? {
    get
  }
  public var movementNumber: Swift.Int? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var playCount: Swift.Int? {
    get
  }
  public var playParameters: MusicKit.PlayParameters? {
    get
  }
  public var previewAssets: [MusicKit.PreviewAsset]? {
    get
  }
  public var releaseDate: Foundation.Date? {
    get
  }
  public var title: Swift.String {
    get
  }
  public var trackNumber: Swift.Int? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var workName: Swift.String? {
    get
  }
  public var albums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var artists: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? {
    get
  }
  public var station: MusicKit.Station? {
    get
  }
  public var composers: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var musicVideos: MusicKit.MusicItemCollection<MusicKit.MusicVideo>? {
    get
  }
  public static func == (a: MusicKit.Song, b: MusicKit.Song) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Song : MusicKit.MusicPropertyContainer {
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Song, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Song, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Song, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.Song {
  @_alwaysEmitIntoClient public static var artistURL: MusicKit.MusicExtendedAttributeProperty<MusicKit.Song, Foundation.URL> {
    get {
        MusicExtendedAttributeProperty("artistUrl")
    }
  }
  public static let albums: MusicKit.MusicRelationshipProperty<MusicKit.Song, MusicKit.Album>
  public static let artists: MusicKit.MusicRelationshipProperty<MusicKit.Song, MusicKit.Artist>
  public static let genres: MusicKit.MusicRelationshipProperty<MusicKit.Song, MusicKit.Genre>
  public static let station: MusicKit.MusicRelationshipProperty<MusicKit.Song, MusicKit.Station>
  public static let composers: MusicKit.MusicRelationshipProperty<MusicKit.Song, MusicKit.Artist>
  public static let musicVideos: MusicKit.MusicRelationshipProperty<MusicKit.Song, MusicKit.MusicVideo>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.Song {
  public static let audioVariants: MusicKit.MusicExtendedAttributeProperty<MusicKit.Song, [MusicKit.AudioVariant]>
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.Song : MusicKit.PlayableMusicItem {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Song : MusicKit.MusicCatalogChartRequestable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Song : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public protocol SongFilter {
  var id: MusicKit.MusicItemID { get }
  var isrc: Swift.String? { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Song : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.SongFilter
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
extension MusicKit.Song : MusicKit.MusicLibraryAddable, MusicKit.MusicPlaylistAddable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Song : MusicKit.MusicLibraryRequestable {
  public typealias LibraryFilter = MusicKit.LibrarySongFilter
  public typealias LibrarySortProperties = MusicKit.LibrarySongSortProperties
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibrarySongFilter {
  var id: MusicKit.MusicItemID { get }
  var albums: MusicKit.MusicItemCollection<MusicKit.Album>? { get }
  var artists: MusicKit.MusicItemCollection<MusicKit.Artist>? { get }
  var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? { get }
  var albumTitle: Swift.String? { get }
  var artistName: Swift.String? { get }
  var composerName: Swift.String? { get }
  var title: Swift.String { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibrarySongSortProperties {
  var albumTitle: Swift.String? { get }
  var artistName: Swift.String? { get }
  var composerName: Swift.String? { get }
  var discNumber: Swift.Int? { get }
  var duration: Foundation.TimeInterval? { get }
  var lastPlayedDate: Foundation.Date? { get }
  var libraryAddedDate: Foundation.Date? { get }
  var playCount: Swift.Int? { get }
  var title: Swift.String { get }
  var trackNumber: Swift.Int? { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Song : MusicKit.MusicLibrarySearchable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Song : MusicKit.MusicRecentlyPlayedRequestable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Song : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Song : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
public typealias MusicRecentlyPlayedContainerResponse = MusicKit.MusicRecentlyPlayedResponse<MusicKit.RecentlyPlayedMusicItem>
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicDataRequest {
  public struct Error : Swift.Error, Swift.Sendable {
    public let status: Swift.Int
    public let code: Swift.Int
    public let title: Swift.String
    public let detailText: Swift.String
    public let id: Swift.String
    public let source: MusicKit.MusicDataRequest.Error.Source?
    public let originalResponse: MusicKit.MusicDataResponse
    public enum Source : Swift.Equatable, Swift.Sendable {
      case parameter(Swift.String)
      public static func == (a: MusicKit.MusicDataRequest.Error.Source, b: MusicKit.MusicDataRequest.Error.Source) -> Swift.Bool
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicDataRequest.Error : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicDataRequest.Error.Source : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct Album : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var artistName: Swift.String {
    get
  }
  public var artistURL: Foundation.URL? {
    get
  }
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public var audioVariants: [MusicKit.AudioVariant]? {
    get
  }
  public var contentRating: MusicKit.ContentRating? {
    get
  }
  public var copyright: Swift.String? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var genreNames: [Swift.String] {
    get
  }
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
  public var isAppleDigitalMaster: Swift.Bool? {
    get
  }
  public var isCompilation: Swift.Bool? {
    get
  }
  public var isComplete: Swift.Bool? {
    get
  }
  public var isSingle: Swift.Bool? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var lastPlayedDate: Foundation.Date? {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
  public var libraryAddedDate: Foundation.Date? {
    get
  }
  public var playParameters: MusicKit.PlayParameters? {
    get
  }
  public var recordLabelName: Swift.String? {
    get
  }
  public var releaseDate: Foundation.Date? {
    get
  }
  public var title: Swift.String {
    get
  }
  public var trackCount: Swift.Int {
    get
  }
  public var upc: Swift.String? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var artists: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? {
    get
  }
  public var tracks: MusicKit.MusicItemCollection<MusicKit.Track>? {
    get
  }
  public var recordLabels: MusicKit.MusicItemCollection<MusicKit.RecordLabel>? {
    get
  }
  public var appearsOn: MusicKit.MusicItemCollection<MusicKit.Playlist>? {
    get
  }
  public var otherVersions: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var relatedAlbums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var relatedVideos: MusicKit.MusicItemCollection<MusicKit.MusicVideo>? {
    get
  }
  public static func == (a: MusicKit.Album, b: MusicKit.Album) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Album : MusicKit.MusicPropertyContainer {
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Album, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Album, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Album, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.Album {
  @_alwaysEmitIntoClient public static var artistURL: MusicKit.MusicExtendedAttributeProperty<MusicKit.Album, Foundation.URL> {
    get {
        MusicExtendedAttributeProperty("artistUrl")
    }
  }
  public static let artists: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.Artist>
  public static let genres: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.Genre>
  public static let tracks: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.Track>
  public static let recordLabels: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.RecordLabel>
  public static let appearsOn: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.Playlist>
  public static let otherVersions: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.Album>
  public static let relatedAlbums: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.Album>
  public static let relatedVideos: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.MusicVideo>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.Album {
  public static let audioVariants: MusicKit.MusicExtendedAttributeProperty<MusicKit.Album, [MusicKit.AudioVariant]>
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.Album : MusicKit.PlayableMusicItem {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Album : MusicKit.MusicCatalogChartRequestable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Album : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public protocol AlbumFilter {
  var id: MusicKit.MusicItemID { get }
  var upc: Swift.String? { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Album : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.AlbumFilter
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
extension MusicKit.Album : MusicKit.MusicLibraryAddable, MusicKit.MusicPlaylistAddable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Album : MusicKit.MusicLibraryRequestable {
  public typealias LibraryFilter = MusicKit.LibraryAlbumFilter
  public typealias LibrarySortProperties = MusicKit.LibraryAlbumSortProperties
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryAlbumFilter {
  var id: MusicKit.MusicItemID { get }
  var isCompilation: Swift.Bool? { get }
  var artists: MusicKit.MusicItemCollection<MusicKit.Artist>? { get }
  var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? { get }
  var title: Swift.String { get }
  var artistName: Swift.String { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
public protocol LibraryAlbumSortProperties {
  var artistName: Swift.String { get }
  var releaseDate: Foundation.Date? { get }
  var title: Swift.String { get }
  var trackCount: Swift.Int { get }
  var lastPlayedDate: Foundation.Date? { get }
  var libraryAddedDate: Foundation.Date? { get }
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Album : MusicKit.MusicLibrarySectionRequestable {
}
@available(iOS 16.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.Album : MusicKit.MusicLibrarySearchable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, visionOS 1.0, *)
extension MusicKit.Album : MusicKit.MusicPersonalRecommendationItem {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Album : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.Album : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct MusicItemCollection<MusicItemType> where MusicItemType : MusicKit.MusicItem {
  public var title: Swift.String? {
    get
  }
  public static func += (collection: inout MusicKit.MusicItemCollection<MusicItemType>, nextBatchCollection: MusicKit.MusicItemCollection<MusicItemType>)
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicItemCollection {
  public var hasNextBatch: Swift.Bool {
    get
  }
  public func nextBatch(limit: Swift.Int? = nil) async throws -> MusicKit.MusicItemCollection<MusicItemType>?
  public func nextBatch(limit: Swift.Int? = nil) async throws -> MusicKit.MusicItemCollection<MusicItemType>? where MusicItemType : Swift.Decodable
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicItemCollection : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral items: MusicItemType...)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias ArrayLiteralElement = MusicItemType
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicItemCollection {
  public init<S>(_ elements: S) where MusicItemType == S.Element, S : Swift.Sequence
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicItemCollection : Swift.RandomAccessCollection {
  public typealias Element = MusicItemType
  public typealias Index = Swift.Array<MusicItemType>.Index
  public typealias SubSequence = Swift.Array<MusicItemType>.SubSequence
  public typealias Indices = Swift.Array<MusicItemType>.Indices
  public var indices: MusicKit.MusicItemCollection<MusicItemType>.Indices {
    get
  }
  public subscript(bounds: Swift.Range<MusicKit.MusicItemCollection<MusicItemType>.Index>) -> MusicKit.MusicItemCollection<MusicItemType>.SubSequence {
    get
  }
  public subscript(position: MusicKit.MusicItemCollection<MusicItemType>.Index) -> MusicKit.MusicItemCollection<MusicItemType>.Element {
    get
  }
  public var startIndex: MusicKit.MusicItemCollection<MusicItemType>.Index {
    get
  }
  public var endIndex: MusicKit.MusicItemCollection<MusicItemType>.Index {
    get
  }
  public func index(before i: MusicKit.MusicItemCollection<MusicItemType>.Index) -> MusicKit.MusicItemCollection<MusicItemType>.Index
  public func formIndex(before i: inout MusicKit.MusicItemCollection<MusicItemType>.Index)
  public func index(after i: MusicKit.MusicItemCollection<MusicItemType>.Index) -> MusicKit.MusicItemCollection<MusicItemType>.Index
  public func formIndex(after i: inout MusicKit.MusicItemCollection<MusicItemType>.Index)
  public func index(_ i: MusicKit.MusicItemCollection<MusicItemType>.Index, offsetBy distance: Swift.Int) -> MusicKit.MusicItemCollection<MusicItemType>.Index
  public func index(_ i: MusicKit.MusicItemCollection<MusicItemType>.Index, offsetBy distance: Swift.Int, limitedBy limit: MusicKit.MusicItemCollection<MusicItemType>.Index) -> MusicKit.MusicItemCollection<MusicItemType>.Index?
  public func distance(from start: MusicKit.MusicItemCollection<MusicItemType>.Index, to end: MusicKit.MusicItemCollection<MusicItemType>.Index) -> Swift.Int
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, macOS 12.0, *)
  public typealias Iterator = Swift.IndexingIterator<MusicKit.MusicItemCollection<MusicItemType>>
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicItemCollection : Swift.Equatable where MusicItemType : Swift.Equatable {
  public static func == (left: MusicKit.MusicItemCollection<MusicItemType>, right: MusicKit.MusicItemCollection<MusicItemType>) -> Swift.Bool
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicItemCollection : Swift.Hashable where MusicItemType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicItemCollection : Swift.Sendable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicItemCollection : Swift.Decodable where MusicItemType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicItemCollection : Swift.Encodable where MusicItemType : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicItemCollection : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
public struct PlayParameters : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public static func == (a: MusicKit.PlayParameters, b: MusicKit.PlayParameters) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.PlayParameters : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.EntryInsertionPosition : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.EntryInsertionPosition : Swift.Hashable {}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.RepeatMode : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.RepeatMode : Swift.Hashable {}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.ShuffleMode : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, visionOS 1.0, macOS 14.0, *)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.ShuffleMode : Swift.Hashable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicRelationshipPropertyKind : Swift.Equatable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicRelationshipPropertyKind : Swift.Hashable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicSubscription.Error : Swift.Equatable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicSubscription.Error : Swift.Hashable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicSubscription.Error : Swift.RawRepresentable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicTokenRequestError : Swift.Equatable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicTokenRequestError : Swift.Hashable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicTokenRequestError : Swift.RawRepresentable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicAuthorization.Status : Swift.Equatable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicAuthorization.Status : Swift.Hashable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension MusicKit.MusicAuthorization.Status : Swift.RawRepresentable {}
@available(iOS 16.1, tvOS 16.1, watchOS 9.1, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrary.Error : Swift.Equatable {}
@available(iOS 16.1, tvOS 16.1, watchOS 9.1, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrary.Error : Swift.Hashable {}
@available(iOS 16.1, tvOS 16.1, watchOS 9.1, visionOS 1.0, macOS 14.0, macCatalyst 17.0, *)
extension MusicKit.MusicLibrary.Error : Swift.RawRepresentable {}
