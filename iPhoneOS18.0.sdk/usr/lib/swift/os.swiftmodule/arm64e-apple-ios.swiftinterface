// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0 effective-5.10 (swiftlang-6.0.0.7.24 clang-1600.0.25.1)
// swift-module-flags: -target arm64e-apple-ios18.0 -enable-objc-interop -assert-config DisableReplacement -autolink-force-load -enable-library-evolution -module-link-name swiftos -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-bare-slash-regex -user-module-version 1062.0.2 -module-name os
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@_exported import os.log
@_exported import os
@_exported import os.signpost
@_exported import os.workgroup
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct OSLogFloatFormatting {
  @usableFromInline
  internal var explicitPositiveSign: Swift.Bool
  @usableFromInline
  internal var uppercase: Swift.Bool
  @usableFromInline
  internal var precision: (() -> Swift.Int)?
  @usableFromInline
  internal enum Notation {
    case hex
    case fixed
    case exponential
    case hybrid
    @usableFromInline
    internal static func == (a: os.OSLogFloatFormatting.Notation, b: os.OSLogFloatFormatting.Notation) -> Swift.Bool
    @usableFromInline
    internal func hash(into hasher: inout Swift.Hasher)
    @usableFromInline
    internal var hashValue: Swift.Int {
      @usableFromInline
      get
    }
  }
  @usableFromInline
  internal var notation: os.OSLogFloatFormatting.Notation
  @usableFromInline
  @_transparent internal init(explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false, precision: (() -> Swift.Int)?, notation: os.OSLogFloatFormatting.Notation) {
    self.explicitPositiveSign = explicitPositiveSign
    self.uppercase = uppercase
    self.precision = precision
    self.notation = notation
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var fixed: os.OSLogFloatFormatting {
    get { .fixed() }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func fixed(precision: @autoclosure @escaping () -> Swift.Int, explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> os.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: precision,
      notation: .fixed
    )
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func fixed(explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> os.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: nil,
      notation: .fixed
    )
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var hex: os.OSLogFloatFormatting {
    get { .hex() }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func hex(explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> os.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: nil,
      notation: .hex
    )
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var exponential: os.OSLogFloatFormatting {
    get { .exponential() }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func exponential(precision: @autoclosure @escaping () -> Swift.Int, explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> os.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: precision,
      notation: .exponential
    )
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func exponential(explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> os.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: nil,
      notation: .exponential
    )
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var hybrid: os.OSLogFloatFormatting {
    get { .hybrid() }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func hybrid(precision: @autoclosure @escaping () -> Swift.Int, explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> os.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: precision,
      notation: .hybrid
    )
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func hybrid(explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> os.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: nil,
      notation: .hybrid
    )
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogFloatFormatting {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal static func _formatStringLengthModifier<I>(_ type: I.Type) -> Swift.String? where I : Swift.FloatingPoint {
    switch type {
     
    case is Float.Type: return ""
    case is Double.Type: return ""
    default: return nil
    }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) internal func formatSpecifier<I>(for type: I.Type, align: os.OSLogStringAlignment, privacy: os.OSLogPrivacy, attributes: Swift.String) -> Swift.String where I : Swift.FloatingPoint {
    var specification = "%"
     
     
    if let privacyAndAttr = concatPrivacyAndAttributes(privacy: privacy,
                                                       attributes: attributes) {
      specification += "{"
      specification += privacyAndAttr
      specification += "}"
    }

     
     
     
    if explicitPositiveSign {
      specification += "+"
    }

     
     
    if case .start = align.anchor {
      specification += "-"
    }

    if let _ = align.minimumColumnWidth {
       
       
      specification += "*"
    }

    if let _ = precision {
      specification += ".*"
    }

    guard let lengthModifier =
      OSLogFloatFormatting._formatStringLengthModifier(type) else {
      fatalError("Float type has unknown length")
    }
    specification += lengthModifier

     
    switch notation {
    case .fixed:
      specification += (uppercase ? "F" : "f")
    case .exponential:
      specification += (uppercase ? "E" : "e")
    case .hybrid:
      specification += (uppercase ? "G" : "g")
    case .hex:
       
      specification += (uppercase ? "A" : "a")
    default:
      fatalError("Unknown float notation")
    }
    return specification
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogInterpolation {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ argumentObject: @autoclosure @escaping () -> ObjectiveC.NSObject, privacy: os.OSLogPrivacy = .auto) {
    appendInterpolation(argumentObject() as Optional, privacy: privacy, attributes: "")
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ argumentObject: @autoclosure @escaping () -> ObjectiveC.NSObject, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String) {
    appendInterpolation(argumentObject() as Optional, privacy: privacy, attributes: attributes)
  }
  @_alwaysEmitIntoClient @_optimize(none) @_semantics("constant_evaluable") @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ object: @autoclosure @escaping () -> ObjectiveC.NSObject?, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String = "") {
    guard argumentCount < maxOSLogArgumentCount else { return }

    formatString += getNSObjectFormatSpecifier(privacy, attributes)
     
    if privacy.hasMask {
      appendMaskArgument(privacy)
    }
    addNSObjectHeaders(privacy)
    arguments.append(object)
    argumentCount += 1
    objectArgumentCount += 1
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func addNSObjectHeaders(_ privacy: os.OSLogPrivacy) {
     
    let header = getArgumentHeader(privacy: privacy, type: .object)
    arguments.append(header)

     
    let byteCount = pointerSizeInBytes()
    arguments.append(UInt8(byteCount))

     
     
     
    totalBytesForSerializingArguments += byteCount + 2

    preamble = getUpdatedPreamble(privacy: privacy, isScalar: false)
  }
  @_alwaysEmitIntoClient @_semantics("constant_evaluable") @_effects(readonly) @_optimize(none) internal func getNSObjectFormatSpecifier(_ privacy: os.OSLogPrivacy, _ attributes: Swift.String) -> Swift.String {
    var specifier = "%"
     
     
    if let privacyAndAttr = concatPrivacyAndAttributes(privacy: privacy,
                                                       attributes: attributes) {
      specifier += "{"
      specifier += privacyAndAttr
      specifier += "}"
    }
    specifier += "@"
    return specifier
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogArguments {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func append(_ value: @escaping () -> ObjectiveC.NSObject?) {
    argumentClosures.append({ (position, objectArguments, _) in
      serialize(value(), at: &position, storingObjectsIn: &objectArguments)
    })
  }
}
@_alwaysEmitIntoClient @inline(__always) internal func serialize(_ object: ObjectiveC.NSObject?, at bufferPosition: inout os.ByteBufferPointer, storingObjectsIn objectArguments: inout os.ObjectStorage<ObjectiveC.NSObject?>) {
  let byteCount = pointerSizeInBytes();
  let dest =
    UnsafeMutableRawBufferPointer(start: bufferPosition, count: byteCount)

  if let object = object {
     
    let objectAddress = Unmanaged.passUnretained(object).toOpaque()
     
     
     
    _withUnprotectedUnsafeBytes(of: objectAddress) { dest.copyMemory(from: $0) }
  } else {
     
    withUnsafeBytes(of: 0) { dest.copyMemory(from: $0) }
  }

  bufferPosition += byteCount
   
   
  initializeAndAdvance(&objectArguments, to: object)
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public enum OSLogPointerFormat {
  case ipv6Address
  case timeval
  case timespec
  case uuid
  case sockaddr
  case none
  public static func == (a: os.OSLogPointerFormat, b: os.OSLogPointerFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogInterpolation {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ pointer: @autoclosure @escaping () -> Swift.UnsafeRawBufferPointer, format: os.OSLogPointerFormat = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInterpolation(
      pointer().baseAddress!,
      bytes: pointer().count,
      format: format,
      privacy: privacy,
      attributes: "")
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ pointer: @autoclosure @escaping () -> Swift.UnsafeRawBufferPointer, format: os.OSLogPointerFormat = .none, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String) {
    appendInterpolation(
      pointer().baseAddress!,
      bytes: pointer().count,
      format: format,
      privacy: privacy,
      attributes: attributes)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ pointer: @autoclosure @escaping () -> Swift.UnsafeRawPointer, bytes: @autoclosure @escaping () -> Swift.Int, format: os.OSLogPointerFormat = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInterpolation(pointer(), bytes: bytes(), format: format, privacy: privacy, attributes: "")
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ pointer: @autoclosure @escaping () -> Swift.UnsafeRawPointer, bytes: @autoclosure @escaping () -> Swift.Int, format: os.OSLogPointerFormat = .none, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String) {
    guard argumentCount < maxOSLogArgumentCount else { return }

    formatString += getPointerFormatSpecifier(format, privacy, attributes)
     
    if privacy.hasMask {
      appendMaskArgument(privacy)
    }
     
    appendPrecisionArgument(bytes)
     
    addPointerHeaders(privacy)
    arguments.append(pointer)
    argumentCount += 1
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func addPointerHeaders(_ privacy: os.OSLogPrivacy) {
     
    let header = getArgumentHeader(privacy: privacy, type: .pointer)
    arguments.append(header)
     
    let byteCount = pointerSizeInBytes()
    arguments.append(UInt8(byteCount))
     
     
     
    totalBytesForSerializingArguments += byteCount + 2
    preamble = getUpdatedPreamble(privacy: privacy, isScalar: false)
  }
  @_alwaysEmitIntoClient @_semantics("constant_evaluable") @_effects(readonly) @_optimize(none) internal func getPointerFormatSpecifier(_ format: os.OSLogPointerFormat, _ privacy: os.OSLogPrivacy, _ attributes: Swift.String) -> Swift.String {
    var hasFormat: Bool = true
    if case .none = format {
      hasFormat = false
    }
    let privacyAndAttr = concatPrivacyAndAttributes(privacy: privacy,
                                                    attributes: attributes)
    let hasPrivacyAndAttr: Bool = privacyAndAttr != nil
    let hasTag = hasFormat || hasPrivacyAndAttr
    let hasBoth = hasFormat && hasPrivacyAndAttr
    var specifier = "%"
    if hasTag {
      specifier += "{"
    }
     
    switch (format) {
    case .ipv6Address:
      specifier += "network:in6_addr"
    case .timeval:
      specifier += "timeval"
    case .timespec:
      specifier += "timespec"
    case .uuid:
      specifier += "uuid_t"
    case .sockaddr:
      specifier += "network:sockaddr"
    default:
      break
    }
    if hasBoth {
      specifier += ","
    }
     
    if let privacyAndAttr = privacyAndAttr {
      specifier += privacyAndAttr
    }
    if hasTag {
      specifier += "}"
    }
    specifier += ".*P"
    return specifier
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogArguments {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func append(_ value: @escaping () -> Swift.UnsafeRawPointer) {
    argumentClosures.append({ (position, _, _) in
      serialize(value(), at: &position)
    })
  }
}
@_alwaysEmitIntoClient @inline(__always) internal func serialize(_ pointer: Swift.UnsafeRawPointer, at bufferPosition: inout os.ByteBufferPointer) {
  let byteCount = pointerSizeInBytes();
  let dest =
    UnsafeMutableRawBufferPointer(start: bufferPosition, count: byteCount)
   
   
   
  withUnsafeBytes(of: pointer) { dest.copyMemory(from: $0) }
  bufferPosition += byteCount
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public func os_signpost(_ type: os.OSSignpostType, dso: Swift.UnsafeRawPointer = #dsohandle, log: os.OSLog, name: Swift.StaticString, signpostID: os.OSSignpostID = .exclusive)
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public func os_signpost(_ type: os.OSSignpostType, dso: Swift.UnsafeRawPointer = #dsohandle, log: os.OSLog, name: Swift.StaticString, signpostID: os.OSSignpostID = .exclusive, _ format: Swift.StaticString, _ arguments: any Swift.CVarArg...)
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public enum AnimationFormatString {
  @inlinable @_optimize(none) @_semantics("constant_evaluable") internal static func constructOSLogInterpolation(_ formatString: Swift.String) -> os.OSLogInterpolation {
    var s = OSLogInterpolation(literalCapacity: 1, interpolationCount: 0)
    s.formatString += formatString
    s.formatString += " isAnimation=YES"
    return s
  }
  @frozen public struct OSLogMessage : Swift.ExpressibleByStringLiteral {
    @usableFromInline
    internal var formatStringPointer: Swift.UnsafePointer<Swift.CChar>
    @_transparent public init(stringLiteral value: Swift.String) {
       
       
       
       
      let message =
        os.OSLogMessage(
          stringInterpolation:
            constructOSLogInterpolation(
              value))
      let formatString = message.interpolation.formatString
      formatStringPointer = _getGlobalStringTablePointer(formatString)
    }
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias StringLiteralType = Swift.String
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias UnicodeScalarLiteralType = Swift.String
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public enum OSSignpostAnimationBegin {
  case animationBegin
  public static func == (a: os.OSSignpostAnimationBegin, b: os.OSSignpostAnimationBegin) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@usableFromInline
internal func animationBeginSignpostHelper(dso: Swift.UnsafeRawPointer, log: os.OSLog, name: Swift.StaticString, signpostID: os.OSSignpostID, formatStringPointer: Swift.UnsafePointer<Swift.CChar>, arguments: [any Swift.CVarArg])
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@_transparent public func os_signpost(_ animationBegin: os.OSSignpostAnimationBegin, dso: Swift.UnsafeRawPointer = #dsohandle, log: os.OSLog, name: Swift.StaticString, signpostID: os.OSSignpostID = .exclusive, _ format: os.AnimationFormatString.OSLogMessage, _ arguments: any Swift.CVarArg...) {
   
   
   
  animationBeginSignpostHelper(
    dso: dso,
    log: log,
    name: name,
    signpostID: signpostID,
    formatStringPointer: format.formatStringPointer,
    arguments: arguments)
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@_transparent public func os_signpost(_ animationBegin: os.OSSignpostAnimationBegin, dso: Swift.UnsafeRawPointer = #dsohandle, log: os.OSLog, name: Swift.StaticString, signpostID: os.OSSignpostID = .exclusive) {
   
   
   
   
   
  let formatStringPointer = _getGlobalStringTablePointer("isAnimation=YES")
  animationBeginSignpostHelper(
    dso: dso,
    log: log,
    name: name,
    signpostID: signpostID,
    formatStringPointer: formatStringPointer,
    arguments: [])
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension os.OSSignpostType {
  public static let event: os.OSSignpostType
  public static let begin: os.OSSignpostType
  public static let end: os.OSSignpostType
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public struct OSSignpostID : Swift.Sendable {
  public let rawValue: os.os_signpost_id_t
  public static let exclusive: os.OSSignpostID
  public static let invalid: os.OSSignpostID
  public static let null: os.OSSignpostID
  public init(log: os.OSLog)
  public init(log: os.OSLog, object: Swift.AnyObject)
  public init(_ value: Swift.UInt64)
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension os.OSSignpostID : Swift.Comparable {
  public static func < (a: os.OSSignpostID, b: os.OSSignpostID) -> Swift.Bool
  public static func == (a: os.OSSignpostID, b: os.OSSignpostID) -> Swift.Bool
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension os.OSLog {
  public struct Category : Swift.Sendable {
    public let rawValue: Swift.String
    public static let pointsOfInterest: os.OSLog.Category
  }
  convenience public init(subsystem: Swift.String, category: os.OSLog.Category)
  public var signpostsEnabled: Swift.Bool {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension os.OSLog.Category {
  public static let dynamicTracing: os.OSLog.Category
  public static let dynamicStackTracing: os.OSLog.Category
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogInterpolation {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Int, format: os.OSLogIntegerFormatting = .decimal, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInteger(number, format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Int8, format: os.OSLogIntegerFormatting = .decimal, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInteger(number, format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Int16, format: os.OSLogIntegerFormatting = .decimal, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInteger(number, format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Int32, format: os.OSLogIntegerFormatting = .decimal, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInteger(number, format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Int64, format: os.OSLogIntegerFormatting = .decimal, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInteger(number, format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.UInt, format: os.OSLogIntegerFormatting = .decimal, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInteger(number, format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.UInt8, format: os.OSLogIntegerFormatting = .decimal, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInteger(number, format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.UInt16, format: os.OSLogIntegerFormatting = .decimal, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInteger(number, format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.UInt32, format: os.OSLogIntegerFormatting = .decimal, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInteger(number, format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.UInt64, format: os.OSLogIntegerFormatting = .decimal, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInteger(number, format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation<T>(_ number: @autoclosure @escaping () -> T, format: os.OSLogIntegerFormatting = .decimal, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String) where T : Swift.FixedWidthInteger {
    appendInteger(number, format: format, align: align, privacy: privacy, attributes: attributes)
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) internal mutating func appendInteger<T>(_ number: @escaping () -> T, format: os.OSLogIntegerFormatting, align: os.OSLogStringAlignment, privacy: os.OSLogPrivacy, attributes: Swift.String = "") where T : Swift.FixedWidthInteger {
    guard argumentCount < maxOSLogArgumentCount else { return }
    formatString +=
      format.formatSpecifier(for: T.self, align: align, privacy: privacy, attributes: attributes)

     
     
    if let minColumns = align.minimumColumnWidth {
      appendAlignmentArgument(minColumns)
    }

     
     
    if privacy.hasMask {
      appendMaskArgument(privacy)
    }

     
     
     
    if let minDigits = format.minDigits {
      appendPrecisionArgument(minDigits)
    }

     
    addIntHeaders(privacy, sizeForEncoding(T.self))
    arguments.append(number)
    argumentCount += 1
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func addIntHeaders(_ privacy: os.OSLogPrivacy, _ byteCount: Swift.Int) {
     
    let argumentHeader = getArgumentHeader(privacy: privacy, type: .scalar)
    arguments.append(argumentHeader)

     
    arguments.append(UInt8(byteCount))

     
     
     
    totalBytesForSerializingArguments += byteCount + 2

    preamble = getUpdatedPreamble(privacy: privacy, isScalar: true)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func appendPrecisionArgument(_ count: @escaping () -> Swift.Int) {
    appendPrecisionAlignCount(
      count,
      getArgumentHeader(privacy: .auto, type: .count))
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func appendAlignmentArgument(_ count: @escaping () -> Swift.Int) {
    appendPrecisionAlignCount(
      count,
      getArgumentHeader(privacy: .auto, type: .scalar))
  }
  @_transparent @inlinable internal mutating func appendPrecisionAlignCount(_ count: @escaping () -> Swift.Int, _ argumentHeader: Swift.UInt8) {
    arguments.append(argumentHeader)
     
    arguments.append(4)
     
     
     
    totalBytesForSerializingArguments += 6
     
    arguments.append({ CInt(count()) })
    argumentCount += 1
     
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func appendMaskArgument(_ privacy: os.OSLogPrivacy) {
    arguments.append(getArgumentHeader(privacy: .auto, type: .mask))
     
    arguments.append(8)
     
     
     
    totalBytesForSerializingArguments += 10
     
    let maskValue = privacy.maskValue
    arguments.append({ maskValue })
    argumentCount += 1
     
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogArguments {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func append<T>(_ value: @escaping () -> T) where T : Swift.FixedWidthInteger {
    argumentClosures.append({ (position, _, _) in
      serialize(value(), at: &position)
    })
  }
}
@_transparent @_alwaysEmitIntoClient internal func sizeForEncoding<T>(_ type: T.Type) -> Swift.Int where T : Swift.FixedWidthInteger {
  return type.bitWidth &>> logBitsPerByte
}
@_alwaysEmitIntoClient @inline(__always) internal func serialize<T>(_ value: T, at bufferPosition: inout os.ByteBufferPointer) where T : Swift.FixedWidthInteger {
  let byteCount = sizeForEncoding(T.self)
  let dest =
    UnsafeMutableRawBufferPointer(start: bufferPosition, count: byteCount)
  _withUnprotectedUnsafeBytes(of: value) { dest.copyMemory(from: $0) }
  bufferPosition += byteCount
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public func os_log(_ type: os.OSLogType, dso: Swift.UnsafeRawPointer = #dsohandle, log: os.OSLog = .default, _ message: Swift.StaticString, _ args: any Swift.CVarArg...)
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
public func os_log(_ message: Swift.StaticString, dso: Swift.UnsafeRawPointer? = #dsohandle, log: os.OSLog = .default, type: os.OSLogType = .default, _ args: any Swift.CVarArg...)
extension os.OSLogType {
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static let `default`: os.OSLogType
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static let info: os.OSLogType
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static let debug: os.OSLogType
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static let error: os.OSLogType
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static let fault: os.OSLogType
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension os.OSLog : @unchecked Swift.Sendable {
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static let disabled: os.OSLog
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static let `default`: os.OSLog
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  convenience public init(subsystem: Swift.String, category: Swift.String)
}
@available(*, unavailable, renamed: "OSLogType.default")
public var OS_LOG_TYPE_DEFAULT: os.OSLogType {
  get
}
@available(*, unavailable, renamed: "OSLogType.info")
public var OS_LOG_TYPE_INFO: os.OSLogType {
  get
}
@available(*, unavailable, renamed: "OSLogType.debug")
public var OS_LOG_TYPE_DEBUG: os.OSLogType {
  get
}
@available(*, unavailable, renamed: "OSLogType.error")
public var OS_LOG_TYPE_ERROR: os.OSLogType {
  get
}
@available(*, unavailable, renamed: "OSLogType.fault")
public var OS_LOG_TYPE_FAULT: os.OSLogType {
  get
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogInterpolation {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Float, format: os.OSLogFloatFormatting = .fixed, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInterpolation(Double(number()), format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Float, format: os.OSLogFloatFormatting = .fixed, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String) {
    appendInterpolation(Double(number()), format: format, align: align, privacy: privacy, attributes: attributes)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Double, format: os.OSLogFloatFormatting = .fixed, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInterpolation(number(), format: format, align: align, privacy: privacy, attributes: "")
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Double, format: os.OSLogFloatFormatting = .fixed, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String) {
    guard argumentCount < maxOSLogArgumentCount else { return }
    formatString +=
      format.formatSpecifier(for: Double.self, align: align, privacy: privacy, attributes: attributes)

     
     
    if let minColumns = align.minimumColumnWidth {
      appendAlignmentArgument(minColumns)
    }

     
     
    if privacy.hasMask {
      appendMaskArgument(privacy)
    }

     
     
     
    if let precision = format.precision {
      appendPrecisionArgument(precision)
    }
     
    addDoubleHeaders(privacy)
    arguments.append(number)
    argumentCount += 1
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func addDoubleHeaders(_ privacy: os.OSLogPrivacy) {
     
    let argumentHeader = getArgumentHeader(privacy: privacy, type: .scalar)
    arguments.append(argumentHeader)

     
    let byteCount = doubleSizeInBytes()
    arguments.append(UInt8(byteCount))

     
     
     
    totalBytesForSerializingArguments += byteCount + 2

    preamble = getUpdatedPreamble(privacy: privacy, isScalar: true)
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogArguments {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func append(_ value: @escaping () -> Swift.Double) {
    argumentClosures.append({ (position, _, _) in
      serialize(value(), at: &position)
    })
  }
}
@_transparent @_alwaysEmitIntoClient internal func doubleSizeInBytes() -> Swift.Int {
  return 8
}
@_alwaysEmitIntoClient @inline(__always) internal func serialize(_ value: Swift.Double, at bufferPosition: inout os.ByteBufferPointer) {
  let byteCount = doubleSizeInBytes()
  let dest =
    UnsafeMutableRawBufferPointer(start: bufferPosition, count: byteCount)
  _withUnprotectedUnsafeBytes(of: value) { dest.copyMemory(from: $0) }
  bufferPosition += byteCount
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct OSLogIntegerFormatting {
  @usableFromInline
  internal var radix: Swift.Int
  @usableFromInline
  internal var explicitPositiveSign: Swift.Bool
  @usableFromInline
  internal var includePrefix: Swift.Bool
  @usableFromInline
  internal var uppercase: Swift.Bool
  @usableFromInline
  internal var minDigits: (() -> Swift.Int)?
  @usableFromInline
  @_transparent internal init(radix: Swift.Int = 10, explicitPositiveSign: Swift.Bool = false, includePrefix: Swift.Bool = false, uppercase: Swift.Bool = false, minDigits: (() -> Swift.Int)?) {
    self.radix = radix
    self.explicitPositiveSign = explicitPositiveSign
    self.includePrefix = includePrefix
    self.uppercase = uppercase
    self.minDigits = minDigits
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func decimal(explicitPositiveSign: Swift.Bool = false, minDigits: @autoclosure @escaping () -> Swift.Int) -> os.OSLogIntegerFormatting {
    return OSLogIntegerFormatting(
      radix: 10,
      explicitPositiveSign: explicitPositiveSign,
      minDigits: minDigits)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func decimal(explicitPositiveSign: Swift.Bool = false) -> os.OSLogIntegerFormatting {
    return OSLogIntegerFormatting(
      radix: 10,
      explicitPositiveSign: explicitPositiveSign,
      minDigits: nil)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var decimal: os.OSLogIntegerFormatting {
    get { .decimal() }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func hex(explicitPositiveSign: Swift.Bool = false, includePrefix: Swift.Bool = false, uppercase: Swift.Bool = false, minDigits: @autoclosure @escaping () -> Swift.Int) -> os.OSLogIntegerFormatting {
    return OSLogIntegerFormatting(
      radix: 16,
      explicitPositiveSign: explicitPositiveSign,
      includePrefix: includePrefix,
      uppercase: uppercase,
      minDigits: minDigits)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func hex(explicitPositiveSign: Swift.Bool = false, includePrefix: Swift.Bool = false, uppercase: Swift.Bool = false) -> os.OSLogIntegerFormatting {
    return OSLogIntegerFormatting(
      radix: 16,
      explicitPositiveSign: explicitPositiveSign,
      includePrefix: includePrefix,
      uppercase: uppercase,
      minDigits: nil)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var hex: os.OSLogIntegerFormatting {
    get { .hex() }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func octal(explicitPositiveSign: Swift.Bool = false, includePrefix: Swift.Bool = false, uppercase: Swift.Bool = false, minDigits: @autoclosure @escaping () -> Swift.Int) -> os.OSLogIntegerFormatting {
    OSLogIntegerFormatting(
      radix: 8,
      explicitPositiveSign: explicitPositiveSign,
      includePrefix: includePrefix,
      uppercase: uppercase,
      minDigits: minDigits)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func octal(explicitPositiveSign: Swift.Bool = false, includePrefix: Swift.Bool = false, uppercase: Swift.Bool = false) -> os.OSLogIntegerFormatting {
    OSLogIntegerFormatting(
      radix: 8,
      explicitPositiveSign: explicitPositiveSign,
      includePrefix: includePrefix,
      uppercase: uppercase,
      minDigits: nil)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var octal: os.OSLogIntegerFormatting {
    get { .octal() }
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogIntegerFormatting {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal var _prefix: Swift.String {
    get {
    guard includePrefix else { return "" }
    switch radix {
    case 2: return "0b"
    case 8: return "0o"
    case 16: return "0x"
    default: return ""
    }
  }
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogIntegerFormatting {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal static func formatSpecifierLengthModifier<I>(_ type: I.Type) -> Swift.String? where I : Swift.FixedWidthInteger {
     
    switch type {
     
     
    case is CChar.Type: return "hh"
    case is CUnsignedChar.Type: return "hh"

     
     
    case is CShort.Type: return "h"
    case is CUnsignedShort.Type: return "h"

    case is CInt.Type: return ""
    case is CUnsignedInt.Type: return ""

     
     
    case is CLong.Type: return "l"
    case is CUnsignedLong.Type: return "l"

     
     
    case is CLongLong.Type: return "ll"
    case is CUnsignedLongLong.Type: return "ll"

    default: return nil
    }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) @_effects(readonly) internal func formatSpecifier<I>(for type: I.Type, align: os.OSLogStringAlignment, privacy: os.OSLogPrivacy, attributes: Swift.String) -> Swift.String where I : Swift.FixedWidthInteger {
     
     
    if (type.isSigned && radix != 10) {
      fatalError("Signed integers must be formatted using .decimal")
    }

     
     
     
     
     
     
     
     
     
     
     
     
     
     

     
    var specification = _prefix
    specification += "%"

     
     
    if let privacyAndAttr = concatPrivacyAndAttributes(privacy: privacy,
                                                       attributes: attributes) {
      specification += "{"
      specification += privacyAndAttr
      specification += "}"
    }

     
     
     
     
    if explicitPositiveSign {
       
       
      if type.isSigned {
        specification += "+"
      } else {
        var newSpecification = "+"
        newSpecification += specification
        specification = newSpecification
      }
    }

     
     
     
    if case .start = align.anchor {
      specification += "-"
    }

     
     
     
     
     
     
     
     
     
     
     
     
     
     
    if let _ = align.minimumColumnWidth {
       
       
      specification += "*"
    }

     

     
     
     
    if let _ = minDigits {
      specification += ".*"
    }

     
    guard let lengthModifier =
      OSLogIntegerFormatting.formatSpecifierLengthModifier(type) else {
      fatalError("Integer type has unknown byte length")
    }
    specification += lengthModifier

     
    switch radix {
    case 10:
      specification += type.isSigned ? "d" : "u"
    case 8:
      specification += "o"
    case 16:
      specification += uppercase ? "X" : "x"
    default:
      fatalError("radix must be 10, 8 or 16")
    }
    return specification
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct OSLogPrivacy {
  @usableFromInline
  internal enum PrivacyOption {
    case `private`
    case `public`
    case sensitive
    case auto
    @usableFromInline
    internal static func == (a: os.OSLogPrivacy.PrivacyOption, b: os.OSLogPrivacy.PrivacyOption) -> Swift.Bool
    @usableFromInline
    internal func hash(into hasher: inout Swift.Hasher)
    @usableFromInline
    internal var hashValue: Swift.Int {
      @usableFromInline
      get
    }
  }
  public enum Mask {
    case hash
    case none
    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    case _mailName
    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    case _mailAddress
    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    case _mailSubject
    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    case _mailSummary
    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    case _mailAccount
    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    case _mailbox
    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    case _mailboxPath
    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    case _mailAttachmentFileName
    public static func == (a: os.OSLogPrivacy.Mask, b: os.OSLogPrivacy.Mask) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum _MailMask {
    case name
    case address
    case subject
    case summary
    case account
    case mailbox
    case mailboxPath
    case attachmentFileName
    public static func == (a: os.OSLogPrivacy._MailMask, b: os.OSLogPrivacy._MailMask) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @usableFromInline
  internal var privacy: os.OSLogPrivacy.PrivacyOption
  @usableFromInline
  internal var mask: os.OSLogPrivacy.Mask
  @usableFromInline
  @_transparent internal init(privacy: os.OSLogPrivacy.PrivacyOption, mask: os.OSLogPrivacy.Mask) {
    self.privacy = privacy
    self.mask = mask
  }
  @_semantics("constant_evaluable") @_optimize(none) @inlinable public static var `public`: os.OSLogPrivacy {
    get {
    OSLogPrivacy(privacy: .public, mask: .none)
  }
  }
  @_semantics("constant_evaluable") @_optimize(none) @inlinable public static var `private`: os.OSLogPrivacy {
    get {
    OSLogPrivacy(privacy: .private, mask: .none)
  }
  }
  @_semantics("constant_evaluable") @_optimize(none) @inlinable public static func `private`(mask: os.OSLogPrivacy.Mask) -> os.OSLogPrivacy {
    OSLogPrivacy(privacy: .private, mask: mask)
  }
  @_semantics("constant_evaluable") @_optimize(none) @inlinable public static var sensitive: os.OSLogPrivacy {
    get {
    OSLogPrivacy(privacy: .sensitive, mask: .none)
  }
  }
  @_semantics("constant_evaluable") @_optimize(none) @inlinable public static func sensitive(mask: os.OSLogPrivacy.Mask) -> os.OSLogPrivacy {
    return OSLogPrivacy(privacy: .sensitive, mask: mask)
  }
  @_semantics("constant_evaluable") @_optimize(none) @inlinable public static var auto: os.OSLogPrivacy {
    get {
    OSLogPrivacy(privacy: .auto, mask: .none)
  }
  }
  @_semantics("constant_evaluable") @_optimize(none) @inlinable public static func auto(mask: os.OSLogPrivacy.Mask) -> os.OSLogPrivacy {
    OSLogPrivacy(privacy: .auto, mask: mask)
  }
  @inlinable @_semantics("constant_evaluable") @_optimize(none) internal var argumentFlag: Swift.UInt8 {
    get {
    switch privacy {
    case .private:
      return 0x1
    case .public:
      return 0x2
    case .sensitive:
      return 0x5
    default:
      return 0
    }
  }
  }
  @inlinable @_semantics("constant_evaluable") @_optimize(none) internal var isAtleastPrivate: Swift.Bool {
    get {
    switch privacy {
    case .public:
      return false
    case .auto:
      return false
    default:
      return true
    }
  }
  }
  @inlinable @_semantics("constant_evaluable") @_optimize(none) internal var needsPrivacySpecifier: Swift.Bool {
    get {
    if case .hash = mask {
      return true
    }
    switch privacy {
    case .auto:
      return false
    default:
      return true
    }
  }
  }
  @inlinable @_transparent internal var hasMask: Swift.Bool {
    @_transparent get {
    if case .none = mask {
      return false
    }
    return true
  }
  }
  @inlinable @_transparent internal var maskValue: Swift.UInt64 {
    @_transparent get {
     
     
     
     
     
     
     
     
     
     
     
     
    switch mask {
    case ._mailName:
      return 0x656d616e6c69616d  
    case ._mailAddress:
      return 0x726464616c69616d  
    case ._mailSubject:
      return 0x6a6275736c69616d  
    case ._mailSummary:
      return 0x6d6d75736c69616d  
    case ._mailAccount:
      return 0x6f6363616c69616d  
    case ._mailbox:
      return 0x786f626c69616d  
    case ._mailboxPath:
      return 0x7075626d6c69616d  
    case ._mailAttachmentFileName:
      return 0x617474616c69616d  
    case .hash,
         .none:
      return 0x68736168  
    @unknown default:
      return 0x68736168  
    }
  }
  }
  @inlinable @_semantics("constant_evaluable") @_optimize(none) internal var privacySpecifier: Swift.String? {
    get {
    let hasMask = self.hasMask
    var isAuto = false
    if case .auto = privacy {
      isAuto = true
    }
    if isAuto, !hasMask {
      return nil
    }
    var specifier: String
    switch privacy {
    case .public:
      specifier = "public"
    case .private:
      specifier = "private"
    case .sensitive:
      specifier = "sensitive"
    default:
      specifier = ""
    }
    if hasMask {
      if !isAuto {
        specifier += ","
      }
      specifier += "mask."
      specifier += maskSpecifier
    }
    return specifier
  }
  }
  @inlinable @_transparent internal var maskSpecifier: Swift.String {
    @_transparent get {
    switch mask {
    case ._mailName:
      return "mailname"
    case ._mailAddress:
      return "mailaddr"
    case ._mailSubject:
      return "mailsubj"
    case ._mailSummary:
      return "mailsumm"
    case ._mailAccount:
      return "mailacco"
    case ._mailbox:
      return "mailbox"
    case ._mailboxPath:
      return "mailmbup"
    case ._mailAttachmentFileName:
      return "mailatta"
    case .hash,
         .none:
      return "hash"
    @unknown default:
      return "hash"
    }
  }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension os_workgroup.WorkGroup {
  @available(macOS 11.0, *)
  public func copyPort() -> _mach_port_t.mach_port_t
  @available(macOS 11.0, *)
  convenience public init?(port: _mach_port_t.mach_port_t, name: Swift.String? = nil)
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public func copy(name: Swift.String? = nil) -> os_workgroup.WorkGroup?
  public struct JoinToken {
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public func join() -> os_workgroup.WorkGroup.JoinToken
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public func leave(token: os_workgroup.WorkGroup.JoinToken)
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public func cancel()
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var isCancelled: Swift.Bool {
    @_effects(readonly) get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var maxParallelThreads: Swift.Int {
    @_effects(readonly) get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public func setWorkingArena(arena: Swift.UnsafeMutableRawPointer?, max_workers: Swift.UInt32, destruct: @convention(c) (Swift.UnsafeMutableRawPointer?) -> Swift.Void)
  public typealias Index = Swift.UInt32
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var workingArena: (Swift.UnsafeMutableRawPointer?, os_workgroup.WorkGroup.Index) {
    @_effects(readonly) get
  }
}
extension os_workgroup.WorkGroup : os_workgroup.Repeatable {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public func start(at timestamp: Swift.UInt64, deadline: Swift.UInt64)
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public func updateDeadline(deadline: Swift.UInt64)
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public func finish()
}
extension os_workgroup.WorkGroupParallel {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  convenience public init?(name: Swift.String? = nil)
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogInterpolation {
  @usableFromInline
  @available(*, unavailable)
  internal mutating func appendInteger<T>(_ number: @escaping () -> T, format: os.OSLogIntegerFormatting, align: os.OSLogStringAlignment, privacy: os.OSLogPrivacy) where T : Swift.FixedWidthInteger
  @usableFromInline
  @available(*, unavailable)
  internal func getNSObjectFormatSpecifier(_ privacy: os.OSLogPrivacy) -> Swift.String
  @usableFromInline
  @available(*, unavailable)
  internal func getPointerFormatSpecifier(_ format: os.OSLogPointerFormat, _ privacy: os.OSLogPrivacy) -> Swift.String
  @usableFromInline
  @available(*, unavailable)
  internal func getStringFormatSpecifier(_ align: os.OSLogStringAlignment, _ privacy: os.OSLogPrivacy) -> Swift.String
  @usableFromInline
  @available(*, unavailable)
  internal func getExtendedFormatSpecifier(_ format: os.OSLogInt32ExtendedFormat, _ privacy: os.OSLogPrivacy) -> Swift.String
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogIntegerFormatting {
  @usableFromInline
  @available(*, unavailable)
  internal func formatSpecifier<I>(for type: I.Type, align: os.OSLogStringAlignment, privacy: os.OSLogPrivacy) -> Swift.String where I : Swift.FixedWidthInteger
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogFloatFormatting {
  @usableFromInline
  @available(*, unavailable)
  internal func formatSpecifier<I>(for type: I.Type, align: os.OSLogStringAlignment, privacy: os.OSLogPrivacy) -> Swift.String where I : Swift.FloatingPoint
}
@usableFromInline
@available(*, unavailable)
internal func serialize(_ stringValue: Swift.String, at bufferPosition: inout Swift.UnsafeMutablePointer<Swift.UInt8>, using stringStorage: inout os.ObjectStorage<Any>)
@usableFromInline
@available(*, unavailable)
internal func getNullTerminatedUTF8Pointer(_ stringValue: Swift.String, using stringStorage: inout os.ObjectStorage<Any>) -> Swift.UnsafeRawPointer
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogInterpolation {
  @_disfavoredOverload @_alwaysEmitIntoClient @_optimize(none) @_semantics("constant_evaluable") @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ error: @autoclosure @escaping () -> any Swift.Error, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String = "") {
     
     
    self.appendInterpolation(unsafeBitCast(_bridgeErrorToNSError(error()), to: NSObject.self), privacy: privacy, attributes: attributes)
  }
  @_disfavoredOverload @_alwaysEmitIntoClient @_optimize(none) @_semantics("constant_evaluable") @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ error: @autoclosure @escaping () -> (any Swift.Error)?, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String = "") {
     
     
    self.appendInterpolation(error().map({ unsafeBitCast(_bridgeErrorToNSError($0), to: NSObject.self) }), privacy: privacy, attributes: attributes)
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public typealias SignpostMetadata = os.OSLogMessage
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public struct OSSignposter : @unchecked Swift.Sendable {
  @usableFromInline
  internal let logHandle: os.OSLog
  public var isEnabled: Swift.Bool {
    get
  }
  public static var disabled: os.OSSignposter {
    get
  }
  public init(subsystem: Swift.String, category: Swift.String)
  public init(subsystem: Swift.String, category: os.OSLog.Category)
  public init()
  public init(logHandle: os.OSLog)
  public init(logger: os.Logger)
  @_transparent @_optimize(none) @_semantics("constant_evaluable") public func emitEvent(_ name: Swift.StaticString, id: os.OSSignpostID = .exclusive, _ message: os.SignpostMetadata) {
    osSignpost(message, log: logHandle, name: name, id: id, type: .event, state: nil)
  }
  @_transparent @_optimize(none) @_semantics("constant_evaluable") public func emitEvent(_ name: Swift.StaticString, id: os.OSSignpostID = .exclusive) {
    osSignpostWithoutMessage(log: logHandle, name: name, id: id, type: .event, state: nil)
  }
  @_transparent @_optimize(none) @_semantics("constant_evaluable") public func beginInterval(_ name: Swift.StaticString, id: os.OSSignpostID = .exclusive, _ message: os.SignpostMetadata) -> os.OSSignpostIntervalState {
    osSignpost(message, log: logHandle, name: name, id: id, type: .begin, state: nil)
    return OSSignpostIntervalState(id: id)
  }
  @_transparent @_optimize(none) @_semantics("constant_evaluable") public func beginInterval(_ name: Swift.StaticString, id: os.OSSignpostID = .exclusive) -> os.OSSignpostIntervalState {
    osSignpostWithoutMessage(log: logHandle, name: name, id: id, type: .begin, state: nil)
    return OSSignpostIntervalState(id: id)
  }
  @_transparent @_optimize(none) @_semantics("constant_evaluable") public func beginAnimationInterval(_ name: Swift.StaticString, id: os.OSSignpostID = .exclusive) -> os.OSSignpostIntervalState {
    osSignpostWithoutMessage(log: logHandle, name: name, id: id, type: .begin, state: nil, formatString: "isAnimation=YES")
    return OSSignpostIntervalState(id: id)
  }
  @_transparent @_optimize(none) @_semantics("constant_evaluable") public func beginAnimationInterval(_ name: Swift.StaticString, id: os.OSSignpostID = .exclusive, _ message: os.SignpostMetadata) -> os.OSSignpostIntervalState {
     
    osSignpost(message, log: logHandle, name: name, id: id, type: .begin, state: nil, formatStringTransform: animationFormatString)
    return OSSignpostIntervalState(id: id)
  }
  @_transparent @_optimize(none) @_semantics("constant_evaluable") public func endInterval(_ name: Swift.StaticString, _ state: os.OSSignpostIntervalState, _ message: os.SignpostMetadata) {
    osSignpost(message, log: logHandle, name: name, id: state.signpostID, type: .end, state: state)
  }
  @_transparent @_optimize(none) @_semantics("constant_evaluable") public func endInterval(_ name: Swift.StaticString, _ state: os.OSSignpostIntervalState) {
    osSignpostWithoutMessage(log: logHandle, name: name, id: state.signpostID, type: .end, state: state)
  }
  @_transparent @_optimize(none) @_semantics("constant_evaluable") public func withIntervalSignpost<T>(_ name: Swift.StaticString, id: os.OSSignpostID = .exclusive, _ message: os.SignpostMetadata, around task: () throws -> T) rethrows -> T {
    let formatString = message.interpolation.formatString
    let preamble = message.interpolation.preamble
    let argumentCount = message.interpolation.argumentCount
    let bufferSize = message.bufferSize
    let objectCount = message.interpolation.objectArgumentCount
    let stringCount = message.interpolation.stringArgumentCount
    let argumentClosures = message.interpolation.arguments.argumentClosures

    let nameStringPointer = _globalStringTablePointerOfStaticString(name)
    let formatStringPointer = _getGlobalStringTablePointer(formatString)

    return try emitSignpost(
      preamble: preamble,
      argumentCount: argumentCount,
      bufferSize: bufferSize,
      objectCount: objectCount,
      stringCount: stringCount,
      argumentClosures: argumentClosures) {
        try callSignpostAroundTask(
          dsoHandle: UnsafeMutableRawPointer(mutating: #dsohandle),
          log: logHandle,
          id: id,
          nameStringPointer: nameStringPointer,
          formatStringPointer: formatStringPointer,
          bufferMemory: $0,
          uint32bufferSize: $1,
          task: task
        )
    }
  }
  @_transparent @_optimize(none) @_semantics("constant_evaluable") public func withIntervalSignpost<T>(_ name: Swift.StaticString, id: os.OSSignpostID = .exclusive, around task: () throws -> T) rethrows -> T {
    let nameStringPointer = _globalStringTablePointerOfStaticString(name)
    let formatStringPointer = _getGlobalStringTablePointer("")

    return try emitSignpost(
      preamble: 0,
      argumentCount: 0,
      bufferSize: 2,
      objectCount: 0,
      stringCount: 0,
      argumentClosures: []) {
        try callSignpostAroundTask(
          dsoHandle: UnsafeMutableRawPointer(mutating: #dsohandle),
          log: logHandle,
          id: id,
          nameStringPointer: nameStringPointer,
          formatStringPointer: formatStringPointer,
          bufferMemory: $0,
          uint32bufferSize: $1,
          task: task
        )
    }
  }
  @inlinable @inline(__always) public func makeSignpostID() -> os.OSSignpostID {
    return OSSignpostID(log: logHandle)
  }
  @inlinable @inline(__always) public func makeSignpostID(from object: Swift.AnyObject) -> os.OSSignpostID {
    return OSSignpostID(log: logHandle, object: object)
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@usableFromInline
internal enum OSSignpostError {
  case doubleEnd
  case none
  @_transparent @_alwaysEmitIntoClient internal static var doubleEndErrorString: Swift.String {
    @_transparent get {
    return "[Error] Interval already ended"
  }
  }
  @usableFromInline
  internal static func == (a: os.OSSignpostError, b: os.OSSignpostError) -> Swift.Bool
  @usableFromInline
  internal func hash(into hasher: inout Swift.Hasher)
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public class OSSignpostIntervalState : Swift.Codable {
  @usableFromInline
  final internal let signpostID: os.OSSignpostID
  @usableFromInline
  internal init(id: os.OSSignpostID, isOpen: Swift.Bool = true)
  @inlinable @inline(__always) public static func beginState(id: os.OSSignpostID) -> os.OSSignpostIntervalState {
    return OSSignpostIntervalState(id: id)
  }
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public func _hasValue(id: os.OSSignpostID, isOpen: Swift.Bool) -> Swift.Bool
  @objc deinit
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@_transparent @_alwaysEmitIntoClient @_optimize(none) internal func osSignpost(_ message: os.SignpostMetadata, log: os.OSLog, name: Swift.StaticString, id: os.OSSignpostID, type: os.OSSignpostType, state: os.OSSignpostIntervalState?, formatStringTransform: (Swift.String) -> Swift.String = id) {
  let formatString = formatStringTransform(message.interpolation.formatString)
  let preamble = message.interpolation.preamble
  let argumentCount = message.interpolation.argumentCount
  let bufferSize = message.bufferSize
  let objectCount = message.interpolation.objectArgumentCount
  let stringCount = message.interpolation.stringArgumentCount
  let argumentClosures = message.interpolation.arguments.argumentClosures
    
   
  guard log.signpostsEnabled else { return }

  var newPreamble = preamble
  var newArgumentCount = argumentCount
  let nameStringPointer = _globalStringTablePointerOfStaticString(name)
  let formatStringPointer =
    checkStateAndGetFormatStringPointer(
      formatString: formatString,
      state: state,
      preamble: &newPreamble,
      argumentCount: &newArgumentCount
    )

  emitSignpost(
    preamble: newPreamble,
    argumentCount: newArgumentCount,
    bufferSize: bufferSize,
    objectCount: objectCount,
    stringCount: stringCount,
    argumentClosures: argumentClosures) {
    ___os_signpost_emit_with_name_impl(
      UnsafeMutableRawPointer(mutating: #dsohandle),
      log,
      type,
      id.rawValue,
      nameStringPointer,
      formatStringPointer,
      $0,
      $1)
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@_transparent @_alwaysEmitIntoClient @_optimize(none) internal func osSignpostWithoutMessage(log: os.OSLog, name: Swift.StaticString, id: os.OSSignpostID, type: os.OSSignpostType, state: os.OSSignpostIntervalState?, formatString: Swift.String = "") {
   
  guard log.signpostsEnabled else { return }

  var preamble: UInt8 = 0
  var argumentCount: UInt8 = 0
  let nameStringPointer = _globalStringTablePointerOfStaticString(name)
  let formatStringPointer = checkStateAndGetFormatStringPointer(
    formatString: formatString,
    state: state,
    preamble: &preamble,
    argumentCount: &argumentCount)

  emitSignpost(
    preamble: preamble,
    argumentCount: argumentCount,
    bufferSize: 2,
    objectCount: 0,
    stringCount: 0,
    argumentClosures: []) {
    ___os_signpost_emit_with_name_impl(
      UnsafeMutableRawPointer(mutating: #dsohandle),
      log,
      type,
      id.rawValue,
      nameStringPointer,
      formatStringPointer,
      $0,
      $1)
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@_transparent @_alwaysEmitIntoClient @_optimize(none) internal func emitSignpost<T>(preamble: Swift.UInt8, argumentCount: Swift.UInt8, bufferSize: Swift.Int, objectCount: Swift.Int, stringCount: Swift.Int, argumentClosures: os.ArgumentClosures, signpostTask: (Swift.UnsafeMutablePointer<Swift.UInt8>, Swift.UInt32) throws -> T) rethrows -> T {
  let uint32bufferSize: UInt32 = UInt32(bufferSize)
   
  let bufferMemory = UnsafeMutablePointer<UInt8>.allocate(capacity: bufferSize)
   
   
  let objectArguments = createStorage(capacity: objectCount, type: NSObject?.self)
  let stringArgumentOwners = createStorage(capacity: stringCount, type: Any.self)

  var currentBufferPosition = bufferMemory
  var objectArgumentsPosition = objectArguments
  var stringArgumentOwnersPosition = stringArgumentOwners
  serialize(preamble, at: &currentBufferPosition)
  serialize(argumentCount, at: &currentBufferPosition)
  argumentClosures.forEach {
    $0(&currentBufferPosition,
       &objectArgumentsPosition,
       &stringArgumentOwnersPosition)
  }

  let result = try signpostTask(bufferMemory, uint32bufferSize)

   
   
   
  destroyStorage(objectArguments, count: objectCount)
  destroyStorage(stringArgumentOwners, count: stringCount)
  bufferMemory.deallocate()

  return result
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@_transparent @_alwaysEmitIntoClient internal func callSignpostAroundTask<T>(dsoHandle: Swift.UnsafeMutableRawPointer, log: os.OSLog, id: os.OSSignpostID, nameStringPointer: Swift.UnsafePointer<Swift.CChar>, formatStringPointer: Swift.UnsafePointer<Swift.CChar>, bufferMemory: Swift.UnsafeMutablePointer<Swift.UInt8>, uint32bufferSize: Swift.UInt32, task: () throws -> T) rethrows -> T {
   
  ___os_signpost_emit_with_name_impl(
    dsoHandle,
    log,
    .begin,
    id.rawValue,
    nameStringPointer,
    formatStringPointer,
    bufferMemory,
    uint32bufferSize)
   
  let result = try task()
   
  ___os_signpost_emit_with_name_impl(
    dsoHandle,
    log,
    .end,
    id.rawValue,
    nameStringPointer,
    formatStringPointer,
    bufferMemory,
    uint32bufferSize)
  return result
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@_transparent @_alwaysEmitIntoClient @_optimize(none) internal func checkStateAndGetFormatStringPointer(formatString: Swift.String, state: os.OSSignpostIntervalState?, preamble: inout Swift.UInt8, argumentCount: inout Swift.UInt8) -> Swift.UnsafePointer<Swift.CChar> {
  var formatStringPointer = _getGlobalStringTablePointer(formatString)

  if let state = state {
    switch checkForErrorAndConsumeState(state: state) {
    case .doubleEnd:
      assert(false, OSSignpostError.doubleEndErrorString)
      formatStringPointer = _getGlobalStringTablePointer(OSSignpostError.doubleEndErrorString)
      preamble = 0
      argumentCount = 0
    default:
      break
    }
  }

  return formatStringPointer
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@usableFromInline
internal func checkForErrorAndConsumeState(state: os.OSSignpostIntervalState) -> os.OSSignpostError
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@_transparent @_alwaysEmitIntoClient @_optimize(none) internal func _globalStringTablePointerOfStaticString(_ value: Swift.StaticString) -> Swift.UnsafePointer<Swift.CChar> {
  value.withUTF8Buffer { (valueBuf: UnsafeBufferPointer<UInt8>) in
    valueBuf.baseAddress!.withMemoryRebound(
      to: CChar.self, capacity: valueBuf.count
    ) {
      return $0
    }
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@_transparent @_optimize(none) @_alwaysEmitIntoClient @_semantics("constant_evaluable") internal func animationFormatString(_ formatString: Swift.String) -> Swift.String {
  var s = ""
  s += formatString
  s += " isAnimation=YES"
  return s
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@_transparent @_optimize(none) @_alwaysEmitIntoClient @_semantics("constant_evaluable") internal func id(_ s: Swift.String) -> Swift.String {
  return s
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@_transparent @_alwaysEmitIntoClient @_optimize(none) public func _checkSignpostFormatStringAndBuffer(_ message: os.SignpostMetadata, state: os.OSSignpostIntervalState?, with assertion: (Swift.String, Swift.UnsafeBufferPointer<Swift.UInt8>) -> Swift.Void) {
  let formatString = message.interpolation.formatString
  let preamble = message.interpolation.preamble
  let argumentCount = message.interpolation.argumentCount
  let bufferSize = message.bufferSize
  let objectCount = message.interpolation.objectArgumentCount
  let stringCount = message.interpolation.stringArgumentCount
  let argumentClosures = message.interpolation.arguments.argumentClosures

  var newPreamble = preamble
  var newArgumentCount = argumentCount
  let formatStringPointer = checkStateAndGetFormatStringPointer(
    formatString: formatString,
    state: state,
    preamble: &newPreamble,
    argumentCount: &newArgumentCount)

  let errorString = OSSignpostError.doubleEndErrorString
  let newFormatString = formatStringPointer == _getGlobalStringTablePointer(errorString) ? errorString : formatString

  emitSignpost(
    preamble: preamble,
    argumentCount: argumentCount,
    bufferSize: bufferSize,
    objectCount: objectCount,
    stringCount: stringCount,
    argumentClosures: argumentClosures) {
    assertion(newFormatString, UnsafeBufferPointer(start: UnsafePointer($0), count: Int($1)))
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@_transparent @_alwaysEmitIntoClient @_optimize(none) public func _checkSignpostBufferNoMessage(state: os.OSSignpostIntervalState?, with assertion: (Swift.String, Swift.UnsafeBufferPointer<Swift.UInt8>) -> Swift.Void) {
  var preamble: UInt8 = 0
  var argumentCount: UInt8 = 0
  let formatStringPointer = checkStateAndGetFormatStringPointer(
    formatString: "",
    state: state,
    preamble: &preamble,
    argumentCount: &argumentCount)

  let errorString = OSSignpostError.doubleEndErrorString
  let newFormatString = formatStringPointer == _getGlobalStringTablePointer(errorString) ? errorString : ""

  emitSignpost(
    preamble: preamble,
    argumentCount: argumentCount,
    bufferSize: 2,
    objectCount: 0,
    stringCount: 0,
    argumentClosures: []) {
    assertion(newFormatString, UnsafeBufferPointer(start: UnsafePointer($0), count: Int($1)))
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
@_transparent @_alwaysEmitIntoClient @_optimize(none) public func _checkAnimationSignpostFormatStringAndBuffer(_ message: os.SignpostMetadata, state: os.OSSignpostIntervalState?, with assertion: (Swift.String, Swift.UnsafeBufferPointer<Swift.UInt8>) -> Swift.Void) {
  let formatString = animationFormatString(message.interpolation.formatString)
  let preamble = message.interpolation.preamble
  let argumentCount = message.interpolation.argumentCount
  let bufferSize = message.bufferSize
  let objectCount = message.interpolation.objectArgumentCount
  let stringCount = message.interpolation.stringArgumentCount
  let argumentClosures = message.interpolation.arguments.argumentClosures

  var newPreamble = preamble
  var newArgumentCount = argumentCount
  let formatStringPointer = checkStateAndGetFormatStringPointer(
    formatString: formatString,
    state: state,
    preamble: &newPreamble,
    argumentCount: &newArgumentCount)

  let errorString = OSSignpostError.doubleEndErrorString
  let newFormatString = formatStringPointer == _getGlobalStringTablePointer(errorString) ? errorString : formatString

  emitSignpost(
    preamble: preamble,
    argumentCount: argumentCount,
    bufferSize: bufferSize,
    objectCount: objectCount,
    stringCount: stringCount,
    argumentClosures: argumentClosures) {
    assertion(newFormatString, UnsafeBufferPointer(start: UnsafePointer($0), count: Int($1)))
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@_semantics("constant_evaluable") @inlinable public var maxOSLogArgumentCount: Swift.UInt8 {
  get { return 48 }
}
@_transparent @_alwaysEmitIntoClient internal var logBitsPerByte: Swift.Int {
  @_transparent get { return 3 }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct OSLogInterpolation : Swift.StringInterpolationProtocol {
  @usableFromInline
  internal var formatString: Swift.String
  @usableFromInline
  internal var arguments: os.OSLogArguments
  @usableFromInline
  internal enum ArgumentType {
    case scalar, count, string, pointer, object, mask
    @inlinable internal var rawValue: Swift.UInt8 {
      get {
      switch self {
      case .scalar:
        return 0
      case .count:
        return 1
      case .string:
        return 2
      case .pointer:
        return 3
      case .mask:
        return 7
      default:  
        return 4
      }
    }
    }
    @usableFromInline
    internal static func == (a: os.OSLogInterpolation.ArgumentType, b: os.OSLogInterpolation.ArgumentType) -> Swift.Bool
    @usableFromInline
    internal func hash(into hasher: inout Swift.Hasher)
    @usableFromInline
    internal var hashValue: Swift.Int {
      @usableFromInline
      get
    }
  }
  @usableFromInline
  internal var preamble: Swift.UInt8
  @_semantics("constant_evaluable") @inlinable internal var privateBitMask: Swift.UInt8 {
    get { 0x1 }
  }
  @_semantics("constant_evaluable") @inlinable internal var nonScalarBitMask: Swift.UInt8 {
    get { 0x2 }
  }
  @usableFromInline
  internal var argumentCount: Swift.UInt8
  @usableFromInline
  internal var totalBytesForSerializingArguments: Swift.Int
  @usableFromInline
  internal var stringArgumentCount: Swift.Int
  @usableFromInline
  internal var objectArgumentCount: Swift.Int
  @_semantics("oslog.interpolation.init") @_semantics("constant_evaluable") @inlinable @_optimize(none) public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int) {
     
     
    formatString = ""
    arguments = OSLogArguments()
    preamble = 0
    argumentCount = 0
    totalBytesForSerializingArguments = 0
    stringArgumentCount = 0
    objectArgumentCount = 0
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public mutating func appendLiteral(_ literal: Swift.String) {
    formatString += literal.percentEscapedString
  }
  @inlinable @_semantics("constant_evaluable") @_effects(readonly) @_optimize(none) internal func getArgumentHeader(privacy: os.OSLogPrivacy, type: os.OSLogInterpolation.ArgumentType) -> Swift.UInt8 {
    return (type.rawValue &<< 4) | privacy.argumentFlag
  }
  @inlinable @_semantics("constant_evaluable") @_effects(readonly) @_optimize(none) internal func getUpdatedPreamble(privacy: os.OSLogPrivacy, isScalar: Swift.Bool) -> Swift.UInt8 {
    var preamble = self.preamble
    if privacy.isAtleastPrivate {
      preamble |= privateBitMask
    }
    if !isScalar || privacy.hasMask {
      preamble |= nonScalarBitMask
    }
    return preamble
  }
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias StringLiteralType = Swift.String
}
extension Swift.String {
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @inlinable internal var percentEscapedString: Swift.String {
    @_semantics("string.escapePercent.get") @_effects(readonly) @_optimize(none) get {
      return self
        .split(separator: "%", omittingEmptySubsequences: false)
        .joined(separator: "%%")
    }
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct OSLogMessage : Swift.ExpressibleByStringInterpolation, Swift.ExpressibleByStringLiteral {
  public let interpolation: os.OSLogInterpolation
  @inlinable @_optimize(none) @_semantics("oslog.message.init_interpolation") @_semantics("constant_evaluable") public init(stringInterpolation: os.OSLogInterpolation) {
    self.interpolation = stringInterpolation
  }
  @inlinable @_optimize(none) @_semantics("oslog.message.init_stringliteral") @_semantics("constant_evaluable") public init(stringLiteral value: Swift.String) {
    var s = OSLogInterpolation(literalCapacity: 1, interpolationCount: 0)
    s.appendLiteral(value)
    self.interpolation = s
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public var bufferSize: Swift.Int {
    get {
     
    return interpolation.totalBytesForSerializingArguments + 2
  }
  }
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias StringInterpolation = os.OSLogInterpolation
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias StringLiteralType = Swift.String
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias UnicodeScalarLiteralType = Swift.String
}
@usableFromInline
internal typealias ByteBufferPointer = Swift.UnsafeMutablePointer<Swift.UInt8>
@usableFromInline
internal typealias ObjectStorage<T> = Swift.UnsafeMutablePointer<T>?
@usableFromInline
internal typealias ArgumentClosures = [(inout os.ByteBufferPointer, inout os.ObjectStorage<ObjectiveC.NSObject?>, inout os.ObjectStorage<Any>) -> ()]
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@usableFromInline
@frozen internal struct OSLogArguments {
  @usableFromInline
  internal var argumentClosures: os.ArgumentClosures
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal init() {
    argumentClosures = []
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func append(_ header: Swift.UInt8) {
    argumentClosures.append({ (position, _, _) in
      serialize(header, at: &position)
    })
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) internal func concatPrivacyAndAttributes(privacy: os.OSLogPrivacy, attributes: Swift.String) -> Swift.String? {
  let hasPrivacy: Bool = privacy.needsPrivacySpecifier
  let hasAttr: Bool = !(attributes == "")
  let hasBoth = hasPrivacy && hasAttr
  var tagString = attributes
  if hasBoth {
    tagString += ","
  }
  if let privacySpecifier = privacy.privacySpecifier {
    tagString += privacySpecifier
  }
  return (tagString == "") ? nil : tagString
}
@_alwaysEmitIntoClient @inline(__always) internal func serialize(_ value: Swift.UInt8, at bufferPosition: inout os.ByteBufferPointer) {
  bufferPosition[0] = value
  bufferPosition += 1
}
@_alwaysEmitIntoClient @inline(__always) internal func createStorage<T>(capacity: Swift.Int, type: T.Type) -> os.ObjectStorage<T> {
  return
    capacity == 0 ?
      nil :
      UnsafeMutablePointer<T>.allocate(capacity: capacity)
}
@_alwaysEmitIntoClient @inline(__always) internal func initializeAndAdvance<T>(_ storageOpt: inout os.ObjectStorage<T>, to value: T) {
   
  if let storage = storageOpt {
    storage.initialize(to: value)
    storageOpt = storage.advanced(by: 1)
  }
}
@_alwaysEmitIntoClient @inline(__always) internal func destroyStorage<T>(_ storageOpt: os.ObjectStorage<T>, count: Swift.Int) {
   
  if let storage = storageOpt {
    storage.deinitialize(count: count)
    storage.deallocate()
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct OSAllocatedUnfairLockFlags : Swift.OptionSet, Swift.RawRepresentable {
  public let rawValue: Swift.UInt32
  public init(rawValue: Swift.UInt32)
  public static let adaptiveSpin: os.OSAllocatedUnfairLockFlags
  @usableFromInline
  internal var _translatedValue: Darwin.__os_unfair_lock_flags_t {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias ArrayLiteralElement = os.OSAllocatedUnfairLockFlags
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Element = os.OSAllocatedUnfairLockFlags
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias RawValue = Swift.UInt32
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct OSAllocatedUnfairLock<State> : @unchecked Swift.Sendable {
  @_alwaysEmitIntoClient internal let __lock: Swift.ManagedBuffer<State, Darwin.os_unfair_lock>
  @_alwaysEmitIntoClient public init(uncheckedState initialState: State) {
		__lock = .create(minimumCapacity: 1) { buffer in
			

			buffer.withUnsafeMutablePointerToElements { lock in
				lock.initialize(to: .init())
			}
			return initialState
		}
	}
  @_alwaysEmitIntoClient internal func withLockUncheckedInternal<R>(body: (inout State) throws -> R) rethrows -> R {
		return try self.__lock.withUnsafeMutablePointers { header, lock in
			os_unfair_lock_lock(lock)
			defer {
				os_unfair_lock_unlock(lock)
			}
			return try body(&header.pointee)
		}
	}
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient internal func withLockUncheckedInternal<R>(flags: os.OSAllocatedUnfairLockFlags, body: (inout State) throws -> R) rethrows -> R {
		return try self.__lock.withUnsafeMutablePointers { header, lock in
			if (!flags.isEmpty) {
				os_unfair_lock_lock_with_flags(lock, flags._translatedValue)
			} else {
				os_unfair_lock_lock(lock)
			}
			defer {
				os_unfair_lock_unlock(lock)
			}
			return try body(&header.pointee)
		}
	}
  @_alwaysEmitIntoClient public func withLockUnchecked<R>(_ body: (inout State) throws -> R) rethrows -> R {
			return try self.withLockUncheckedInternal(body: body)
	}
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient public func withLockUnchecked<R>(flags: os.OSAllocatedUnfairLockFlags, _ body: (inout State) throws -> R) rethrows -> R {
			return try self.withLockUncheckedInternal(flags: flags, body: body)
	}
  @_alwaysEmitIntoClient public func withLock<R>(_ body: @Sendable (inout State) throws -> R) rethrows -> R where R : Swift.Sendable {
		return try self.withLockUncheckedInternal(body: body)
	}
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient public func withLock<R>(flags: os.OSAllocatedUnfairLockFlags, _ body: @Sendable (inout State) throws -> R) rethrows -> R where R : Swift.Sendable {
		return try self.withLockUncheckedInternal(flags: flags, body: body)
	}
  @_alwaysEmitIntoClient internal func withLockIfAvailableUncheckedInternal<R>(_ body: (inout State) throws -> R) rethrows -> R? {
		return try self.__lock.withUnsafeMutablePointers { header, lock in
			guard os_unfair_lock_trylock(lock) else {
				return nil
			}
			defer {
				os_unfair_lock_unlock(lock)
			}
			return try body(&header.pointee)
		}
	}
  @_alwaysEmitIntoClient public func withLockIfAvailableUnchecked<R>(_ body: (inout State) throws -> R) rethrows -> R? {
			return try self.withLockIfAvailableUncheckedInternal(body)
	}
  @_alwaysEmitIntoClient public func withLockIfAvailable<R>(_ body: @Sendable (inout State) throws -> R) rethrows -> R? where R : Swift.Sendable {
			return try self.withLockIfAvailableUncheckedInternal(body)
	}
  @frozen public enum Ownership {
    case owner
    case notOwner
    public static func == (a: os.OSAllocatedUnfairLock<State>.Ownership, b: os.OSAllocatedUnfairLock<State>.Ownership) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_alwaysEmitIntoClient internal func _preconditionTest(_ condition: os.OSAllocatedUnfairLock<State>.Ownership) -> Swift.Bool {
		self.__lock.withUnsafeMutablePointerToElements { lock in
			switch condition {
			case .owner:
				os_unfair_lock_assert_owner(lock)
			case .notOwner:
				os_unfair_lock_assert_not_owner(lock)
			}
		}
		return true
	}
  @_transparent @_alwaysEmitIntoClient public func precondition(_ condition: os.OSAllocatedUnfairLock<State>.Ownership) {
		 
		 
		 
		Swift.precondition(_preconditionTest(condition), "lockPrecondition failure")
	}
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension os.OSAllocatedUnfairLock where State == () {
  @_alwaysEmitIntoClient public init() { self.init(uncheckedState: ()) }
  @_alwaysEmitIntoClient public func withLockUnchecked<R>(_ body: () throws -> R) rethrows -> R {
		return try withLockUnchecked { _ in try body() }
	}
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient public func withLockUnchecked<R>(flags: os.OSAllocatedUnfairLockFlags, _ body: () throws -> R) rethrows -> R {
			return try withLockUnchecked(flags : flags) { _ in try body() }
	}
  @_alwaysEmitIntoClient public func withLock<R>(_ body: @Sendable () throws -> R) rethrows -> R where R : Swift.Sendable {
		return try withLock { _ in try body() }
	}
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient public func withLock<R>(flags: os.OSAllocatedUnfairLockFlags, _ body: @Sendable () throws -> R) rethrows -> R where R : Swift.Sendable {
			return try withLock(flags : flags) { _ in try body() }
	}
  @_alwaysEmitIntoClient public func withLockIfAvailableUnchecked<R>(_ body: () throws -> R) rethrows -> R? {
		return try withLockIfAvailableUnchecked { _ in try body() }
	}
  @_alwaysEmitIntoClient public func withLockIfAvailable<R>(_ body: @Sendable () throws -> R) rethrows -> R? where R : Swift.Sendable {
		return try withLockIfAvailable { _ in try body() }
	}
  @_alwaysEmitIntoClient @_unavailableFromAsync(message: "Use withLock for scoped locking") public func lock() {
		self.__lock.withUnsafeMutablePointerToElements { lock in
			os_unfair_lock_lock(lock)
		}
	}
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_unavailableFromAsync(message: "Use withLock for scoped locking") public func lock(flags: os.OSAllocatedUnfairLockFlags) {
		self.__lock.withUnsafeMutablePointerToElements { lock in
			if (!flags.isEmpty) {
				os_unfair_lock_lock_with_flags(lock, flags._translatedValue)
			} else {
				os_unfair_lock_lock(lock)
			}
		}
	}
  @_alwaysEmitIntoClient @_unavailableFromAsync(message: "Use withLock for scoped locking") public func unlock() {
		self.__lock.withUnsafeMutablePointerToElements { lock in
			os_unfair_lock_unlock(lock)
		}
	}
  @_alwaysEmitIntoClient @_unavailableFromAsync(message: "Use withLockIfAvailable for scoped locking") public func lockIfAvailable() -> Swift.Bool {
		return self.__lock.withUnsafeMutablePointerToElements { lock in
			return os_unfair_lock_trylock(lock)
		}
	}
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension os.OSAllocatedUnfairLock where State : Swift.Sendable {
  @_alwaysEmitIntoClient public init(initialState: State) { self.init(uncheckedState: initialState) }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public struct Logger : @unchecked Swift.Sendable {
  @usableFromInline
  internal let logObject: os.OSLog
  public init(subsystem: Swift.String, category: Swift.String)
  public init()
  public init(_ logObj: os.OSLog)
  @_transparent @_optimize(none) @_semantics("oslog.requires_constant_arguments") public func log(_ message: os.OSLogMessage) {
    osLogInternal(message, log: logObject, type: .default)
  }
  @_transparent @_optimize(none) @_semantics("oslog.log_with_level") public func log(level: os.OSLogType, _ message: os.OSLogMessage) {
     
     
     
    osLogInternal(message, log: logObject, type: level)
  }
  @_transparent @_optimize(none) @_semantics("oslog.requires_constant_arguments") public func trace(_ message: os.OSLogMessage) {
    osLogInternal(message, log: logObject, type: .debug)
  }
  @_transparent @_optimize(none) @_semantics("oslog.requires_constant_arguments") public func debug(_ message: os.OSLogMessage) {
    osLogInternal(message, log: logObject, type: .debug)
  }
  @_transparent @_optimize(none) @_semantics("oslog.requires_constant_arguments") public func info(_ message: os.OSLogMessage) {
    osLogInternal(message, log: logObject, type: .info)
  }
  @_transparent @_optimize(none) @_semantics("oslog.requires_constant_arguments") public func notice(_ message: os.OSLogMessage) {
    osLogInternal(message, log: logObject, type: .default)
  }
  @_transparent @_optimize(none) @_semantics("oslog.requires_constant_arguments") public func warning(_ message: os.OSLogMessage) {
    osLogInternal(message, log: logObject, type: .error)
  }
  @_transparent @_optimize(none) @_semantics("oslog.requires_constant_arguments") public func error(_ message: os.OSLogMessage) {
    osLogInternal(message, log: logObject, type: .error)
  }
  @_transparent @_optimize(none) @_semantics("oslog.requires_constant_arguments") public func critical(_ message: os.OSLogMessage) {
    osLogInternal(message, log: logObject, type: .fault)
  }
  @_transparent @_optimize(none) @_semantics("oslog.requires_constant_arguments") public func fault(_ message: os.OSLogMessage) {
    osLogInternal(message, log: logObject, type: .fault)
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@_disfavoredOverload @_transparent @_optimize(none) @_semantics("oslog.requires_constant_arguments") @_alwaysEmitIntoClient public func os_log(_ message: os.OSLogMessage) {
   
   
   
  osLogInternal(message, log: .default, type: .default)
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@_disfavoredOverload @_transparent @_optimize(none) @_semantics("oslog.log_with_level") public func os_log(_ logLevel: os.OSLogType = .default, log logObject: os.OSLog = .default, _ message: os.OSLogMessage) {
   
   
   
  osLogInternal(message, log: logObject, type: logLevel)
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@_transparent @_alwaysEmitIntoClient @_optimize(none) internal func osLogInternal(_ message: os.OSLogMessage, log logObject: os.OSLog, type logLevel: os.OSLogType) {
   
   
  let formatString = message.interpolation.formatString
  let preamble = message.interpolation.preamble
  let argumentCount = message.interpolation.argumentCount
  let bufferSize = message.bufferSize
  let objectCount = message.interpolation.objectArgumentCount
  let stringCount = message.interpolation.stringArgumentCount
  let uint32bufferSize = UInt32(bufferSize)
  let argumentClosures = message.interpolation.arguments.argumentClosures

  let formatStringPointer = _getGlobalStringTablePointer(formatString)

   
  guard logObject.isEnabled(type: logLevel) else { return }

   
  let bufferMemory = UnsafeMutablePointer<UInt8>.allocate(capacity: bufferSize)
   
   
  let objectArguments = createStorage(capacity: objectCount, type: NSObject?.self)
  let stringArgumentOwners = createStorage(capacity: stringCount, type: Any.self)

  var currentBufferPosition = bufferMemory
  var objectArgumentsPosition = objectArguments
  var stringArgumentOwnersPosition = stringArgumentOwners
  serialize(preamble, at: &currentBufferPosition)
  serialize(argumentCount, at: &currentBufferPosition)
  argumentClosures.forEach {
    $0(&currentBufferPosition,
       &objectArgumentsPosition,
       &stringArgumentOwnersPosition)
  }

  ___os_log_impl(UnsafeMutableRawPointer(mutating: #dsohandle),
                 logObject,
                 logLevel,
                 formatStringPointer,
                 bufferMemory,
                 uint32bufferSize)

   
   
   
  destroyStorage(objectArguments, count: objectCount)
  destroyStorage(stringArgumentOwners, count: stringCount)
  bufferMemory.deallocate()
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@_transparent @_optimize(none) public func _checkFormatStringAndBuffer(_ message: os.OSLogMessage, with assertion: (Swift.String, Swift.UnsafeBufferPointer<Swift.UInt8>) -> Swift.Void) {
   
   
  let formatString = message.interpolation.formatString
  let preamble = message.interpolation.preamble
  let argumentCount = message.interpolation.argumentCount
  let bufferSize = message.bufferSize
  let objectCount = message.interpolation.objectArgumentCount
  let stringCount = message.interpolation.stringArgumentCount
  let argumentClosures = message.interpolation.arguments.argumentClosures

   
  let bufferMemory = UnsafeMutablePointer<UInt8>.allocate(capacity: bufferSize)
  let objectArguments = createStorage(capacity: objectCount, type: NSObject?.self)
  let stringArgumentOwners = createStorage(capacity: stringCount, type: Any.self)

  var currentBufferPosition = bufferMemory
  var objectArgumentsPosition = objectArguments
  var stringArgumentOwnersPosition = stringArgumentOwners
  serialize(preamble, at: &currentBufferPosition)
  serialize(argumentCount, at: &currentBufferPosition)
  argumentClosures.forEach {
    $0(&currentBufferPosition,
       &objectArgumentsPosition,
       &stringArgumentOwnersPosition)
  }
  
  assertion(
    formatString,
    UnsafeBufferPointer(start: UnsafePointer(bufferMemory), count: bufferSize))
  
  destroyStorage(objectArguments, count: objectCount)
  destroyStorage(stringArgumentOwners, count: stringCount)
  bufferMemory.deallocate()
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@usableFromInline
internal enum OSLogCollectionBound {
  case start
  case end
  @usableFromInline
  internal static func == (a: os.OSLogCollectionBound, b: os.OSLogCollectionBound) -> Swift.Bool
  @usableFromInline
  internal func hash(into hasher: inout Swift.Hasher)
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct OSLogStringAlignment {
  @usableFromInline
  internal var minimumColumnWidth: (() -> Swift.Int)?
  @usableFromInline
  internal var anchor: os.OSLogCollectionBound
  @usableFromInline
  @_transparent internal init(minimumColumnWidth: (() -> Swift.Int)? = nil, anchor: os.OSLogCollectionBound = .end) {
    self.minimumColumnWidth = minimumColumnWidth
    self.anchor = anchor
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var none: os.OSLogStringAlignment {
    get { OSLogStringAlignment(anchor: .end)  }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func right(columns: @autoclosure @escaping () -> Swift.Int) -> os.OSLogStringAlignment {
    OSLogStringAlignment(minimumColumnWidth: columns, anchor: .end)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func left(columns: @autoclosure @escaping () -> Swift.Int) -> os.OSLogStringAlignment {
    OSLogStringAlignment(minimumColumnWidth: columns, anchor: .start)
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogInterpolation {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ argumentString: @autoclosure @escaping () -> Swift.String, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInterpolation(argumentString(), align: align, privacy: privacy, attributes: "")
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ argumentString: @autoclosure @escaping () -> Swift.String, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String) {
    guard argumentCount < maxOSLogArgumentCount else { return }

    formatString += getStringFormatSpecifier(align, privacy, attributes)

     
     
    if let minColumns = align.minimumColumnWidth {
      appendAlignmentArgument(minColumns)
    }

     
     
    if privacy.hasMask {
      appendMaskArgument(privacy)
    }

     
    addStringHeaders(privacy)
    arguments.append(argumentString)
    argumentCount += 1
    stringArgumentCount += 1
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func addStringHeaders(_ privacy: os.OSLogPrivacy) {
     
    let header = getArgumentHeader(privacy: privacy, type: .string)
    arguments.append(header)

     
    let byteCount = pointerSizeInBytes()
    arguments.append(UInt8(byteCount))

     
     
     
    totalBytesForSerializingArguments += byteCount + 2

    preamble = getUpdatedPreamble(privacy: privacy, isScalar: false)
  }
  @_alwaysEmitIntoClient @_semantics("constant_evaluable") @_effects(readonly) @_optimize(none) internal func getStringFormatSpecifier(_ align: os.OSLogStringAlignment, _ privacy: os.OSLogPrivacy, _ attributes: Swift.String) -> Swift.String {
    var specifier = "%"
     
     
    if let privacyAndAttr = concatPrivacyAndAttributes(privacy: privacy,
                                                       attributes: attributes) {
      specifier += "{"
      specifier += privacyAndAttr
      specifier += "}"
    }
    if case .start = align.anchor {
      specifier += "-"
    }
    if let _ = align.minimumColumnWidth {
      specifier += "*"
    }
    specifier += "s"
    return specifier
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogArguments {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func append(_ value: @escaping () -> Swift.String) {
    argumentClosures.append({ (position, _, stringArgumentOwners) in
      serializeImpl(
        value(),
        at: &position,
        storingStringOwnersIn: &stringArgumentOwners)
    })
  }
}
@_transparent @_alwaysEmitIntoClient internal func pointerSizeInBytes() -> Swift.Int {
  return Int.bitWidth &>> logBitsPerByte
}
@_alwaysEmitIntoClient @inline(__always) internal func serializeImpl(_ stringValue: Swift.String, at bufferPosition: inout Swift.UnsafeMutablePointer<Swift.UInt8>, storingStringOwnersIn stringArgumentOwners: inout os.ObjectStorage<Any>) {
  let stringPointer =
    getNullTerminatedUTF8PointerImpl(
      stringValue,
      storingStringOwnersIn: &stringArgumentOwners)

  let byteCount = pointerSizeInBytes()
  let dest =
    UnsafeMutableRawBufferPointer(start: bufferPosition, count: byteCount)
  _withUnprotectedUnsafeBytes(of: stringPointer) { dest.copyMemory(from: $0) }
  bufferPosition += byteCount
}
@_alwaysEmitIntoClient @inline(never) internal func getNullTerminatedUTF8PointerImpl(_ stringValue: Swift.String, storingStringOwnersIn stringArgumentOwners: inout os.ObjectStorage<Any>) -> Swift.UnsafeRawPointer {
  let (optStorage, bytePointer, _, _, _):
    (AnyObject?, UnsafeRawPointer, Int, Bool, Bool) =
     stringValue._deconstructUTF8(scratch: nil)
  if let storage = optStorage {
    initializeAndAdvance(&stringArgumentOwners, to: storage)
  } else {
    initializeAndAdvance(&stringArgumentOwners, to: stringValue._guts)
  }
  return bytePointer
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public enum OSLogBoolFormat {
  case truth
  case answer
  public static func == (a: os.OSLogBoolFormat, b: os.OSLogBoolFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public enum OSLogInt32ExtendedFormat {
  case ipv4Address
  case secondsSince1970
  case darwinErrno
  case darwinMode
  case darwinSignal
  case machErrno
  case bitrate
  case bitrateIEC
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  case byteCount
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  case byteCountIEC
  case truth
  case answer
  public static func == (a: os.OSLogInt32ExtendedFormat, b: os.OSLogInt32ExtendedFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public enum OSLogIntExtendedFormat {
  case bitrate
  case bitrateIEC
  case byteCount
  case byteCountIEC
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) internal var tag: Swift.String {
    get {
    switch self {
      case .bitrate:
        return "bitrate"
      case .bitrateIEC:
        return "iec-bitrate"
      case .byteCount:
        return "bytes"
      case .byteCountIEC:
        return "iec-bytes"
      default:
        return ""
    }
  }
  }
  public static func == (a: os.OSLogIntExtendedFormat, b: os.OSLogIntExtendedFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogInterpolation {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Int32, format: os.OSLogInt32ExtendedFormat, privacy: os.OSLogPrivacy = .auto) {
    appendInterpolation(number(), format: format, privacy: privacy, attributes: "")
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Int32, format: os.OSLogInt32ExtendedFormat, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String) {
    guard argumentCount < maxOSLogArgumentCount else { return }

    formatString += getExtendedFormatSpecifier(format, privacy, attributes)
     
    if privacy.hasMask {
      appendMaskArgument(privacy)
    }
    addIntHeaders(privacy, sizeForEncoding(Int32.self))
    arguments.append(number)
    argumentCount += 1
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ boolean: @autoclosure @escaping () -> Swift.Bool, format: os.OSLogBoolFormat = .truth, privacy: os.OSLogPrivacy = .auto) {
    appendInterpolation(
      boolean() ? Int32(1) : Int32(0),
      format: getInt32BoolFormat(format),
      privacy: privacy
    )
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Int, format: os.OSLogIntExtendedFormat, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String = "") {
    let tag = format.tag
    let attrWithFormat = attributes == "" ? tag : tag + "," + attributes
    appendInteger(number, format: .decimal, align: .none, privacy: privacy, attributes: attrWithFormat)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal func getInt32BoolFormat(_ format: os.OSLogBoolFormat) -> os.OSLogInt32ExtendedFormat {
    switch format {
    case .answer:
      return .answer
    default:
      return .truth
    }
  }
  @_alwaysEmitIntoClient @_semantics("constant_evaluable") @_effects(readonly) @_optimize(none) internal func getExtendedFormatSpecifier(_ format: os.OSLogInt32ExtendedFormat, _ privacy: os.OSLogPrivacy, _ attributes: Swift.String) -> Swift.String {
    var specifier = "%{"
     
    switch (format) {
    case .secondsSince1970:
      specifier += "time_t"
    case .ipv4Address:
      specifier += "network:in_addr"
    case .darwinErrno:
      specifier += "darwin.errno"
    case .darwinMode:
      specifier += "darwin.mode"
    case .machErrno:
      specifier += "mach.errno"
    case .darwinSignal:
      specifier += "darwin.signal"
    case .bitrate:
      specifier += "bitrate"
    case .bitrateIEC:
      specifier += "iec-bitrate"
    case .byteCount:
      specifier += "bytes"
    case .byteCountIEC:
      specifier += "iec-bytes"
    case .truth:
      specifier += "bool"
    case .answer:
      specifier += "BOOL"
    default:
      break
    }
     
    if let privacyAndAttr = concatPrivacyAndAttributes(privacy: privacy,
                                                       attributes: attributes) {
      specifier += ","
      specifier += privacyAndAttr
    }
    specifier += "}d"
    return specifier
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogInterpolation {
  @_optimize(none) @_transparent @_semantics("oslog.requires_constant_arguments") @_disfavoredOverload public mutating func appendInterpolation<T>(_ value: @autoclosure @escaping () -> T, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) where T : Swift.CustomStringConvertible {
     
     
     
    appendInterpolation(value().description, align: align, privacy: privacy)
  }
  @_optimize(none) @_transparent @_alwaysEmitIntoClient @_semantics("oslog.requires_constant_arguments") @_disfavoredOverload public mutating func appendInterpolation<T>(_ value: @autoclosure @escaping () -> T, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String) where T : Swift.CustomStringConvertible {
     
     
     
    appendInterpolation(value().description, align: align, privacy: privacy, attributes: attributes)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ value: @autoclosure @escaping () -> any Any.Type, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto) {
    appendInterpolation(
      _typeName(value(), qualified: false),
      align: align,
      privacy: privacy)
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ value: @autoclosure @escaping () -> any Any.Type, align: os.OSLogStringAlignment = .none, privacy: os.OSLogPrivacy = .auto, attributes: Swift.String) {
    appendInterpolation(
      _typeName(value(), qualified: false),
      align: align,
      privacy: privacy,
      attributes: attributes)
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogFloatFormatting.Notation : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogFloatFormatting.Notation : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogPointerFormat : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogPointerFormat : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.AnimationFormatString.OSLogMessage : Swift.BitwiseCopyable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSSignpostAnimationBegin : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSSignpostAnimationBegin : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogPrivacy.PrivacyOption : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogPrivacy.PrivacyOption : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogPrivacy.Mask : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogPrivacy.Mask : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension os.OSLogPrivacy._MailMask : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension os.OSLogPrivacy._MailMask : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension os.OSSignpostError : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension os.OSSignpostError : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogInterpolation.ArgumentType : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogInterpolation.ArgumentType : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension os.OSAllocatedUnfairLock.Ownership : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension os.OSAllocatedUnfairLock.Ownership : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension os.OSAllocatedUnfairLock.Ownership : Swift.Sendable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension os.OSAllocatedUnfairLock.Ownership : Swift.BitwiseCopyable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogCollectionBound : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogCollectionBound : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogBoolFormat : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogBoolFormat : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogInt32ExtendedFormat : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension os.OSLogInt32ExtendedFormat : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension os.OSLogIntExtendedFormat : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension os.OSLogIntExtendedFormat : Swift.Hashable {}
