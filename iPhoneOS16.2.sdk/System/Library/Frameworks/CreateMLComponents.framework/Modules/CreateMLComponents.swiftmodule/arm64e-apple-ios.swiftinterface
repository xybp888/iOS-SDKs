// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.1 (swiftlang-5.7.1.134.3 clang-1400.0.29.51)
// swift-module-flags: -target arm64e-apple-ios16.2 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -module-name CreateMLComponents
// swift-module-flags-ignorable: -enable-bare-slash-regex -user-module-version 831.40.3
import AVFAudio
import AVFoundation
import Combine
import CoreGraphics
import CoreImage
import CoreML
import CoreMedia
import CoreVideo
import Foundation
import SoundAnalysis
import Swift
import TabularData
import UniformTypeIdentifiers
import Vision
import _Concurrency
import _StringProcessing
import os
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioReader {
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct AsyncBuffers : CreateMLComponents.TemporalSequence {
    public typealias AsyncIterator = CreateMLComponents.AudioReader.AsyncBuffers.Iterator
    public typealias Feature = AVFAudio.AVAudioPCMBuffer
    public let url: Foundation.URL
    public let count: Swift.Int?
    public func makeAsyncIterator() -> CreateMLComponents.AudioReader.AsyncBuffers.Iterator
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.AudioReader.AsyncBuffers.Feature>
  }
  #endif
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.AudioReader.AsyncBuffers : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
extension CreateMLComponents.AudioReader.AsyncBuffers {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async throws -> CreateMLComponents.TemporalFeature<AVFAudio.AVAudioPCMBuffer>?
    #endif
    public typealias Element = CreateMLComponents.TemporalFeature<AVFAudio.AVAudioPCMBuffer>
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.AudioReader.AsyncBuffers.Iterator : Swift.Sendable {
}
#endif
extension CreateMLComponents.VideoReader {
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  public struct CameraAsyncBuffers : CreateMLComponents.TemporalSequence {
    public typealias AsyncIterator = CreateMLComponents.VideoReader.CameraAsyncBuffers.Iterator
    public typealias Feature = CoreImage.CIImage
    public var count: Swift.Int? {
      get
    }
    public func makeAsyncIterator() -> CreateMLComponents.VideoReader.CameraAsyncBuffers.Iterator
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.VideoReader.CameraAsyncBuffers.Feature>
  }
  #endif
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraAsyncBuffers : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraAsyncBuffers {
  @_hasMissingDesignatedInitializers @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  final public class Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $AsyncAwait
    final public func next() async throws -> CreateMLComponents.TemporalFeature<CoreImage.CIImage>?
    #endif
    public typealias Element = CreateMLComponents.TemporalFeature<CoreImage.CIImage>
    @objc deinit
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraAsyncBuffers.Iterator : Swift.Sendable {
}
#endif
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct OneHotEncoder<Category> : CreateMLComponents.Estimator where Category : Swift.Comparable, Category : Swift.Decodable, Category : Swift.Encodable, Category : Swift.Hashable {
  public init()
  #if compiler(>=5.3) && $Sendable
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.OneHotEncoder<Category>.Transformer where S : Swift.Sequence, S.Element == Category?
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.OneHotEncoder : Swift.Sendable where Category : Swift.Sendable {
}
extension CreateMLComponents.OneHotEncoder {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Transformer : CreateMLComponents.Transformer {
    public var categories: Swift.Set<Category?>
    public init(categories: Swift.Set<Category?>)
    #if compiler(>=5.3) && $Sendable
    public func applied(to input: Category?, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> [Swift.Int]
    #endif
    #if compiler(>=5.3) && $Sendable
    public func applied<S>(_ input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> [[Swift.Int]] where S : Swift.Sequence, S.Element == Category?
    #endif
    public func category(at index: Swift.Int) -> Category?
    public typealias Input = Category?
    public typealias Output = [Swift.Int]
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.OneHotEncoder.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.OneHotEncoder.Transformer : Swift.Sendable where Category : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.OneHotEncoder.Transformer : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.OneHotEncoder.Transformer : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct MinMaxScaler<Element> : CreateMLComponents.Estimator where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public var range: Swift.ClosedRange<Element>
  public init(range: Swift.ClosedRange<Element> = 0...1)
  #if compiler(>=5.3) && $Sendable
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.MinMaxScaler<Element>.Transformer where Element == S.Element, S : Swift.Sequence
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MinMaxScaler : Swift.Sendable where Element : Swift.Sendable {
}
extension CreateMLComponents.MinMaxScaler {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Transformer : CreateMLComponents.Transformer, Swift.Hashable {
    public var desiredRange: Swift.ClosedRange<Element>
    public var fittedRange: Swift.ClosedRange<Element>
    public init(desiredRange: Swift.ClosedRange<Element>, fittedRange: Swift.ClosedRange<Element>)
    #if compiler(>=5.3) && $Sendable
    @inlinable public func applied(to input: Element, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
            if fittedRange.lowerBound == fittedRange.upperBound {
                return fittedRange.lowerBound
            }

            // scale the value to the range [0, 1].
            let unitScaledInput = (input - fittedRange.lowerBound) / (fittedRange.upperBound - fittedRange.lowerBound)

            // scale the values to the desired range.
            return unitScaledInput * (desiredRange.upperBound - desiredRange.lowerBound) + desiredRange.lowerBound
        }
    #endif
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.MinMaxScaler<Element>.Transformer, b: CreateMLComponents.MinMaxScaler<Element>.Transformer) -> Swift.Bool
    public typealias Input = Element
    public typealias Output = Element
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MinMaxScaler.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MinMaxScaler.Transformer : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MinMaxScaler.Transformer : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MinMaxScaler.Transformer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct SlidingWindowTransformer<Input> : CreateMLComponents.TemporalTransformer, Swift.Codable, Swift.Sendable where Input : Swift.Sendable {
  public typealias Input = Input
  public typealias Output = [Input]
  public let stride: Swift.Int
  public let length: Swift.Int
  public init(stride: Swift.Int, length: Swift.Int)
  #if compiler(>=5.3) && $RethrowsProtocol && $Sendable
  public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler?) throws -> CreateMLComponents.SlidingWindowTransformer<Input>.WindowSequence where Input == S.Feature, S : CreateMLComponents.TemporalSequence
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public typealias OutputSequence = CreateMLComponents.SlidingWindowTransformer<Input>.WindowSequence
  #endif
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.SlidingWindowTransformer {
  #if compiler(>=5.3) && $RethrowsProtocol
  public struct WindowSequence : CreateMLComponents.TemporalSequence {
    public typealias Feature = [Input]
    public typealias AsyncIterator = CreateMLComponents.SlidingWindowTransformer<Input>.WindowSequence.Iterator
    public var count: Swift.Int? {
      get
    }
    public func makeAsyncIterator() -> CreateMLComponents.SlidingWindowTransformer<Input>.WindowSequence.Iterator
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.SlidingWindowTransformer<Input>.WindowSequence.Feature>
  }
  #endif
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.SlidingWindowTransformer.WindowSequence : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.SlidingWindowTransformer.WindowSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async throws -> CreateMLComponents.TemporalFeature<CreateMLComponents.SlidingWindowTransformer<Input>.Output>?
    #endif
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.SlidingWindowTransformer<Input>.Output>
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.SlidingWindowTransformer.WindowSequence.Iterator : Swift.Sendable {
}
#endif
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator> : CreateMLComponents.UpdatableSupervisedTemporalEstimator where Preprocessor : CreateMLComponents.TemporalTransformer, Estimator : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTemporalTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public typealias Annotation = Estimator.Annotation
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ inner: Preprocessor, _ outer: Estimator)
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func preprocessed<InputSequence, FeatureSequence>(from input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>] where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        var preprocessed = [AnnotatedFeature<PreprocessedFeatureSequence<Preprocessor.Output>, Annotation>]()
        for item in input {
            let transformed = try await preprocessor.applied(to: item.feature, eventHandler: eventHandler)
            let stored = try await PreprocessedFeatureSequence(transformed)
            preprocessed.append(AnnotatedFeature(feature: stored, annotation: item.annotation))
        }
        return preprocessed
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted(toPreprocessed preprocessed: [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTemporalTransformer(preprocessor, fittedTransformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted(toPreprocessed preprocessedInput: [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>], validateOn preprocessedValidation: [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
        return ComposedTemporalTransformer(preprocessor, fittedTransformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        let preprocessedInput = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        let preprocessedValidation = try await preprocessed(from: validation, eventHandler: eventHandler)
        try Task.checkCancellation()

        return try await fitted(
            toPreprocessed: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
    }
  #endif
  @inlinable public func makeTransformer() -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer {
        ComposedTemporalTransformer(preprocessor, estimator.makeTransformer())
    }
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func update<InputSequence, FeatureSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer, withPreprocessed preprocessed: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Output == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input {
        try await estimator.update(
            &transformer.outer,
            with: preprocessed,
            eventHandler: eventHandler
        )
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func update<InputSequence, FeatureSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        try await estimator.update(
            &transformer.outer,
            with: preprocessed,
            eventHandler: eventHandler
        )
    }
  #endif
  public func encode(_ transformer: CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<CreateMLComponents.TransformerToTemporalAdaptor<Self>, Other> where Other : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Self.Output == Other.Transformer.Input
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Self, CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Other>> where Other : CreateMLComponents.UpdatableSupervisedEstimator, Self.Output == Other.Transformer.Input, Other.Annotation : Swift.Sendable
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableSupervisedTemporalEstimator<Self, Other> where Other : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Self.Output == Other.Transformer.Input
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ImageScaler : CreateMLComponents.Transformer, Swift.Sendable {
  public var targetSize: CoreFoundation.CGSize
  public init(targetSize: CoreFoundation.CGSize)
  #if compiler(>=5.3) && $Sendable
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CoreImage.CIImage
  #endif
  public typealias Input = CoreImage.CIImage
  public typealias Output = CoreImage.CIImage
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageScaler : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageScaler : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum TabularPipelineDataError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case missingColumn(operation: Swift.String, columnName: Swift.String)
  case incorrectType(operation: Swift.String, columnName: Swift.String, actual: Swift.String, expected: Swift.String)
  case missingValues(operation: Swift.String, columnName: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.TabularPipelineDataError, b: CreateMLComponents.TabularPipelineDataError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TabularPipelineDataError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.FullyConnectedNetworkRegressor : CreateMLComponents.UpdatableSupervisedEstimator {
  public func makeTransformer() -> CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar>
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func update<InputSequence>(_ transformer: inout CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar>, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Swift.Float>
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct BoostedTreeRegressor<Annotation> : CreateMLComponents.SupervisedTabularEstimator {
  public typealias Transformer = CreateMLComponents.TreeRegressorModel
  public var configuration: CreateMLComponents.BoostedTreeConfiguration
  public var annotationColumnID: TabularData.ColumnID<Annotation>
  public var featureColumnNames: [Swift.String]
  public init(annotationColumnName: Swift.String, featureColumnNames: [Swift.String], configuration: CreateMLComponents.BoostedTreeConfiguration = BoostedTreeConfiguration())
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame? = nil, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.TreeRegressorModel
  #endif
  public func encode(_ transformer: CreateMLComponents.TreeRegressorModel, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.TreeRegressorModel
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.BoostedTreeRegressor : Swift.Sendable where Annotation : Swift.Sendable {
}
extension Swift.Sequence {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func randomSplit<Feature, Annotation>(by proportion: Swift.Double, seed: Swift.Int? = nil) -> ([CreateMLComponents.AnnotatedFeature<Feature, Annotation>], [CreateMLComponents.AnnotatedFeature<Feature, Annotation>]) where Annotation : Swift.Hashable, Self.Element == CreateMLComponents.AnnotatedFeature<Feature, Annotation>
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func randomSplit<T>(by proportion: Swift.Double, seed: Swift.Int? = nil) -> (Swift.ArraySlice<T>, Swift.ArraySlice<T>) where T == Self.Element
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func randomSplit<Feature, Annotation, Generator>(by proportion: Swift.Double, using generator: inout Generator) -> ([CreateMLComponents.AnnotatedFeature<Feature, Annotation>], [CreateMLComponents.AnnotatedFeature<Feature, Annotation>]) where Annotation : Swift.Hashable, Generator : Swift.RandomNumberGenerator, Self.Element == CreateMLComponents.AnnotatedFeature<Feature, Annotation>
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func randomSplit<T, Generator>(by proportion: Swift.Double, using generator: inout Generator) -> (Swift.ArraySlice<T>, Swift.ArraySlice<T>) where T == Self.Element, Generator : Swift.RandomNumberGenerator
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct MLModelClassifierAdaptor<Scalar> : CreateMLComponents.Classifier where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public enum Label : Swift.Hashable, Swift.Sendable {
    case string(Swift.String)
    case int(Swift.Int)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.MLModelClassifierAdaptor<Scalar>.Label, b: CreateMLComponents.MLModelClassifierAdaptor<Scalar>.Label) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let model: CoreML.MLModel
  public init(contentsOf url: Foundation.URL, configuration: CoreML.MLModelConfiguration) throws
  public init(model: CoreML.MLModel) throws
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ClassificationDistribution<CreateMLComponents.MLModelClassifierAdaptor<Scalar>.Label>
  #endif
  public typealias Input = CoreML.MLShapedArray<Scalar>
  public typealias Output = CreateMLComponents.ClassificationDistribution<CreateMLComponents.MLModelClassifierAdaptor<Scalar>.Label>
}
@available(*, unavailable)
extension CreateMLComponents.MLModelClassifierAdaptor : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MLModelClassifierAdaptor.Label : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MLModelClassifierAdaptor.Label : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MLModelClassifierAdaptor.Label : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct Classification<Label> : Swift.Hashable where Label : Swift.Hashable {
  public var label: Label
  public var probability: Swift.Float
  public init(label: Label, probability: Swift.Float)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.Classification<Label>, b: CreateMLComponents.Classification<Label>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Classification : Swift.Codable where Label : Swift.Decodable, Label : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Classification : Swift.Sendable where Label : Swift.Sendable {
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol Estimator<Transformer> {
  associatedtype Transformer : CreateMLComponents.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where S : Swift.Sequence, S.Element == Self.Transformer.Input
  #endif
  func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol Estimator {
  associatedtype Transformer : CreateMLComponents.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where S : Swift.Sequence, S.Element == Self.Transformer.Input
  #endif
  func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.Estimator {
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func fitted<S>(to input: S) async throws -> Self.Transformer where S : Swift.Sequence, S.Element == Self.Transformer.Input {
        try await fitted(to: input, eventHandler: nil)
    }
  #endif
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol UpdatableEstimator<Transformer> : CreateMLComponents.Estimator {
  func makeTransformer() -> Self.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element == Self.Transformer.Input
  #endif
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol UpdatableEstimator : CreateMLComponents.Estimator {
  func makeTransformer() -> Self.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element == Self.Transformer.Input
  #endif
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.UpdatableEstimator {
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence) async throws where InputSequence : Swift.Sequence, InputSequence.Element == Self.Transformer.Input {
        try await update(&transformer, with: input, eventHandler: nil)
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct AnnotatedFeature<Feature, Annotation> {
  public var feature: Feature
  public var annotation: Annotation
  public init(feature: Feature, annotation: Annotation)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AnnotatedFeature : Swift.Encodable where Feature : Swift.Encodable, Annotation : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AnnotatedFeature : Swift.Decodable where Feature : Swift.Decodable, Annotation : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AnnotatedFeature : Swift.Equatable where Feature : Swift.Equatable, Annotation : Swift.Equatable {
  public static func == (a: CreateMLComponents.AnnotatedFeature<Feature, Annotation>, b: CreateMLComponents.AnnotatedFeature<Feature, Annotation>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AnnotatedFeature : Swift.Hashable where Feature : Swift.Hashable, Annotation : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AnnotatedFeature : Swift.Sendable where Feature : Swift.Sendable, Annotation : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct FullyConnectedNetworkRegressorModel<Scalar> : CreateMLComponents.Regressor, Swift.Codable where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public typealias Target = Swift.Float
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar>.Target
  #endif
  public typealias Input = CoreML.MLShapedArray<Scalar>
  public typealias Output = CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar>.Target
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.FullyConnectedNetworkRegressorModel : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(*, unavailable)
extension CreateMLComponents.FullyConnectedNetworkRegressorModel : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct PreprocessingTemporalEstimator<Preprocessor, Estimator> : CreateMLComponents.TemporalEstimator where Preprocessor : CreateMLComponents.TemporalTransformer, Estimator : CreateMLComponents.TemporalEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTemporalTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func preprocessed<InputSequence>(from input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>] where InputSequence : Swift.Sequence, Preprocessor.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        var preprocessed = [PreprocessedFeatureSequence<Preprocessor.Output>]()
        for item in input {
            let transformed = try await preprocessor.applied(to: item, eventHandler: eventHandler)
            let stored = try await PreprocessedFeatureSequence(transformed)
            preprocessed.append(stored)
        }
        return preprocessed
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted(toPreprocessed preprocessed: [CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingTemporalEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTemporalTransformer(preprocessor, fittedTransformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingTemporalEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Preprocessor.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  #endif
  public func encode(_ transformer: CreateMLComponents.PreprocessingTemporalEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingTemporalEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PreprocessingTemporalEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingTemporalEstimator<CreateMLComponents.TransformerToTemporalAdaptor<Self>, Other> where Other : CreateMLComponents.TemporalEstimator, Self.Output == Other.Transformer.Input
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingTemporalEstimator<Self, CreateMLComponents.EstimatorToTemporalAdaptor<Other>> where Other : CreateMLComponents.Estimator, Self.Output == Other.Transformer.Input
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingTemporalEstimator<Self, Other> where Other : CreateMLComponents.TemporalEstimator, Self.Output == Other.Transformer.Input
}
extension CreateMLComponents.AudioReader {
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  public struct MicrophoneAsyncBuffers : CreateMLComponents.TemporalSequence, Swift.Sendable {
    public typealias AsyncIterator = CreateMLComponents.AudioReader.MicrophoneAsyncBuffers.Iterator
    public typealias Feature = AVFAudio.AVAudioPCMBuffer
    public var count: Swift.Int? {
      get
    }
    public func makeAsyncIterator() -> CreateMLComponents.AudioReader.MicrophoneAsyncBuffers.Iterator
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.AudioReader.MicrophoneAsyncBuffers.Feature>
  }
  #endif
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.AudioReader.MicrophoneAsyncBuffers {
  @_hasMissingDesignatedInitializers @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  final public class Iterator : _Concurrency.AsyncIteratorProtocol {
    @objc deinit
    #if compiler(>=5.3) && $AsyncAwait
    final public func next() async throws -> CreateMLComponents.TemporalFeature<CreateMLComponents.AudioReader.MicrophoneAsyncBuffers.Feature>?
    #endif
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.AudioReader.MicrophoneAsyncBuffers.Feature>
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
@available(tvOS, unavailable)
extension CreateMLComponents.AudioReader.MicrophoneAsyncBuffers.Iterator : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol SupervisedTabularEstimator<Transformer, Annotation> {
  associatedtype Transformer : CreateMLComponents.TabularTransformer
  associatedtype Annotation
  var annotationColumnID: TabularData.ColumnID<Self.Annotation> { get set }
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame?, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer
  #endif
  func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol SupervisedTabularEstimator {
  associatedtype Transformer : CreateMLComponents.TabularTransformer
  associatedtype Annotation
  var annotationColumnID: TabularData.ColumnID<Self.Annotation> { get set }
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame?, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer
  #endif
  func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.SupervisedTabularEstimator {
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame? = nil) async throws -> Self.Transformer {
        try await fitted(to: input, validateOn: validation, eventHandler: nil)
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.SupervisedTabularEstimator where Self.Transformer : Swift.Encodable {
  public func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.SupervisedTabularEstimator where Self.Transformer : Swift.Decodable {
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol UpdatableSupervisedTabularEstimator<Transformer, Annotation> : CreateMLComponents.SupervisedTabularEstimator {
  func makeTransformer() -> Self.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func update(_ transformer: inout Self.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws
  #endif
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol UpdatableSupervisedTabularEstimator : CreateMLComponents.SupervisedTabularEstimator {
  func makeTransformer() -> Self.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func update(_ transformer: inout Self.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws
  #endif
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.UpdatableSupervisedTabularEstimator {
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func update(_ transformer: inout Self.Transformer, with input: TabularData.DataFrame) async throws {
        try await update(&transformer, with: input, eventHandler: nil)
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct CategoricalImputer<Element> : CreateMLComponents.Estimator where Element : Swift.Decodable, Element : Swift.Encodable, Element : Swift.Hashable {
  public typealias Transformer = CreateMLComponents.ImputeTransformer<Element>
  public enum Strategy {
    case mode
    case constant(Element)
  }
  public var strategy: CreateMLComponents.CategoricalImputer<Element>.Strategy
  public init(_ strategy: CreateMLComponents.CategoricalImputer<Element>.Strategy)
  public init(constant: Element)
  #if compiler(>=5.3) && $Sendable
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) -> CreateMLComponents.CategoricalImputer<Element>.Transformer where S : Swift.Sequence, S.Element == Element?
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.CategoricalImputer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.CategoricalImputer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.CategoricalImputer.Strategy : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum ModelUpdateError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case invalidState(debugDescription: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.ModelUpdateError, b: CreateMLComponents.ModelUpdateError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ModelUpdateError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension CreateMLComponents.UpdatableTabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTabularEstimator where Other : CreateMLComponents.TabularTransformer
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTabularEstimator where Other : CreateMLComponents.UpdatableTabularEstimator
  
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol Transformer<Input, Output> {
  associatedtype Input
  associatedtype Output
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func applied(to input: Self.Input, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Output
  #endif
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol Transformer {
  associatedtype Input
  associatedtype Output
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func applied(to input: Self.Input, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Output
  #endif
}
#endif
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Transformer {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [Self.Output] where S : Swift.Sequence, Self.Input == S.Element {
        var result = [Output]()
        result.reserveCapacity(input.underestimatedCount)
        for example in input {
            try Task.checkCancellation()
            try await result.append(applied(to: example, eventHandler: eventHandler))
            if let eventHandler = eventHandler {
                let event = Event(
                    origin: String(describing: self),
                    itemCount: result.count,
                    totalItemCount: input.underestimatedCount,
                    metrics: [:]
                )
                eventHandler(event)
            }
        }
        return result
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func applied<S, Annotation>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.AnnotatedFeature<Self.Output, Annotation>] where S : Swift.Sequence, S.Element == CreateMLComponents.AnnotatedFeature<Self.Input, Annotation> {
        var result = [AnnotatedFeature<Output, Annotation>]()
        result.reserveCapacity(input.underestimatedCount)
        for example in input {
            try Task.checkCancellation()
            let transformed = try await applied(to: example.feature, eventHandler: eventHandler)
            result.append(AnnotatedFeature(feature: transformed, annotation: example.annotation))
            if let eventHandler = eventHandler {
                let event = Event(
                    origin: String(describing: self),
                    itemCount: result.count,
                    totalItemCount: input.underestimatedCount,
                    metrics: [:]
                )
                eventHandler(event)
            }
        }
        return result
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Transformer {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func callAsFunction(_ input: Self.Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Self.Output {
        try await applied(to: input, eventHandler: eventHandler)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func callAsFunction<S>(_ input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [Self.Output] where S : Swift.Sequence, Self.Input == S.Element {
        try await applied(to: input, eventHandler: eventHandler)
    }
  #endif
}
extension CreateMLComponents.UpdatableTabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTabularEstimator where Other : CreateMLComponents.UpdatableSupervisedTabularEstimator, Other.Annotation : Swift.Equatable
  
}
extension CreateMLComponents.UpdatableSupervisedTabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTabularEstimator where Other : CreateMLComponents.TabularTransformer, Self.Annotation : Swift.Equatable
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTabularEstimator where Other : CreateMLComponents.UpdatableTabularEstimator, Self.Annotation : Swift.Equatable
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTabularEstimator where Other : CreateMLComponents.UpdatableSupervisedTabularEstimator, Self.Annotation == Other.Annotation
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct OrdinalEncoder<Category> : CreateMLComponents.Estimator where Category : Swift.Comparable, Category : Swift.Decodable, Category : Swift.Encodable, Category : Swift.Hashable {
  public init()
  #if compiler(>=5.3) && $Sendable
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.OrdinalEncoder<Category>.Transformer where S : Swift.Sequence, S.Element == Category?
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.OrdinalEncoder : Swift.Sendable where Category : Swift.Sendable {
}
extension CreateMLComponents.OrdinalEncoder {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Transformer : CreateMLComponents.Transformer {
    public var categories: Swift.Set<Category?>
    public init(categories: Swift.Set<Category?>)
    #if compiler(>=5.3) && $Sendable
    public func applied(to input: Category?, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> Swift.Int
    #endif
    #if compiler(>=5.3) && $Sendable
    public func applied<S>(_ input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> [Swift.Int] where S : Swift.Sequence, S.Element == Category?
    #endif
    public func category(at index: Swift.Int) -> Category?
    public typealias Input = Category?
    public typealias Output = Swift.Int
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.OrdinalEncoder.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.OrdinalEncoder.Transformer : Swift.Sendable where Category : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.OrdinalEncoder.Transformer : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.OrdinalEncoder.Transformer : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct RobustScaler<Element> : CreateMLComponents.Estimator where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public var quantileRange: Swift.ClosedRange<Element>
  public init(quantileRange: Swift.ClosedRange<Element> = 0.25...0.75)
  #if compiler(>=5.3) && $Sendable
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.RobustScaler<Element>.Transformer where Element == S.Element, S : Swift.Sequence
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.RobustScaler : Swift.Sendable where Element : Swift.Sendable {
}
extension CreateMLComponents.RobustScaler {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Transformer : CreateMLComponents.Transformer, Swift.Hashable {
    public var median: Element
    public var interQuartileRange: Element
    public init(median: Element, interQuartileRange: Element)
    #if compiler(>=5.3) && $Sendable
    @inlinable public func applied(to input: Element, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
            var result = input

            if median.isFinite {
                result -= median
            }

            if interQuartileRange.isFinite && !interQuartileRange.isZero {
                result /= interQuartileRange
            }

            return result
        }
    #endif
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.RobustScaler<Element>.Transformer, b: CreateMLComponents.RobustScaler<Element>.Transformer) -> Swift.Bool
    public typealias Input = Element
    public typealias Output = Element
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.RobustScaler.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.RobustScaler.Transformer : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.RobustScaler.Transformer : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.RobustScaler.Transformer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct EstimatorToSupervisedAdaptor<Estimator, Annotation> : CreateMLComponents.SupervisedEstimator where Estimator : CreateMLComponents.Estimator, Annotation : Swift.Equatable {
  public typealias Transformer = Estimator.Transformer
  public let estimator: Estimator
  public init(_ estimator: Estimator)
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.EstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.EstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>
  #endif
  public func encode(_ transformer: CreateMLComponents.EstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.EstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.EstimatorToSupervisedAdaptor : Swift.Sendable where Estimator : Swift.Sendable, Annotation : Swift.Sendable {
}
extension CreateMLComponents.Estimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func adaptedAsSupervised<Annotation>(annotationType: Annotation.Type = Annotation.self) -> CreateMLComponents.EstimatorToSupervisedAdaptor<Self, Annotation> where Annotation : Swift.Equatable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation> : CreateMLComponents.UpdatableSupervisedEstimator where Estimator : CreateMLComponents.UpdatableEstimator, Annotation : Swift.Equatable {
  public typealias Transformer = Estimator.Transformer
  public let estimator: Estimator
  public init(_ estimator: Estimator)
  public func makeTransformer() -> Estimator.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func update<InputSequence>(_ transformer: inout Estimator.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func update<InputSequence, Validation>(_ transformer: inout Estimator.Transformer, with input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Validation : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Estimator.Transformer.Input, Annotation>
  #endif
  public func encode(_ transformer: CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor : Swift.Sendable where Estimator : Swift.Sendable, Annotation : Swift.Sendable {
}
extension CreateMLComponents.UpdatableEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func adaptedAsSupervised<Annotation>(annotationType: Annotation.Type = Annotation.self) -> CreateMLComponents.UpdatableEstimatorToSupervisedAdaptor<Self, Annotation> where Annotation : Swift.Equatable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TemporalEstimatorToSupervisedAdaptor<Estimator, Annotation> : CreateMLComponents.SupervisedTemporalEstimator where Estimator : CreateMLComponents.TemporalEstimator, Annotation : Swift.Equatable, Annotation : Swift.Sendable {
  public typealias Transformer = Estimator.Transformer
  public let estimator: Estimator
  public init(_ estimator: Estimator)
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  public func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.TemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.TemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input
  #endif
  public func encode(_ transformer: CreateMLComponents.TemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.TemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalEstimatorToSupervisedAdaptor : Swift.Sendable where Estimator : Swift.Sendable {
}
extension CreateMLComponents.TemporalEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func adaptedAsSupervised<Annotation>(annotationType: Annotation.Type = Annotation.self) -> CreateMLComponents.TemporalEstimatorToSupervisedAdaptor<Self, Annotation> where Annotation : Swift.Equatable, Annotation : Swift.Sendable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation> : CreateMLComponents.UpdatableSupervisedTemporalEstimator where Estimator : CreateMLComponents.UpdatableTemporalEstimator, Annotation : Swift.Equatable, Annotation : Swift.Sendable {
  public typealias Transformer = Estimator.Transformer
  public let estimator: Estimator
  public init(_ estimator: Estimator)
  public func makeTransformer() -> Estimator.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  public func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  public func update<InputSequence, FeatureSequence>(_ transformer: inout CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  public func update<InputSequence, Validation, FeatureSequence>(_ transformer: inout CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, with input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Annotation>, FeatureSequence.Feature == Estimator.Transformer.Input
  #endif
  public func encode(_ transformer: CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor : Swift.Sendable where Estimator : Swift.Sendable {
}
extension CreateMLComponents.UpdatableTemporalEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func adaptedAsSupervised<Annotation>(annotationType: Annotation.Type = Annotation.self) -> CreateMLComponents.UpdatableTemporalEstimatorToSupervisedAdaptor<Self, Annotation> where Annotation : Swift.Equatable, Annotation : Swift.Sendable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TabularEstimatorToSupervisedAdaptor<Estimator, Annotation> : CreateMLComponents.SupervisedTabularEstimator where Estimator : CreateMLComponents.TabularEstimator {
  public typealias Transformer = Estimator.Transformer
  public var annotationColumnID: TabularData.ColumnID<Annotation>
  public let estimator: Estimator
  public init(_ estimator: Estimator, annotationColumnID: TabularData.ColumnID<Annotation>)
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame? = nil, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Estimator.Transformer {
        try await estimator.fitted(to: input, eventHandler: eventHandler)
    }
  #endif
  public func encode(_ transformer: Estimator.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Estimator.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TabularEstimatorToSupervisedAdaptor : Swift.Sendable where Estimator : Swift.Sendable, Annotation : Swift.Sendable {
}
extension CreateMLComponents.TabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func adaptedAsSupervised<Annotation>(annotationColumnID: TabularData.ColumnID<Annotation>) -> CreateMLComponents.TabularEstimatorToSupervisedAdaptor<Self, Annotation>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation> : CreateMLComponents.UpdatableSupervisedTabularEstimator where Estimator : CreateMLComponents.UpdatableTabularEstimator, Annotation : Swift.Equatable {
  public typealias Transformer = Estimator.Transformer
  public var annotationColumnID: TabularData.ColumnID<Annotation>
  public let estimator: Estimator
  public init(_ estimator: Estimator, annotationColumnID: TabularData.ColumnID<Annotation>)
  public func makeTransformer() -> Estimator.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame?, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func update(_ transformer: inout CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws
  #endif
  public func encode(_ transformer: CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Estimator, Annotation>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor : Swift.Sendable where Estimator : Swift.Sendable, Annotation : Swift.Sendable {
}
extension CreateMLComponents.UpdatableTabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func adaptedAsSupervised<Annotation>(annotationColumnID: TabularData.ColumnID<Annotation>) -> CreateMLComponents.UpdatableTabularEstimatorToSupervisedAdaptor<Self, Annotation> where Annotation : Swift.Equatable
}
extension CreateMLComponents.UpdatableEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTemporalEstimator where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTemporalEstimator where Other : CreateMLComponents.UpdatableTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.UpdatableTemporalEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTemporalEstimator where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTemporalEstimator where Other : CreateMLComponents.UpdatableEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTemporalEstimator where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableTemporalEstimator where Other : CreateMLComponents.UpdatableTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum ColumnSelection : Swift.Codable, Swift.Sendable {
  case all
  case numeric
  case include(columnNames: [Swift.String])
  case exclude(columnNames: [Swift.String])
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension TabularData.DataFrame {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func selecting(_ selection: CreateMLComponents.ColumnSelection) -> TabularData.DataFrame
}
extension TabularData.DataFrame {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public init<S, Feature, Annotation>(_ sequence: S, featuresColumnID: TabularData.ColumnID<Feature>, annotationsColumnID: TabularData.ColumnID<Annotation>) throws where S : Swift.Sequence, S.Element == CreateMLComponents.AnnotatedFeature<Feature, Annotation>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.FullyConnectedNetworkRegressor {
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar>
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.FullyConnectedNetworkRegressor<Scalar>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.FullyConnectedNetworkRegressor<Scalar>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct HumanBodyActionCounter : CreateMLComponents.TemporalTransformer, Swift.Sendable {
  public typealias Input = [CreateMLComponents.Pose]
  public typealias Output = Swift.Float
  #if compiler(>=5.3) && $RethrowsProtocol
  public typealias OutputSequence = CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence
  #endif
  public init()
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.HumanBodyActionCounter.OutputSequence where S : CreateMLComponents.TemporalSequence, S.Feature == [CreateMLComponents.Pose]
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum PipelineDataError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case missingValue(operation: Swift.String)
  case missingAnnotation(operation: Swift.String)
  case emptyInput(operation: Swift.String)
  case unrecognizedCategory(operation: Swift.String, category: Swift.String)
  case incompatibleDataFormat(operation: Swift.String, debugDescription: Swift.String)
  case incompatibleConfiguration(operation: Swift.String, debugDescription: Swift.String)
  case incompatibleShape([Swift.Int], debugDescription: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.PipelineDataError, b: CreateMLComponents.PipelineDataError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PipelineDataError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct AudioFeaturePrint : CreateMLComponents.TemporalTransformer, Swift.Sendable {
  public typealias Input = AVFAudio.AVAudioPCMBuffer
  public typealias Output = CoreML.MLShapedArray<Swift.Float>
  public let windowDuration: Foundation.TimeInterval
  public let overlapFactor: Swift.Double
  public init(windowDuration: Foundation.TimeInterval, overlapFactor: Swift.Double)
  #if compiler(>=5.3) && $RethrowsProtocol && $Sendable
  public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.AudioFeaturePrint.FeatureSequence where S : CreateMLComponents.TemporalSequence, S.Feature == AVFAudio.AVAudioPCMBuffer
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public typealias OutputSequence = CreateMLComponents.AudioFeaturePrint.FeatureSequence
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioFeaturePrint : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioFeaturePrint {
  #if compiler(>=5.3) && $RethrowsProtocol
  public struct FeatureSequence : CreateMLComponents.TemporalSequence {
    public typealias Feature = CoreML.MLShapedArray<Swift.Float>
    public typealias AsyncIterator = CreateMLComponents.AudioFeaturePrint.FeatureSequence.Iterator
    public var count: Swift.Int? {
      get
    }
    public func makeAsyncIterator() -> CreateMLComponents.AudioFeaturePrint.FeatureSequence.AsyncIterator
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.AudioFeaturePrint.FeatureSequence.Feature>
  }
  #endif
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.AudioFeaturePrint.FeatureSequence : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioFeaturePrint.FeatureSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async throws -> CreateMLComponents.TemporalFeature<CoreML.MLShapedArray<Swift.Float>>?
    #endif
    public typealias Element = CreateMLComponents.TemporalFeature<CoreML.MLShapedArray<Swift.Float>>
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.AudioFeaturePrint.FeatureSequence.Iterator : Swift.Sendable {
}
#endif
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct AudioReader : CreateMLComponents.Transformer, Swift.Sendable {
  public var configuration: CreateMLComponents.AudioReader.Configuration
  public init(configuration: CreateMLComponents.AudioReader.Configuration = .init())
  #if compiler(>=5.3) && $RethrowsProtocol && $Sendable
  public func applied(to url: Foundation.URL, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.AudioReader.AsyncBuffers
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public static func read(contentsOf url: Foundation.URL, configuration: CreateMLComponents.AudioReader.Configuration = .init()) throws -> CreateMLComponents.AudioReader.AsyncBuffers
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public static func read<S>(_ files: S, configuration: CreateMLComponents.AudioReader.Configuration = .init()) throws -> [CreateMLComponents.AudioReader.AsyncBuffers] where S : Swift.Sequence, S.Element == Foundation.URL
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public static func read<S, Annotation>(_ annotatedFiles: S, configuration: CreateMLComponents.AudioReader.Configuration = .init()) throws -> [CreateMLComponents.AnnotatedFeature<CreateMLComponents.AudioReader.AsyncBuffers, Annotation>] where S : Swift.Sequence, Annotation : Swift.Equatable, Annotation : Swift.Sendable, S.Element == CreateMLComponents.AnnotatedFeature<Foundation.URL, Annotation>
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  public static func readMicrophone(configuration: CreateMLComponents.AudioReader.Configuration = .init()) async throws -> CreateMLComponents.AudioReader.MicrophoneAsyncBuffers
  #endif
  public typealias Input = Foundation.URL
  #if compiler(>=5.3) && $RethrowsProtocol
  public typealias Output = CreateMLComponents.AudioReader.AsyncBuffers
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct PreprocessingEstimator<Preprocessor, Estimator> : CreateMLComponents.Estimator where Preprocessor : CreateMLComponents.Transformer, Estimator : CreateMLComponents.Estimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func preprocessed<S>(from input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [Preprocessor.Output] where S : Swift.Sequence, Preprocessor.Input == S.Element {
        try await preprocessor.applied(to: input, eventHandler: eventHandler)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<S>(toPreprocessed preprocessed: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingEstimator<Preprocessor, Estimator>.Transformer where S : Swift.Sequence, Preprocessor.Output == S.Element, S.Element == Estimator.Transformer.Input {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingEstimator<Preprocessor, Estimator>.Transformer where S : Swift.Sequence, Preprocessor.Input == S.Element {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  #endif
  public func encode(_ transformer: CreateMLComponents.PreprocessingEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PreprocessingEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingEstimator<Self, Other> where Other : CreateMLComponents.Estimator, Self.Output == Other.Transformer.Input
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct AnnotatedFiles : Swift.Collection {
  public typealias Element = CreateMLComponents.AnnotatedFeature<Foundation.URL, Swift.String>
  public typealias Index = Swift.Array<CreateMLComponents.AnnotatedFiles.Element>.Index
  public var startIndex: CreateMLComponents.AnnotatedFiles.Index {
    get
  }
  public var endIndex: CreateMLComponents.AnnotatedFiles.Index {
    get
  }
  public subscript(index: CreateMLComponents.AnnotatedFiles.Index) -> Swift.IndexingIterator<CreateMLComponents.AnnotatedFiles>.Element {
    get
  }
  public func index(after i: CreateMLComponents.AnnotatedFiles.Index) -> CreateMLComponents.AnnotatedFiles.Index
  public typealias Indices = Swift.DefaultIndices<CreateMLComponents.AnnotatedFiles>
  public typealias Iterator = Swift.IndexingIterator<CreateMLComponents.AnnotatedFiles>
  public typealias SubSequence = Swift.Slice<CreateMLComponents.AnnotatedFiles>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AnnotatedFiles {
  public init(labeledByNamesAt url: Foundation.URL, separator: Swift.Character = ".", index: Swift.Int = 0, type: UniformTypeIdentifiers.UTType, continueOnFailure: Swift.Bool = false) throws
  public init(labeledBySubdirectoryNamesAt url: Foundation.URL, type: UniformTypeIdentifiers.UTType, continueOnFailure: Swift.Bool = false) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AnnotatedFiles : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AnnotatedFiles : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AnnotatedFiles : Swift.Equatable {
  public static func == (a: CreateMLComponents.AnnotatedFiles, b: CreateMLComponents.AnnotatedFiles) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AnnotatedFiles : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AnnotatedFiles : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.FullyConnectedNetworkClassifier {
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.FullyConnectedNetworkClassifierModel<Scalar, Label>
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.FullyConnectedNetworkClassifier<Scalar, Label>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.FullyConnectedNetworkClassifier<Scalar, Label>.Transformer
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol TabularEstimator<Transformer> {
  associatedtype Transformer : CreateMLComponents.TabularTransformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func fitted(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer
  #endif
  func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol TabularEstimator {
  associatedtype Transformer : CreateMLComponents.TabularTransformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func fitted(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer
  #endif
  func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.TabularEstimator where Self.Transformer : Swift.Encodable {
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func fitted(to input: TabularData.DataFrame) async throws -> Self.Transformer {
        try await fitted(to: input, eventHandler: nil)
    }
  #endif
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        try encoder.encode(transformer)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TabularEstimator where Self.Transformer : Swift.Decodable {
  @inlinable public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer {
        try decoder.decode(Transformer.self)
    }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol UpdatableTabularEstimator<Transformer> : CreateMLComponents.TabularEstimator {
  func makeTransformer() -> Self.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func update(_ transformer: inout Self.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws
  #endif
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol UpdatableTabularEstimator : CreateMLComponents.TabularEstimator {
  func makeTransformer() -> Self.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func update(_ transformer: inout Self.Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler?) async throws
  #endif
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.UpdatableTabularEstimator {
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func update(_ transformer: inout Self.Transformer, with input: TabularData.DataFrame) async throws {
        try await update(&transformer, with: input, eventHandler: nil)
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct AnnotatedFeatureProvider<Base, UnwrappedInput> : CreateMLComponents.SupervisedTabularEstimator where Base : CreateMLComponents.SupervisedEstimator, Base.Transformer.Input == UnwrappedInput? {
  public typealias Transformer = CreateMLComponents.ColumnSelectorTransformer<Base.Transformer, UnwrappedInput>
  public typealias Annotation = Base.Annotation
  public var base: Base
  public var annotationColumnID: TabularData.ColumnID<CreateMLComponents.AnnotatedFeatureProvider<Base, UnwrappedInput>.Annotation>
  public var featuresColumnName: Swift.String
  public var resultsColumnName: Swift.String
  public init(_ base: Base, annotationsColumnName: Swift.String = "targets", featuresColumnName: Swift.String = "features", resultsColumnName: Swift.String = "results")
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame? = nil, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ColumnSelectorTransformer<Base.Transformer, UnwrappedInput>
  #endif
  public func encode(_ transformer: CreateMLComponents.AnnotatedFeatureProvider<Base, UnwrappedInput>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.AnnotatedFeatureProvider<Base, UnwrappedInput>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AnnotatedFeatureProvider : Swift.Sendable where Base : Swift.Sendable {
}
extension CreateMLComponents.UpdatableEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator where Other : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.UpdatableSupervisedEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator where Other : CreateMLComponents.UpdatableTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator where Other : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.UpdatableTemporalEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator where Other : CreateMLComponents.UpdatableSupervisedEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator where Other : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.UpdatableSupervisedTemporalEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator where Other : CreateMLComponents.UpdatableEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator where Other : CreateMLComponents.UpdatableSupervisedEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator where Other : CreateMLComponents.UpdatableTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedTemporalEstimator where Other : CreateMLComponents.UpdatableSupervisedTemporalEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol TabularTransformer : CreateMLComponents.Transformer where Self.Input == TabularData.DataFrame, Self.Output == TabularData.DataFrame {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TabularTransformer {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func callAsFunction(_ input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame {
        try await applied(to: input, eventHandler: eventHandler)
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct PreprocessingSupervisedEstimator<Preprocessor, Estimator> : CreateMLComponents.SupervisedEstimator where Preprocessor : CreateMLComponents.Transformer, Estimator : CreateMLComponents.SupervisedEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public typealias Annotation = Estimator.Annotation
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func preprocessed<S>(from input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Swift.AnySequence<CreateMLComponents.AnnotatedFeature<Preprocessor.Output, CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Annotation>> where S : Swift.Sequence, S.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let inputFeatures = input.lazy.map(\.feature)
        let preprocessedFeatures = try await preprocessor.applied(to: inputFeatures, eventHandler: eventHandler)
        return AnySequence(zip(preprocessedFeatures, input.lazy.map(\.annotation)).lazy.map(AnnotatedFeature.init))
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<S>(toPreprocessed preprocessed: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Transformer where S : Swift.Sequence, S.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation> {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessed,
            eventHandler: eventHandler
        )
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<Input, Validation>(toPreprocessed preprocessedInput: Input, validateOn preprocessedValidation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Transformer where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation> {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let inputFeatures = input.lazy.map(\.feature)
        let inputAnnotations = input.lazy.map(\.annotation)

        let preprocessed = try await preprocessor.applied(to: inputFeatures, eventHandler: eventHandler)
        try Task.checkCancellation()

        let fittedTransformer = try await estimator.fitted(
            to: zip(preprocessed, inputAnnotations).lazy.map(AnnotatedFeature.init),
            eventHandler: eventHandler
        )
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<InputSequence, Validation>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let inputFeatures = input.lazy.map(\.feature)
        let inputAnnotations = input.lazy.map(\.annotation)

        let validationFeatures = validation.lazy.map(\.feature)
        let validationAnnotations = validation.lazy.map(\.annotation)

        let preprocessedInput = try await preprocessor.applied(to: inputFeatures, eventHandler: eventHandler)
        try Task.checkCancellation()

        let preprocessedValidation = try await preprocessor.applied(to: validationFeatures, eventHandler: eventHandler)
        try Task.checkCancellation()

        let fittedTransformer = try await estimator.fitted(
            to: zip(preprocessedInput, inputAnnotations).lazy.map(AnnotatedFeature.init),
            validateOn: zip(preprocessedValidation, validationAnnotations).lazy.map(AnnotatedFeature.init),
            eventHandler: eventHandler
        )
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  #endif
  public func encode(_ transformer: CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingSupervisedEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PreprocessingSupervisedEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingSupervisedEstimator<Self, Other> where Other : CreateMLComponents.SupervisedEstimator, Self.Output == Other.Transformer.Input
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct JointsSelector : CreateMLComponents.Transformer, Swift.Sendable {
  public var ignoredJoints: [CreateMLComponents.JointKey]?
  public var selectedJoints: [CreateMLComponents.JointKey]?
  public init(ignoredJoints: [CreateMLComponents.JointKey])
  public init(selectedJoints: [CreateMLComponents.JointKey])
  #if compiler(>=5.3) && $Sendable
  public func applied(to input: CreateMLComponents.Pose, eventHandler: CreateMLComponents.EventHandler? = nil) -> CreateMLComponents.Pose
  #endif
  public typealias Input = CreateMLComponents.Pose
  public typealias Output = CreateMLComponents.Pose
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.JointsSelector : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct PreprocessingUpdatableEstimator<Preprocessor, Estimator> : CreateMLComponents.UpdatableEstimator where Preprocessor : CreateMLComponents.Transformer, Estimator : CreateMLComponents.UpdatableEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ inner: Preprocessor, _ outer: Estimator)
  @inlinable public func makeTransformer() -> CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer {
        ComposedTransformer(preprocessor, estimator.makeTransformer())
    }
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func preprocessed<S>(from input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [Preprocessor.Output] where S : Swift.Sequence, Preprocessor.Input == S.Element {
        try await preprocessor.applied(to: input, eventHandler: eventHandler)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<S>(toPreprocessed preprocessed: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer where S : Swift.Sequence, Preprocessor.Output == S.Element, S.Element == Estimator.Transformer.Input {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer where S : Swift.Sequence, Preprocessor.Input == S.Element {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer, withPreprocessed preprocessed: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Preprocessor.Output == InputSequence.Element, InputSequence.Element == Estimator.Transformer.Input {
        try await estimator.update(&transformer.outer, with: preprocessed, eventHandler: eventHandler)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Preprocessor.Input == InputSequence.Element {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        try await estimator.update(&transformer.outer, with: preprocessed, eventHandler: eventHandler)
    }
  #endif
  public func encode(_ transformer: CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PreprocessingUpdatableEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableEstimator<Self, Other> where Other : CreateMLComponents.UpdatableEstimator, Self.Output == Other.Transformer.Input
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TreeRegressorModel : CreateMLComponents.TabularTransformer {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame
  #endif
  public typealias Input = TabularData.DataFrame
  public typealias Output = TabularData.DataFrame
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TreeRegressorModel : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(*, unavailable)
extension CreateMLComponents.TreeRegressorModel : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ImageReader : CreateMLComponents.Transformer, Swift.Sendable {
  public init()
  #if compiler(>=5.3) && $Sendable
  public func applied(to url: Foundation.URL, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CoreImage.CIImage
  #endif
  public static func read(url: Foundation.URL) throws -> CoreImage.CIImage
  public typealias Input = Foundation.URL
  public typealias Output = CoreImage.CIImage
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageReader : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public func maximumAbsoluteError<E, C>(_ estimated: E, _ correct: C) -> E.Element where E : Swift.Collection, C : Swift.Collection, E.Element : Swift.FloatingPoint, E.Element == C.Element
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public func meanAbsoluteError<E, C>(_ estimated: E, _ correct: C) -> E.Element where E : Swift.Collection, C : Swift.Collection, E.Element : Swift.FloatingPoint, E.Element == C.Element
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public func rootMeanSquaredError<E, C>(_ estimated: E, _ correct: C) -> E.Element where E : Swift.Collection, C : Swift.Collection, E.Element : Swift.FloatingPoint, E.Element == C.Element
#if compiler(>=5.3) && $RethrowsProtocol
#if $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol TemporalSequence<Feature> : _Concurrency.AsyncSequence {
  associatedtype Feature where Self.Element == CreateMLComponents.TemporalFeature<Self.Feature>
  var count: Swift.Int? { get }
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol TemporalSequence : _Concurrency.AsyncSequence {
  associatedtype Feature where Self.Element == CreateMLComponents.TemporalFeature<Self.Feature>
  var count: Swift.Int? { get }
}
#endif
#endif
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TemporalFeature<Feature> : Swift.Identifiable {
  public var id: CreateMLComponents.TemporalSegmentIdentifier
  public var feature: Feature
  public init(id: CreateMLComponents.TemporalSegmentIdentifier, feature: Feature)
  public typealias ID = CreateMLComponents.TemporalSegmentIdentifier
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalFeature : Swift.Equatable where Feature : Swift.Equatable {
  public static func == (a: CreateMLComponents.TemporalFeature<Feature>, b: CreateMLComponents.TemporalFeature<Feature>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalFeature : Swift.Hashable where Feature : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalFeature : Swift.Encodable where Feature : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalFeature : Swift.Decodable where Feature : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalFeature : Swift.Sendable where Feature : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum DatasetError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case missingResource(Foundation.URL)
  case incompatibleDataFormat(Foundation.URL, debugDescription: Swift.String)
  case unreadableResource(Foundation.URL)
  case incorrectName(Foundation.URL, debugDescription: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.DatasetError, b: CreateMLComponents.DatasetError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.DatasetError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum AudioReaderError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case microphoneAuthorizationDenied
  case microphoneAuthorizationRestricted
  case sourceDeviceNotAvailable
  public var errorDescription: Swift.String? {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.AudioReaderError, b: CreateMLComponents.AudioReaderError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioReaderError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ComposedTemporalTransformer<Inner, Outer> : CreateMLComponents.TemporalTransformer where Inner : CreateMLComponents.TemporalTransformer, Outer : CreateMLComponents.TemporalTransformer, Inner.Output == Outer.Input {
  public typealias Input = Inner.Input
  public typealias Intermediate = Inner.Output
  public typealias Output = Outer.Output
  public typealias OutputSequence = Outer.OutputSequence
  public var inner: Inner
  public var outer: Outer
  public init(_ inner: Inner, _ outer: Outer)
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ComposedTemporalTransformer<Inner, Outer>.OutputSequence where S : CreateMLComponents.TemporalSequence, Inner.Input == S.Feature {
        let o0 = try await inner.applied(to: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        let o1 = try await outer.applied(to: o0, eventHandler: eventHandler)
        return o1
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTemporalTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTemporalTransformer : Swift.Sendable where Inner : Swift.Sendable, Outer : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTemporalTransformer : Swift.Equatable where Inner : Swift.Equatable, Outer : Swift.Equatable {
  public static func == (a: CreateMLComponents.ComposedTemporalTransformer<Inner, Outer>, b: CreateMLComponents.ComposedTemporalTransformer<Inner, Outer>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTemporalTransformer : Swift.Encodable where Inner : Swift.Encodable, Outer : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTemporalTransformer : Swift.Decodable where Inner : Swift.Decodable, Outer : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.ComposedTemporalTransformer<CreateMLComponents.TransformerToTemporalAdaptor<Self>, Other> where Other : CreateMLComponents.TemporalTransformer, Self.Output == Other.Input
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.ComposedTemporalTransformer<Self, CreateMLComponents.TransformerToTemporalAdaptor<Other>> where Other : CreateMLComponents.Transformer, Self.Output == Other.Input
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.ComposedTemporalTransformer<Self, Other> where Other : CreateMLComponents.TemporalTransformer, Self.Output == Other.Input
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct DataFrameTemporalAnnotationParameters<Annotation> where Annotation : Swift.Equatable, Annotation : Swift.Sendable {
  public enum FilePathType : Swift.Equatable, Swift.CustomStringConvertible, Swift.Sendable {
    case relative(baseURL: Foundation.URL)
    case absolute
    public var description: Swift.String {
      get
    }
    public static func == (a: CreateMLComponents.DataFrameTemporalAnnotationParameters<Annotation>.FilePathType, b: CreateMLComponents.DataFrameTemporalAnnotationParameters<Annotation>.FilePathType) -> Swift.Bool
  }
  public var filePathType: CreateMLComponents.DataFrameTemporalAnnotationParameters<Annotation>.FilePathType
  public var filePathColumnID: TabularData.ColumnID<Swift.String>
  public var annotationColumnID: TabularData.ColumnID<Annotation>
  public var startTimeColumnID: TabularData.ColumnID<Swift.Double>?
  public var endTimeColumnID: TabularData.ColumnID<Swift.Double>?
  public init()
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.DataFrameTemporalAnnotationParameters : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension TabularData.DataFrame {
  public func loadRangedAnnotations<Annotation>(parameters: CreateMLComponents.DataFrameTemporalAnnotationParameters<Annotation> = .init(), continueOnFailure: Swift.Bool = false) throws -> [CreateMLComponents.AnnotatedFeature<CreateMLComponents.TemporalFileSegment, Annotation>] where Annotation : Swift.Equatable, Annotation : Swift.Sendable
}
extension CreateMLComponents.UpdatableEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedEstimator where Other : CreateMLComponents.UpdatableSupervisedEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.UpdatableSupervisedEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedEstimator where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedEstimator where Other : CreateMLComponents.UpdatableEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableSupervisedEstimator where Other : CreateMLComponents.UpdatableSupervisedEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Estimator where Self.Transformer : Swift.Encodable {
  public func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Estimator where Self.Transformer : Swift.Decodable {
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.SupervisedEstimator where Self.Transformer : Swift.Encodable {
  public func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.SupervisedEstimator where Self.Transformer : Swift.Decodable {
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Estimator {
  public func write(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func read(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.SupervisedEstimator {
  public func write(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func read(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.UpdatableSupervisedEstimator {
  public func writeWithOptimizer(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func readWithOptimizer(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ColumnConcatenator<Scalar> : CreateMLComponents.TabularTransformer where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public var columnSelection: CreateMLComponents.ColumnSelection
  public var concatenatedColumnName: Swift.String
  public init(columnSelection: CreateMLComponents.ColumnSelection = .all, concatenatedColumnName: Swift.String = "features")
  #if compiler(>=5.3) && $Sendable
  public func applied(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> TabularData.DataFrame
  #endif
  public typealias Input = TabularData.DataFrame
  public typealias Output = TabularData.DataFrame
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ColumnConcatenator : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ColumnConcatenator : Swift.Sendable where Scalar : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct StandardScaler<Element> : CreateMLComponents.Estimator where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public init()
  #if compiler(>=5.3) && $Sendable
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.StandardScaler<Element>.Transformer where Element == S.Element, S : Swift.Sequence
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.StandardScaler : Swift.Sendable where Element : Swift.Sendable {
}
extension CreateMLComponents.StandardScaler {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Transformer : CreateMLComponents.Transformer, Swift.Hashable {
    public var mean: Element
    public var standardDeviation: Element
    public init(mean: Element, standardDeviation: Element)
    #if compiler(>=5.3) && $Sendable
    @inlinable public func applied(to input: Element, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
            var result = input

            if mean.isFinite {
                result -= mean
            }

            if standardDeviation.isFinite && !standardDeviation.isZero {
                result /= standardDeviation
            }

            return result
        }
    #endif
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.StandardScaler<Element>.Transformer, b: CreateMLComponents.StandardScaler<Element>.Transformer) -> Swift.Bool
    public typealias Input = Element
    public typealias Output = Element
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.StandardScaler.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.StandardScaler.Transformer : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.StandardScaler.Transformer : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.StandardScaler.Transformer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct FullyConnectedNetworkClassifierModel<Scalar, Label> : CreateMLComponents.Classifier, Swift.Codable where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint, Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ClassificationDistribution<Label>
  #endif
  public typealias Input = CoreML.MLShapedArray<Scalar>
  public typealias Output = CreateMLComponents.ClassificationDistribution<Label>
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.FullyConnectedNetworkClassifierModel : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(*, unavailable)
extension CreateMLComponents.FullyConnectedNetworkClassifierModel : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct Downsampler<Input> : CreateMLComponents.TemporalTransformer, Swift.Codable, Swift.Sendable where Input : Swift.Sendable {
  public typealias Input = Input
  public typealias Output = Input
  public let factor: Swift.Int
  public init(factor: Swift.Int)
  #if compiler(>=5.3) && $RethrowsProtocol && $Sendable
  public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler?) throws -> CreateMLComponents.Downsampler<Input>.DownStreamSequence where Input == S.Feature, S : CreateMLComponents.TemporalSequence
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public typealias OutputSequence = CreateMLComponents.Downsampler<Input>.DownStreamSequence
  #endif
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Downsampler {
  #if compiler(>=5.3) && $RethrowsProtocol
  public struct DownStreamSequence : CreateMLComponents.TemporalSequence {
    public typealias Feature = Input
    public typealias AsyncIterator = CreateMLComponents.Downsampler<Input>.DownStreamSequence.Iterator
    public var count: Swift.Int? {
      get
    }
    public func makeAsyncIterator() -> CreateMLComponents.Downsampler<Input>.DownStreamSequence.Iterator
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.Downsampler<Input>.DownStreamSequence.Feature>
  }
  #endif
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.Downsampler.DownStreamSequence : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Downsampler.DownStreamSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async throws -> CreateMLComponents.TemporalFeature<CreateMLComponents.Downsampler<Input>.Output>?
    #endif
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.Downsampler<Input>.Output>
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.Downsampler.DownStreamSequence.Iterator : Swift.Sendable {
}
#endif
extension CreateMLComponents.TabularTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TabularEstimator where Other : CreateMLComponents.TabularEstimator
  
}
extension CreateMLComponents.TabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TabularEstimator where Other : CreateMLComponents.TabularTransformer
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TabularEstimator where Other : CreateMLComponents.TabularEstimator
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct Reshaper<Scalar> : CreateMLComponents.Transformer, Swift.Equatable, Swift.Codable where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.Decodable, Scalar : Swift.Encodable {
  public var shape: [Swift.Int]
  public init(shape: [Swift.Int])
  #if compiler(>=5.3) && $Sendable
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CoreML.MLShapedArray<Scalar>
  #endif
  #if compiler(>=5.3) && $Sendable
  public func applied<S>(_ input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> [CoreML.MLShapedArray<Scalar>] where S : Swift.Sequence, S.Element == CoreML.MLShapedArray<Scalar>
  #endif
  public static func == (a: CreateMLComponents.Reshaper<Scalar>, b: CreateMLComponents.Reshaper<Scalar>) -> Swift.Bool
  public typealias Input = CoreML.MLShapedArray<Scalar>
  public typealias Output = CoreML.MLShapedArray<Scalar>
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Reshaper : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Reshaper : Swift.Sendable where Scalar : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct MLModelTransformerAdaptor<Scalar> : CreateMLComponents.Transformer where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public let model: CoreML.MLModel
  public init(contentsOf url: Foundation.URL, configuration: CoreML.MLModelConfiguration) throws
  public init(model: CoreML.MLModel) throws
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CoreML.MLShapedArray<Scalar>
  #endif
  public typealias Input = CoreML.MLShapedArray<Scalar>
  public typealias Output = CoreML.MLShapedArray<Scalar>
}
@available(*, unavailable)
extension CreateMLComponents.MLModelTransformerAdaptor : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct FullyConnectedNetworkClassifier<Scalar, Label> : CreateMLComponents.SupervisedEstimator where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint, Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  public typealias Transformer = CreateMLComponents.FullyConnectedNetworkClassifierModel<Scalar, Label>
  public typealias Annotation = Label
  public var configuration: CreateMLComponents.FullyConnectedNetworkConfiguration
  public var labels: Swift.Set<Label>
  public init(labels: Swift.Set<Label>, configuration: CreateMLComponents.FullyConnectedNetworkConfiguration = .init())
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.FullyConnectedNetworkClassifierModel<Scalar, Label> where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.FullyConnectedNetworkClassifierModel<Scalar, Label> where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>, Validation.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.FullyConnectedNetworkClassifier : Swift.Sendable where Scalar : Swift.Sendable, Label : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct HumanBodyPoseExtractor : CreateMLComponents.Transformer, Swift.Sendable {
  public init()
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.Pose]
  #endif
  public typealias Input = CoreImage.CIImage
  public typealias Output = [CreateMLComponents.Pose]
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyPoseExtractor : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum VideoReaderError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case missingVideoTrack(Foundation.URL)
  case cameraAuthorizationDenied
  case cameraAuthorizationRestricted
  case sourceCameraNotAvailable
  case frameRateNotSupported(Swift.Double)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.VideoReaderError, b: CreateMLComponents.VideoReaderError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.VideoReaderError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension CreateMLComponents.Estimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator where Other : CreateMLComponents.SupervisedTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.SupervisedEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator where Other : CreateMLComponents.TemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator where Other : CreateMLComponents.SupervisedTemporalEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.TemporalEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator where Other : CreateMLComponents.SupervisedEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator where Other : CreateMLComponents.SupervisedTemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.SupervisedTemporalEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator where Other : CreateMLComponents.Estimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator where Other : CreateMLComponents.SupervisedEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator where Other : CreateMLComponents.TemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTemporalEstimator where Other : CreateMLComponents.SupervisedTemporalEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ClassificationDistribution<Label> : Swift.Collection where Label : Swift.Hashable {
  public var mostLikelyLabel: Label? {
    get
  }
  public var labelsSortedByProbability: [Label] {
    get
  }
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public init<C>(_ classifications: C) where C : Swift.Collection, C.Element == CreateMLComponents.Classification<Label>
  public func topLabels(_ amount: Swift.Int) -> [Label]
  public subscript(index: Swift.Int) -> CreateMLComponents.Classification<Label> {
    get
  }
  public subscript(label: Label) -> Swift.Float? {
    get
  }
  public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.Slice<CreateMLComponents.ClassificationDistribution<Label>> {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public func index(before i: Swift.Int) -> Swift.Int
  public func map<T>(_ transform: (CreateMLComponents.Classification<Label>) throws -> CreateMLComponents.Classification<T>) rethrows -> CreateMLComponents.ClassificationDistribution<T> where T : Swift.Hashable
  public typealias Element = CreateMLComponents.Classification<Label>
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<CreateMLComponents.ClassificationDistribution<Label>>
  public typealias Iterator = Swift.IndexingIterator<CreateMLComponents.ClassificationDistribution<Label>>
  public typealias SubSequence = Swift.Slice<CreateMLComponents.ClassificationDistribution<Label>>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ClassificationDistribution : Swift.Equatable {
  public static func == (a: CreateMLComponents.ClassificationDistribution<Label>, b: CreateMLComponents.ClassificationDistribution<Label>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ClassificationDistribution : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ClassificationDistribution : Swift.Codable where Label : Swift.Decodable, Label : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ClassificationDistribution : Swift.Sendable where Label : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol Regressor : CreateMLComponents.Transformer where Self.Output : Swift.FloatingPoint {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Regressor {
  #if compiler(>=5.3) && $AsyncAwait
  public func prediction(from input: Self.Input) async throws -> Self.Output
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func prediction<S>(from input: S) async throws -> [Self.Output] where S : Swift.Sequence, Self.Input == S.Element
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TransformerToEstimatorAdaptor<Transformer> : CreateMLComponents.Estimator where Transformer : CreateMLComponents.Transformer {
  public let transformer: Transformer
  public init(_ transformer: Transformer)
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Transformer where S : Swift.Sequence, Transformer.Input == S.Element {
        transformer
    }
  #endif
  @inlinable public func encode(_ transformer: Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        // no op
    }
  @inlinable public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TransformerToEstimatorAdaptor : Swift.Sendable where Transformer : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func adaptedAsEstimator() -> CreateMLComponents.TransformerToEstimatorAdaptor<Self> {
        TransformerToEstimatorAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TransformerToUpdatableEstimatorAdaptor<Transformer> : CreateMLComponents.UpdatableEstimator where Transformer : CreateMLComponents.Transformer {
  public let transformer: Transformer
  public init(_ transformer: Transformer)
  @inlinable public func makeTransformer() -> Transformer {
        transformer
    }
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Transformer where S : Swift.Sequence, Transformer.Input == S.Element {
        transformer
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func update<InputSequence>(_ transformer: inout Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Transformer.Input == InputSequence.Element {
        // no op
    }
  #endif
  @inlinable public func encode(_ transformer: Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        // no op
    }
  @inlinable public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
  @inlinable public func encodeWithOptimizer(_ transformer: Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        // no op
    }
  @inlinable public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TransformerToUpdatableEstimatorAdaptor : Swift.Sendable where Transformer : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func adaptedAsUpdatableEstimator() -> CreateMLComponents.TransformerToUpdatableEstimatorAdaptor<Self> {
        TransformerToUpdatableEstimatorAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TemporalTransformerToEstimatorAdaptor<Transformer> : CreateMLComponents.TemporalEstimator where Transformer : CreateMLComponents.TemporalTransformer {
  public let transformer: Transformer
  public init(_ transformer: Transformer)
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Transformer where InputSequence : Swift.Sequence, Transformer.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        transformer
    }
  #endif
  @inlinable public func encode(_ transformer: Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        // no op
    }
  @inlinable public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalTransformerToEstimatorAdaptor : Swift.Sendable where Transformer : Swift.Sendable {
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func adaptedAsEstimator() -> CreateMLComponents.TemporalTransformerToEstimatorAdaptor<Self> {
        TemporalTransformerToEstimatorAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TemporalTransformerToUpdatableEstimatorAdaptor<Transformer> : CreateMLComponents.UpdatableTemporalEstimator where Transformer : CreateMLComponents.TemporalTransformer {
  public let transformer: Transformer
  public init(_ transformer: Transformer)
  @inlinable public func makeTransformer() -> Transformer {
        transformer
    }
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Transformer where InputSequence : Swift.Sequence, Transformer.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        transformer
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func update<InputSequence>(_ transformer: inout Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Transformer.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        // no op
    }
  #endif
  @inlinable public func encode(_ transformer: Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        // no op
    }
  @inlinable public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
  @inlinable public func encodeWithOptimizer(_ transformer: Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        // no op
    }
  @inlinable public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalTransformerToUpdatableEstimatorAdaptor : Swift.Sendable where Transformer : Swift.Sendable {
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func adaptedAsUpdatableEstimator() -> CreateMLComponents.TemporalTransformerToUpdatableEstimatorAdaptor<Self> {
        TemporalTransformerToUpdatableEstimatorAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TabularTransformerToEstimatorAdaptor<Transformer> : CreateMLComponents.TabularEstimator where Transformer : CreateMLComponents.TabularTransformer {
  public let transformer: Transformer
  public init(_ transformer: Transformer)
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Transformer {
        transformer
    }
  #endif
  @inlinable public func encode(_ transformer: Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        // no op
    }
  @inlinable public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TabularTransformerToEstimatorAdaptor : Swift.Sendable where Transformer : Swift.Sendable {
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func adaptedAsEstimator() -> CreateMLComponents.TabularTransformerToEstimatorAdaptor<Self> {
        TabularTransformerToEstimatorAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TabularTransformerToUpdatableEstimatorAdaptor<Transformer> : CreateMLComponents.UpdatableTabularEstimator where Transformer : CreateMLComponents.TabularTransformer {
  public let transformer: Transformer
  public init(_ transformer: Transformer)
  @inlinable public func makeTransformer() -> Transformer {
        transformer
    }
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Transformer {
        transformer
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func update(_ transformer: inout Transformer, with input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws {
        // no op
    }
  #endif
  @inlinable public func encode(_ transformer: Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        // no op
    }
  @inlinable public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
  @inlinable public func encodeWithOptimizer(_ transformer: Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        // no op
    }
  @inlinable public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Transformer {
        transformer
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TabularTransformerToUpdatableEstimatorAdaptor : Swift.Sendable where Transformer : Swift.Sendable {
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func adaptedAsUpdatableEstimator() -> CreateMLComponents.TabularTransformerToUpdatableEstimatorAdaptor<Self> {
        TabularTransformerToUpdatableEstimatorAdaptor(self)
    }
}
extension CreateMLComponents.VideoReader {
  @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  public struct CameraConfiguration : Swift.Sendable {
    public enum Position : Swift.Sendable {
      case front
      case back
      public static func == (a: CreateMLComponents.VideoReader.CameraConfiguration.Position, b: CreateMLComponents.VideoReader.CameraConfiguration.Position) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum PixelFormat : Swift.Sendable {
      case bgra32
      case yCbCr8BiPlanarFullRange420
      public static func == (a: CreateMLComponents.VideoReader.CameraConfiguration.PixelFormat, b: CreateMLComponents.VideoReader.CameraConfiguration.PixelFormat) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Resolution : Swift.Sendable {
      case low
      case medium
      case high
      public static func == (a: CreateMLComponents.VideoReader.CameraConfiguration.Resolution, b: CreateMLComponents.VideoReader.CameraConfiguration.Resolution) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var cameraPosition: CreateMLComponents.VideoReader.CameraConfiguration.Position {
      get
    }
    public var position: CreateMLComponents.VideoReader.CameraConfiguration.Position
    public var pixelFormat: CreateMLComponents.VideoReader.CameraConfiguration.PixelFormat
    public var resolution: CreateMLComponents.VideoReader.CameraConfiguration.Resolution
    public var frameRate: Swift.Double
    public init()
    public init(position: CreateMLComponents.VideoReader.CameraConfiguration.Position = .front, pixelFormat: CreateMLComponents.VideoReader.CameraConfiguration.PixelFormat = .bgra32, resolution: CreateMLComponents.VideoReader.CameraConfiguration.Resolution = .high, frameRate: Swift.Double = 30.0)
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct LinearRegressorModel<Scalar> : CreateMLComponents.Regressor where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Scalar
  #endif
  public typealias Input = CoreML.MLShapedArray<Scalar>
  public typealias Output = Scalar
}
@available(*, unavailable)
extension CreateMLComponents.LinearRegressorModel : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct OptionalUnwrapper<Element> : CreateMLComponents.Transformer {
  public init()
  #if compiler(>=5.3) && $Sendable
  @inlinable public func applied(to input: Element?, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> Element {
        guard let unwrapped = input else {
            throw PipelineDataError.missingValue(operation: "OptionalUnwrapper")
        }
        return unwrapped
    }
  #endif
  public typealias Input = Element?
  public typealias Output = Element
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.OptionalUnwrapper : Swift.Sendable where Element : Swift.Sendable {
}
extension CreateMLComponents.Estimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TemporalEstimator where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TemporalEstimator where Other : CreateMLComponents.TemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.TemporalEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TemporalEstimator where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TemporalEstimator where Other : CreateMLComponents.Estimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TemporalEstimator where Other : CreateMLComponents.TemporalTransformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.TemporalEstimator where Other : CreateMLComponents.TemporalEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.UpdatableEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableEstimator where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.UpdatableEstimator where Other : CreateMLComponents.UpdatableEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct LinearTransformer<Element> : CreateMLComponents.Transformer, Swift.Hashable, Swift.Codable where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public var scale: Element
  public var offset: Element
  public init(scale: Element, offset: Element)
  #if compiler(>=5.3) && $Sendable
  @inlinable public func applied(to input: Element, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
        return input * scale + offset
    }
  #endif
  #if compiler(>=5.3) && $Sendable
  @inlinable public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) -> [Element] where Element == S.Element, S : Swift.Sequence {
        input.map({ applied(to: $0, eventHandler: eventHandler) })
    }
  #endif
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.LinearTransformer<Element>, b: CreateMLComponents.LinearTransformer<Element>) -> Swift.Bool
  public typealias Input = Element
  public typealias Output = Element
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.LinearTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.LinearTransformer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct AudioConvertingTransformer : CreateMLComponents.Transformer, Swift.Sendable {
  public let targetFormat: AVFAudio.AVAudioFormat
  public init(targetFormat: AVFAudio.AVAudioFormat)
  #if compiler(>=5.3) && $Sendable
  public func applied(to input: AVFAudio.AVAudioPCMBuffer, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> AVFAudio.AVAudioPCMBuffer
  #endif
  public typealias Input = AVFAudio.AVAudioPCMBuffer
  public typealias Output = AVFAudio.AVAudioPCMBuffer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioConvertingTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ColumnSelectorTransformer<Base, UnwrappedInput> : CreateMLComponents.TabularTransformer where Base : CreateMLComponents.Transformer, Base.Input == UnwrappedInput? {
  public var transformers: [Swift.String : Base]
  public var columnMapping: [Swift.String : Swift.String]
  public init(transformers: [Swift.String : Base], columnMapping: [Swift.String : Swift.String] = [:])
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame
  #endif
  public typealias Input = TabularData.DataFrame
  public typealias Output = TabularData.DataFrame
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ColumnSelectorTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ColumnSelectorTransformer : Swift.Sendable where Base : Swift.Sendable, UnwrappedInput : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ColumnSelectorTransformer : Swift.Codable where Base : Swift.Decodable, Base : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol SupervisedEstimator<Transformer, Annotation> {
  associatedtype Transformer : CreateMLComponents.Transformer
  associatedtype Annotation : Swift.Equatable
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
  #endif
  func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol SupervisedEstimator {
  associatedtype Transformer : CreateMLComponents.Transformer
  associatedtype Annotation : Swift.Equatable
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
  #endif
  func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.SupervisedEstimator {
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func fitted<Input>(to input: Input) async throws -> Self.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation> {
        try await fitted(to: input, eventHandler: nil)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation) async throws -> Self.Transformer where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation> {
        try await fitted(to: input, validateOn: validation, eventHandler: nil)
    }
  #endif
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol UpdatableSupervisedEstimator<Transformer, Annotation> : CreateMLComponents.SupervisedEstimator {
  func makeTransformer() -> Self.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
  #endif
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol UpdatableSupervisedEstimator : CreateMLComponents.SupervisedEstimator {
  func makeTransformer() -> Self.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation>
  #endif
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.UpdatableSupervisedEstimator {
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Self.Transformer.Input, Self.Annotation> {
        try await update(&transformer, with: input, eventHandler: nil)
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum SerializationError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case packageAlreadyExists(Foundation.URL)
  case packageNotFound(Foundation.URL)
  case notRepresentableAsCoreML(debugDescription: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.SerializationError, b: CreateMLComponents.SerializationError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.SerializationError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.Sequence {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func mapFeatures<Input, Output, Annotation>(_ transform: (Input) throws -> Output) rethrows -> [CreateMLComponents.AnnotatedFeature<Output, Annotation>] where Self.Element == CreateMLComponents.AnnotatedFeature<Input, Annotation> {
        try map {
            try AnnotatedFeature(feature: transform($0.feature), annotation: $0.annotation)
        }
    }
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func mapFeatures<Input, Output, Annotation>(_ transform: (Input) async throws -> Output) async rethrows -> [CreateMLComponents.AnnotatedFeature<Output, Annotation>] where Self.Element == CreateMLComponents.AnnotatedFeature<Input, Annotation> {
        var result = [AnnotatedFeature<Output, Annotation>]()
        for value in self {
            let transformed = try await transform(value.feature)
            result.append(AnnotatedFeature(feature: transformed, annotation: value.annotation))
        }
        return result
    }
  #endif
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func mapAnnotations<Feature, Input, Output>(_ transform: (Input) throws -> Output) rethrows -> [CreateMLComponents.AnnotatedFeature<Feature, Output>] where Self.Element == CreateMLComponents.AnnotatedFeature<Feature, Input> {
        try map {
            try AnnotatedFeature(feature: $0.feature, annotation: transform($0.annotation))
        }
    }
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func mapAnnotations<Feature, Input, Output>(_ transform: (Input) async throws -> Output) async rethrows -> [CreateMLComponents.AnnotatedFeature<Feature, Output>] where Self.Element == CreateMLComponents.AnnotatedFeature<Feature, Input> {
        var result = [AnnotatedFeature<Feature, Output>]()
        for value in self {
            let transformed = try await transform(value.annotation)
            result.append(AnnotatedFeature(feature: value.feature, annotation: transformed))
        }
        return result
    }
  #endif
}
extension Swift.LazySequence {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func mapFeatures<Input, Output, Annotation>(_ transform: @escaping (Input) -> Output) -> Swift.LazyMapSequence<Base, CreateMLComponents.AnnotatedFeature<Output, Annotation>> where Base.Element == CreateMLComponents.AnnotatedFeature<Input, Annotation> {
        map {
            AnnotatedFeature(feature: transform($0.feature), annotation: $0.annotation)
        }
    }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func mapAnnotations<Feature, Input, Output>(_ transform: @escaping (Input) -> Output) -> Swift.LazyMapSequence<Base, CreateMLComponents.AnnotatedFeature<Feature, Output>> where Base.Element == CreateMLComponents.AnnotatedFeature<Feature, Input> {
        map {
            AnnotatedFeature(feature: $0.feature, annotation: transform($0.annotation))
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TreeClassifierModel<Label> : CreateMLComponents.TabularTransformer where Label : Swift.Hashable {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame
  #endif
  public typealias Input = TabularData.DataFrame
  public typealias Output = TabularData.DataFrame
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TreeClassifierModel : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(*, unavailable)
extension CreateMLComponents.TreeClassifierModel : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum EstimatorEncodingError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case invalidState(debugDescription: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.EstimatorEncodingError, b: CreateMLComponents.EstimatorEncodingError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.EstimatorEncodingError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol SupervisedTemporalEstimator<Transformer, Annotation> {
  associatedtype Transformer : CreateMLComponents.TemporalTransformer
  associatedtype Annotation : Swift.Equatable, Swift.Sendable
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input
  #endif
  func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol SupervisedTemporalEstimator {
  associatedtype Transformer : CreateMLComponents.TemporalTransformer
  associatedtype Annotation : Swift.Equatable, Swift.Sendable
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input
  #endif
  func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.SupervisedTemporalEstimator {
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func fitted<InputSequence, FeatureSequence>(to input: InputSequence) async throws -> Self.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input {
        try await fitted(to: input, eventHandler: nil)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation) async throws -> Self.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input {
        try await fitted(to: input, validateOn: validation, eventHandler: nil)
    }
  #endif
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol UpdatableSupervisedTemporalEstimator<Transformer, Annotation> : CreateMLComponents.SupervisedTemporalEstimator {
  func makeTransformer() -> Self.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  func update<InputSequence, FeatureSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input
  #endif
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol UpdatableSupervisedTemporalEstimator : CreateMLComponents.SupervisedTemporalEstimator {
  func makeTransformer() -> Self.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  func update<InputSequence, FeatureSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input
  #endif
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.UpdatableSupervisedTemporalEstimator {
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func update<InputSequence, FeatureSequence>(_ transformer: inout Self.Transformer, with input: InputSequence) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Self.Annotation>, FeatureSequence.Feature == Self.Transformer.Input {
        try await update(&transformer, with: input, eventHandler: nil)
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionCounter {
  #if compiler(>=5.3) && $RethrowsProtocol
  public struct CumulativeSumSequence : CreateMLComponents.TemporalSequence {
    public typealias AsyncIterator = CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence.Iterator
    public typealias Feature = Swift.Float
    public var count: Swift.Int? {
      get
    }
    public func makeAsyncIterator() -> CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence.Iterator
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence.Feature>
  }
  #endif
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async throws -> CreateMLComponents.TemporalFeature<Swift.Float>?
    #endif
    public typealias Element = CreateMLComponents.TemporalFeature<Swift.Float>
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.HumanBodyActionCounter.CumulativeSumSequence.Iterator : Swift.Sendable {
}
#endif
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct BoostedTreeClassifier<Label> : CreateMLComponents.SupervisedTabularEstimator where Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  public typealias Transformer = CreateMLComponents.TreeClassifierModel<Label>
  public typealias Annotation = Label
  public var configuration: CreateMLComponents.BoostedTreeConfiguration
  public var annotationColumnID: TabularData.ColumnID<Label>
  public var featureColumnNames: [Swift.String]
  public var labels: Swift.Set<Label?>
  public init(labels: Swift.Set<Label?>, annotationColumnName: Swift.String, featureColumnNames: [Swift.String], configuration: CreateMLComponents.BoostedTreeConfiguration = BoostedTreeConfiguration())
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted(to input: TabularData.DataFrame, validateOn validation: TabularData.DataFrame? = nil, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.TreeClassifierModel<Label>
  #endif
  public func encode(_ transformer: CreateMLComponents.TreeClassifierModel<Label>, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.TreeClassifierModel<Label>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.BoostedTreeClassifier : Swift.Sendable where Label : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct BoostedTreeConfiguration : Swift.Hashable, Swift.Codable, Swift.Sendable {
  public var maximumDepth: Swift.Int
  public var maximumIterations: Swift.Int
  public var minimumLossReduction: Swift.Double
  public var minimumChildWeight: Swift.Double
  public var randomSeed: Swift.Int
  public var stepSize: Swift.Double
  public var earlyStoppingIterationCount: Swift.Int?
  public var rowSubsample: Swift.Double
  public var columnSubsample: Swift.Double
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.BoostedTreeConfiguration, b: CreateMLComponents.BoostedTreeConfiguration) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct MLModelRegressorAdaptor<Scalar> : CreateMLComponents.Regressor where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public let model: CoreML.MLModel
  public init(contentsOf url: Foundation.URL, configuration: CoreML.MLModelConfiguration) throws
  public init(model: CoreML.MLModel) throws
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Swift.Double
  #endif
  public typealias Input = CoreML.MLShapedArray<Scalar>
  public typealias Output = Swift.Double
}
@available(*, unavailable)
extension CreateMLComponents.MLModelRegressorAdaptor : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum AudioPreprocessingError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case incompatibleTargetFormatForConversion(inputFormat: AVFAudio.AVAudioFormat, targetFormat: AVFAudio.AVAudioFormat)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.AudioPreprocessingError, b: CreateMLComponents.AudioPreprocessingError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioPreprocessingError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct FullyConnectedNetworkConfiguration : Swift.Hashable, Swift.Codable, Swift.Sendable {
  public var hiddenUnitCounts: [Swift.Int]
  public var maximumIterations: Swift.Int
  public var randomSeed: Swift.Int
  public var batchSize: Swift.Int
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.FullyConnectedNetworkConfiguration, b: CreateMLComponents.FullyConnectedNetworkConfiguration) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum ConcatenationError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case nonUniformShapes(columnName: Swift.String)
  case mismatchedShapes
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.ConcatenationError, b: CreateMLComponents.ConcatenationError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ConcatenationError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct HumanHandPoseExtractor : CreateMLComponents.Transformer, Swift.Sendable {
  public init()
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.Pose]
  #endif
  public typealias Input = CoreImage.CIImage
  public typealias Output = [CreateMLComponents.Pose]
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanHandPoseExtractor : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator> : CreateMLComponents.UpdatableTemporalEstimator where Preprocessor : CreateMLComponents.TemporalTransformer, Estimator : CreateMLComponents.UpdatableTemporalEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTemporalTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func preprocessed<InputSequence>(from input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>] where InputSequence : Swift.Sequence, Preprocessor.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        var preprocessed = [PreprocessedFeatureSequence<Preprocessor.Output>]()
        for item in input {
            let transformed = try await preprocessor.applied(to: item, eventHandler: eventHandler)
            let stored = try await PreprocessedFeatureSequence(transformed)
            preprocessed.append(stored)
        }
        return preprocessed
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted(toPreprocessed preprocessed: [CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTemporalTransformer(preprocessor, fittedTransformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Preprocessor.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  #endif
  @inlinable public func makeTransformer() -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer {
        ComposedTemporalTransformer(preprocessor, estimator.makeTransformer())
    }
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer, withPreprocessed preprocessed: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Estimator.Transformer.Input == InputSequence.Element.Feature {
        try await estimator.update(&transformer.outer, with: preprocessed, eventHandler: eventHandler)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, Preprocessor.Input == InputSequence.Element.Feature, InputSequence.Element : CreateMLComponents.TemporalSequence {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        try await estimator.update(&transformer.outer, with: preprocessed, eventHandler: eventHandler)
    }
  #endif
  public func encode(_ transformer: CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PreprocessingUpdatableTemporalEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<CreateMLComponents.TransformerToTemporalAdaptor<Self>, Other> where Other : CreateMLComponents.UpdatableTemporalEstimator, Self.Output == Other.Transformer.Input
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Self, CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Other>> where Other : CreateMLComponents.UpdatableEstimator, Self.Output == Other.Transformer.Input
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableTemporalEstimator<Self, Other> where Other : CreateMLComponents.UpdatableTemporalEstimator, Self.Output == Other.Transformer.Input
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TemporalFileSegment {
  public var url: Foundation.URL
  public var range: Swift.Range<Foundation.TimeInterval>
  public init(url: Foundation.URL, range: Swift.Range<Foundation.TimeInterval>)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalFileSegment : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalFileSegment : Swift.Equatable {
  public static func == (a: CreateMLComponents.TemporalFileSegment, b: CreateMLComponents.TemporalFileSegment) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalFileSegment : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalFileSegment : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalFileSegment : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TemporalSegmentIdentifier : Swift.Hashable, Swift.Sendable {
  public var source: Swift.String
  public var range: Swift.Range<Swift.Int>
  public var timescale: Swift.Int
  public var rangeInSeconds: Swift.Range<Foundation.TimeInterval> {
    get
  }
  public var durationInSeconds: Foundation.TimeInterval {
    get
  }
  public init(source: Swift.String, range: Swift.Range<Swift.Int>, timescale: Swift.Int)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: CreateMLComponents.TemporalSegmentIdentifier, b: CreateMLComponents.TemporalSegmentIdentifier) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalSegmentIdentifier : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ComposedTabularTransformer<Inner, Outer> : CreateMLComponents.TabularTransformer where Inner : CreateMLComponents.TabularTransformer, Outer : CreateMLComponents.TabularTransformer {
  public var inner: Inner
  public var outer: Outer
  public init(_ inner: Inner, _ outer: Outer)
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func applied(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> TabularData.DataFrame {
        let innerOutput = try await inner.applied(to: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        let outerOutput = try await outer.applied(to: innerOutput, eventHandler: eventHandler)
        return outerOutput
    }
  #endif
  public typealias Input = TabularData.DataFrame
  public typealias Output = TabularData.DataFrame
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTabularTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTabularTransformer : Swift.Sendable where Inner : Swift.Sendable, Outer : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTabularTransformer : Swift.Equatable where Inner : Swift.Equatable, Outer : Swift.Equatable {
  public static func == (a: CreateMLComponents.ComposedTabularTransformer<Inner, Outer>, b: CreateMLComponents.ComposedTabularTransformer<Inner, Outer>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTabularTransformer : Swift.Encodable where Inner : Swift.Encodable, Outer : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTabularTransformer : Swift.Decodable where Inner : Swift.Decodable, Outer : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.ComposedTabularTransformer<Self, Other> where Other : CreateMLComponents.TabularTransformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct TransformerToTemporalAdaptor<Base> : CreateMLComponents.TemporalTransformer where Base : CreateMLComponents.Transformer {
  public typealias Input = Base.Input
  public typealias Output = Base.Output
  #if compiler(>=5.3) && $RethrowsProtocol
  public typealias OutputSequence = CreateMLComponents.AnyTemporalSequence<CreateMLComponents.TransformerToTemporalAdaptor<Base>.Output>
  #endif
  @usableFromInline
  internal var base: Base
  public init(_ transformer: Base)
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.AnyTemporalSequence<CreateMLComponents.TransformerToTemporalAdaptor<Base>.Output> where S : CreateMLComponents.TemporalSequence, Base.Input == S.Feature {
        let sequence = input.map {
            try await TemporalFeature(id: $0.id, feature: base.applied(to: $0.feature, eventHandler: eventHandler))
        }
        return AnyTemporalSequence(sequence, count: input.count)
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TransformerToTemporalAdaptor : Swift.Sendable where Base : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func adaptedAsTemporal() -> CreateMLComponents.TransformerToTemporalAdaptor<Self> {
        TransformerToTemporalAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct EstimatorToTemporalAdaptor<Base> : CreateMLComponents.TemporalEstimator where Base : CreateMLComponents.Estimator {
  public typealias Transformer = CreateMLComponents.TransformerToTemporalAdaptor<Base.Transformer>
  public typealias Input = Base.Transformer.Input
  public typealias Output = Base.Transformer.Output
  @usableFromInline
  internal var base: Base
  public init(_ base: Base)
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.EstimatorToTemporalAdaptor<Base>.Transformer where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Base.Transformer.Input == InputSequence.Element.Feature {
        var collected = [Input]()
        for sequence in input {
            for try await item in sequence {
                collected.append(item.feature)
            }
        }
        return try await Transformer(base.fitted(to: collected, eventHandler: eventHandler))
    }
  #endif
  @inlinable public func encode(_ transformer: CreateMLComponents.EstimatorToTemporalAdaptor<Base>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        try base.encode(transformer.base, to: &encoder)
    }
  @inlinable public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.EstimatorToTemporalAdaptor<Base>.Transformer {
        try Transformer(base.decode(from: &decoder))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.EstimatorToTemporalAdaptor : Swift.Sendable where Base : Swift.Sendable {
}
extension CreateMLComponents.Estimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func adaptedAsTemporal() -> CreateMLComponents.EstimatorToTemporalAdaptor<Self> {
        EstimatorToTemporalAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct UpdatableEstimatorToTemporalAdaptor<Base> : CreateMLComponents.UpdatableTemporalEstimator where Base : CreateMLComponents.UpdatableEstimator {
  public typealias Transformer = CreateMLComponents.TransformerToTemporalAdaptor<Base.Transformer>
  public typealias Input = Base.Transformer.Input
  public typealias Output = Base.Transformer.Output
  @usableFromInline
  internal var base: Base
  public init(_ base: Base)
  @inlinable public func makeTransformer() -> CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer {
        TransformerToTemporalAdaptor(base.makeTransformer())
    }
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Base.Transformer.Input == InputSequence.Element.Feature {
        var collected = [Input]()
        for sequence in input {
            for try await item in sequence {
                collected.append(item.feature)
            }
        }
        return try await Transformer(base.fitted(to: collected, eventHandler: eventHandler))
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Base.Transformer.Input == InputSequence.Element.Feature {
        var collected = [Input]()
        for sequence in input {
            for try await item in sequence {
                collected.append(item.feature)
            }
        }
        return try await base.update(&transformer.base, with: collected, eventHandler: eventHandler)
    }
  #endif
  @inlinable public func encode(_ transformer: CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        try base.encode(transformer.base, to: &encoder)
    }
  @inlinable public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer {
        try Transformer(base.decode(from: &decoder))
    }
  @inlinable public func encodeWithOptimizer(_ transformer: CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        try base.encodeWithOptimizer(transformer.base, to: &encoder)
    }
  @inlinable public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Base>.Transformer {
        try Transformer(base.decodeWithOptimizer(from: &decoder))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.UpdatableEstimatorToTemporalAdaptor : Swift.Sendable where Base : Swift.Sendable {
}
extension CreateMLComponents.UpdatableEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func adaptedAsTemporal() -> CreateMLComponents.UpdatableEstimatorToTemporalAdaptor<Self> {
        UpdatableEstimatorToTemporalAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct SupervisedEstimatorToTemporalAdaptor<Base> : CreateMLComponents.SupervisedTemporalEstimator where Base : CreateMLComponents.SupervisedEstimator, Base.Annotation : Swift.Sendable {
  public typealias Transformer = CreateMLComponents.TransformerToTemporalAdaptor<Base.Transformer>
  public typealias Input = Base.Transformer.Input
  public typealias Output = Base.Transformer.Output
  public typealias Annotation = Base.Annotation
  @usableFromInline
  internal var base: Base
  public init(_ base: Base)
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.SupervisedEstimatorToTemporalAdaptor<Base>.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, FeatureSequence.Feature == Base.Transformer.Input {
        var collected = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collected.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        let transformer = try await base.fitted(
            to: collected,
            eventHandler: eventHandler
        )
        return TransformerToTemporalAdaptor(transformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.SupervisedEstimatorToTemporalAdaptor<Base>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, FeatureSequence.Feature == Base.Transformer.Input {
        var collectedInput = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collectedInput.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        var collectedValidation = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collectedValidation.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        let transformer = try await base.fitted(
            to: collectedInput,
            validateOn: collectedValidation,
            eventHandler: eventHandler
        )
        return TransformerToTemporalAdaptor(transformer)
    }
  #endif
  @inlinable public func encode(_ transformer: CreateMLComponents.SupervisedEstimatorToTemporalAdaptor<Base>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        try base.encode(transformer.base, to: &encoder)
    }
  @inlinable public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.SupervisedEstimatorToTemporalAdaptor<Base>.Transformer {
        try Transformer(base.decode(from: &decoder))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.SupervisedEstimatorToTemporalAdaptor : Swift.Sendable where Base : Swift.Sendable {
}
extension CreateMLComponents.SupervisedEstimator where Self.Annotation : Swift.Sendable {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func adaptedAsTemporal() -> CreateMLComponents.SupervisedEstimatorToTemporalAdaptor<Self> {
        SupervisedEstimatorToTemporalAdaptor(self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct UpdatableSupervisedEstimatorToTemporalAdaptor<Base> : CreateMLComponents.UpdatableSupervisedTemporalEstimator where Base : CreateMLComponents.UpdatableSupervisedEstimator, Base.Annotation : Swift.Sendable {
  public typealias Transformer = CreateMLComponents.TransformerToTemporalAdaptor<Base.Transformer>
  public typealias Input = Base.Transformer.Input
  public typealias Output = Base.Transformer.Output
  public typealias Annotation = Base.Annotation
  @usableFromInline
  internal var base: Base
  public init(_ base: Base)
  @inlinable public func makeTransformer() -> CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer {
        TransformerToTemporalAdaptor(base.makeTransformer())
    }
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, FeatureSequence.Feature == Base.Transformer.Input {
        var collected = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collected.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        let transformer = try await base.fitted(
            to: collected,
            eventHandler: eventHandler
        )
        return TransformerToTemporalAdaptor(transformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, FeatureSequence.Feature == Base.Transformer.Input {
        var collectedInput = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collectedInput.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        var collectedValidation = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collectedValidation.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        let transformer = try await base.fitted(
            to: collectedInput,
            validateOn: collectedValidation,
            eventHandler: eventHandler
        )
        return TransformerToTemporalAdaptor(transformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func update<InputSequence, FeatureSequence>(_ transformer: inout CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Base.Annotation>, FeatureSequence.Feature == Base.Transformer.Input {
        var collected = [AnnotatedFeature<Input, Annotation>]()
        for sequence in input {
            for try await item in sequence.feature {
                collected.append(AnnotatedFeature(feature: item.feature, annotation: sequence.annotation))
            }
        }

        try await base.update(
            &transformer.base,
            with: collected,
            eventHandler: eventHandler
        )
    }
  #endif
  @inlinable public func encode(_ transformer: CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws {
        try base.encode(transformer.base, to: &encoder)
    }
  @inlinable public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer {
        try Transformer(base.decode(from: &decoder))
    }
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Base>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor : Swift.Sendable where Base : Swift.Sendable {
}
extension CreateMLComponents.UpdatableSupervisedEstimator where Self.Annotation : Swift.Sendable {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func adaptedAsTemporal() -> CreateMLComponents.UpdatableSupervisedEstimatorToTemporalAdaptor<Self> {
        UpdatableSupervisedEstimatorToTemporalAdaptor(self)
    }
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func export(to url: Foundation.URL) throws
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func export(to url: Foundation.URL) throws
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func export(to url: Foundation.URL) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ImageCropper : CreateMLComponents.Transformer, Swift.Sendable {
  public var cropRectangle: CoreFoundation.CGRect
  public init(cropRectangle: CoreFoundation.CGRect)
  #if compiler(>=5.3) && $Sendable
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CoreImage.CIImage
  #endif
  public typealias Input = CoreImage.CIImage
  public typealias Output = CoreImage.CIImage
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageCropper : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageCropper : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
#if compiler(>=5.3) && $Sendable
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public typealias EventHandler = @Sendable (CreateMLComponents.Event) -> Swift.Void
#endif
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct Event : Swift.Sendable {
  public var origin: Swift.String
  public var itemCount: Swift.Int
  public var totalItemCount: Swift.Int?
  public var metrics: [CreateMLComponents.MetricsKey : Swift.Sendable]
  public init(origin: Swift.String, itemCount: Swift.Int, totalItemCount: Swift.Int? = nil, metrics: [CreateMLComponents.MetricsKey : Swift.Sendable])
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Event : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct MetricsKey : Swift.Hashable, Swift.RawRepresentable, Swift.Sendable {
  public var rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let source: CreateMLComponents.MetricsKey
  public static let trainingAccuracy: CreateMLComponents.MetricsKey
  public static let validationAccuracy: CreateMLComponents.MetricsKey
  public static let trainingLoss: CreateMLComponents.MetricsKey
  public static let validationLoss: CreateMLComponents.MetricsKey
  public static let trainingMaximumError: CreateMLComponents.MetricsKey
  public static let validationMaximumError: CreateMLComponents.MetricsKey
  public static let trainingError: CreateMLComponents.MetricsKey
  public static let validationError: CreateMLComponents.MetricsKey
  public typealias RawValue = Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MetricsKey : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension CreateMLComponents.Estimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedEstimator where Other : CreateMLComponents.SupervisedEstimator, Self.Transformer.Output == Other.Transformer.Input
  
}
extension CreateMLComponents.SupervisedEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedEstimator where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedEstimator where Other : CreateMLComponents.Estimator, Self.Transformer.Output == Other.Transformer.Input
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedEstimator where Other : CreateMLComponents.SupervisedEstimator, Self.Annotation == Other.Annotation, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct NormalizationScaler<Element> : CreateMLComponents.Estimator where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public enum NormalizationStrategy : Swift.Sendable {
    case l1
    case l2
    public static func == (a: CreateMLComponents.NormalizationScaler<Element>.NormalizationStrategy, b: CreateMLComponents.NormalizationScaler<Element>.NormalizationStrategy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var norm: CreateMLComponents.NormalizationScaler<Element>.NormalizationStrategy
  public init(norm: CreateMLComponents.NormalizationScaler<Element>.NormalizationStrategy = .l2)
  #if compiler(>=5.3) && $Sendable
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.NormalizationScaler<Element>.Transformer where Element == S.Element, S : Swift.Sequence
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.NormalizationScaler : Swift.Sendable where Element : Swift.Sendable {
}
extension CreateMLComponents.NormalizationScaler {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Transformer : CreateMLComponents.Transformer, Swift.Hashable {
    public var scale: Element
    public init(scale: Element)
    #if compiler(>=5.3) && $Sendable
    @inlinable public func applied(to input: Element, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
            input / scale
        }
    #endif
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.NormalizationScaler<Element>.Transformer, b: CreateMLComponents.NormalizationScaler<Element>.Transformer) -> Swift.Bool
    public typealias Input = Element
    public typealias Output = Element
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.NormalizationScaler.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.NormalizationScaler.Transformer : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.NormalizationScaler.Transformer : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.NormalizationScaler.Transformer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ImputeTransformer<Element> : CreateMLComponents.Transformer, Swift.Codable where Element : Swift.Decodable, Element : Swift.Encodable {
  public var value: Element
  public init(value: Element)
  #if compiler(>=5.3) && $Sendable
  @inlinable public func applied(to input: Element?, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
        input ?? value
    }
  #endif
  public typealias Input = Element?
  public typealias Output = Element
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImputeTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImputeTransformer : Swift.Equatable where Element : Swift.Equatable {
  public static func == (a: CreateMLComponents.ImputeTransformer<Element>, b: CreateMLComponents.ImputeTransformer<Element>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImputeTransformer : Swift.Hashable where Element : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImputeTransformer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct NumericImputer<Element> : CreateMLComponents.Estimator where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public typealias Transformer = CreateMLComponents.ImputeTransformer<Element>
  public enum Strategy {
    case median
    case mean
    case constant(Element)
  }
  public var strategy: CreateMLComponents.NumericImputer<Element>.Strategy
  public init(_ strategy: CreateMLComponents.NumericImputer<Element>.Strategy)
  public init(constant: Element)
  #if compiler(>=5.3) && $Sendable
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) -> CreateMLComponents.NumericImputer<Element>.Transformer where S : Swift.Sequence, S.Element == Element?
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.NumericImputer : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.NumericImputer.Strategy : Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct LinearRegressor<Scalar> : CreateMLComponents.SupervisedEstimator where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public typealias Transformer = CreateMLComponents.LinearRegressorModel<Scalar>
  public typealias Annotation = Scalar
  public var configuration: CreateMLComponents.LinearRegressor<Scalar>.Configuration
  public init(configuration: CreateMLComponents.LinearRegressor<Scalar>.Configuration = Configuration())
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.LinearRegressorModel<Scalar> where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Scalar>
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.LinearRegressorModel<Scalar> where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Scalar>, Validation.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Scalar>
  #endif
  public func encode(_ transformer: CreateMLComponents.LinearRegressorModel<Scalar>, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.LinearRegressorModel<Scalar>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.LinearRegressor : Swift.Sendable where Scalar : Swift.Sendable {
}
extension CreateMLComponents.LinearRegressor {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Configuration : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var l2Penalty: Swift.Double
    public var l1Penalty: Swift.Double
    public var maximumIterations: Swift.Int
    public var stepSize: Swift.Double
    public var convergenceThreshold: Swift.Double
    public init()
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.LinearRegressor<Scalar>.Configuration, b: CreateMLComponents.LinearRegressor<Scalar>.Configuration) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ClassificationMetrics<Label> where Label : Swift.Hashable {
  public var accuracy: Swift.Double
  public init<Predicted, Correct>(_ predictedLabels: Predicted, _ correctLabels: Correct) where Label == Predicted.Element, Predicted : Swift.Collection, Correct : Swift.Collection, Predicted.Element == Correct.Element
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  public init<S, Inner>(_ predicted: S) async throws where S : Swift.Sequence, Inner : CreateMLComponents.TemporalSequence, S.Element == CreateMLComponents.AnnotatedFeature<Inner, Label>, Inner.Feature == CreateMLComponents.ClassificationDistribution<Label>
  #endif
  public func makeConfusionMatrix() -> CoreML.MLShapedArray<Swift.Float> where Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ClassificationMetrics {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func precisionScore(label: Label) -> Swift.Double
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func recallScore(label: Label) -> Swift.Double
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ClassificationMetrics : Swift.Sendable where Label : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct HumanBodyActionPeriodPredictor : CreateMLComponents.Transformer, Swift.Sendable {
  public typealias Input = [CreateMLComponents.Pose]
  public typealias Output = [CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction]
  public init()
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to input: [CreateMLComponents.Pose], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction]
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionPeriodPredictor {
  public struct Prediction {
    public var period: Swift.Float
    public var periodicity: Swift.Float
    public init(period: Swift.Float, periodicity: Swift.Float)
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction : Swift.Equatable {
  public static func == (a: CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction, b: CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.HumanBodyActionPeriodPredictor.Prediction : Swift.Sendable {
}
extension CreateMLComponents.Estimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.Estimator where Other : CreateMLComponents.Transformer, Other.Input == Self.Transformer.Output
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.Estimator where Other : CreateMLComponents.Estimator, Self.Transformer.Output == Other.Transformer.Input
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol Classifier : CreateMLComponents.Transformer {
  associatedtype Label : Swift.Hashable where Self.Output == CreateMLComponents.ClassificationDistribution<Self.Label>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.Transformer {
  #if compiler(>=5.3) && $AsyncAwait
  public func prediction<Label>(from input: Self.Input) async throws -> CreateMLComponents.ClassificationDistribution<Label> where Label : Swift.Hashable, Self.Output == CreateMLComponents.ClassificationDistribution<Label>
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func prediction<S, Label>(from input: S) async throws -> [CreateMLComponents.ClassificationDistribution<Label>] where S : Swift.Sequence, Label : Swift.Hashable, Self.Input == S.Element, Self.Output == CreateMLComponents.ClassificationDistribution<Label>
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalTransformer {
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  public func prediction<S, Label>(from input: S) async throws -> Self.OutputSequence where S : CreateMLComponents.TemporalSequence, Label : Swift.Hashable, Self.Input == S.Feature, Self.Output == CreateMLComponents.ClassificationDistribution<Label>
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ImageFeaturePrint : CreateMLComponents.ImageFeatureExtractor {
  public let cropAndScale: Vision.VNImageCropAndScaleOption
  public init(cropAndScale: Vision.VNImageCropAndScaleOption = .centerCrop, context: CoreImage.CIContext = CIContext())
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to image: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CoreML.MLShapedArray<Swift.Float>
  #endif
  public typealias Input = CoreImage.CIImage
  public typealias Output = CoreML.MLShapedArray<Swift.Float>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageFeaturePrint : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ImageFeaturePrint : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(*, unavailable)
extension CreateMLComponents.ImageFeaturePrint : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioReader {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Configuration : Swift.Sendable {
    public var frameCount: Swift.Int
    public init()
    public init(frameCount: Swift.Int)
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct MaxAbsScaler<Element> : CreateMLComponents.Estimator where Element : Swift.BinaryFloatingPoint, Element : Swift.Decodable, Element : Swift.Encodable {
  public init()
  #if compiler(>=5.3) && $Sendable
  public func fitted<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) throws -> CreateMLComponents.MaxAbsScaler<Element>.Transformer where Element == S.Element, S : Swift.Sequence
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MaxAbsScaler : Swift.Sendable where Element : Swift.Sendable {
}
extension CreateMLComponents.MaxAbsScaler {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Transformer : CreateMLComponents.Transformer, Swift.Hashable {
    public var maximumAbsoluteValue: Element
    public init(maximumAbsoluteValue: Element)
    #if compiler(>=5.3) && $Sendable
    @inlinable public func applied(to input: Element, eventHandler: CreateMLComponents.EventHandler? = nil) -> Element {
            input / maximumAbsoluteValue
        }
    #endif
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.MaxAbsScaler<Element>.Transformer, b: CreateMLComponents.MaxAbsScaler<Element>.Transformer) -> Swift.Bool
    public typealias Input = Element
    public typealias Output = Element
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MaxAbsScaler.Transformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MaxAbsScaler.Transformer : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MaxAbsScaler.Transformer : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.MaxAbsScaler.Transformer : Swift.Sendable where Element : Swift.Sendable {
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol TemporalTransformer<Input, Output> {
  associatedtype Input
  associatedtype Output where Self.Output == Self.OutputSequence.Feature
  associatedtype OutputSequence : CreateMLComponents.TemporalSequence
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.OutputSequence where S : CreateMLComponents.TemporalSequence, Self.Input == S.Feature
  #endif
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol TemporalTransformer {
  associatedtype Input
  associatedtype Output where Self.Output == Self.OutputSequence.Feature
  associatedtype OutputSequence : CreateMLComponents.TemporalSequence
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.OutputSequence where S : CreateMLComponents.TemporalSequence, Self.Input == S.Feature
  #endif
}
#endif
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalTransformer {
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func applied<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [Self.OutputSequence] where S : Swift.Sequence, Self.Input == S.Element.Feature, S.Element : CreateMLComponents.TemporalSequence {
        var result = [OutputSequence]()
        result.reserveCapacity(input.underestimatedCount)
        for example in input {
            try Task.checkCancellation()
            try await result.append(applied(to: example, eventHandler: eventHandler))
            if let eventHandler = eventHandler {
                let event = Event(
                    origin: String(describing: self),
                    itemCount: result.count,
                    totalItemCount: input.underestimatedCount,
                    metrics: [:]
                )
                eventHandler(event)
            }
        }
        return result
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func applied<S, TS, Annotation>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.AnnotatedFeature<Self.OutputSequence, Annotation>] where S : Swift.Sequence, TS : CreateMLComponents.TemporalSequence, Self.Input == TS.Feature, S.Element == CreateMLComponents.AnnotatedFeature<TS, Annotation> {
        var result = [AnnotatedFeature<OutputSequence, Annotation>]()
        result.reserveCapacity(input.underestimatedCount)
        for example in input {
            try Task.checkCancellation()
            let transformed = try await applied(to: example.feature, eventHandler: eventHandler)
            result.append(AnnotatedFeature(feature: transformed, annotation: example.annotation))
            if let eventHandler = eventHandler {
                let event = Event(
                    origin: String(describing: self),
                    itemCount: result.count,
                    totalItemCount: input.underestimatedCount,
                    metrics: [:]
                )
                eventHandler(event)
            }
        }
        return result
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalTransformer {
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func callAsFunction<S>(_ input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Self.OutputSequence where S : CreateMLComponents.TemporalSequence, Self.Input == S.Feature {
        try await applied(to: input, eventHandler: eventHandler)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func callAsFunction<S>(to input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [Self.OutputSequence] where S : Swift.Sequence, Self.Input == S.Element.Feature, S.Element : CreateMLComponents.TemporalSequence {
        try await applied(to: input, eventHandler: eventHandler)
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ColumnSelector<Estimator, UnwrappedInput> : CreateMLComponents.TabularEstimator where Estimator : CreateMLComponents.Estimator, Estimator.Transformer.Input == UnwrappedInput? {
  public var columnSelection: CreateMLComponents.ColumnSelection
  public var estimator: Estimator
  public typealias Transformer = CreateMLComponents.ColumnSelectorTransformer<Estimator.Transformer, UnwrappedInput>
  public typealias Input = Estimator.Transformer.Input
  public typealias Output = Estimator.Transformer.Output
  public init(_ columnSelection: CreateMLComponents.ColumnSelection, estimator: Estimator)
  public init<T>(_ columnSelection: CreateMLComponents.ColumnSelection, transformer: T) where Estimator == CreateMLComponents.TransformerToEstimatorAdaptor<T>, T : CreateMLComponents.Transformer, T.Input == UnwrappedInput?
  public init(columns: [Swift.String], estimator: Estimator)
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted(to input: TabularData.DataFrame, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ColumnSelector<Estimator, UnwrappedInput>.Transformer
  #endif
  public func encode(_ transformer: CreateMLComponents.ColumnSelector<Estimator, UnwrappedInput>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.ColumnSelector<Estimator, UnwrappedInput>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ColumnSelector : Swift.Sendable where Estimator : Swift.Sendable, UnwrappedInput : Swift.Sendable {
}
extension CreateMLComponents.VideoReader {
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct AsyncFrames : CreateMLComponents.TemporalSequence {
    public typealias AsyncIterator = CreateMLComponents.VideoReader.AsyncFrames.Iterator
    public typealias Feature = CoreImage.CIImage
    public var count: Swift.Int? {
      get
    }
    public let url: Foundation.URL
    public let timescale: CoreMedia.CMTimeScale
    public let nominalFrameRate: Swift.Float
    public let frameSize: CoreFoundation.CGSize
    public let videoDuration: CoreMedia.CMTime
    public func makeAsyncIterator() -> CreateMLComponents.VideoReader.AsyncFrames.Iterator
    public typealias Element = CreateMLComponents.TemporalFeature<CreateMLComponents.VideoReader.AsyncFrames.Feature>
  }
  #endif
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.VideoReader.AsyncFrames : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
extension CreateMLComponents.VideoReader.AsyncFrames {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async throws -> CreateMLComponents.TemporalFeature<CoreImage.CIImage>?
    #endif
    public typealias Element = CreateMLComponents.TemporalFeature<CoreImage.CIImage>
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.VideoReader.AsyncFrames.Iterator : Swift.Sendable {
}
#endif
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum PoseSelectionStrategy : Swift.Sendable {
  case maximumBoundingBoxArea
  case highestJointLocation
  case lowestJointLocation
  case leftmostJointLocation
  case rightmostJointLocation
  public static func == (a: CreateMLComponents.PoseSelectionStrategy, b: CreateMLComponents.PoseSelectionStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct PoseSelector : CreateMLComponents.Transformer, Swift.Sendable {
  public var strategy: CreateMLComponents.PoseSelectionStrategy
  public var confidenceThreshold: Swift.Float
  public init(strategy: CreateMLComponents.PoseSelectionStrategy, confidenceThreshold: Swift.Float)
  public init(strategy: CreateMLComponents.PoseSelectionStrategy)
  public init()
  #if compiler(>=5.3) && $Sendable
  public func applied(to input: [CreateMLComponents.Pose], eventHandler: CreateMLComponents.EventHandler? = nil) -> CreateMLComponents.Pose
  #endif
  public typealias Input = [CreateMLComponents.Pose]
  public typealias Output = CreateMLComponents.Pose
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PoseSelector : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.FullyConnectedNetworkClassifier : CreateMLComponents.UpdatableSupervisedEstimator {
  public func makeTransformer() -> CreateMLComponents.FullyConnectedNetworkClassifierModel<Scalar, Label>
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func update<InputSequence>(_ transformer: inout CreateMLComponents.FullyConnectedNetworkClassifierModel<Scalar, Label>, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>
  #endif
}
extension CreateMLComponents.TabularTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTabularEstimator where Other : CreateMLComponents.SupervisedTabularEstimator
  
}
extension CreateMLComponents.TabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTabularEstimator where Other : CreateMLComponents.SupervisedTabularEstimator
  
}
extension CreateMLComponents.SupervisedTabularEstimator {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTabularEstimator where Other : CreateMLComponents.TabularTransformer
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTabularEstimator where Other : CreateMLComponents.TabularEstimator
  
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> some CreateMLComponents.SupervisedTabularEstimator where Other : CreateMLComponents.SupervisedTabularEstimator, Self.Annotation == Other.Annotation
  
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct ComposedTransformer<Inner, Outer> : CreateMLComponents.Transformer where Inner : CreateMLComponents.Transformer, Outer : CreateMLComponents.Transformer, Inner.Output == Outer.Input {
  public typealias Input = Inner.Input
  public typealias Intermediate = Inner.Output
  public typealias Output = Outer.Output
  public var inner: Inner
  public var outer: Outer
  public init(_ inner: Inner, _ outer: Outer)
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func applied(to input: CreateMLComponents.ComposedTransformer<Inner, Outer>.Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ComposedTransformer<Inner, Outer>.Output {
        let innerOutput = try await inner.applied(to: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        let outerOutput = try await outer.applied(to: innerOutput, eventHandler: eventHandler)
        return outerOutput
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTransformer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTransformer : Swift.Sendable where Inner : Swift.Sendable, Outer : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTransformer : Swift.Equatable where Inner : Swift.Equatable, Outer : Swift.Equatable {
  public static func == (a: CreateMLComponents.ComposedTransformer<Inner, Outer>, b: CreateMLComponents.ComposedTransformer<Inner, Outer>) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTransformer : Swift.Encodable where Inner : Swift.Encodable, Outer : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ComposedTransformer : Swift.Decodable where Inner : Swift.Decodable, Outer : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.ComposedTransformer<Self, Other> where Other : CreateMLComponents.Transformer, Self.Output == Other.Input
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol ImageFeatureExtractor : CreateMLComponents.Transformer where Self.Input == CoreImage.CIImage, Self.Output == CoreML.MLShapedArray<Swift.Float> {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public enum ModelCompatibilityError : Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case missingLabel
  case missingLabelProbabilities
  case missingPredictedFeature
  case incompatibleLabelType
  case incompatibleInputDataFormat(expected: CoreML.MLFeatureType, actual: CoreML.MLFeatureType)
  case incompatibleInputMultiArrayDataType(CoreML.MLMultiArrayDataType)
  case incompatibleOutputDataFormat(expected: CoreML.MLFeatureType, actual: CoreML.MLFeatureType)
  case incompatibleInputCount(expected: Swift.Int, actual: Swift.Int)
  case incompatibleOutputCount(expected: Swift.Int, actual: Swift.Int)
  case missingInput(name: Swift.String)
  case missingOutput(name: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: CreateMLComponents.ModelCompatibilityError, b: CreateMLComponents.ModelCompatibilityError) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.ModelCompatibilityError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct PreprocessedFeatureSequence<Feature> : CreateMLComponents.TemporalSequence {
  public var features: [CreateMLComponents.TemporalFeature<Feature>]
  @inlinable public var count: Swift.Int? {
    get {
        features.count
    }
  }
  #if compiler(>=5.3) && $AsyncAwait
  public init<S>(_ sequence: S) async throws where Feature == S.Feature, S : CreateMLComponents.TemporalSequence
  #endif
  public func makeAsyncIterator() -> CreateMLComponents.PreprocessedFeatureSequence<Feature>.AsyncIterator
  public typealias Element = CreateMLComponents.TemporalFeature<Feature>
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
extension CreateMLComponents.PreprocessedFeatureSequence {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal let features: [CreateMLComponents.TemporalFeature<Feature>]
    @usableFromInline
    internal var index: Swift.Int
    @inlinable public mutating func next() -> CreateMLComponents.TemporalFeature<Feature>? {
            if index >= features.count {
                return nil
            }
            defer {
                index += 1
            }
            return features[index]
        }
    public typealias Element = CreateMLComponents.TemporalFeature<Feature>
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct AnyTemporalSequence<Feature> : CreateMLComponents.TemporalSequence {
  public typealias Element = CreateMLComponents.TemporalFeature<Feature>
  public typealias AsyncIterator = CreateMLComponents.AnyTemporalIterator<CreateMLComponents.AnyTemporalSequence<Feature>.Element>
  public let count: Swift.Int?
  public init<S>(_ sequence: S) where Feature == S.Feature, S : CreateMLComponents.TemporalSequence
  public init<S>(_ sequence: S, count: Swift.Int?) where S : _Concurrency.AsyncSequence, S.Element == CreateMLComponents.TemporalFeature<Feature>
  public func makeAsyncIterator() -> CreateMLComponents.AnyTemporalIterator<CreateMLComponents.AnyTemporalSequence<Feature>.Element>
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.AnyTemporalSequence : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct AnyTemporalIterator<Element> : _Concurrency.AsyncIteratorProtocol {
  #if compiler(>=5.3) && $AsyncAwait
  public func next() async throws -> Element?
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(*, unavailable)
extension CreateMLComponents.AnyTemporalIterator : Swift.Sendable {
}
#endif
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator> : CreateMLComponents.UpdatableSupervisedEstimator where Preprocessor : CreateMLComponents.Transformer, Estimator : CreateMLComponents.UpdatableSupervisedEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public typealias Annotation = Estimator.Annotation
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  @inlinable public func makeTransformer() -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer {
        ComposedTransformer(preprocessor, estimator.makeTransformer())
    }
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func preprocessed<S>(from input: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> Swift.AnySequence<CreateMLComponents.AnnotatedFeature<Preprocessor.Output, CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Annotation>> where S : Swift.Sequence, S.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let inputFeatures = input.lazy.map(\.feature)
        let preprocessedFeatures = try await preprocessor.applied(to: inputFeatures, eventHandler: eventHandler)
        return AnySequence(zip(preprocessedFeatures, input.lazy.map(\.annotation)).lazy.map(AnnotatedFeature.init))
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<S>(toPreprocessed preprocessed: S, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer where S : Swift.Sequence, S.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation> {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessed,
            eventHandler: eventHandler
        )
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<InputSequence, Validation>(toPreprocessed preprocessedInput: InputSequence, validateOn preprocessedValidation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation> {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
        return ComposedTransformer(preprocessor, fittedTransformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func fitted<InputSequence, Validation>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let preprocessedInput = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        let preprocessedValidation = try await preprocessed(from: validation, eventHandler: eventHandler)
        try Task.checkCancellation()

        return try await fitted(
            toPreprocessed: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer, withPreprocessed preprocessed: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Output, Estimator.Annotation> {
        try await estimator.update(
            &transformer.outer,
            with: preprocessed,
            eventHandler: eventHandler
        )
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @inlinable public func update<InputSequence>(_ transformer: inout CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws where InputSequence : Swift.Sequence, InputSequence.Element == CreateMLComponents.AnnotatedFeature<Preprocessor.Input, Estimator.Annotation> {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()

        try await estimator.update(
            &transformer.outer,
            with: preprocessed,
            eventHandler: eventHandler
        )
    }
  #endif
  public func encode(_ transformer: CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer
  public func encodeWithOptimizer(_ transformer: CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PreprocessingUpdatableSupervisedEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingUpdatableSupervisedEstimator<Self, Other> where Other : CreateMLComponents.UpdatableSupervisedEstimator, Self.Output == Other.Transformer.Input
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct JointKey : Swift.Hashable, Swift.RawRepresentable, Swift.Sendable {
  public var rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let leftEar: CreateMLComponents.JointKey
  public static let leftEye: CreateMLComponents.JointKey
  public static let rightEar: CreateMLComponents.JointKey
  public static let rightEye: CreateMLComponents.JointKey
  public static let neck: CreateMLComponents.JointKey
  public static let nose: CreateMLComponents.JointKey
  public static let leftShoulder: CreateMLComponents.JointKey
  public static let leftElbow: CreateMLComponents.JointKey
  public static let leftWrist: CreateMLComponents.JointKey
  public static let rightShoulder: CreateMLComponents.JointKey
  public static let rightElbow: CreateMLComponents.JointKey
  public static let rightWrist: CreateMLComponents.JointKey
  public static let root: CreateMLComponents.JointKey
  public static let leftHip: CreateMLComponents.JointKey
  public static let leftKnee: CreateMLComponents.JointKey
  public static let leftAnkle: CreateMLComponents.JointKey
  public static let rightHip: CreateMLComponents.JointKey
  public static let rightKnee: CreateMLComponents.JointKey
  public static let rightAnkle: CreateMLComponents.JointKey
  public static let thumbTip: CreateMLComponents.JointKey
  public static let thumbIP: CreateMLComponents.JointKey
  public static let thumbMP: CreateMLComponents.JointKey
  public static let thumbCMC: CreateMLComponents.JointKey
  public static let indexTip: CreateMLComponents.JointKey
  public static let indexDIP: CreateMLComponents.JointKey
  public static let indexPIP: CreateMLComponents.JointKey
  public static let indexMCP: CreateMLComponents.JointKey
  public static let middleTip: CreateMLComponents.JointKey
  public static let middleDIP: CreateMLComponents.JointKey
  public static let middlePIP: CreateMLComponents.JointKey
  public static let middleMCP: CreateMLComponents.JointKey
  public static let ringTip: CreateMLComponents.JointKey
  public static let ringDIP: CreateMLComponents.JointKey
  public static let ringPIP: CreateMLComponents.JointKey
  public static let ringMCP: CreateMLComponents.JointKey
  public static let littleTip: CreateMLComponents.JointKey
  public static let littleDIP: CreateMLComponents.JointKey
  public static let littlePIP: CreateMLComponents.JointKey
  public static let littleMCP: CreateMLComponents.JointKey
  public static let wrist: CreateMLComponents.JointKey
  public typealias RawValue = Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.JointKey : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct JointPoint : Swift.Sendable {
  public let key: CreateMLComponents.JointKey
  public var location: CoreFoundation.CGPoint
  public var confidence: Swift.Float
  public init(_ key: CreateMLComponents.JointKey, location: CoreFoundation.CGPoint, confidence: Swift.Float)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct Pose : Swift.Sendable {
  public init(_ observation: Vision.VNRecognizedPointsObservation) throws
  public init(from points: [CreateMLComponents.JointKey : CreateMLComponents.JointPoint])
  public var keypoints: [CreateMLComponents.JointKey : CreateMLComponents.JointPoint]
  public func boundingBoxArea(confidenceThreshold: Swift.Float = 0.2) -> Swift.Float
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct VideoReader : CreateMLComponents.Transformer, Swift.Sendable {
  public init()
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  public func applied(to url: Foundation.URL, eventHandler: CreateMLComponents.EventHandler?) async throws -> CreateMLComponents.VideoReader.AsyncFrames
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  public static func read(contentsOf url: Foundation.URL) async throws -> CreateMLComponents.VideoReader.AsyncFrames
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  public static func read<S>(_ files: S) async throws -> [CreateMLComponents.VideoReader.AsyncFrames] where S : Swift.Sequence, S.Element == Foundation.URL
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  public static func read<S, Annotation>(_ annotatedFiles: S) async throws -> [CreateMLComponents.AnnotatedFeature<CreateMLComponents.VideoReader.AsyncFrames, Annotation>] where S : Swift.Sequence, Annotation : Swift.Equatable, Annotation : Swift.Sendable, S.Element == CreateMLComponents.AnnotatedFeature<Foundation.URL, Annotation>
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  public static func readCamera(configuration: CreateMLComponents.VideoReader.CameraConfiguration) async throws -> CreateMLComponents.VideoReader.CameraAsyncBuffers
  #endif
  public typealias Input = Foundation.URL
  #if compiler(>=5.3) && $RethrowsProtocol
  public typealias Output = CreateMLComponents.VideoReader.AsyncFrames
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol EstimatorEncoder {
  mutating func encode<T>(_ value: T) throws where T : Swift.Encodable
  mutating func encodeOptimizer<T>(_ value: T) throws where T : Swift.Encodable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol EstimatorDecoder {
  mutating func decode<T>(_ type: T.Type) throws -> T where T : Swift.Decodable
  mutating func decodeOptimizer<T>(_ value: T.Type) throws -> T where T : Swift.Decodable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct FullyConnectedNetworkRegressor<Scalar> : CreateMLComponents.SupervisedEstimator where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint {
  public typealias Transformer = CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar>
  public typealias Annotation = Swift.Float
  public var configuration: CreateMLComponents.FullyConnectedNetworkConfiguration
  public init(configuration: CreateMLComponents.FullyConnectedNetworkConfiguration = .init())
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.FullyConnectedNetworkRegressor<Scalar>.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Swift.Float>
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.FullyConnectedNetworkRegressorModel<Scalar> where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Swift.Float>, Validation.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Swift.Float>
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.FullyConnectedNetworkRegressor : Swift.Sendable where Scalar : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct MLModelImageFeatureExtractor : CreateMLComponents.ImageFeatureExtractor {
  public let model: CoreML.MLModel
  public let inputName: Swift.String
  public let outputName: Swift.String
  public init(model: CoreML.MLModel, inputName: Swift.String = "image", outputName: Swift.String, context: CoreImage.CIContext = CIContext()) throws
  #if compiler(>=5.3) && $AsyncAwait
  public init(contentsOf url: Foundation.URL, configuration: CoreML.MLModelConfiguration, inputName: Swift.String = "image", outputName: Swift.String, context: CoreImage.CIContext = CIContext()) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to input: CoreImage.CIImage, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CoreML.MLShapedArray<Swift.Float>
  #endif
  public typealias Input = CoreImage.CIImage
  public typealias Output = CoreML.MLShapedArray<Swift.Float>
}
extension CreateMLComponents.MLModelImageFeatureExtractor {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public enum Error : Swift.Error, Swift.Equatable, Swift.CustomDebugStringConvertible {
    case invalidInput(Swift.String)
    case invalidOutput(Swift.String)
    public var debugDescription: Swift.String {
      get
    }
    public static func == (a: CreateMLComponents.MLModelImageFeatureExtractor.Error, b: CreateMLComponents.MLModelImageFeatureExtractor.Error) -> Swift.Bool
  }
}
@available(*, unavailable)
extension CreateMLComponents.MLModelImageFeatureExtractor : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TabularEstimator {
  public func write(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func read(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.SupervisedTabularEstimator {
  public func write(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func read(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.UpdatableSupervisedTabularEstimator {
  public func writeWithOptimizer(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func readWithOptimizer(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator> : CreateMLComponents.SupervisedTemporalEstimator where Preprocessor : CreateMLComponents.TemporalTransformer, Estimator : CreateMLComponents.SupervisedTemporalEstimator, Preprocessor.Output == Estimator.Transformer.Input {
  public typealias Transformer = CreateMLComponents.ComposedTemporalTransformer<Preprocessor, Estimator.Transformer>
  public typealias Input = Preprocessor.Input
  public typealias Intermediate = Preprocessor.Output
  public typealias Output = Estimator.Transformer.Output
  public typealias Annotation = Estimator.Annotation
  public var preprocessor: Preprocessor
  public var estimator: Estimator
  public init(_ preprocessor: Preprocessor, _ estimator: Estimator)
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func preprocessed<InputSequence, FeatureSequence>(from input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>] where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        var preprocessed = [AnnotatedFeature<PreprocessedFeatureSequence<Preprocessor.Output>, Annotation>]()
        for item in input {
            let transformed = try await preprocessor.applied(to: item.feature, eventHandler: eventHandler)
            let stored = try await PreprocessedFeatureSequence(transformed)
            preprocessed.append(AnnotatedFeature(feature: stored, annotation: item.annotation))
        }
        return preprocessed
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted(toPreprocessed preprocessed: [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(to: preprocessed, eventHandler: eventHandler)
        return ComposedTemporalTransformer(preprocessor, fittedTransformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted(toPreprocessed preprocessedInput: [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>], validateOn preprocessedValidation: [CreateMLComponents.AnnotatedFeature<CreateMLComponents.PreprocessedFeatureSequence<Preprocessor.Output>, CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Annotation>], eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer {
        let fittedTransformer = try await estimator.fitted(
            to: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
        return ComposedTemporalTransformer(preprocessor, fittedTransformer)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence, FeatureSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        let preprocessed = try await preprocessed(from: input, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(toPreprocessed: preprocessed, eventHandler: eventHandler)
    }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  @inlinable public func fitted<InputSequence, Validation, FeatureSequence>(to input: InputSequence, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer where InputSequence : Swift.Sequence, Validation : Swift.Sequence, FeatureSequence : CreateMLComponents.TemporalSequence, Preprocessor.Input == FeatureSequence.Feature, InputSequence.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation>, Validation.Element == CreateMLComponents.AnnotatedFeature<FeatureSequence, Estimator.Annotation> {
        let preprocessedInput = try await preprocessed(from: input, eventHandler: eventHandler)
        let preprocessedValidation = try await preprocessed(from: validation, eventHandler: eventHandler)
        try Task.checkCancellation()
        return try await fitted(
            toPreprocessed: preprocessedInput,
            validateOn: preprocessedValidation,
            eventHandler: eventHandler
        )
    }
  #endif
  public func encode(_ transformer: CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Preprocessor, Estimator>.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PreprocessingSupervisedTemporalEstimator : Swift.Sendable where Preprocessor : Swift.Sendable, Estimator : Swift.Sendable {
}
extension CreateMLComponents.Transformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<CreateMLComponents.TransformerToTemporalAdaptor<Self>, Other> where Other : CreateMLComponents.SupervisedTemporalEstimator, Self.Output == Other.Transformer.Input
}
extension CreateMLComponents.TemporalTransformer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Self, CreateMLComponents.SupervisedEstimatorToTemporalAdaptor<Other>> where Other : CreateMLComponents.SupervisedEstimator, Self.Output == Other.Transformer.Input, Other.Annotation : Swift.Sendable
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public func appending<Other>(_ other: Other) -> CreateMLComponents.PreprocessingSupervisedTemporalEstimator<Self, Other> where Other : CreateMLComponents.SupervisedTemporalEstimator, Self.Output == Other.Transformer.Input
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol TemporalEstimator<Transformer> {
  associatedtype Transformer : CreateMLComponents.TemporalTransformer
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Self.Transformer.Input == InputSequence.Element.Feature
  #endif
  func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol TemporalEstimator {
  associatedtype Transformer : CreateMLComponents.TemporalTransformer
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  func fitted<InputSequence>(to input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws -> Self.Transformer where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Self.Transformer.Input == InputSequence.Element.Feature
  #endif
  func encode(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.TemporalEstimator {
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func fitted<InputSequence>(to input: InputSequence) async throws -> Self.Transformer where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Self.Transformer.Input == InputSequence.Element.Feature {
        try await fitted(to: input, eventHandler: nil)
    }
  #endif
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol UpdatableTemporalEstimator<Transformer> : CreateMLComponents.TemporalEstimator {
  func makeTransformer() -> Self.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Self.Transformer.Input == InputSequence.Element.Feature
  #endif
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#else
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public protocol UpdatableTemporalEstimator : CreateMLComponents.TemporalEstimator {
  func makeTransformer() -> Self.Transformer
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol && $Sendable
  func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence, eventHandler: CreateMLComponents.EventHandler?) async throws where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Self.Transformer.Input == InputSequence.Element.Feature
  #endif
  func encodeWithOptimizer(_ transformer: Self.Transformer, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  func decodeWithOptimizer(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> Self.Transformer
}
#endif
extension CreateMLComponents.UpdatableTemporalEstimator {
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @inlinable public func update<InputSequence>(_ transformer: inout Self.Transformer, with input: InputSequence) async throws where InputSequence : Swift.Sequence, InputSequence.Element : CreateMLComponents.TemporalSequence, Self.Transformer.Input == InputSequence.Element.Feature {
        try await update(&transformer, with: input, eventHandler: nil)
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.TemporalEstimator {
  public func write(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func read(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.SupervisedTemporalEstimator {
  public func write(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func read(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.UpdatableSupervisedTemporalEstimator {
  public func writeWithOptimizer(_ transformer: Self.Transformer, to url: Foundation.URL, overwrite: Swift.Bool = true) throws
  public func readWithOptimizer(from url: Foundation.URL) throws -> Self.Transformer
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct LogisticRegressionClassifier<Scalar, Label> : CreateMLComponents.SupervisedEstimator where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint, Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  public typealias Transformer = CreateMLComponents.LogisticRegressionClassifierModel<Scalar, Label>
  public typealias Annotation = Label
  public var configuration: CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Configuration
  public var labels: Swift.Set<Label>
  public init(labels: Swift.Set<Label>, configuration: CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Configuration = Configuration())
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted<Input>(to input: Input, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Transformer where Input : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func fitted<Input, Validation>(to input: Input, validateOn validation: Validation, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.LogisticRegressionClassifierModel<Scalar, Label> where Input : Swift.Sequence, Validation : Swift.Sequence, Input.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>, Validation.Element == CreateMLComponents.AnnotatedFeature<CoreML.MLShapedArray<Scalar>, Label>
  #endif
  public func encode(_ transformer: CreateMLComponents.LogisticRegressionClassifierModel<Scalar, Label>, to encoder: inout CreateMLComponents.EstimatorEncoder) throws
  public func decode(from decoder: inout CreateMLComponents.EstimatorDecoder) throws -> CreateMLComponents.LogisticRegressionClassifierModel<Scalar, Label>
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.LogisticRegressionClassifier : Swift.Sendable where Scalar : Swift.Sendable, Label : Swift.Sendable {
}
extension CreateMLComponents.LogisticRegressionClassifier {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  public struct Configuration : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var l2Penalty: Swift.Double
    public var l1Penalty: Swift.Double
    public var maximumIterations: Swift.Int
    public var stepSize: Swift.Double
    public var convergenceThreshold: Swift.Double
    public init()
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Configuration, b: CreateMLComponents.LogisticRegressionClassifier<Scalar, Label>.Configuration) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct LogisticRegressionClassifierModel<Scalar, Label> : CreateMLComponents.Classifier where Scalar : CoreML.MLShapedArrayScalar, Scalar : Swift.BinaryFloatingPoint, Label : Swift.Comparable, Label : Swift.Decodable, Label : Swift.Encodable, Label : Swift.Hashable {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public func applied(to input: CoreML.MLShapedArray<Scalar>, eventHandler: CreateMLComponents.EventHandler? = nil) async throws -> CreateMLComponents.ClassificationDistribution<Label>
  #endif
  public typealias Input = CoreML.MLShapedArray<Scalar>
  public typealias Output = CreateMLComponents.ClassificationDistribution<Label>
}
@available(*, unavailable)
extension CreateMLComponents.LogisticRegressionClassifierModel : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.AudioReaderError : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraConfiguration.Position : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraConfiguration.Position : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraConfiguration.PixelFormat : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraConfiguration.PixelFormat : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraConfiguration.Resolution : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, *)
@available(tvOS, unavailable)
extension CreateMLComponents.VideoReader.CameraConfiguration.Resolution : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.NormalizationScaler.NormalizationStrategy : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.NormalizationScaler.NormalizationStrategy : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PoseSelectionStrategy : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension CreateMLComponents.PoseSelectionStrategy : Swift.Hashable {}
