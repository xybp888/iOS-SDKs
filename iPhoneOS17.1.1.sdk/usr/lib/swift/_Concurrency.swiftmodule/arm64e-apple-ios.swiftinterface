// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.123.204 clang-1500.0.37.1)
// swift-module-flags: -disable-objc-attr-requires-foundation-module -target arm64e-apple-ios15.4 -enable-objc-interop -enable-library-evolution -module-link-name swift_Concurrency -parse-stdlib -swift-version 5 -O -library-level api -enforce-exclusivity=unchecked -enable-experimental-concurrency -module-name _Concurrency -disable-availability-checking
// swift-module-flags-ignorable: -user-module-version 5.9.0.123.204 -enable-lexical-lifetimes=false -target-min-inlining-version min
import Swift
import SwiftShims
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_marker public protocol AnyActor : AnyObject, Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol Actor : _Concurrency.AnyActor {
  nonisolated var unownedExecutor: _Concurrency.UnownedSerialExecutor { get }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_defaultActor_initialize")
public func _defaultActorInitialize(_ actor: Swift.AnyObject)
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@_silgen_name("swift_nonDefaultDistributedActor_initialize")
public func _nonDefaultDistributedActorInitialize(_ actor: Swift.AnyObject)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_defaultActor_destroy")
public func _defaultActorDestroy(_ actor: Swift.AnyObject)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_enqueueMainExecutor")
@usableFromInline
internal func _enqueueOnMain(_ job: _Concurrency.UnownedJob)
#if compiler(>=5.3) && $AsyncAwait && $Sendable
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_start")
public func _asyncLetStart<T>(asyncLet: Builtin.RawPointer, options: Builtin.RawPointer?, operation: @Sendable () async throws -> T)
#endif
#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_wait")
public func _asyncLetGet<T>(asyncLet: Builtin.RawPointer) async -> T
#endif
#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_wait_throwing")
public func _asyncLetGetThrowing<T>(asyncLet: Builtin.RawPointer) async throws -> T
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_end")
public func _asyncLetEnd(asyncLet: Builtin.RawPointer)
#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_get")
public func _asyncLet_get(_ asyncLet: Builtin.RawPointer, _ resultBuffer: Builtin.RawPointer) async
#endif
#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_get_throwing")
public func _asyncLet_get_throwing(_ asyncLet: Builtin.RawPointer, _ resultBuffer: Builtin.RawPointer) async throws
#endif
#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_finish")
public func _asyncLet_finish(_ asyncLet: Builtin.RawPointer, _ resultBuffer: Builtin.RawPointer) async
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct CheckedContinuation<T, E> : Swift.Sendable where E : Swift.Error {
  public init(continuation: _Concurrency.UnsafeContinuation<T, E>, function: Swift.String = #function)
  public func resume(returning value: __owned T)
  public func resume(throwing error: __owned E)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.CheckedContinuation {
  @_alwaysEmitIntoClient public func resume<Er>(with result: Swift.Result<T, Er>) where E == any Swift.Error, Er : Swift.Error {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  @_alwaysEmitIntoClient public func resume(with result: Swift.Result<T, E>) {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  @_alwaysEmitIntoClient public func resume() where T == () {
    self.resume(returning: ())
  }
}
#if compiler(>=5.3) && $AsyncAwait
#if $UnsafeInheritExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_unsafeInheritExecutor @inlinable public func withCheckedContinuation<T>(function: Swift.String = #function, _ body: (_Concurrency.CheckedContinuation<T, Swift.Never>) -> Swift.Void) async -> T {
  return await withUnsafeContinuation {
    body(CheckedContinuation(continuation: $0, function: function))
  }
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@inlinable public func withCheckedContinuation<T>(function: Swift.String = #function, _ body: (_Concurrency.CheckedContinuation<T, Swift.Never>) -> Swift.Void) async -> T {
  return await withUnsafeContinuation {
    body(CheckedContinuation(continuation: $0, function: function))
  }
}
#endif
#endif
#if compiler(>=5.3) && $AsyncAwait
#if $UnsafeInheritExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_unsafeInheritExecutor @inlinable public func withCheckedThrowingContinuation<T>(function: Swift.String = #function, _ body: (_Concurrency.CheckedContinuation<T, any Swift.Error>) -> Swift.Void) async throws -> T {
  return try await withUnsafeThrowingContinuation {
    body(CheckedContinuation(continuation: $0, function: function))
  }
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@inlinable public func withCheckedThrowingContinuation<T>(function: Swift.String = #function, _ body: (_Concurrency.CheckedContinuation<T, any Swift.Error>) -> Swift.Void) async throws -> T {
  return try await withUnsafeThrowingContinuation {
    body(CheckedContinuation(continuation: $0, function: function))
  }
}
#endif
#endif
#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_deletedAsyncMethodError")
public func swift_deletedAsyncMethodError() async
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol Executor : AnyObject, Swift.Sendable {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @available(*, deprecated, message: "Implement 'enqueue(_: __owned ExecutorJob)' instead")
  func enqueue(_ job: _Concurrency.UnownedJob)
  #if compiler(>=5.3) && $MoveOnly
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @available(*, deprecated, message: "Implement 'enqueue(_: __owned ExecutorJob)' instead")
  func enqueue(_ job: consuming _Concurrency.Job)
  #endif
  #if compiler(>=5.3) && $MoveOnly
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  func enqueue(_ job: consuming _Concurrency.ExecutorJob)
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol SerialExecutor : _Concurrency.Executor {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @available(*, deprecated, message: "Implement 'enqueue(_: __owned ExecutorJob)' instead")
  @_nonoverride func enqueue(_ job: _Concurrency.UnownedJob)
  #if compiler(>=5.3) && $MoveOnly
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @available(*, deprecated, message: "Implement 'enqueue(_: __owned ExecutorJob)' instead")
  @_nonoverride func enqueue(_ job: consuming _Concurrency.Job)
  #endif
  #if compiler(>=5.3) && $MoveOnly
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_nonoverride func enqueue(_ job: consuming _Concurrency.ExecutorJob)
  #endif
  func asUnownedSerialExecutor() -> _Concurrency.UnownedSerialExecutor
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  func isSameExclusiveExecutionContext(other: Self) -> Swift.Bool
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.Executor {
  public func enqueue(_ job: _Concurrency.UnownedJob)
  #if compiler(>=5.3) && $MoveOnly
  public func enqueue(_ job: consuming _Concurrency.ExecutorJob)
  #endif
  #if compiler(>=5.3) && $MoveOnly
  public func enqueue(_ job: consuming _Concurrency.Job)
  #endif
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.SerialExecutor {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public func asUnownedSerialExecutor() -> _Concurrency.UnownedSerialExecutor
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.SerialExecutor {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public func isSameExclusiveExecutionContext(other: Self) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct UnownedSerialExecutor : Swift.Sendable {
  #if compiler(>=5.3) && $BuiltinExecutor
  @usableFromInline
  internal var executor: Builtin.Executor
  #endif
  #if compiler(>=5.3) && $BuiltinExecutor
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var _executor: Builtin.Executor {
    get
  }
  #endif
  #if compiler(>=5.3) && $BuiltinExecutor
  @inlinable public init(_ executor: Builtin.Executor) {
    #if compiler(>=5.5) && $BuiltinExecutor
    self.executor = executor
    #endif
  }
  #endif
  @inlinable public init<E>(ordinary executor: __shared E) where E : _Concurrency.SerialExecutor {
    #if compiler(>=5.5) && $BuiltinBuildExecutor
    self.executor = Builtin.buildOrdinarySerialExecutorRef(executor)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @inlinable public init<E>(complexEquality executor: __shared E) where E : _Concurrency.SerialExecutor {
    #if compiler(>=5.9) && $BuiltinBuildComplexEqualityExecutor
    self.executor = Builtin.buildComplexEqualitySerialExecutorRef(executor)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@_silgen_name("swift_task_isOnExecutor")
public func _taskIsOnExecutor<Executor>(_ executor: Executor) -> Swift.Bool where Executor : _Concurrency.SerialExecutor
#if compiler(>=5.3) && $BuiltinExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_transparent public func _checkExpectedExecutor(_filenameStart: Builtin.RawPointer, _filenameLength: Builtin.Word, _filenameIsASCII: Builtin.Int1, _line: Builtin.Word, _executor: Builtin.Executor) {
  if _taskIsCurrentExecutor(_executor) {
    return
  }

  _reportUnexpectedExecutor(
      _filenameStart, _filenameLength, _filenameIsASCII, _line, _executor)
}
#endif
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.SerialExecutor {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public func preconditionIsolated(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #fileID, line: Swift.UInt = #line)
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.Actor {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  nonisolated public func preconditionIsolated(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #fileID, line: Swift.UInt = #line)
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.GlobalActor {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public static func preconditionIsolated(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #fileID, line: Swift.UInt = #line)
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.SerialExecutor {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public func assertIsolated(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #fileID, line: Swift.UInt = #line)
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.Actor {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  nonisolated public func assertIsolated(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #fileID, line: Swift.UInt = #line)
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.GlobalActor {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public static func assertIsolated(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #fileID, line: Swift.UInt = #line)
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.Actor {
  #if compiler(>=5.3) && $UnavailableFromAsync
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_unavailableFromAsync(message: "express the closure as an explicit function declared on the specified 'actor' instead") nonisolated public func assumeIsolated<T>(_ operation: (isolated Self) throws -> T, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) rethrows -> T
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  nonisolated public func assumeIsolated<T>(_ operation: (isolated Self) throws -> T, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) rethrows -> T
  #endif
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @preconcurrency @inlinable public __consuming func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Self.Element) async -> ElementOfResult?) -> _Concurrency.AsyncCompactMapSequence<Self, ElementOfResult> {
    return AsyncCompactMapSequence(self, transform: transform)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncCompactMapSequence<Base, ElementOfResult> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async -> ElementOfResult?
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async -> ElementOfResult?)
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncCompactMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = ElementOfResult
  public typealias AsyncIterator = _Concurrency.AsyncCompactMapSequence<Base, ElementOfResult>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = ElementOfResult
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async -> ElementOfResult?
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async -> ElementOfResult?)
    #endif
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> ElementOfResult? {
      while true {
        guard let element = try await baseIterator.next() else {
          return nil
        }

        if let transformed = await transform(element) {
          return transformed
        }
      }
    }
    #endif
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncCompactMapSequence<Base, ElementOfResult>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncCompactMapSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, ElementOfResult : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncCompactMapSequence.Iterator : @unchecked Swift.Sendable where ElementOfResult : Swift.Sendable, Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @inlinable public __consuming func dropFirst(_ count: Swift.Int = 1) -> _Concurrency.AsyncDropFirstSequence<Self> {
    precondition(count >= 0, 
      "Can't drop a negative number of elements from an async sequence")
    return AsyncDropFirstSequence(self, dropping: count)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncDropFirstSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let count: Swift.Int
  @usableFromInline
  internal init(_ base: Base, dropping count: Swift.Int)
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropFirstSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncDropFirstSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal var count: Swift.Int
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, count: Swift.Int)
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      var remainingToDrop = count
      while remainingToDrop > 0 {
        guard try await baseIterator.next() != nil else {
          count = 0
          return nil
        }
        remainingToDrop -= 1
      }
      count = 0
      return try await baseIterator.next()
    }
    #endif
    public typealias Element = Base.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncDropFirstSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), count: count)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropFirstSequence {
  @inlinable public __consuming func dropFirst(_ count: Swift.Int = 1) -> _Concurrency.AsyncDropFirstSequence<Base> {
    // If this is already a AsyncDropFirstSequence, we can just sum the current 
    // drop count and additional drop count.
    precondition(count >= 0, 
      "Can't drop a negative number of elements from an async sequence")
    return AsyncDropFirstSequence(base, dropping: self.count + count)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropFirstSequence : Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropFirstSequence.Iterator : Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @preconcurrency @inlinable public __consuming func drop(while predicate: @escaping @Sendable (Self.Element) async -> Swift.Bool) -> _Concurrency.AsyncDropWhileSequence<Self> {
    AsyncDropWhileSequence(self, predicate: predicate)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncDropWhileSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let predicate: (Base.Element) async -> Swift.Bool
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, predicate: @escaping (Base.Element) async -> Swift.Bool)
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropWhileSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncDropWhileSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal var predicate: ((Base.Element) async -> Swift.Bool)?
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async -> Swift.Bool)
    #endif
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      while let predicate = self.predicate {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        if await predicate(element) == false {
          self.predicate = nil
          return element
        }
      }
      return try await baseIterator.next()
    }
    #endif
    public typealias Element = Base.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncDropWhileSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), predicate: predicate)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropWhileSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropWhileSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @preconcurrency @inlinable public __consuming func filter(_ isIncluded: @escaping @Sendable (Self.Element) async -> Swift.Bool) -> _Concurrency.AsyncFilterSequence<Self> {
    return AsyncFilterSequence(self, isIncluded: isIncluded)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncFilterSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let isIncluded: (_Concurrency.AsyncFilterSequence<Base>.Element) async -> Swift.Bool
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, isIncluded: @escaping (Base.Element) async -> Swift.Bool)
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFilterSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncFilterSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let isIncluded: (Base.Element) async -> Swift.Bool
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, isIncluded: @escaping (Base.Element) async -> Swift.Bool)
    #endif
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      while true {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        if await isIncluded(element) {
          return element
        }
      }
    }
    #endif
    public typealias Element = Base.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncFilterSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), isIncluded: isIncluded)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFilterSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFilterSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @preconcurrency @inlinable public __consuming func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Self.Element) async -> SegmentOfResult) -> _Concurrency.AsyncFlatMapSequence<Self, SegmentOfResult> where SegmentOfResult : _Concurrency.AsyncSequence {
    return AsyncFlatMapSequence(self, transform: transform)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncFlatMapSequence<Base, SegmentOfResult> where Base : _Concurrency.AsyncSequence, SegmentOfResult : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async -> SegmentOfResult
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async -> SegmentOfResult)
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFlatMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = SegmentOfResult.Element
  public typealias AsyncIterator = _Concurrency.AsyncFlatMapSequence<Base, SegmentOfResult>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async -> SegmentOfResult
    @usableFromInline
    internal var currentIterator: SegmentOfResult.AsyncIterator?
    @usableFromInline
    internal var finished: Swift.Bool
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async -> SegmentOfResult)
    #endif
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> SegmentOfResult.Element? {
      while !finished {
        if var iterator = currentIterator {
          do {
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
            // restore the iterator since we just mutated it with next
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        } else {
          guard let item = try await baseIterator.next() else {
            finished = true
            return nil
          }
          do { 
            let segment = await transform(item)
            var iterator = segment.makeAsyncIterator()
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        }
      }
      return nil
    }
    #endif
    public typealias Element = SegmentOfResult.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncFlatMapSequence<Base, SegmentOfResult>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFlatMapSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, SegmentOfResult : Swift.Sendable, Base.Element : Swift.Sendable, SegmentOfResult.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFlatMapSequence.Iterator : @unchecked Swift.Sendable where SegmentOfResult : Swift.Sendable, Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable, SegmentOfResult.AsyncIterator : Swift.Sendable, SegmentOfResult.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@rethrows public protocol AsyncIteratorProtocol {
  associatedtype Element
  #if compiler(>=5.3) && $AsyncAwait
  mutating func next() async throws -> Self.Element?
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @preconcurrency @inlinable public __consuming func map<Transformed>(_ transform: @escaping @Sendable (Self.Element) async -> Transformed) -> _Concurrency.AsyncMapSequence<Self, Transformed> {
    return AsyncMapSequence(self, transform: transform)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncMapSequence<Base, Transformed> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async -> Transformed
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async -> Transformed)
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = Transformed
  public typealias AsyncIterator = _Concurrency.AsyncMapSequence<Base, Transformed>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async -> Transformed
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async -> Transformed)
    #endif
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> Transformed? {
      guard let element = try await baseIterator.next() else {
        return nil
      }
      return await transform(element)
    }
    #endif
    public typealias Element = Transformed
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncMapSequence<Base, Transformed>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncMapSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Transformed : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncMapSequence.Iterator : @unchecked Swift.Sendable where Transformed : Swift.Sendable, Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @inlinable public __consuming func prefix(_ count: Swift.Int) -> _Concurrency.AsyncPrefixSequence<Self> {
    precondition(count >= 0,
      "Can't prefix a negative number of elements from an async sequence")
    return AsyncPrefixSequence(self, count: count)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncPrefixSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let count: Swift.Int
  @usableFromInline
  internal init(_ base: Base, count: Swift.Int)
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncPrefixSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal var remaining: Swift.Int
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, count: Swift.Int)
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      if remaining != 0 {
        remaining &-= 1
        return try await baseIterator.next()
      } else {
        return nil
      }
    }
    #endif
    public typealias Element = Base.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncPrefixSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), count: count)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixSequence : Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixSequence.Iterator : Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @preconcurrency @inlinable public __consuming func prefix(while predicate: @escaping @Sendable (Self.Element) async -> Swift.Bool) rethrows -> _Concurrency.AsyncPrefixWhileSequence<Self> {
    return AsyncPrefixWhileSequence(self, predicate: predicate)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncPrefixWhileSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let predicate: (Base.Element) async -> Swift.Bool
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, predicate: @escaping (Base.Element) async -> Swift.Bool)
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixWhileSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncPrefixWhileSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var predicateHasFailed: Swift.Bool
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let predicate: (Base.Element) async -> Swift.Bool
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async -> Swift.Bool)
    #endif
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      if !predicateHasFailed, let nextElement = try await baseIterator.next() {
        if await predicate(nextElement) {
          return nextElement
        } else {
          predicateHasFailed = true
        }
      }
      return nil
    }
    #endif
    public typealias Element = Base.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncPrefixWhileSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), predicate: predicate)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixWhileSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixWhileSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@rethrows public protocol AsyncSequence {
  associatedtype AsyncIterator : _Concurrency.AsyncIteratorProtocol
  associatedtype Element where Self.Element == Self.AsyncIterator.Element
  __consuming func makeAsyncIterator() -> Self.AsyncIterator
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) async throws -> Result) async rethrows -> Result {
    var accumulator = initialResult
    var iterator = makeAsyncIterator()
    while let element = try await iterator.next() {
      accumulator = try await nextPartialResult(accumulator, element)
    }
    return accumulator
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable public func reduce<Result>(into initialResult: __owned Result, _ updateAccumulatingResult: (_ partialResult: inout Result, Self.Element) async throws -> Swift.Void) async rethrows -> Result {
    var accumulator = initialResult
    var iterator = makeAsyncIterator()
    while let element = try await iterator.next() {
      try await updateAccumulatingResult(&accumulator, element)
    }
    return accumulator
  }
  #endif
}
#endif
#if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@inlinable @inline(__always) internal func _contains<Source>(_ self: Source, where predicate: (Source.Element) async throws -> Swift.Bool) async rethrows -> Swift.Bool where Source : _Concurrency.AsyncSequence {
  for try await element in self {
    if try await predicate(element) {
      return true
    }
  }
  return false
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable public func contains(where predicate: (Self.Element) async throws -> Swift.Bool) async rethrows -> Swift.Bool {
    return try await _contains(self, where: predicate)
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable public func allSatisfy(_ predicate: (Self.Element) async throws -> Swift.Bool) async rethrows -> Swift.Bool {
    return try await !contains { try await !predicate($0) }
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence where Self.Element : Swift.Equatable {
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable public func contains(_ search: Self.Element) async rethrows -> Swift.Bool {
    for try await element in self {
      if element == search {
        return true
      }
    }
    return false
  }
  #endif
}
#endif
#if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@inlinable @inline(__always) internal func _first<Source>(_ self: Source, where predicate: (Source.Element) async throws -> Swift.Bool) async rethrows -> Source.Element? where Source : _Concurrency.AsyncSequence {
  for try await element in self {
    if try await predicate(element) {
      return element
    }
  }
  return nil
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable public func first(where predicate: (Self.Element) async throws -> Swift.Bool) async rethrows -> Self.Element? {
    return try await _first(self, where: predicate)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait
  @warn_unqualified_access
  @inlinable public func min(by areInIncreasingOrder: (Self.Element, Self.Element) async throws -> Swift.Bool) async rethrows -> Self.Element? {
    var it = makeAsyncIterator()
    guard var result = try await it.next() else { 
      return nil 
    }
    while let e = try await it.next() {
      if try await areInIncreasingOrder(e, result) { 
        result = e 
      }
    }
    return result
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @warn_unqualified_access
  @inlinable public func max(by areInIncreasingOrder: (Self.Element, Self.Element) async throws -> Swift.Bool) async rethrows -> Self.Element? {
    var it = makeAsyncIterator()
    guard var result = try await it.next() else { 
      return nil 
    }
    while let e = try await it.next() {
      if try await areInIncreasingOrder(result, e) { 
        result = e 
      }
    }
    return result
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence where Self.Element : Swift.Comparable {
  #if compiler(>=5.3) && $AsyncAwait
  @warn_unqualified_access
  @inlinable public func min() async rethrows -> Self.Element? {
    return try await self.min(by: <)
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @warn_unqualified_access
  @inlinable public func max() async rethrows -> Self.Element? {
    return try await self.max(by: <)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @preconcurrency @inlinable public __consuming func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Self.Element) async throws -> ElementOfResult?) -> _Concurrency.AsyncThrowingCompactMapSequence<Self, ElementOfResult> {
    return AsyncThrowingCompactMapSequence(self, transform: transform)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingCompactMapSequence<Base, ElementOfResult> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async throws -> ElementOfResult?
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async throws -> ElementOfResult?)
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingCompactMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = ElementOfResult
  public typealias AsyncIterator = _Concurrency.AsyncThrowingCompactMapSequence<Base, ElementOfResult>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = ElementOfResult
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async throws -> ElementOfResult?
    @usableFromInline
    internal var finished: Swift.Bool
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async throws -> ElementOfResult?)
    #endif
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async throws -> ElementOfResult? {
      while !finished {
        guard let element = try await baseIterator.next() else {
          finished = true
          return nil
        }
        do {
          if let transformed = try await transform(element) {
            return transformed
          }
        } catch {
          finished = true
          throw error
        }
      }
      return nil
    }
    #endif
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncThrowingCompactMapSequence<Base, ElementOfResult>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingCompactMapSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingCompactMapSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @preconcurrency @inlinable public __consuming func drop(while predicate: @escaping @Sendable (Self.Element) async throws -> Swift.Bool) -> _Concurrency.AsyncThrowingDropWhileSequence<Self> {
    AsyncThrowingDropWhileSequence(self, predicate: predicate)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingDropWhileSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let predicate: (Base.Element) async throws -> Swift.Bool
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, predicate: @escaping (Base.Element) async throws -> Swift.Bool)
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingDropWhileSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncThrowingDropWhileSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let predicate: (Base.Element) async throws -> Swift.Bool
    @usableFromInline
    internal var finished: Swift.Bool
    @usableFromInline
    internal var doneDropping: Swift.Bool
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async throws -> Swift.Bool)
    #endif
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async throws -> Base.Element? {
      while !finished && !doneDropping {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        do {
          if try await predicate(element) == false {
            doneDropping = true
            return element
          }
        } catch {
          finished = true
          throw error
        }
      }
      guard !finished else { 
        return nil
      }
      return try await baseIterator.next()
    }
    #endif
    public typealias Element = Base.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncThrowingDropWhileSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), predicate: predicate)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingDropWhileSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingDropWhileSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @preconcurrency @inlinable public __consuming func filter(_ isIncluded: @escaping @Sendable (Self.Element) async throws -> Swift.Bool) -> _Concurrency.AsyncThrowingFilterSequence<Self> {
    return AsyncThrowingFilterSequence(self, isIncluded: isIncluded)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingFilterSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let isIncluded: (_Concurrency.AsyncThrowingFilterSequence<Base>.Element) async throws -> Swift.Bool
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, isIncluded: @escaping (Base.Element) async throws -> Swift.Bool)
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFilterSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncThrowingFilterSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let isIncluded: (Base.Element) async throws -> Swift.Bool
    @usableFromInline
    internal var finished: Swift.Bool
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, isIncluded: @escaping (Base.Element) async throws -> Swift.Bool)
    #endif
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async throws -> Base.Element? {
      while !finished {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        do {
          if try await isIncluded(element) {
            return element
          }
        } catch {
          finished = true
          throw error
        }
      }

      return nil
    }
    #endif
    public typealias Element = Base.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncThrowingFilterSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), isIncluded: isIncluded)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFilterSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFilterSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @preconcurrency @inlinable public __consuming func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Self.Element) async throws -> SegmentOfResult) -> _Concurrency.AsyncThrowingFlatMapSequence<Self, SegmentOfResult> where SegmentOfResult : _Concurrency.AsyncSequence {
    return AsyncThrowingFlatMapSequence(self, transform: transform)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingFlatMapSequence<Base, SegmentOfResult> where Base : _Concurrency.AsyncSequence, SegmentOfResult : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async throws -> SegmentOfResult
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async throws -> SegmentOfResult)
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFlatMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = SegmentOfResult.Element
  public typealias AsyncIterator = _Concurrency.AsyncThrowingFlatMapSequence<Base, SegmentOfResult>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async throws -> SegmentOfResult
    @usableFromInline
    internal var currentIterator: SegmentOfResult.AsyncIterator?
    @usableFromInline
    internal var finished: Swift.Bool
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async throws -> SegmentOfResult)
    #endif
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async throws -> SegmentOfResult.Element? {
      while !finished {
        if var iterator = currentIterator {
          do {
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
            // restore the iterator since we just mutated it with next
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        } else {
          guard let item = try await baseIterator.next() else {
            return nil
          }
          let segment: SegmentOfResult
          do {
            segment = try await transform(item)
            var iterator = segment.makeAsyncIterator()
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
            currentIterator = iterator
            return element
          } catch {
            finished = true
            currentIterator = nil
            throw error
          }
        }
      }
      return nil
    }
    #endif
    public typealias Element = SegmentOfResult.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncThrowingFlatMapSequence<Base, SegmentOfResult>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFlatMapSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, SegmentOfResult : Swift.Sendable, Base.Element : Swift.Sendable, SegmentOfResult.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFlatMapSequence.Iterator : @unchecked Swift.Sendable where SegmentOfResult : Swift.Sendable, Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable, SegmentOfResult.AsyncIterator : Swift.Sendable, SegmentOfResult.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @preconcurrency @inlinable public __consuming func map<Transformed>(_ transform: @escaping @Sendable (Self.Element) async throws -> Transformed) -> _Concurrency.AsyncThrowingMapSequence<Self, Transformed> {
    return AsyncThrowingMapSequence(self, transform: transform)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingMapSequence<Base, Transformed> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async throws -> Transformed
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async throws -> Transformed)
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = Transformed
  public typealias AsyncIterator = _Concurrency.AsyncThrowingMapSequence<Base, Transformed>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async throws -> Transformed
    @usableFromInline
    internal var finished: Swift.Bool
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async throws -> Transformed)
    #endif
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async throws -> Transformed? {
      guard !finished, let element = try await baseIterator.next() else {
        return nil
      }
      do {
        return try await transform(element)
      } catch {
        finished = true
        throw error   
      }
    }
    #endif
    public typealias Element = Transformed
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncThrowingMapSequence<Base, Transformed>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingMapSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Transformed : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingMapSequence.Iterator : @unchecked Swift.Sendable where Transformed : Swift.Sendable, Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @preconcurrency @inlinable public __consuming func prefix(while predicate: @escaping @Sendable (Self.Element) async throws -> Swift.Bool) rethrows -> _Concurrency.AsyncThrowingPrefixWhileSequence<Self> {
    return AsyncThrowingPrefixWhileSequence(self, predicate: predicate)
  }
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingPrefixWhileSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let predicate: (Base.Element) async throws -> Swift.Bool
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, predicate: @escaping (Base.Element) async throws -> Swift.Bool)
  #endif
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingPrefixWhileSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncThrowingPrefixWhileSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var predicateHasFailed: Swift.Bool
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let predicate: (Base.Element) async throws -> Swift.Bool
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async throws -> Swift.Bool)
    #endif
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async throws -> Base.Element? {
      if !predicateHasFailed, let nextElement = try await baseIterator.next() {
        do { 
          if try await predicate(nextElement) {
            return nextElement
          } else {
            predicateHasFailed = true
          }
        } catch {
          predicateHasFailed = true
          throw error
        }
      }
      return nil
    }
    #endif
    public typealias Element = Base.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncThrowingPrefixWhileSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), predicate: predicate)
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingPrefixWhileSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingPrefixWhileSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol GlobalActor {
  associatedtype ActorType : _Concurrency.Actor
  static var shared: Self.ActorType { get }
  static var sharedUnownedExecutor: _Concurrency.UnownedSerialExecutor { get }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.GlobalActor {
  public static var sharedUnownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
#if compiler(>=5.3) && $Actors
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@globalActor final public actor MainActor : _Concurrency.GlobalActor {
  public static let shared: _Concurrency.MainActor
  @inlinable nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get {
    #if compiler(>=5.5) && $BuiltinBuildMainExecutor
    return UnownedSerialExecutor(Builtin.buildMainActorExecutorRef())
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  }
  @inlinable public static var sharedUnownedExecutor: _Concurrency.UnownedSerialExecutor {
    get {
    #if compiler(>=5.5) && $BuiltinBuildMainExecutor
    return UnownedSerialExecutor(Builtin.buildMainActorExecutorRef())
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  }
  @inlinable nonisolated final public func enqueue(_ job: _Concurrency.UnownedJob) {
    _enqueueOnMain(job)
  }
  public typealias ActorType = _Concurrency.MainActor
  @objc deinit
}
#endif
#if compiler(>=5.3) && $Actors
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.MainActor {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @usableFromInline
  internal static func run<T>(resultType: T.Type = T.self, body: @_Concurrency.MainActor @Sendable () throws -> T) async rethrows -> T
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public static func run<T>(resultType: T.Type = T.self, body: @_Concurrency.MainActor @Sendable () throws -> T) async rethrows -> T where T : Swift.Sendable {
    return try await body()
  }
  #endif
}
#endif
#if compiler(>=5.3) && $Actors
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.MainActor {
  #if compiler(>=5.3) && $UnavailableFromAsync
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_unavailableFromAsync(message: "await the call to the @MainActor closure directly") public static func assumeIsolated<T>(_ operation: @_Concurrency.MainActor () throws -> T, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) rethrows -> T
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public static func assumeIsolated<T>(_ operation: @_Concurrency.MainActor () throws -> T, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) rethrows -> T
  #endif
}
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_job_run")
@usableFromInline
internal func _swiftJobRun(_ job: _Concurrency.UnownedJob, _ executor: _Concurrency.UnownedSerialExecutor)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct UnownedJob : Swift.Sendable {
  #if compiler(>=5.3) && $BuiltinJob
  private var context: Builtin.Job
  #endif
  #if compiler(>=5.3) && $BuiltinJob
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal init(context: Builtin.Job)
  #endif
  #if compiler(>=5.3) && $MoveOnly
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public init(_ job: __owned _Concurrency.Job)
  #endif
  #if compiler(>=5.3) && $MoveOnly
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public init(_ job: __owned _Concurrency.ExecutorJob)
  #endif
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var priority: _Concurrency.JobPriority {
    get
  }
  @available(*, deprecated, renamed: "ExecutorJob.runSynchronously(on:)")
  @_alwaysEmitIntoClient @inlinable public func _runSynchronously(on executor: _Concurrency.UnownedSerialExecutor) {
    _swiftJobRun(self, executor)
  }
  @_alwaysEmitIntoClient @inlinable public func runSynchronously(on executor: _Concurrency.UnownedSerialExecutor) {
    _swiftJobRun(self, executor)
  }
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.UnownedJob : Swift.CustomStringConvertible {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var description: Swift.String {
    get
  }
}
#if compiler(>=5.3) && $MoveOnly
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@available(*, deprecated, renamed: "ExecutorJob")
@frozen @_moveOnly public struct Job : Swift.Sendable {
  #if compiler(>=5.3) && $BuiltinJob
  internal var context: Builtin.Job
  #endif
  #if compiler(>=5.3) && $BuiltinJob
  @usableFromInline
  internal init(context: __owned Builtin.Job)
  #endif
  public init(_ job: _Concurrency.UnownedJob)
  public init(_ job: __owned _Concurrency.ExecutorJob)
  public var priority: _Concurrency.JobPriority {
    get
  }
  public var description: Swift.String {
    get
  }
}
#endif
#if compiler(>=5.3) && $MoveOnly
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.Job {
  @_alwaysEmitIntoClient @inlinable public __consuming func runSynchronously(on executor: _Concurrency.UnownedSerialExecutor) {
    _swiftJobRun(UnownedJob(self), executor)
  }
}
#endif
#if compiler(>=5.3) && $MoveOnly
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@frozen @_moveOnly public struct ExecutorJob : Swift.Sendable {
  #if compiler(>=5.3) && $BuiltinJob
  internal var context: Builtin.Job
  #endif
  #if compiler(>=5.3) && $BuiltinJob
  @usableFromInline
  internal init(context: __owned Builtin.Job)
  #endif
  public init(_ job: _Concurrency.UnownedJob)
  public init(_ job: __owned _Concurrency.Job)
  public var priority: _Concurrency.JobPriority {
    get
  }
  public var description: Swift.String {
    get
  }
}
#endif
#if compiler(>=5.3) && $MoveOnly
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.ExecutorJob {
  @_alwaysEmitIntoClient @inlinable public __consuming func runSynchronously(on executor: _Concurrency.UnownedSerialExecutor) {
    _swiftJobRun(UnownedJob(self), executor)
  }
}
#endif
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@frozen public struct JobPriority : Swift.Sendable {
  public typealias RawValue = Swift.UInt8
  public var rawValue: _Concurrency.JobPriority.RawValue
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.TaskPriority {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public init?(_ p: _Concurrency.JobPriority)
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.JobPriority : Swift.Equatable {
  public static func == (lhs: _Concurrency.JobPriority, rhs: _Concurrency.JobPriority) -> Swift.Bool
  public static func != (lhs: _Concurrency.JobPriority, rhs: _Concurrency.JobPriority) -> Swift.Bool
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.JobPriority : Swift.Comparable {
  public static func < (lhs: _Concurrency.JobPriority, rhs: _Concurrency.JobPriority) -> Swift.Bool
  public static func <= (lhs: _Concurrency.JobPriority, rhs: _Concurrency.JobPriority) -> Swift.Bool
  public static func > (lhs: _Concurrency.JobPriority, rhs: _Concurrency.JobPriority) -> Swift.Bool
  public static func >= (lhs: _Concurrency.JobPriority, rhs: _Concurrency.JobPriority) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct UnsafeContinuation<T, E> : Swift.Sendable where E : Swift.Error {
  @usableFromInline
  internal var context: Builtin.RawUnsafeContinuation
  @_alwaysEmitIntoClient internal init(_ context: Builtin.RawUnsafeContinuation) {
    self.context = context
  }
  @_alwaysEmitIntoClient public func resume(returning value: __owned T) where E == Swift.Never {
    #if compiler(>=5.5) && $BuiltinContinuation
    Builtin.resumeNonThrowingContinuationReturning(context, value)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  @_alwaysEmitIntoClient public func resume(returning value: __owned T) {
    #if compiler(>=5.5) && $BuiltinContinuation
    Builtin.resumeThrowingContinuationReturning(context, value)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  @_alwaysEmitIntoClient public func resume(throwing error: __owned E) {
    #if compiler(>=5.5) && $BuiltinContinuation
    Builtin.resumeThrowingContinuationThrowing(context, error)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.UnsafeContinuation {
  @_alwaysEmitIntoClient public func resume<Er>(with result: Swift.Result<T, Er>) where E == any Swift.Error, Er : Swift.Error {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  @_alwaysEmitIntoClient public func resume(with result: Swift.Result<T, E>) {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  @_alwaysEmitIntoClient public func resume() where T == () {
    self.resume(returning: ())
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _resumeUnsafeContinuation<T>(_ continuation: _Concurrency.UnsafeContinuation<T, Swift.Never>, _ value: __owned T) {
  continuation.resume(returning: value)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _resumeUnsafeThrowingContinuation<T>(_ continuation: _Concurrency.UnsafeContinuation<T, any Swift.Error>, _ value: __owned T) {
  continuation.resume(returning: value)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _resumeUnsafeThrowingContinuationWithError<T>(_ continuation: _Concurrency.UnsafeContinuation<T, any Swift.Error>, _ error: __owned any Swift.Error) {
  continuation.resume(throwing: error)
}
#if compiler(>=5.3) && $AsyncAwait
#if $UnsafeInheritExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_unsafeInheritExecutor @_alwaysEmitIntoClient public func withUnsafeContinuation<T>(_ fn: (_Concurrency.UnsafeContinuation<T, Swift.Never>) -> Swift.Void) async -> T {
  return await Builtin.withUnsafeContinuation {
    fn(UnsafeContinuation<T, Never>($0))
  }
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient public func withUnsafeContinuation<T>(_ fn: (_Concurrency.UnsafeContinuation<T, Swift.Never>) -> Swift.Void) async -> T {
  return await Builtin.withUnsafeContinuation {
    fn(UnsafeContinuation<T, Never>($0))
  }
}
#endif
#endif
#if compiler(>=5.3) && $AsyncAwait
#if $UnsafeInheritExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_unsafeInheritExecutor @_alwaysEmitIntoClient public func withUnsafeThrowingContinuation<T>(_ fn: (_Concurrency.UnsafeContinuation<T, any Swift.Error>) -> Swift.Void) async throws -> T {
  return try await Builtin.withUnsafeThrowingContinuation {
    fn(UnsafeContinuation<T, Error>($0))
  }
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient public func withUnsafeThrowingContinuation<T>(_ fn: (_Concurrency.UnsafeContinuation<T, any Swift.Error>) -> Swift.Void) async throws -> T {
  return try await Builtin.withUnsafeThrowingContinuation {
    fn(UnsafeContinuation<T, Error>($0))
  }
}
#endif
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient public func _abiEnableAwaitContinuation() {
  fatalError("never use this function")
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  @available(*, deprecated, message: "Task.Priority has been removed; use TaskPriority")
  public typealias Priority = _Concurrency.TaskPriority
  @available(*, deprecated, message: "Task.Handle has been removed; use Task")
  public typealias Handle = _Concurrency.Task
  @available(*, deprecated, message: "Task.CancellationError has been removed; use CancellationError")
  @_alwaysEmitIntoClient public static func CancellationError() -> _Concurrency.CancellationError {
    return _Concurrency.CancellationError()
  }
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, renamed: "yield()")
  @_alwaysEmitIntoClient public static func suspend() async {
    await yield()
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskPriority {
  @available(*, deprecated, message: "unspecified priority will be removed; use nil")
  @_alwaysEmitIntoClient public static var unspecified: _Concurrency.TaskPriority {
    get {
    .init(rawValue: 0x00)
  }
  }
  @available(*, deprecated, message: "userInteractive priority will be removed")
  @_alwaysEmitIntoClient public static var userInteractive: _Concurrency.TaskPriority {
    get {
    .init(rawValue: 0x21)
  }
  }
}
#if compiler(>=5.3) && $AsyncAwait && $Sendable
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, renamed: "withTaskCancellationHandler(operation:onCancel:)")
@_alwaysEmitIntoClient public func withTaskCancellationHandler<T>(handler: @Sendable () -> Swift.Void, operation: () async throws -> T) async rethrows -> T {
  try await withTaskCancellationHandler(operation: operation, onCancel: handler)
}
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, message: "`Task.withCancellationHandler` has been replaced by `withTaskCancellationHandler` and will be removed shortly.")
  @_alwaysEmitIntoClient public static func withCancellationHandler<T>(handler: @Sendable () -> Swift.Void, operation: () async throws -> T) async rethrows -> T {
    try await withTaskCancellationHandler(handler: handler, operation: operation)
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == any Swift.Error {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @discardableResult
  @available(*, deprecated, message: "`Task.runDetached` was replaced by `Task.detached` and will be removed shortly.")
  @_alwaysEmitIntoClient public static func runDetached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) -> _Concurrency.Task<Success, Failure> {
    detached(priority: priority, operation: operation)
  }
  #endif
}
#if compiler(>=5.3) && $AsyncAwait && $Sendable
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`detach` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func detach<T>(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> T) -> _Concurrency.Task<T, Swift.Never> where T : Swift.Sendable {
  Task.detached(priority: priority, operation: operation)
}
#endif
#if compiler(>=5.3) && $AsyncAwait && $Sendable
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`detach` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func detach<T>(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> T) -> _Concurrency.Task<T, any Swift.Error> where T : Swift.Sendable {
  Task.detached(priority: priority, operation: operation)
}
#endif
#if compiler(>=5.3) && $AsyncAwait && $Sendable && $ImplicitSelfCapture
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`asyncDetached` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func asyncDetached<T>(priority: _Concurrency.TaskPriority? = nil, @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> T) -> _Concurrency.Task<T, Swift.Never> where T : Swift.Sendable {
  return Task.detached(priority: priority, operation: operation)
}
#endif
#if compiler(>=5.3) && $AsyncAwait && $Sendable && $ImplicitSelfCapture
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`asyncDetached` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func asyncDetached<T>(priority: _Concurrency.TaskPriority? = nil, @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> T) -> _Concurrency.Task<T, any Swift.Error> where T : Swift.Sendable {
  return Task.detached(priority: priority, operation: operation)
}
#endif
#if compiler(>=5.3) && $AsyncAwait && $Sendable && $InheritActorContext && $ImplicitSelfCapture
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "`async` was replaced by `Task.init` and will be removed shortly.")
@discardableResult
@_alwaysEmitIntoClient public func async<T>(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> T) -> _Concurrency.Task<T, Swift.Never> where T : Swift.Sendable {
  .init(priority: priority, operation: operation)
}
#endif
#if compiler(>=5.3) && $AsyncAwait && $Sendable && $InheritActorContext && $ImplicitSelfCapture
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "`async` was replaced by `Task.init` and will be removed shortly.")
@discardableResult
@_alwaysEmitIntoClient public func async<T>(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> T) -> _Concurrency.Task<T, any Swift.Error> where T : Swift.Sendable {
  .init(priority: priority, operation: operation)
}
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  @available(*, deprecated, message: "`Task.Group` was replaced by `ThrowingTaskGroup` and `TaskGroup` and will be removed shortly.")
  public typealias Group<TaskResult> = _Concurrency.ThrowingTaskGroup<TaskResult, any Swift.Error> where TaskResult : Swift.Sendable
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, message: "`Task.withGroup` was replaced by `withThrowingTaskGroup` and `withTaskGroup` and will be removed shortly.")
  @_alwaysEmitIntoClient public static func withGroup<TaskResult, BodyResult>(resultType: TaskResult.Type, returning returnType: BodyResult.Type = BodyResult.self, body: (inout _Concurrency.Task<Success, Failure>.Group<TaskResult>) async throws -> BodyResult) async rethrows -> BodyResult where TaskResult : Swift.Sendable {
    try await withThrowingTaskGroup(of: resultType) { group in
      try await body(&group)
    }
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task {
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, message: "get() has been replaced by .value")
  @_alwaysEmitIntoClient public func get() async throws -> Success {
    return try await value
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, message: "getResult() has been replaced by .result")
  @_alwaysEmitIntoClient public func getResult() async -> Swift.Result<Success, Failure> {
    return await result
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, message: "get() has been replaced by .value")
  @_alwaysEmitIntoClient public func get() async -> Success {
    return await value
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskGroup {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func add(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) async -> Swift.Bool {
    return self.addTaskUnlessCancelled(priority: priority) {
      await operation()
    }
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawn(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawnUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func async(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func asyncUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.ThrowingTaskGroup {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func add(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) async -> Swift.Bool {
    return self.addTaskUnlessCancelled(priority: priority) {
      try await operation()
    }
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawn(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawnUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func async(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func asyncUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "please use UnsafeContinuation<..., Error>")
public typealias UnsafeThrowingContinuation<T> = _Concurrency.UnsafeContinuation<T, any Swift.Error>
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, renamed: "UnownedJob")
public typealias PartialAsyncTask = _Concurrency.UnownedJob
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct Task<Success, Failure> : Swift.Sendable where Success : Swift.Sendable, Failure : Swift.Error {
  @usableFromInline
  internal let _task: Builtin.NativeObject
  @_alwaysEmitIntoClient internal init(_ task: Builtin.NativeObject) {
    self._task = task
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task {
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Success {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var result: Swift.Result<Success, Failure> {
    get async
  }
  #endif
  public func cancel()
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Success {
    get async
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task : Swift.Equatable {
  public static func == (lhs: _Concurrency.Task<Success, Failure>, rhs: _Concurrency.Task<Success, Failure>) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct TaskPriority : Swift.RawRepresentable, Swift.Sendable {
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8
  public init(rawValue: Swift.UInt8)
  public static let high: _Concurrency.TaskPriority
  @_alwaysEmitIntoClient public static var medium: _Concurrency.TaskPriority {
    get {
    .init(rawValue: 0x15)
  }
  }
  public static let low: _Concurrency.TaskPriority
  public static let userInitiated: _Concurrency.TaskPriority
  public static let utility: _Concurrency.TaskPriority
  public static let background: _Concurrency.TaskPriority
  @available(*, deprecated, renamed: "medium")
  public static let `default`: _Concurrency.TaskPriority
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskPriority : Swift.Equatable {
  public static func == (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
  public static func != (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskPriority : Swift.Comparable {
  public static func < (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
  public static func <= (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
  public static func > (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
  public static func >= (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.TaskPriority : Swift.CustomStringConvertible {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var description: Swift.String {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskPriority : Swift.Codable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  public static var currentPriority: _Concurrency.TaskPriority {
    get
  }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static var basePriority: _Concurrency.TaskPriority? {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func taskCreateFlags(priority: _Concurrency.TaskPriority?, isChildTask: Swift.Bool, copyTaskLocals: Swift.Bool, inheritContext: Swift.Bool, enqueueJob: Swift.Bool, addPendingGroupTaskUnconditionally: Swift.Bool, isDiscardingTask: Swift.Bool) -> Swift.Int {
  var bits = 0
  bits |= (bits & ~0xFF) | Int(priority?.rawValue ?? 0)
  if isChildTask {
    bits |= 1 << 8
  }
  if copyTaskLocals {
    bits |= 1 << 10
  }
  if inheritContext {
    bits |= 1 << 11
  }
  if enqueueJob {
    bits |= 1 << 12
  }
  if addPendingGroupTaskUnconditionally {
    bits |= 1 << 13
  }
  if isDiscardingTask {
    bits |= 1 << 14
  }
  return bits
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable && $InheritActorContext && $ImplicitSelfCapture
  @discardableResult
  @_alwaysEmitIntoClient public init(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> Success) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    // Set up the job flags for a new task.
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

    // Create the asynchronous task.
    let (task, _) = Builtin.createAsyncTask(flags, operation)

    self._task = task
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == any Swift.Error {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable && $InheritActorContext && $ImplicitSelfCapture
  @discardableResult
  @_alwaysEmitIntoClient public init(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> Success) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    // Set up the task flags for a new task.
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

    // Create the asynchronous task future.
    let (task, _) = Builtin.createAsyncTask(flags, operation)

    self._task = task
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Success) -> _Concurrency.Task<Success, Failure> {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    // Set up the job flags for a new task.
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

    // Create the asynchronous task future.
    let (task, _) = Builtin.createAsyncTask(flags, operation)

    return Task(task)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == any Swift.Error {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) -> _Concurrency.Task<Success, Failure> {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    // Set up the job flags for a new task.
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

    // Create the asynchronous task future.
    let (task, _) = Builtin.createAsyncTask(flags, operation)

    return Task(task)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  #if compiler(>=5.3) && $AsyncAwait
  public static func yield() async
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func withUnsafeCurrentTask<T>(body: (_Concurrency.UnsafeCurrentTask?) throws -> T) rethrows -> T
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct UnsafeCurrentTask {
  public var isCancelled: Swift.Bool {
    get
  }
  public var priority: _Concurrency.TaskPriority {
    get
  }
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var basePriority: _Concurrency.TaskPriority {
    get
  }
  public func cancel()
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, unavailable)
extension _Concurrency.UnsafeCurrentTask : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.UnsafeCurrentTask : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.UnsafeCurrentTask : Swift.Equatable {
  public static func == (lhs: _Concurrency.UnsafeCurrentTask, rhs: _Concurrency.UnsafeCurrentTask) -> Swift.Bool
}
#if compiler(>=5.3) && $BuiltinJob
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_enqueueGlobal")
@usableFromInline
internal func _enqueueJobGlobal(_ task: Builtin.Job)
#endif
#if compiler(>=5.3) && $BuiltinJob
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_enqueueGlobalWithDelay")
@usableFromInline
internal func _enqueueJobGlobalWithDelay(_ delay: Swift.UInt64, _ task: Builtin.Job)
#endif
#if compiler(>=5.3) && $BuiltinJob
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@_silgen_name("swift_task_enqueueGlobalWithDeadline")
@usableFromInline
internal func _enqueueJobGlobalWithDeadline(_ seconds: Swift.Int64, _ nanoseconds: Swift.Int64, _ toleranceSec: Swift.Int64, _ toleranceNSec: Swift.Int64, _ clock: Swift.Int32, _ task: Builtin.Job)
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_asyncMainDrainQueue")
internal func _asyncMainDrainQueue() -> Swift.Never
#if compiler(>=5.3) && $BuiltinExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_getMainExecutor")
internal func _getMainExecutor() -> Builtin.Executor
#endif
#if compiler(>=5.3) && $AsyncAwait && $Sendable
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@preconcurrency internal func _runAsyncMain(_ asyncFun: @escaping @Sendable () async throws -> ())
#endif
#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_future_wait")
public func _taskFutureGet<T>(_ task: Builtin.NativeObject) async -> T
#endif
#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_future_wait_throwing")
public func _taskFutureGetThrowing<T>(_ task: Builtin.NativeObject) async throws -> T
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_isCancelled")
@usableFromInline
internal func _taskIsCancelled(_ task: Builtin.NativeObject) -> Swift.Bool
#if compiler(>=5.3) && $BuiltinExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_isCurrentExecutor")
internal func _taskIsCurrentExecutor(_ executor: Builtin.Executor) -> Swift.Bool
#endif
#if compiler(>=5.3) && $BuiltinExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_reportUnexpectedExecutor")
internal func _reportUnexpectedExecutor(_ _filenameStart: Builtin.RawPointer, _ _filenameLength: Builtin.Word, _ _filenameIsASCII: Builtin.Int1, _ _line: Builtin.Word, _ _executor: Builtin.Executor)
#endif
#if compiler(>=5.3) && $AsyncAwait && $Sendable && $InheritActorContext
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_alwaysEmitIntoClient internal func _runTaskForBridgedAsyncMethod(@_inheritActorContext _ body: __owned @escaping @Sendable () async -> Swift.Void) {
#if compiler(>=5.6)
  Task(operation: body)
#else
  Task<Int, Error> {
    await body()
    return 0
  }
#endif
}
#endif
#if compiler(>=5.3) && $AsyncAwait && $Sendable
#if $UnsafeInheritExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_backDeploy(before: macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4)
@_unsafeInheritExecutor public func withTaskCancellationHandler<T>(operation: () async throws -> T, onCancel handler: @Sendable () -> Swift.Void) async rethrows -> T {
  // unconditionally add the cancellation record to the task.
  // if the task was already cancelled, it will be executed right away.
  let record = _taskAddCancellationHandler(handler: handler)
  do {
    let result = try await operation()
    _taskRemoveCancellationHandler(record: record)
    return result
  } catch {
    _taskRemoveCancellationHandler(record: record)
    throw error
  }
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_backDeploy(before: macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4)
public func withTaskCancellationHandler<T>(operation: () async throws -> T, onCancel handler: @Sendable () -> Swift.Void) async rethrows -> T {
  // unconditionally add the cancellation record to the task.
  // if the task was already cancelled, it will be executed right away.
  let record = _taskAddCancellationHandler(handler: handler)
  do {
    let result = try await operation()
    _taskRemoveCancellationHandler(record: record)
    return result
  } catch {
    _taskRemoveCancellationHandler(record: record)
    throw error
  }
}
#endif
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task {
  @_transparent public var isCancelled: Swift.Bool {
    @_transparent get {
    _taskIsCancelled(_task)
  }
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  public static var isCancelled: Swift.Bool {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  public static func checkCancellation() throws
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct CancellationError : Swift.Error {
  public init()
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_addCancellationHandler")
internal func _taskAddCancellationHandler(handler: () -> Swift.Void) -> Swift.UnsafeRawPointer
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_removeCancellationHandler")
internal func _taskRemoveCancellationHandler(record: Swift.UnsafeRawPointer)
#if compiler(>=5.3) && $AsyncAwait
#if $UnsafeInheritExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("$ss13withTaskGroup2of9returning4bodyq_xm_q_mq_ScGyxGzYaXEtYar0_lF")
@_unsafeInheritExecutor @inlinable public func withTaskGroup<ChildTaskResult, GroupResult>(of childTaskResultType: ChildTaskResult.Type, returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.TaskGroup<ChildTaskResult>) async -> GroupResult) async -> GroupResult where ChildTaskResult : Swift.Sendable {
  #if compiler(>=5.5) && $BuiltinTaskGroupWithArgument

  let _group = Builtin.createTaskGroup(ChildTaskResult.self)
  var group = TaskGroup<ChildTaskResult>(group: _group)

  // Run the withTaskGroup body.
  let result = await body(&group)

  await group.awaitAllRemainingTasks()

  Builtin.destroyTaskGroup(_group)
  return result

  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("$ss13withTaskGroup2of9returning4bodyq_xm_q_mq_ScGyxGzYaXEtYar0_lF")
@inlinable public func withTaskGroup<ChildTaskResult, GroupResult>(of childTaskResultType: ChildTaskResult.Type, returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.TaskGroup<ChildTaskResult>) async -> GroupResult) async -> GroupResult where ChildTaskResult : Swift.Sendable {
  #if compiler(>=5.5) && $BuiltinTaskGroupWithArgument

  let _group = Builtin.createTaskGroup(ChildTaskResult.self)
  var group = TaskGroup<ChildTaskResult>(group: _group)

  // Run the withTaskGroup body.
  let result = await body(&group)

  await group.awaitAllRemainingTasks()

  Builtin.destroyTaskGroup(_group)
  return result

  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
#endif
#endif
#if compiler(>=5.3) && $AsyncAwait
#if $UnsafeInheritExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("$ss21withThrowingTaskGroup2of9returning4bodyq_xm_q_mq_Scgyxs5Error_pGzYaKXEtYaKr0_lF")
@_unsafeInheritExecutor @inlinable public func withThrowingTaskGroup<ChildTaskResult, GroupResult>(of childTaskResultType: ChildTaskResult.Type, returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.ThrowingTaskGroup<ChildTaskResult, any Swift.Error>) async throws -> GroupResult) async rethrows -> GroupResult where ChildTaskResult : Swift.Sendable {
  #if compiler(>=5.5) && $BuiltinTaskGroupWithArgument

  let _group = Builtin.createTaskGroup(ChildTaskResult.self)
  var group = ThrowingTaskGroup<ChildTaskResult, Error>(group: _group)

  do {
    // Run the withTaskGroup body.
    let result = try await body(&group)

    await group.awaitAllRemainingTasks()
    Builtin.destroyTaskGroup(_group)

    return result
  } catch {
    group.cancelAll()

    await group.awaitAllRemainingTasks()
    Builtin.destroyTaskGroup(_group)

    throw error
  }

  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("$ss21withThrowingTaskGroup2of9returning4bodyq_xm_q_mq_Scgyxs5Error_pGzYaKXEtYaKr0_lF")
@inlinable public func withThrowingTaskGroup<ChildTaskResult, GroupResult>(of childTaskResultType: ChildTaskResult.Type, returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.ThrowingTaskGroup<ChildTaskResult, any Swift.Error>) async throws -> GroupResult) async rethrows -> GroupResult where ChildTaskResult : Swift.Sendable {
  #if compiler(>=5.5) && $BuiltinTaskGroupWithArgument

  let _group = Builtin.createTaskGroup(ChildTaskResult.self)
  var group = ThrowingTaskGroup<ChildTaskResult, Error>(group: _group)

  do {
    // Run the withTaskGroup body.
    let result = try await body(&group)

    await group.awaitAllRemainingTasks()
    Builtin.destroyTaskGroup(_group)

    return result
  } catch {
    group.cancelAll()

    await group.awaitAllRemainingTasks()
    Builtin.destroyTaskGroup(_group)

    throw error
  }

  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
#endif
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct TaskGroup<ChildTaskResult> where ChildTaskResult : Swift.Sendable {
  @usableFromInline
  internal let _group: Builtin.RawPointer
  @inlinable internal init(group: Builtin.RawPointer) {
    self._group = group
  }
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
#if SWIFT_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: false,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false
    )
#else
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false)
#endif

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
      // the group is cancelled and is not accepting any new work
      return false
    }
#if SWIFT_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: false,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)
#else
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)
#endif

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public mutating func next() async -> ChildTaskResult?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal mutating func awaitAllRemainingTasks() async
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @_alwaysEmitIntoClient public mutating func waitForAll() async {
    await awaitAllRemainingTasks()
  }
  #endif
  public var isEmpty: Swift.Bool {
    get
  }
  public func cancelAll()
  public var isCancelled: Swift.Bool {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, unavailable)
extension _Concurrency.TaskGroup : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct ThrowingTaskGroup<ChildTaskResult, Failure> where ChildTaskResult : Swift.Sendable, Failure : Swift.Error {
  @usableFromInline
  internal let _group: Builtin.RawPointer
  @inlinable internal init(group: Builtin.RawPointer) {
    self._group = group
  }
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal mutating func awaitAllRemainingTasks() async
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal mutating func _waitForAll() async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @_alwaysEmitIntoClient public mutating func waitForAll() async throws {
    var firstError: Error? = nil

    // Make sure we loop until all child tasks have completed
    while !isEmpty {
      do {
        while let _ = try await next() {}
      } catch {
        // Upon error throws, capture the first one
        if firstError == nil {
          firstError = error
        }
      }
    }

    if let firstError {
      throw firstError
    }
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false
    )

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
      // the group is cancelled and is not accepting any new work
      return false
    }

    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public mutating func next() async throws -> ChildTaskResult?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @_silgen_name("$sScg10nextResults0B0Oyxq_GSgyYaKF")
  @usableFromInline
  internal mutating func nextResultForABI() async throws -> Swift.Result<ChildTaskResult, Failure>?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @_alwaysEmitIntoClient public mutating func nextResult() async -> Swift.Result<ChildTaskResult, Failure>? {
    return try! await nextResultForABI()
  }
  #endif
  public var isEmpty: Swift.Bool {
    get
  }
  public func cancelAll()
  public var isCancelled: Swift.Bool {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, unavailable)
extension _Concurrency.ThrowingTaskGroup : Swift.Sendable {
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskGroup : _Concurrency.AsyncSequence {
  public typealias AsyncIterator = _Concurrency.TaskGroup<ChildTaskResult>.Iterator
  public typealias Element = ChildTaskResult
  public func makeAsyncIterator() -> _Concurrency.TaskGroup<ChildTaskResult>.Iterator
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = ChildTaskResult
    @usableFromInline
    internal var group: _Concurrency.TaskGroup<ChildTaskResult>
    @usableFromInline
    internal var finished: Swift.Bool
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async -> _Concurrency.TaskGroup<ChildTaskResult>.Iterator.Element?
    #endif
    public mutating func cancel()
  }
}
#endif
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.ThrowingTaskGroup : _Concurrency.AsyncSequence {
  public typealias AsyncIterator = _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator
  public typealias Element = ChildTaskResult
  public func makeAsyncIterator() -> _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = ChildTaskResult
    @usableFromInline
    internal var group: _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>
    @usableFromInline
    internal var finished: Swift.Bool
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async throws -> _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator.Element?
    #endif
    public mutating func cancel()
  }
}
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_taskGroup_addPending")
@usableFromInline
internal func _taskGroupAddPendingTask(group: Builtin.RawPointer, unconditionally: Swift.Bool) -> Swift.Bool
@available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
@_alwaysEmitIntoClient internal func taskGroupCreateFlags(discardResults: Swift.Bool) -> Swift.Int {
  var bits = 0
  if discardResults {
    bits |= 1 << 8
  }
  return bits
}
#if compiler(>=5.3) && $AsyncAwait
#if $UnsafeInheritExecutor
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@inlinable @_unsafeInheritExecutor public func withDiscardingTaskGroup<GroupResult>(returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.DiscardingTaskGroup) async -> GroupResult) async -> GroupResult {
  #if compiler(>=5.5) && $BuiltinCreateTaskGroupWithFlags
  let flags = taskGroupCreateFlags(
    discardResults: true
  )

  let _group = Builtin.createTaskGroupWithFlags(flags, GroupResult.self)
  var group = DiscardingTaskGroup(group: _group)
  defer { Builtin.destroyTaskGroup(_group) }

  let result = await body(&group)

  try! await group.awaitAllRemainingTasks() // try!-safe, cannot throw since this is a non throwing group

  return result
  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
#else
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@inlinable public func withDiscardingTaskGroup<GroupResult>(returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.DiscardingTaskGroup) async -> GroupResult) async -> GroupResult {
  #if compiler(>=5.5) && $BuiltinCreateTaskGroupWithFlags
  let flags = taskGroupCreateFlags(
    discardResults: true
  )

  let _group = Builtin.createTaskGroupWithFlags(flags, GroupResult.self)
  var group = DiscardingTaskGroup(group: _group)
  defer { Builtin.destroyTaskGroup(_group) }

  let result = await body(&group)

  try! await group.awaitAllRemainingTasks() // try!-safe, cannot throw since this is a non throwing group

  return result
  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
#endif
#endif
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@frozen public struct DiscardingTaskGroup {
  @usableFromInline
  internal let _group: Builtin.RawPointer
  @inlinable internal init(group: Builtin.RawPointer) {
    self._group = group
  }
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal mutating func awaitAllRemainingTasks() async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Swift.Void) {
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true, isDiscardingTask: true
    )

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Swift.Void) -> Swift.Bool {
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
      // the group is cancelled and is not accepting any new work
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)

    return true
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTask(operation: __owned @escaping @Sendable () async -> Swift.Void) {
    let flags = taskCreateFlags(
      priority: nil, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true, isDiscardingTask: true
    )

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(operation: __owned @escaping @Sendable () async -> Swift.Void) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
      // the group is cancelled and is not accepting any new work
      return false
    }

    let flags = taskCreateFlags(
      priority: nil, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  public var isEmpty: Swift.Bool {
    get
  }
  public func cancelAll()
  public var isCancelled: Swift.Bool {
    get
  }
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@available(*, unavailable)
extension _Concurrency.DiscardingTaskGroup : Swift.Sendable {
}
#if compiler(>=5.3) && $AsyncAwait
#if $UnsafeInheritExecutor
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@inlinable @_unsafeInheritExecutor public func withThrowingDiscardingTaskGroup<GroupResult>(returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.ThrowingDiscardingTaskGroup<any Swift.Error>) async throws -> GroupResult) async throws -> GroupResult {
  #if compiler(>=5.5) && $BuiltinCreateTaskGroupWithFlags
  let flags = taskGroupCreateFlags(
      discardResults: true
  )

  let _group = Builtin.createTaskGroupWithFlags(flags, GroupResult.self)
  var group = ThrowingDiscardingTaskGroup<Error>(group: _group)
  defer { Builtin.destroyTaskGroup(_group) }

  let result: GroupResult
  do {
    result = try await body(&group)
  } catch {
    group.cancelAll()

    try await group.awaitAllRemainingTasks(bodyError: error)

    throw error
  }

  try await group.awaitAllRemainingTasks(bodyError: nil)

  return result
  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
#else
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@inlinable public func withThrowingDiscardingTaskGroup<GroupResult>(returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.ThrowingDiscardingTaskGroup<any Swift.Error>) async throws -> GroupResult) async throws -> GroupResult {
  #if compiler(>=5.5) && $BuiltinCreateTaskGroupWithFlags
  let flags = taskGroupCreateFlags(
      discardResults: true
  )

  let _group = Builtin.createTaskGroupWithFlags(flags, GroupResult.self)
  var group = ThrowingDiscardingTaskGroup<Error>(group: _group)
  defer { Builtin.destroyTaskGroup(_group) }

  let result: GroupResult
  do {
    result = try await body(&group)
  } catch {
    group.cancelAll()

    try await group.awaitAllRemainingTasks(bodyError: error)

    throw error
  }

  try await group.awaitAllRemainingTasks(bodyError: nil)

  return result
  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
#endif
#endif
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@frozen public struct ThrowingDiscardingTaskGroup<Failure> where Failure : Swift.Error {
  @usableFromInline
  internal let _group: Builtin.RawPointer
  @inlinable internal init(group: Builtin.RawPointer) {
    self._group = group
  }
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal mutating func awaitAllRemainingTasks(bodyError: (any Swift.Error)?) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Swift.Void) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true, isDiscardingTask: true
    )

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Swift.Void) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
      // the group is cancelled and is not accepting any new work
      return false
    }

    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  public var isEmpty: Swift.Bool {
    get
  }
  public func cancelAll()
  public var isCancelled: Swift.Bool {
    get
  }
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@available(*, unavailable)
extension _Concurrency.ThrowingDiscardingTaskGroup : Swift.Sendable {
}
#if compiler(>=5.3) && $AsyncAwait
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@usableFromInline
@discardableResult
@_silgen_name("swift_taskGroup_waitAll")
internal func _taskGroupWaitAll<T>(group: Builtin.RawPointer, bodyError: (any Swift.Error)?) async throws -> T?
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@propertyWrapper final public class TaskLocal<Value> : Swift.Sendable, Swift.CustomStringConvertible where Value : Swift.Sendable {
  public init(wrappedValue defaultValue: Value)
  @_alwaysEmitIntoClient final internal var key: Builtin.RawPointer {
    get {
    unsafeBitCast(self, to: Builtin.RawPointer.self)
  }
  }
  final public func get() -> Value
  #if compiler(>=5.3) && $AsyncAwait
  #if $UnsafeInheritExecutor
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @_backDeploy(before: macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4)
  @discardableResult
  @_unsafeInheritExecutor final public func withValue<R>(_ valueDuringOperation: Value, operation: () async throws -> R, file: Swift.String = #fileID, line: Swift.UInt = #line) async rethrows -> R {
    return try await withValueImpl(valueDuringOperation, operation: operation, file: file, line: line)
  }
  #else
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @_backDeploy(before: macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4)
  @discardableResult
  final public func withValue<R>(_ valueDuringOperation: Value, operation: () async throws -> R, file: Swift.String = #fileID, line: Swift.UInt = #line) async rethrows -> R {
    return try await withValueImpl(valueDuringOperation, operation: operation, file: file, line: line)
  }
  #endif
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  #if $UnsafeInheritExecutor
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @_backDeploy(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
  @discardableResult
  @inlinable @_unsafeInheritExecutor final internal func withValueImpl<R>(_ valueDuringOperation: __owned Value, operation: () async throws -> R, file: Swift.String = #fileID, line: Swift.UInt = #line) async rethrows -> R {
    // check if we're not trying to bind a value from an illegal context; this may crash
    _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: file, line: line)

    _taskLocalValuePush(key: key, value: valueDuringOperation)
    do {
      let result = try await operation()
      _taskLocalValuePop()
      return result
    } catch {
      _taskLocalValuePop()
      throw error
    }
  }
  #else
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @_backDeploy(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
  @discardableResult
  @inlinable final internal func withValueImpl<R>(_ valueDuringOperation: __owned Value, operation: () async throws -> R, file: Swift.String = #fileID, line: Swift.UInt = #line) async rethrows -> R {
    // check if we're not trying to bind a value from an illegal context; this may crash
    _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: file, line: line)

    _taskLocalValuePush(key: key, value: valueDuringOperation)
    do {
      let result = try await operation()
      _taskLocalValuePop()
      return result
    } catch {
      _taskLocalValuePop()
      throw error
    }
  }
  #endif
  #endif
  @discardableResult
  @inlinable final public func withValue<R>(_ valueDuringOperation: Value, operation: () throws -> R, file: Swift.String = #fileID, line: Swift.UInt = #line) rethrows -> R {
    // check if we're not trying to bind a value from an illegal context; this may crash
    _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: file, line: line)

    _taskLocalValuePush(key: key, value: valueDuringOperation)
    defer { _taskLocalValuePop() }

    return try operation()
  }
  final public var projectedValue: _Concurrency.TaskLocal<Value> {
    get
    @available(*, unavailable, message: "use '$myTaskLocal.withValue(_:do:)' instead")
    set
  }
  @available(*, unavailable, message: "property wrappers cannot be instance members")
  public static subscript(_enclosingInstance object: Swift.Never, wrapped wrappedKeyPath: Swift.ReferenceWritableKeyPath<Swift.Never, Value>, storage storageKeyPath: Swift.ReferenceWritableKeyPath<Swift.Never, _Concurrency.TaskLocal<Value>>) -> Value {
    get
  }
  final public var wrappedValue: Value {
    get
  }
  final public var description: Swift.String {
    get
  }
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_localValuePush")
internal func _taskLocalValuePush<Value>(key: Builtin.RawPointer, value: __owned Value)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_localValuePop")
internal func _taskLocalValuePop()
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
internal func _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: Swift.String, line: Swift.UInt)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_reportIllegalTaskLocalBindingWithinWithTaskGroup")
internal func _reportIllegalTaskLocalBindingWithinWithTaskGroup(_ _filenameStart: Swift.UnsafePointer<Swift.Int8>, _ _filenameLength: Swift.Int, _ _filenameIsASCII: Swift.Bool, _ _line: Swift.UInt)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, renamed: "Task.sleep(nanoseconds:)")
  public static func sleep(_ duration: Swift.UInt64) async
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public static func sleep(nanoseconds duration: Swift.UInt64) async throws
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncStream<Element> {
  public struct Continuation : Swift.Sendable {
    public enum Termination {
      case finished
      case cancelled
      public static func == (a: _Concurrency.AsyncStream<Element>.Continuation.Termination, b: _Concurrency.AsyncStream<Element>.Continuation.Termination) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum YieldResult {
      case enqueued(remaining: Swift.Int)
      case dropped(Element)
      case terminated
    }
    public enum BufferingPolicy {
      case unbounded
      case bufferingOldest(Swift.Int)
      case bufferingNewest(Swift.Int)
    }
    @discardableResult
    public func yield(_ value: __owned Element) -> _Concurrency.AsyncStream<Element>.Continuation.YieldResult
    public func finish()
    #if compiler(>=5.3) && $Sendable
    public var onTermination: (@Sendable (_Concurrency.AsyncStream<Element>.Continuation.Termination) -> Swift.Void)? {
      get
      nonmutating set
    }
    #endif
  }
  public init(_ elementType: Element.Type = Element.self, bufferingPolicy limit: _Concurrency.AsyncStream<Element>.Continuation.BufferingPolicy = .unbounded, _ build: (_Concurrency.AsyncStream<Element>.Continuation) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public init(unfolding produce: @escaping () async -> Element?, onCancel: (@Sendable () -> Swift.Void)? = nil)
  #endif
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream : _Concurrency.AsyncSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async -> Element?
    #endif
  }
  public func makeAsyncIterator() -> _Concurrency.AsyncStream<Element>.Iterator
  public typealias AsyncIterator = _Concurrency.AsyncStream<Element>.Iterator
}
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream.Continuation {
  @discardableResult
  public func yield(with result: Swift.Result<Element, Swift.Never>) -> _Concurrency.AsyncStream<Element>.Continuation.YieldResult
  @discardableResult
  public func yield() -> _Concurrency.AsyncStream<Element>.Continuation.YieldResult where Element == ()
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @_backDeploy(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
  public static func makeStream(of elementType: Element.Type = Element.self, bufferingPolicy limit: _Concurrency.AsyncStream<Element>.Continuation.BufferingPolicy = .unbounded) -> (stream: _Concurrency.AsyncStream<Element>, continuation: _Concurrency.AsyncStream<Element>.Continuation) {
    var continuation: AsyncStream<Element>.Continuation!
    let stream = AsyncStream<Element>(bufferingPolicy: limit) { continuation = $0 }
    return (stream: stream, continuation: continuation!)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream : @unchecked Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingStream<Element, Failure> where Failure : Swift.Error {
  public struct Continuation : Swift.Sendable {
    public enum Termination {
      case finished(Failure?)
      case cancelled
    }
    public enum YieldResult {
      case enqueued(remaining: Swift.Int)
      case dropped(Element)
      case terminated
    }
    public enum BufferingPolicy {
      case unbounded
      case bufferingOldest(Swift.Int)
      case bufferingNewest(Swift.Int)
    }
    @discardableResult
    public func yield(_ value: __owned Element) -> _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.YieldResult
    public func finish(throwing error: __owned Failure? = nil)
    #if compiler(>=5.3) && $Sendable
    public var onTermination: (@Sendable (_Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.Termination) -> Swift.Void)? {
      get
      nonmutating set
    }
    #endif
  }
  public init(_ elementType: Element.Type = Element.self, bufferingPolicy limit: _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.BufferingPolicy = .unbounded, _ build: (_Concurrency.AsyncThrowingStream<Element, Failure>.Continuation) -> Swift.Void) where Failure == any Swift.Error
  #if compiler(>=5.3) && $AsyncAwait
  public init(unfolding produce: @escaping () async throws -> Element?) where Failure == any Swift.Error
  #endif
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingStream : _Concurrency.AsyncSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async throws -> Element?
    #endif
  }
  public func makeAsyncIterator() -> _Concurrency.AsyncThrowingStream<Element, Failure>.Iterator
  public typealias AsyncIterator = _Concurrency.AsyncThrowingStream<Element, Failure>.Iterator
}
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingStream.Continuation {
  @discardableResult
  public func yield(with result: Swift.Result<Element, Failure>) -> _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.YieldResult where Failure == any Swift.Error
  @discardableResult
  public func yield() -> _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.YieldResult where Element == ()
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingStream {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @_backDeploy(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
  public static func makeStream(of elementType: Element.Type = Element.self, throwing failureType: Failure.Type = Failure.self, bufferingPolicy limit: _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.BufferingPolicy = .unbounded) -> (stream: _Concurrency.AsyncThrowingStream<Element, Failure>, continuation: _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation) where Failure == any Swift.Error {
    var continuation: AsyncThrowingStream<Element, Failure>.Continuation!
    let stream = AsyncThrowingStream<Element, Failure>(bufferingPolicy: limit) { continuation = $0 }
    return (stream: stream, continuation: continuation!)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingStream : @unchecked Swift.Sendable where Element : Swift.Sendable {
}
@_alwaysEmitIntoClient @_transparent internal func _internalInvariant(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #fileID, line: Swift.UInt = #line) {
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol Clock<Duration> : Swift.Sendable {
  associatedtype Duration where Self.Duration == Self.Instant.Duration
  associatedtype Instant : Swift.InstantProtocol
  var now: Self.Instant { get }
  var minimumResolution: Self.Duration { get }
  #if compiler(>=5.3) && $AsyncAwait
  func sleep(until deadline: Self.Instant, tolerance: Self.Instant.Duration?) async throws
  #endif
}
#else
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol Clock : Swift.Sendable {
  associatedtype Duration where Self.Duration == Self.Instant.Duration
  associatedtype Instant : Swift.InstantProtocol
  var now: Self.Instant { get }
  var minimumResolution: Self.Duration { get }
  #if compiler(>=5.3) && $AsyncAwait
  func sleep(until deadline: Self.Instant, tolerance: Self.Instant.Duration?) async throws
  #endif
}
#endif
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.Clock {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func measure(_ work: () throws -> Swift.Void) rethrows -> Self.Instant.Duration
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func measure(_ work: () async throws -> Swift.Void) async rethrows -> Self.Instant.Duration
  #endif
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.Clock {
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public func sleep(for duration: Self.Instant.Duration, tolerance: Self.Instant.Duration? = nil) async throws {
    try await sleep(until: now.advanced(by: duration), tolerance: tolerance)
  }
  #endif
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct ContinuousClock {
  public struct Instant : Swift.Codable, Swift.Sendable {
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public init()
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.Clock where Self == _Concurrency.ContinuousClock {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static var continuous: _Concurrency.ContinuousClock {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.ContinuousClock : _Concurrency.Clock {
  public var now: _Concurrency.ContinuousClock.Instant {
    get
  }
  public var minimumResolution: Swift.Duration {
    get
  }
  public static var now: _Concurrency.ContinuousClock.Instant {
    get
  }
  #if compiler(>=5.3) && $AsyncAwait
  public func sleep(until deadline: _Concurrency.ContinuousClock.Instant, tolerance: Swift.Duration? = nil) async throws
  #endif
  public typealias Duration = Swift.Duration
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.ContinuousClock.Instant : Swift.InstantProtocol {
  public static var now: _Concurrency.ContinuousClock.Instant {
    get
  }
  public func advanced(by duration: Swift.Duration) -> _Concurrency.ContinuousClock.Instant
  public func duration(to other: _Concurrency.ContinuousClock.Instant) -> Swift.Duration
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: _Concurrency.ContinuousClock.Instant, rhs: _Concurrency.ContinuousClock.Instant) -> Swift.Bool
  public static func < (lhs: _Concurrency.ContinuousClock.Instant, rhs: _Concurrency.ContinuousClock.Instant) -> Swift.Bool
  @_alwaysEmitIntoClient @inlinable public static func + (lhs: _Concurrency.ContinuousClock.Instant, rhs: Swift.Duration) -> _Concurrency.ContinuousClock.Instant {
    lhs.advanced(by: rhs)
  }
  @_alwaysEmitIntoClient @inlinable public static func += (lhs: inout _Concurrency.ContinuousClock.Instant, rhs: Swift.Duration) {
    lhs = lhs.advanced(by: rhs)
  }
  @_alwaysEmitIntoClient @inlinable public static func - (lhs: _Concurrency.ContinuousClock.Instant, rhs: Swift.Duration) -> _Concurrency.ContinuousClock.Instant {
    lhs.advanced(by: .zero - rhs)
  }
  @_alwaysEmitIntoClient @inlinable public static func -= (lhs: inout _Concurrency.ContinuousClock.Instant, rhs: Swift.Duration) {
    lhs = lhs.advanced(by: .zero - rhs)
  }
  @_alwaysEmitIntoClient @inlinable public static func - (lhs: _Concurrency.ContinuousClock.Instant, rhs: _Concurrency.ContinuousClock.Instant) -> Swift.Duration {
    rhs.duration(to: lhs)
  }
  public typealias Duration = Swift.Duration
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct SuspendingClock {
  public struct Instant : Swift.Codable, Swift.Sendable {
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public init()
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.Clock where Self == _Concurrency.SuspendingClock {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static var suspending: _Concurrency.SuspendingClock {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.SuspendingClock : _Concurrency.Clock {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public var now: _Concurrency.SuspendingClock.Instant {
    get
  }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static var now: _Concurrency.SuspendingClock.Instant {
    get
  }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public var minimumResolution: Swift.Duration {
    get
  }
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func sleep(until deadline: _Concurrency.SuspendingClock.Instant, tolerance: Swift.Duration? = nil) async throws
  #endif
  public typealias Duration = Swift.Duration
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.SuspendingClock.Instant : Swift.InstantProtocol {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static var now: _Concurrency.SuspendingClock.Instant {
    get
  }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func advanced(by duration: Swift.Duration) -> _Concurrency.SuspendingClock.Instant
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func duration(to other: _Concurrency.SuspendingClock.Instant) -> Swift.Duration
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func == (lhs: _Concurrency.SuspendingClock.Instant, rhs: _Concurrency.SuspendingClock.Instant) -> Swift.Bool
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func < (lhs: _Concurrency.SuspendingClock.Instant, rhs: _Concurrency.SuspendingClock.Instant) -> Swift.Bool
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func + (lhs: _Concurrency.SuspendingClock.Instant, rhs: Swift.Duration) -> _Concurrency.SuspendingClock.Instant
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func += (lhs: inout _Concurrency.SuspendingClock.Instant, rhs: Swift.Duration)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func - (lhs: _Concurrency.SuspendingClock.Instant, rhs: Swift.Duration) -> _Concurrency.SuspendingClock.Instant
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func -= (lhs: inout _Concurrency.SuspendingClock.Instant, rhs: Swift.Duration)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func - (lhs: _Concurrency.SuspendingClock.Instant, rhs: _Concurrency.SuspendingClock.Instant) -> Swift.Duration
  public typealias Duration = Swift.Duration
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func sleep<C>(until deadline: C.Instant, tolerance: C.Instant.Duration? = nil, clock: C = ContinuousClock()) async throws where C : _Concurrency.Clock
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func sleep<C>(for duration: C.Instant.Duration, tolerance: C.Instant.Duration? = nil, clock: C = ContinuousClock()) async throws where C : _Concurrency.Clock {
    try await clock.sleep(for: duration, tolerance: tolerance)
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream.Continuation.Termination : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream.Continuation.Termination : Swift.Hashable {}
