// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.123.203 clang-1500.0.37.1)
// swift-module-flags: -target arm64-apple-ios17.0 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftAccelerate -swift-version 5 -enforce-exclusivity=checked -O -library-level api -module-name Accelerate
// swift-module-flags-ignorable: -enable-bare-slash-regex -user-module-version 45
@_exported import Accelerate
@_exported import Accelerate.vecLib.BNNS
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import simd
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx2 {
  public init(planarBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>])
  @inlinable public func planarBuffers() -> [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>] {
        
        let componentCount = 2
        
        let buffers: [vImage.PixelBuffer<vImage.PlanarF>] = (0 ..< componentCount).map { _ in
            vImage.PixelBuffer(size: size,
                               pixelFormat: vImage.PlanarF.self)
            
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: buffers[0].vImageBuffer) { zeroPtr in
                withUnsafePointer(to: buffers[1].vImageBuffer) { onePtr in
                    
                    var srcChannels = [UnsafeRawPointer(self.vImageBuffer.data),
                                       UnsafeRawPointer(self.vImageBuffer.data.advanced(by: 4))]
                    
                    var destPlanarBuffers = [Optional(zeroPtr), Optional(onePtr)]
                    
                    vImageConvert_ChunkyToPlanarF(&srcChannels,
                                                  &destPlanarBuffers,
                                                  2,
                                                  8,
                                                  vImagePixelCount(width),
                                                  vImagePixelCount(height),
                                                  self.vImageBuffer.rowBytes,
                                                  vImage_Flags(kvImageNoFlags))
                    
                }
            }
        }
        
        return buffers
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved16Fx2>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 2,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        let fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 2,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        
        withUnsafePointer(to: fauxSource) { srcPtr in
            withUnsafePointer(to: fauxDestination) { destPtr in
                
                _ = vImageConvert_PlanarFtoPlanar16F(srcPtr,
                                                     destPtr,
                                                     vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public enum vImage {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public enum vDSP {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public enum vForce {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct VectorizableFloat {
    public typealias Scalar = Swift.Float
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct VectorizableDouble {
    public typealias Scalar = Swift.Double
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarFx3 {
  public init(interleavedBuffer: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx3>)
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx3>) {
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: destination.vImageBuffer) { destPtr in
            withUnsafePointer(to: vImageBuffers[0]) { zeroPtr in
                withUnsafePointer(to: vImageBuffers[1]) { onePtr in
                    withUnsafePointer(to: vImageBuffers[2]) { twoPtr in
                        _ = vImageConvert_PlanarFtoRGBFFF(zeroPtr,
                                                          onePtr,
                                                          twoPtr,
                                                          destPtr,
                                                          vImage_Flags(kvImageNoFlags))
                    }
                }
            }
        }
    }
  @inlinable public func interleave(destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx3>) {
            
            self.withUnsafePixelBuffers { planarSourceBuffers in
                
                destination.interleave(planarSourceBuffers: planarSourceBuffers)
            }
        }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func applyPolynomial(coefficientSegments: [[Swift.Float]], boundaries: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>) {
        
        self._applyPolynomial(coefficientSegments: coefficientSegments,
                              boundaries: boundaries,
                              destination: destination,
                              polynomialFunc: vImagePiecewisePolynomial_Planar8toPlanarF,
                              widthMultiplier: Format.channelCount)
        
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x2 {
  @inlinable public func applyPolynomial(coefficientSegments: [[Swift.Float]], boundaries: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx2>) {
        
        self._applyPolynomial(coefficientSegments: coefficientSegments,
                              boundaries: boundaries,
                              destination: destination,
                              polynomialFunc: vImagePiecewisePolynomial_Planar8toPlanarF,
                              widthMultiplier: Format.channelCount)
        
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x3 {
  @inlinable public func applyPolynomial(coefficientSegments: [[Swift.Float]], boundaries: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx3>) {
        
        self._applyPolynomial(coefficientSegments: coefficientSegments,
                              boundaries: boundaries,
                              destination: destination,
                              polynomialFunc: vImagePiecewisePolynomial_Planar8toPlanarF,
                              widthMultiplier: Format.channelCount)
        
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func applyPolynomial(coefficientSegments: [[Swift.Float]], boundaries: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx4>) {
        
        self._applyPolynomial(coefficientSegments: coefficientSegments,
                              boundaries: boundaries,
                              destination: destination,
                              polynomialFunc: vImagePiecewisePolynomial_Planar8toPlanarF,
                              widthMultiplier: Format.channelCount)
        
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func applyPolynomial(coefficientSegments: [[Swift.Float]], boundaries: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        self._applyPolynomial(coefficientSegments: coefficientSegments,
                              boundaries: boundaries,
                              destination: destination,
                              polynomialFunc: vImagePiecewisePolynomial_PlanarF,
                              widthMultiplier: Format.channelCount)
        
    }
  @inlinable public func applyPolynomial(coefficientSegments: [[Swift.Float]], boundaries: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>) {
        
        self._applyPolynomial(coefficientSegments: coefficientSegments,
                              boundaries: boundaries,
                              destination: destination,
                              polynomialFunc: vImagePiecewisePolynomial_PlanarFtoPlanar8,
                              widthMultiplier: Format.channelCount)
        
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx2 {
  @inlinable public func applyPolynomial(coefficientSegments: [[Swift.Float]], boundaries: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        self._applyPolynomial(coefficientSegments: coefficientSegments,
                              boundaries: boundaries,
                              destination: destination,
                              polynomialFunc: vImagePiecewisePolynomial_PlanarF,
                              widthMultiplier: Format.channelCount)
        
    }
  @inlinable public func applyPolynomial(coefficientSegments: [[Swift.Float]], boundaries: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x2>) {
        
        self._applyPolynomial(coefficientSegments: coefficientSegments,
                              boundaries: boundaries,
                              destination: destination,
                              polynomialFunc: vImagePiecewisePolynomial_PlanarFtoPlanar8,
                              widthMultiplier: Format.channelCount)
        
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx3 {
  @inlinable public func applyPolynomial(coefficientSegments: [[Swift.Float]], boundaries: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        self._applyPolynomial(coefficientSegments: coefficientSegments,
                              boundaries: boundaries,
                              destination: destination,
                              polynomialFunc: vImagePiecewisePolynomial_PlanarF,
                              widthMultiplier: Format.channelCount)
        
    }
  @inlinable public func applyPolynomial(coefficientSegments: [[Swift.Float]], boundaries: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x3>) {
        
        self._applyPolynomial(coefficientSegments: coefficientSegments,
                              boundaries: boundaries,
                              destination: destination,
                              polynomialFunc: vImagePiecewisePolynomial_PlanarFtoPlanar8,
                              widthMultiplier: Format.channelCount)
        
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func applyPolynomial(coefficientSegments: [[Swift.Float]], boundaries: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        self._applyPolynomial(coefficientSegments: coefficientSegments,
                              boundaries: boundaries,
                              destination: destination,
                              polynomialFunc: vImagePiecewisePolynomial_PlanarF,
                              widthMultiplier: Format.channelCount)
        
    }
  @inlinable public func applyPolynomial(coefficientSegments: [[Swift.Float]], boundaries: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x4>) {
        
        self._applyPolynomial(coefficientSegments: coefficientSegments,
                              boundaries: boundaries,
                              destination: destination,
                              polynomialFunc: vImagePiecewisePolynomial_PlanarFtoPlanar8,
                              widthMultiplier: Format.channelCount)
        
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  @usableFromInline
  internal typealias PiecewisePolynomialFunc = (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutablePointer<Swift.UnsafePointer<Swift.Float>?>, Swift.UnsafePointer<Swift.Float>, Swift.UInt32, Swift.UInt32, Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal func _applyPolynomial<T>(coefficientSegments: [[Swift.Float]], boundaries: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<T>, polynomialFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutablePointer<Swift.UnsafePointer<Swift.Float>?>, Swift.UnsafePointer<Swift.Float>, Swift.UInt32, Swift.UInt32, Accelerate.vImage_Flags) -> Accelerate.vImage_Error, widthMultiplier: Swift.Int) where T : Accelerate.SinglePlanePixelFormat
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func convolve<T, U>(_ vector: T, withKernel kernel: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let n = vector.count - kernel.count
            
            let result = Array<Float>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                convolve(vector,
                         withKernel: kernel,
                         result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, withKernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count >= n + kernel.count - 1,
                         "Source vector count must be at least the sum of the result and kernel counts, minus one.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_conv(src.baseAddress!, 1,
                                  k.baseAddress!.advanced(by: kernel.count - 1), -1,
                                  dest.baseAddress!, 1,
                                  vDSP_Length(n),
                                  vDSP_Length(kernel.count))
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, withKernel kernel: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let n = vector.count - kernel.count
            
            let result = Array<Double>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                convolve(vector,
                         withKernel: kernel,
                         result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, withKernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count >= n + kernel.count - 1,
                         "Source vector count must be at least the sum of the result and kernel counts, minus one.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_convD(src.baseAddress!, 1,
                                   k.baseAddress!.advanced(by: kernel.count - 1), -1,
                                   dest.baseAddress!, 1,
                                   vDSP_Length(n),
                                   vDSP_Length(kernel.count))
                    }
                }
            }
    }
  @inlinable public static func correlate<T, U>(_ vector: T, withKernel kernel: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let n = vector.count - kernel.count
            
            let result = Array<Float>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                correlate(vector,
                          withKernel: kernel,
                          result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func correlate<T, U, V>(_ vector: T, withKernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count >= n + kernel.count - 1,
                         "Source vector count must be at least the sum of the result and kernel counts, minus one.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_conv(src.baseAddress!, 1,
                                  k.baseAddress!, 1,
                                  dest.baseAddress!, 1,
                                  vDSP_Length(n),
                                  vDSP_Length(kernel.count))
                    }
                }
            }
    }
  @inlinable public static func correlate<T, U>(_ vector: T, withKernel kernel: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let n = vector.count - kernel.count
            
            let result = Array<Double>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                correlate(vector,
                          withKernel: kernel,
                          result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func correlate<T, U, V>(_ vector: T, withKernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count >= n + kernel.count - 1,
                         "Source vector count must be at least the sum of the result and kernel counts, minus one.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_convD(src.baseAddress!, 1,
                                   k.baseAddress!, 1,
                                   dest.baseAddress!, 1,
                                   vDSP_Length(n),
                                   vDSP_Length(kernel.count))
                    }
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with3x3Kernel kernel: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         with3x3Kernel: kernel,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with3x3Kernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernel.count == 9,
                         "Kernel must contain 9 elements.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_f3x3(src.baseAddress!,
                                  vDSP_Length(rowCount), vDSP_Length(columnCount),
                                  k.baseAddress!,
                                  dest.baseAddress!)
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with3x3Kernel kernel: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         with3x3Kernel: kernel,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with3x3Kernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernel.count == 9,
                         "Kernel must contain 9 elements.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_f3x3D(src.baseAddress!,
                                   vDSP_Length(rowCount), vDSP_Length(columnCount),
                                   k.baseAddress!,
                                   dest.baseAddress!)
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with5x5Kernel kernel: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         with5x5Kernel: kernel,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with5x5Kernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernel.count == 25,
                         "Kernel must contain 25 elements.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_f5x5(src.baseAddress!,
                                  vDSP_Length(rowCount), vDSP_Length(columnCount),
                                  k.baseAddress!,
                                  dest.baseAddress!)
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with5x5Kernel kernel: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         with5x5Kernel: kernel,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with5x5Kernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernel.count == 25,
                         "Kernel must contain 25 elements.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_f5x5D(src.baseAddress!,
                                   vDSP_Length(rowCount), vDSP_Length(columnCount),
                                   k.baseAddress!,
                                   dest.baseAddress!)
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, withKernel kernel: U, kernelRowCount: Swift.Int, kernelColumnCount: Swift.Int) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         withKernel: kernel,
                         kernelRowCount: kernelRowCount, kernelColumnCount: kernelColumnCount,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, withKernel kernel: U, kernelRowCount: Swift.Int, kernelColumnCount: Swift.Int, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernelRowCount % 2 == 1,
                         "Kernel row count must be odd.")
            
            precondition(kernelColumnCount % 2 == 1,
                         "Kernel column count must be odd.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_imgfir(src.baseAddress!,
                                    vDSP_Length(rowCount), vDSP_Length(columnCount),
                                    k.baseAddress!,
                                    dest.baseAddress!,
                                    vDSP_Length(kernelRowCount), vDSP_Length(kernelColumnCount))
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, withKernel kernel: U, kernelRowCount: Swift.Int, kernelColumnCount: Swift.Int) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         withKernel: kernel,
                         kernelRowCount: kernelRowCount, kernelColumnCount: kernelColumnCount,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, withKernel kernel: U, kernelRowCount: Swift.Int, kernelColumnCount: Swift.Int, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernelRowCount % 2 == 1,
                         "Kernel row count must be odd.")
            
            precondition(kernelColumnCount % 2 == 1,
                         "Kernel column count must be odd.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_imgfirD(src.baseAddress!,
                                     vDSP_Length(rowCount), vDSP_Length(columnCount),
                                     k.baseAddress!,
                                     dest.baseAddress!,
                                     vDSP_Length(kernelRowCount), vDSP_Length(kernelColumnCount))
                    }
                }
            }
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  @frozen public struct Norm : Swift.Equatable {
    @_alwaysEmitIntoClient public var rawValue: Swift.Float
    @_alwaysEmitIntoClient public init(rawValue: Swift.Float) { self.rawValue = rawValue }
    @_alwaysEmitIntoClient public static var l1: Accelerate.BNNS.Norm {
      get { Norm(rawValue: 1) }
    }
    @_alwaysEmitIntoClient public static var taxicab: Accelerate.BNNS.Norm {
      get { Norm(rawValue: 1) }
    }
    @_alwaysEmitIntoClient public static var l2: Accelerate.BNNS.Norm {
      get { Norm(rawValue: 2) }
    }
    @_alwaysEmitIntoClient public static var euclidean: Accelerate.BNNS.Norm {
      get { Norm(rawValue: 2) }
    }
    @_alwaysEmitIntoClient public static var lInfinity: Accelerate.BNNS.Norm {
      get { Norm(rawValue: .infinity) }
    }
    @_alwaysEmitIntoClient public static var maximum: Accelerate.BNNS.Norm {
      get { Norm(rawValue: .infinity) }
    }
    public static func == (a: Accelerate.BNNS.Norm, b: Accelerate.BNNS.Norm) -> Swift.Bool
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class EmbeddingLayer : Accelerate.BNNS.Layer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, dictionary: Accelerate.BNNSNDArrayDescriptor, paddingIndex: Swift.Int, maximumNorm: Swift.Float, normType: Accelerate.BNNS.Norm, scalesGradientByFrequency: Swift.Bool, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingWeightsGradient weightsGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public static func transpose(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, firstTransposeAxis: Swift.Int, secondTransposeAxis: Swift.Int, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func downsample<T, U>(_ source: U, decimationFactor: Swift.Int, filter: T) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let n = (source.count - filter.count) / decimationFactor + 1
            
            let result = Array<Float>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                downsample(source,
                           decimationFactor: decimationFactor,
                           filter: filter,
                           result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func downsample<T, U, V>(_ source: U, decimationFactor: Swift.Int, filter: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let p = filter.count
            let n = result.count
            
            precondition(source.count >= decimationFactor * (n - 1) + p,
            "The number of elements in the input must be at least `decimationFactor * (result.count - 1) + filter.count`.")
            
            result.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    filter.withUnsafeBufferPointer { f in
                        
                        vDSP_desamp(src.baseAddress!,
                                    vDSP_Stride(decimationFactor),
                                    f.baseAddress!,
                                    dest.baseAddress!,
                                    vDSP_Length(n),
                                    vDSP_Length(p))
                    }
                }
            }
    }
  @inlinable public static func downsample<T, U>(_ source: U, decimationFactor: Swift.Int, filter: T) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            let n = (source.count - filter.count) / decimationFactor + 1
            
            let result = Array<Double>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                downsample(source,
                           decimationFactor: decimationFactor,
                           filter: filter,
                           result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func downsample<T, U, V>(_ source: U, decimationFactor: Swift.Int, filter: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let p = filter.count
            let n = result.count
            
            precondition(source.count >= decimationFactor * (n - 1) + p,
            "The number of elements in the input must be at least `decimationFactor * (result.count - 1) + filter.count`.")
            
            result.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    filter.withUnsafeBufferPointer { f in
                        
                        vDSP_desampD(src.baseAddress!,
                                     vDSP_Stride(decimationFactor),
                                     f.baseAddress!,
                                     dest.baseAddress!,
                                     vDSP_Length(n),
                                     vDSP_Length(p))
                    }
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage {
  public struct Options : Swift.OptionSet {
    public init(rawValue: Accelerate.vImage_Flags)
    public let rawValue: Accelerate.vImage_Flags
    public static let noFlags: Accelerate.vImage.Options
    public static let leaveAlphaUnchanged: Accelerate.vImage.Options
    public static let copyInPlace: Accelerate.vImage.Options
    public static let backgroundColorFill: Accelerate.vImage.Options
    public static let imageExtend: Accelerate.vImage.Options
    public static let doNotTile: Accelerate.vImage.Options
    public static let highQualityResampling: Accelerate.vImage.Options
    public static let truncateKernel: Accelerate.vImage.Options
    public static let getTempBufferSize: Accelerate.vImage.Options
    public static let printDiagnosticsToConsole: Accelerate.vImage.Options
    public static let noAllocate: Accelerate.vImage.Options
    public static let hdrContent: Accelerate.vImage.Options
    public static let doNotClamp: Accelerate.vImage.Options
    public var flags: Accelerate.vImage_Flags {
      get
    }
    public typealias ArrayLiteralElement = Accelerate.vImage.Options
    public typealias Element = Accelerate.vImage.Options
    public typealias RawValue = Accelerate.vImage_Flags
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.UInt8 {
  @inlinable public func multiply<Matrix, DestFormat>(by matrix: Matrix, divisor: Swift.Int, preBias: [Swift.Int], postBias: [Swift.Int], destination: Accelerate.vImage.PixelBuffer<DestFormat>) where Matrix : Accelerate.AccelerateBuffer, DestFormat : Accelerate.MultiplePlanePixelFormat, Matrix.Element == Swift.Int, DestFormat.ComponentType == Swift.UInt8 {
              
              precondition(self.size == destination.size,
                           "Source and destination buffer must be the same size.")
              
              matrix.withUnsafeBufferPointer { matrixPtr in
                  
                  let matrixArray = Array(matrixPtr)
                  
                  precondition(matrix.count == Format.planeCount * DestFormat.planeCount,
                               "`matrix` must must contain `Format.planeCount * DestFormat.planeCount` elements.")
                  precondition(preBias.count == Format.planeCount,
                               "`preBias` must contain `Format.planeCount` elements.")
                  precondition(postBias.count == DestFormat.planeCount,
                               "`preBias` must contain `Format.planeCount` elements.")
                  precondition(abs(matrixArray.max() ?? 0) <= Int16.max,
                               "`matrix.max()` must be less than or equal to `Int16.max`.")
                  precondition(abs(divisor) <= Int32.max,
                               "`divisor` must be less than or equal to `Int32.max`.")
                  precondition(abs(preBias.max() ?? 0) <= Int16.max,
                               "`preBias.max()` must be less than or equal to `Int16.max`.")
                  precondition(abs(postBias.max() ?? 0) <= Int32.max,
                               "`postBias.max` must be less than or equal to `Int32.max`.")
                  
                  var sources: [UnsafePointer<vImage_Buffer>?] = self.vImageBuffers.map { buffer in
                      let ptr = UnsafeMutableBufferPointer<vImage_Buffer>.allocate(capacity: 1)
                      _ = ptr.initialize(from: [buffer])
                      return UnsafeBufferPointer(ptr).baseAddress!
                  }
                  
                  var destinations: [UnsafePointer<vImage_Buffer>?] = destination.vImageBuffers.map { buffer in
                      let ptr = UnsafeMutableBufferPointer<vImage_Buffer>.allocate(capacity: 1)
                      _ = ptr.initialize(from: [buffer])
                      return UnsafeBufferPointer(ptr).baseAddress!
                  }
                  
                  defer {
                      sources.forEach {
                          $0?.deallocate()
                      }
                      destinations.forEach {
                          $0?.deallocate()
                      }
                  }
                  
                  _ = vImageMatrixMultiply_Planar8(&sources,
                                                   &destinations,
                                                   UInt32(Format.planeCount),
                                                   UInt32(DestFormat.planeCount),
                                                   matrixArray.map{ Int16($0) },
                                                   Int32(divisor),
                                                   preBias.map{ Int16($0) },
                                                   postBias.map{ Int32($0) },
                                                   vImage_Flags(kvImageNoFlags))
                  
              }
          }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.Float {
  @inlinable public func multiply<Matrix, DestFormat>(by matrix: Matrix, preBias: [Swift.Float], postBias: [Swift.Float], destination: Accelerate.vImage.PixelBuffer<DestFormat>) where Matrix : Accelerate.AccelerateBuffer, DestFormat : Accelerate.MultiplePlanePixelFormat, Matrix.Element == Swift.Float, DestFormat.ComponentType == Swift.Float {
              
              precondition(self.size == destination.size,
                           "Source and destination buffer must be the same size.")
              
              matrix.withUnsafeBufferPointer { matrixPtr in
                  
                  let matrixArray = Array(matrixPtr)
                  
                  precondition(matrix.count == Format.planeCount * DestFormat.planeCount,
                               "`matrix` must must contain `Format.planeCount * DestFormat.planeCount` elements.")
                  precondition(preBias.count == Format.planeCount,
                               "`preBias` must contain `Format.planeCount` elements.")
                  precondition(postBias.count == DestFormat.planeCount,
                               "`preBias` must contain `Format.planeCount` elements.")
                  
                  var sources: [UnsafePointer<vImage_Buffer>?] = self.vImageBuffers.map { buffer in
                      let ptr = UnsafeMutableBufferPointer<vImage_Buffer>.allocate(capacity: 1)
                      _ = ptr.initialize(from: [buffer])
                      return UnsafeBufferPointer(ptr).baseAddress!
                  }
                  
                  var destinations: [UnsafePointer<vImage_Buffer>?] = destination.vImageBuffers.map { buffer in
                      let ptr = UnsafeMutableBufferPointer<vImage_Buffer>.allocate(capacity: 1)
                      _ = ptr.initialize(from: [buffer])
                      return UnsafeBufferPointer(ptr).baseAddress!
                  }
                  
                  defer {
                      sources.forEach {
                          $0?.deallocate()
                      }
                      destinations.forEach {
                          $0?.deallocate()
                      }
                  }
                  
                  _ = vImageMatrixMultiply_PlanarF(&sources,
                                                   &destinations,
                                                   UInt32(Format.planeCount),
                                                   UInt32(DestFormat.planeCount),
                                                   matrixArray,
                                                   preBias,
                                                   postBias,
                                                   vImage_Flags(kvImageNoFlags))
                  
              }
          }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func multiply(by factor: Swift.Int, divisor: Swift.Int, preBias: Swift.Int, postBias: Swift.Int, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        precondition(abs(factor) <= Int16.max,
                     "`factor` must be less than or equal to `Int16.max`.")
        precondition(abs(divisor) <= Int32.max,
                     "`divisor` must be less than or equal to `Int32.max`.")
        precondition(abs(preBias) <= Int16.max,
                     "`preBias.max()` must be less than or equal to `Int16.max`.")
        precondition(abs(postBias) <= Int32.max,
                     "`divisor` must be less than or equal to `Int32.max`.")
        
        var mutablePreBias = Int16(preBias)
        var mutablePostBias = Int32(postBias)
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                var src: UnsafePointer<vImage_Buffer>? = srcPtr
                var dest: UnsafePointer<vImage_Buffer>? = destPtr
                
                let matrix = [Int16(factor)]
                
                _ = vImageMatrixMultiply_Planar8(&src,
                                                 &dest,
                                                 1, 1,
                                                 matrix,
                                                 Int32(divisor),
                                                 &mutablePreBias,
                                                 &mutablePostBias,
                                                 vImage_Flags(kvImageNoFlags))
                
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func multiply(by matrix: (Swift.Int, Swift.Int, Swift.Int, Swift.Int), divisor: Swift.Int, preBias: (Swift.Int, Swift.Int, Swift.Int, Swift.Int), postBias: Swift.Int, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let matrixArray = [matrix.0, matrix.1, matrix.2, matrix.3]
        let preBiasArray = [preBias.0, preBias.1, preBias.2, preBias.3]
        
        precondition(abs(matrixArray.max() ?? 0) <= Int16.max,
                     "`matrix.max()` must be less than or equal to `Int16.max`.")
        precondition(abs(divisor) <= Int32.max,
                     "`divisor` must be less than or equal to `Int32.max`.")
        precondition(abs(preBiasArray.max() ?? 0) <= Int16.max,
                     "`preBias.max()` must be less than or equal to `Int16.max`.")
        precondition(abs(postBias) <= Int32.max,
                     "`postBias` must be less than or equal to `Int32.max`.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageMatrixMultiply_ARGB8888ToPlanar8(srcPtr,
                                                           destPtr,
                                                           matrixArray.map{ Int16($0) },
                                                           Int32(divisor),
                                                           preBiasArray.map{ Int16($0) },
                                                           Int32(postBias),
                                                           vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func multiply<Matrix>(by matrix: Matrix, divisor: Swift.Int, preBias: (Swift.Int, Swift.Int, Swift.Int, Swift.Int), postBias: (Swift.Int, Swift.Int, Swift.Int, Swift.Int), destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x4>) where Matrix : Accelerate.AccelerateBuffer, Matrix.Element == Swift.Int {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let preBiasArray = [preBias.0, preBias.1, preBias.2, preBias.3]
        let postBiasArray = [postBias.0, postBias.1, postBias.2, postBias.3]
        
        matrix.withUnsafeBufferPointer { matrixPtr in
            
            let matrixArray = Array(matrixPtr)
           
            precondition(matrix.count == 16,
                         "`matrix` must must contain 16 (4 x 4) elements.")
            precondition(abs(matrixArray.max() ?? 0) <= Int16.max,
                         "`matrix.max()` must be less than or equal to `Int16.max`.")
            precondition(abs(divisor) <= Int32.max,
                         "`divisor` must be less than or equal to `Int32.max`.")
            precondition(abs(preBiasArray.max() ?? 0) <= Int16.max,
                         "`preBias.max()` must be less than or equal to `Int16.max`.")
            precondition(abs(postBiasArray.max() ?? 0) <= Int32.max,
                         "`postBias.max` must be less than or equal to `Int32.max`.")
            
            withUnsafePointer(to: self.vImageBuffer) { srcPtr in
                withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                    _ = vImageMatrixMultiply_ARGB8888(srcPtr,
                                                      destPtr,
                                                      matrixArray.map{ Int16($0) },
                                                      Int32(divisor),
                                                      preBiasArray.map{ Int16($0) },
                                                      postBiasArray.map{ Int32($0) },
                                                      vImage_Flags(kvImageNoFlags))
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func multiply(by factor: Swift.Float, preBias: Swift.Float, postBias: Swift.Float, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        var mutablePreBias = Float(preBias)
        var mutablePostBias = Float(postBias)
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                var src: UnsafePointer<vImage_Buffer>? = srcPtr
                var dest: UnsafePointer<vImage_Buffer>? = destPtr
                
                let matrix = [factor]
                
                _ = vImageMatrixMultiply_PlanarF(&src,
                                                 &dest,
                                                 1, 1,
                                                 matrix,
                                                 &mutablePreBias,
                                                 &mutablePostBias,
                                                 vImage_Flags(kvImageNoFlags))
                
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func multiply(by matrix: (Swift.Float, Swift.Float, Swift.Float, Swift.Float), preBias: (Swift.Float, Swift.Float, Swift.Float, Swift.Float), postBias: Swift.Float, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let matrixArray = [matrix.0, matrix.1, matrix.2, matrix.3]
        let preBiasArray = [preBias.0, preBias.1, preBias.2, preBias.3]
        
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageMatrixMultiply_ARGBFFFFToPlanarF(srcPtr,
                                                           destPtr,
                                                           matrixArray,
                                                           preBiasArray,
                                                           postBias,
                                                           vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func multiply<Matrix>(by matrix: Matrix, preBias: (Swift.Float, Swift.Float, Swift.Float, Swift.Float), postBias: (Swift.Float, Swift.Float, Swift.Float, Swift.Float), destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx4>) where Matrix : Accelerate.AccelerateBuffer, Matrix.Element == Swift.Float {
        
        precondition(matrix.count == 16,
                     "`matrix` must must contain 16 (4 x 4) elements.")
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let preBiasArray = [preBias.0, preBias.1, preBias.2, preBias.3]
        let postBiasArray = [postBias.0, postBias.1, postBias.2, postBias.3]
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                matrix.withUnsafeBufferPointer { matrixPtr in
                    _ = vImageMatrixMultiply_ARGBFFFF(srcPtr,
                                                      destPtr,
                                                      matrixPtr.baseAddress!,
                                                      preBiasArray,
                                                      postBiasArray,
                                                      vImage_Flags(kvImageNoFlags))
                }
            }
        }
    }
  @inlinable public func multiply(by matrix: simd.simd_float4x4, preBias: (Swift.Float, Swift.Float, Swift.Float, Swift.Float), postBias: (Swift.Float, Swift.Float, Swift.Float, Swift.Float), destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx4>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let preBiasArray = [preBias.0, preBias.1, preBias.2, preBias.3]
        let postBiasArray = [postBias.0, postBias.1, postBias.2, postBias.3]
        
        let columns = matrix.transpose.columns
        let array = [ columns.0.x, columns.0.y, columns.0.z, columns.0.w,
                      columns.1.x, columns.1.y, columns.1.z, columns.1.w,
                      columns.2.x, columns.2.y, columns.2.z, columns.2.w,
                      columns.3.x, columns.3.y, columns.3.z, columns.3.w]
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageMatrixMultiply_ARGBFFFF(srcPtr,
                                                  destPtr,
                                                  array,
                                                  preBiasArray,
                                                  postBiasArray,
                                                  vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func extractChannel(at channelIndex: Swift.Int, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>) {
        
        _extractChannel(channelIndex: channelIndex,
                        destination: destination,
                        extractFunc: vImageExtractChannel_ARGB8888)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func extractChannel(at channelIndex: Swift.Int, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>) {
        
        _extractChannel(channelIndex: channelIndex,
                        destination: destination,
                        extractFunc: vImageExtractChannel_ARGBFFFF)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux4 {
  @inlinable public func extractChannel(at channelIndex: Swift.Int, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar16U>) {
        
        _extractChannel(channelIndex: channelIndex,
                        destination: destination,
                        extractFunc: vImageExtractChannel_ARGB16U)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  @usableFromInline
  internal typealias ExtractFunc = (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.Int, Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal func _extractChannel<T>(channelIndex: Swift.Int, destination: Accelerate.vImage.PixelBuffer<T>, extractFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.Int, Accelerate.vImage_Flags) -> Accelerate.vImage_Error) where T : Accelerate.StaticPixelFormat
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum ActivationFunction {
    case identity
    case rectifiedLinear
    case leakyRectifiedLinear(alpha: Swift.Float)
    case sigmoid
    case logSigmoid
    case tanh
    case scaledTanh(alpha: Swift.Float, beta: Swift.Float)
    case abs
    case linear(alpha: Swift.Float)
    case clamp(bounds: Swift.ClosedRange<Swift.Float>)
    case softmax
    case geluApproximation(alpha: Swift.Float, beta: Swift.Float)
    case geluApproximation2(alpha: Swift.Float, beta: Swift.Float)
    case gumbel(alpha: Swift.Float, beta: Swift.Float)
    case gumbelMax(alpha: Swift.Float, beta: Swift.Float)
    case hardSigmoid(alpha: Swift.Float, beta: Swift.Float)
    case softplus(alpha: Swift.Float, beta: Swift.Float)
    case softsign
    case elu(alpha: Swift.Float)
    case selu
    case celu(alpha: Swift.Float)
    case clampedLeakyRectifiedLinear(alpha: Swift.Float, beta: Swift.Float)
    case linearWithBias(alpha: Swift.Float, beta: Swift.Float)
    case logSoftmax
    case hardShrink(alpha: Swift.Float)
    case softShrink(alpha: Swift.Float)
    case tanhShrink
    case threshold(alpha: Swift.Float, beta: Swift.Float)
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case hardSwish(alpha: Swift.Float, beta: Swift.Float)
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case silu
    public var bnnsActivation: Accelerate.BNNSActivation {
      get
    }
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ActivationLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(function activationFunction: Accelerate.BNNS.ActivationFunction, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
  public static func applyActivation(activation: Accelerate.BNNS.ActivationFunction, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, batchSize: Swift.Int, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.ActivationLayer {
  convenience public init?(function activationFunction: Accelerate.BNNS.ActivationFunction, axes: [Swift.Int], input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, filterParameters: Accelerate.BNNSFilterParameters? = nil)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public static func applyActivation(activation: Accelerate.BNNS.ActivationFunction, axes: [Swift.Int], input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, batchSize: Swift.Int, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public enum BNNS {
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum DataLayout : Swift.CaseIterable {
    case vector
    case matrixRowMajor
    case matrixColumnMajor
    case matrixFirstMajor
    case matrixLastMajor
    case imageCHW
    case tensor3DFirstMajor
    case tensor3DLastMajor
    case convolutionWeightsOIHW
    case tensor4DFirstMajor
    case tensor4DLastMajor
    case tensor5DFirstMajor
    case tensor5DLastMajor
    case tensor6DFirstMajor
    case tensor6DLastMajor
    case tensor7DFirstMajor
    case tensor7DLastMajor
    case tensor8DFirstMajor
    case tensor8DLastMajor
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case tensor3DSNE
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case tensor3DNSE
    public static var allCases: [Accelerate.BNNS.DataLayout] {
      get
    }
    public var rank: Swift.Int {
      get
    }
    public static func == (a: Accelerate.BNNS.DataLayout, b: Accelerate.BNNS.DataLayout) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [Accelerate.BNNS.DataLayout]
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum Error : Swift.Error {
    case layerApplyFail
    case unableToCreateLayer
    case arrayDescriptorInvalidData
    case optimizerStepFail
    public static func == (a: Accelerate.BNNS.Error, b: Accelerate.BNNS.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Accelerate.BNNSFilterParameters {
  public init(options: Accelerate.BNNSFlags, threadCount: Swift.Int, allocator: Accelerate.BNNSAlloc?, deallocator: Accelerate.BNNSFree?)
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var options: Accelerate.BNNSFlags {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var threadCount: Swift.Int {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var allocator: Accelerate.BNNSAlloc? {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var deallocator: Accelerate.BNNSFree? {
    get
    set
  }
}
extension Accelerate.BNNSFlags : Swift.OptionSet {
  public typealias ArrayLiteralElement = Accelerate.BNNSFlags
  public typealias Element = Accelerate.BNNSFlags
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum PoolingType {
    case max(indices: Swift.UnsafeMutableBufferPointer<Swift.Int>? = nil, xDilationStride: Swift.Int = 0, yDilationStride: Swift.Int = 0)
    case unMax(indices: Swift.UnsafeMutableBufferPointer<Swift.Int>? = nil, xDilationStride: Swift.Int = 0, yDilationStride: Swift.Int = 0)
    case average(countIncludesPadding: Swift.Bool)
    case l2Norm
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case maxEx(indicesDescriptor: Accelerate.BNNSNDArrayDescriptor? = nil, xDilationStride: Swift.Int = 0, yDilationStride: Swift.Int = 0)
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case unMaxEx(indicesDescriptor: Accelerate.BNNSNDArrayDescriptor, xDilationStride: Swift.Int = 0, yDilationStride: Swift.Int = 0)
    public var bnnsPoolingFunction: Accelerate.BNNSPoolingFunction {
      get
    }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class PoolingLayer : Accelerate.BNNS.Layer {
    convenience public init?(type poolingType: Accelerate.BNNS.PoolingType, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, bias: Accelerate.BNNSNDArrayDescriptor?, activation: Accelerate.BNNS.ActivationFunction, kernelSize: (width: Swift.Int, height: Swift.Int), stride: (x: Swift.Int, y: Swift.Int), padding: Accelerate.BNNS.ConvolutionPadding, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor, generatingBiasGradient biasGradient: Accelerate.BNNSNDArrayDescriptor? = nil) throws
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ConvolutionLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(type convolutionType: Accelerate.BNNS.ConvolutionType, input: Accelerate.BNNSNDArrayDescriptor, weights: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, bias: Accelerate.BNNSNDArrayDescriptor?, padding: Accelerate.BNNS.ConvolutionPadding, activation: Accelerate.BNNS.ActivationFunction, groupCount: Swift.Int, stride: (x: Swift.Int, y: Swift.Int), dilationStride: (x: Swift.Int, y: Swift.Int), filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor, generatingWeightsGradient weightsGradient: Accelerate.BNNSNDArrayDescriptor? = nil, generatingBiasGradient biasGradient: Accelerate.BNNSNDArrayDescriptor? = nil) throws
    @objc deinit
  }
  public enum ConvolutionPadding {
    case symmetric(x: Swift.Int, y: Swift.Int)
    case asymmetric(left: Swift.Int, right: Swift.Int, up: Swift.Int, down: Swift.Int)
    public static var zero: Accelerate.BNNS.ConvolutionPadding {
      get
    }
  }
  public enum ConvolutionType {
    case standard
    case transposed
    public static func == (a: Accelerate.BNNS.ConvolutionType, b: Accelerate.BNNS.ConvolutionType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func convert(splitComplexVector: Accelerate.DSPSplitComplex, toInterleavedComplexVector interleavedComplexVector: inout [Accelerate.DSPComplex]) {
        
        withUnsafePointer(to: splitComplexVector) {
            vDSP_ztoc($0, 1,
                      &interleavedComplexVector, 2,
                      vDSP_Length(interleavedComplexVector.count))
        }
    }
  @inlinable public static func convert(interleavedComplexVector: [Accelerate.DSPComplex], toSplitComplexVector splitComplexVector: inout Accelerate.DSPSplitComplex) {
        
        vDSP_ctoz(interleavedComplexVector, 2,
                  &splitComplexVector, 1,
                  vDSP_Length(interleavedComplexVector.count))
    }
  @inlinable public static func convert(splitComplexVector: Accelerate.DSPDoubleSplitComplex, toInterleavedComplexVector interleavedComplexVector: inout [Accelerate.DSPDoubleComplex]) {
        
        withUnsafePointer(to: splitComplexVector) {
            vDSP_ztocD($0, 1,
                       &interleavedComplexVector, 2,
                       vDSP_Length(interleavedComplexVector.count))
        }
    }
  @inlinable public static func convert(interleavedComplexVector: [Accelerate.DSPDoubleComplex], toSplitComplexVector splitComplexVector: inout Accelerate.DSPDoubleSplitComplex) {
        
        vDSP_ctozD(interleavedComplexVector, 2,
                   &splitComplexVector, 1,
                   vDSP_Length(interleavedComplexVector.count))
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @frozen public enum LearningPhase {
    case training
    case inference
    public static func == (a: Accelerate.BNNS.LearningPhase, b: Accelerate.BNNS.LearningPhase) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FusedLayer : Accelerate.BNNS.Layer {
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, for learningPhase: Accelerate.BNNS.LearningPhase) throws
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor, generatingParameterGradients parameterGradients: [Accelerate.BNNSNDArrayDescriptor]) throws
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FusedConvolutionNormalizationLayer : Accelerate.BNNS.FusedLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, convolutionWeights: Accelerate.BNNSNDArrayDescriptor, convolutionBias: Accelerate.BNNSNDArrayDescriptor?, convolutionStride: (x: Swift.Int, y: Swift.Int), convolutionDilationStride: (x: Swift.Int, y: Swift.Int), convolutionPadding: Accelerate.BNNS.ConvolutionPadding, normalization: Accelerate.BNNS.NormalizationType, normalizationBeta: Accelerate.BNNSNDArrayDescriptor, normalizationGamma: Accelerate.BNNSNDArrayDescriptor, normalizationMomentum: Swift.Float, normalizationEpsilon: Swift.Float, normalizationActivation: Accelerate.BNNS.ActivationFunction, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FusedFullyConnectedNormalizationLayer : Accelerate.BNNS.FusedLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, fullyConnectedWeights: Accelerate.BNNSNDArrayDescriptor, fullyConnectedBias: Accelerate.BNNSNDArrayDescriptor?, normalization: Accelerate.BNNS.NormalizationType, normalizationBeta: Accelerate.BNNSNDArrayDescriptor, normalizationGamma: Accelerate.BNNSNDArrayDescriptor, normalizationMomentum: Swift.Float, normalizationEpsilon: Swift.Float, normalizationActivation: Accelerate.BNNS.ActivationFunction, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func flatten(channelOrdering: Accelerate.vImage.ChannelOrdering, backgroundColor: Accelerate.Pixel_8888, isPremultiplied: Swift.Bool, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x3>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let flatten: (UnsafePointer<vImage_Buffer>,
                      UnsafePointer<vImage_Buffer>,
                      UnsafePointer<UInt8>,
                      Bool,
                      vImage_Flags) -> vImage_Error
        
        switch channelOrdering {
            case .ARGB:
                flatten = vImageFlatten_ARGB8888ToRGB888
            case .RGBA:
                flatten = vImageFlatten_RGBA8888ToRGB888
            @unknown default:
                fatalError("Unsupported channel ordering")
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                _ = flatten(srcPtr,
                            destPtr,
                            [ backgroundColor.0,
                              backgroundColor.1,
                              backgroundColor.2,
                              backgroundColor.3 ],
                            isPremultiplied,
                            vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func flatten(channelOrdering: Accelerate.vImage.ChannelOrdering, backgroundColor: Accelerate.Pixel_FFFF, isPremultiplied: Swift.Bool, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx3>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let flatten: (UnsafePointer<vImage_Buffer>,
                      UnsafePointer<vImage_Buffer>,
                      UnsafePointer<Pixel_F>,
                      Bool,
                      vImage_Flags) -> vImage_Error
        
        switch channelOrdering {
            case .ARGB:
                flatten = vImageFlatten_ARGBFFFFToRGBFFF
            case .RGBA:
                flatten = vImageFlatten_RGBAFFFFToRGBFFF
            @unknown default:
                fatalError("Unsupported channel ordering")
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                _ = flatten(srcPtr,
                            destPtr,
                            [ backgroundColor.0,
                              backgroundColor.1,
                              backgroundColor.2,
                              backgroundColor.3 ],
                            isPremultiplied,
                            vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public enum ChannelOrdering {
    case ARGB
    case RGBA
    public static func == (a: Accelerate.vImage.ChannelOrdering, b: Accelerate.vImage.ChannelOrdering) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func tile(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func tileBackward(outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func copyBandPart(_ source: Accelerate.BNNSNDArrayDescriptor, to destination: Accelerate.BNNSNDArrayDescriptor, lowerBandCount: Swift.Int?, upperBandCount: Swift.Int?, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public class CropResizeLayer {
    public enum BoxCoordinateMode {
      case cornersHeightFirst
      case cornersWidthFirst
      case centerSizeHeightFirst
      case centerSizeWidthFirst
      public static func == (a: Accelerate.BNNS.CropResizeLayer.BoxCoordinateMode, b: Accelerate.BNNS.CropResizeLayer.BoxCoordinateMode) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum LinearSamplingMode {
      case `default`
      case alignCorners
      case unalignCorners
      case strictAlignCorners
      case offsetCorners
      public static func == (a: Accelerate.BNNS.CropResizeLayer.LinearSamplingMode, b: Accelerate.BNNS.CropResizeLayer.LinearSamplingMode) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public init(coordinatesAreNormalized: Swift.Bool, spatialScale: Swift.Float, extrapolationValue: Swift.Float = 0, samplingMode: Accelerate.BNNS.CropResizeLayer.LinearSamplingMode = .default, boxCoordinateMode: Accelerate.BNNS.CropResizeLayer.BoxCoordinateMode)
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public func apply(input: Accelerate.BNNSNDArrayDescriptor, regionOfInterest: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public func applyBackward(regionOfInterest: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
    @objc deinit
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public enum ShuffleType {
    case depthToSpaceNCHW
    case spaceToDepthNCHW
    public static func == (a: Accelerate.BNNS.ShuffleType, b: Accelerate.BNNS.ShuffleType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func shuffle(_ shuffleType: Accelerate.BNNS.ShuffleType, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNSNDArrayDescriptor {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public var dataSize: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func gather(input: Accelerate.BNNSNDArrayDescriptor, indices: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axis: Swift.Int, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func gatherND(input: Accelerate.BNNSNDArrayDescriptor, indices: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func scatter(input: Accelerate.BNNSNDArrayDescriptor, indices: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axis: Swift.Int, reductionFunction: Accelerate.BNNS.ReductionFunction, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func scatterND(input: Accelerate.BNNSNDArrayDescriptor, indices: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, reductionFunction: Accelerate.BNNS.ReductionFunction, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNSNDArrayDescriptor {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func allocate<Scalar>(randomNormalUsing: Accelerate.BNNS.RandomGenerator, mean: Scalar, standardDeviation: Scalar, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor? where Scalar : Accelerate.BNNSScalar, Scalar : Swift.BinaryFloatingPoint
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedNormalizationParameters : Accelerate.FusableLayerParameters {
    public init(type: Accelerate.BNNS.NormalizationType, beta: Accelerate.BNNSNDArrayDescriptor? = nil, gamma: Accelerate.BNNSNDArrayDescriptor? = nil, momentum: Swift.Float = 0, epsilon: Swift.Float, activation: Accelerate.BNNS.ActivationFunction)
    public var type: Accelerate.BNNS.NormalizationType
    public var beta: Accelerate.BNNSNDArrayDescriptor?
    public var gamma: Accelerate.BNNSNDArrayDescriptor?
    public var momentum: Swift.Float
    public var epsilon: Swift.Float
    public var activation: Accelerate.BNNS.ActivationFunction
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func maximum<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxv(v.baseAddress!, 1,
                          &output,
                          n)
            }
            
            return output
    }
  @inlinable public static func maximum<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxvD(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func maximumMagnitude<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxmgv(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func maximumMagnitude<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxmgvD(v.baseAddress!, 1,
                             &output,
                             n)
            }
            
            return output
    }
  @inlinable public static func minimum<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_minv(v.baseAddress!, 1,
                          &output,
                          n)
            }
            
            return output
    }
  @inlinable public static func minimum<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_minvD(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func sum<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_sve(v.baseAddress!, 1,
                         &output,
                         n)
            }
            
            return output
    }
  @inlinable public static func sum<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_sveD(v.baseAddress!, 1,
                          &output,
                          n)
            }
            
            return output
    }
  @inlinable public static func sumOfSquares<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_svesq(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func sumOfSquares<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_svesqD(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func sumAndSumOfSquares<U>(_ vector: U) -> (elementsSum: Swift.Float, squaresSum: Swift.Float) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var sum = Float.nan
            var sumOfSquares = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_sve_svesq(v.baseAddress!, 1,
                               &sum,
                               &sumOfSquares,
                               n)
            }
            
            return (elementsSum: sum, squaresSum: sumOfSquares)
    }
  @inlinable public static func sumAndSumOfSquares<U>(_ vector: U) -> (elementsSum: Swift.Double, squaresSum: Swift.Double) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var sum = Double.nan
            var sumOfSquares = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_sve_svesqD(v.baseAddress!, 1,
                                &sum,
                                &sumOfSquares,
                                n)
            }
            
            return (elementsSum: sum, squaresSum: sumOfSquares)
    }
  @inlinable public static func sumOfMagnitudes<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_svemg(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func sumOfMagnitudes<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_svemgD(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func indexOfMaximum<U>(_ vector: U) -> (Swift.UInt, Swift.Float) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxvi(v.baseAddress!, 1,
                           &output,
                           &index,
                           n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMaximum<U>(_ vector: U) -> (Swift.UInt, Swift.Double) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxviD(v.baseAddress!, 1,
                            &output,
                            &index,
                            n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMaximumMagnitude<U>(_ vector: U) -> (Swift.UInt, Swift.Float) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxmgvi(v.baseAddress!, 1,
                             &output,
                             &index,
                             n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMaximumMagnitude<U>(_ vector: U) -> (Swift.UInt, Swift.Double) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxmgviD(v.baseAddress!, 1,
                              &output,
                              &index,
                              n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMinimum<U>(_ vector: U) -> (Swift.UInt, Swift.Float) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_minvi(v.baseAddress!, 1,
                           &output,
                           &index,
                           n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMinimum<U>(_ vector: U) -> (Swift.UInt, Swift.Double) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_minviD(v.baseAddress!, 1,
                            &output,
                            &index,
                            n)
            }
            
            return (index, output)
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func meanSquare<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_measqv(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func meanSquare<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_measqvD(v.baseAddress!, 1,
                             &output,
                             n)
            }
            
            return output
    }
  @inlinable public static func meanMagnitude<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_meamgv(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func meanMagnitude<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_meamgvD(v.baseAddress!, 1,
                             &output,
                             n)
            }
            
            return output
    }
  @inlinable public static func mean<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_meanv(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func mean<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_meanvD(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func rootMeanSquare<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_rmsqv(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func rootMeanSquare<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_rmsqvD(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_hasMissingDesignatedInitializers public class BroadcastMatrixMultiplyLayer : Accelerate.BNNS.Layer {
    convenience public init?(inputA: Accelerate.BNNSNDArrayDescriptor, transposed transposeA: Swift.Bool, isWeights aIsWeights: Swift.Bool, inputB: Accelerate.BNNSNDArrayDescriptor, transposed transposeB: Swift.Bool, isWeights bIsWeights: Swift.Bool, output: Accelerate.BNNSNDArrayDescriptor, alpha: Swift.Float, accumulatesToOutput: Swift.Bool, isQuadratic: Swift.Bool, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public func apply(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputAGradient inputAGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputBGradient inputBGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt8, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu8(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt8, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu8D(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt16, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu16(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt16, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu16D(src.baseAddress!, 1,
                                  dest.baseAddress!, 1,
                                  n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt32, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu32(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt32, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu32D(src.baseAddress!, 1,
                                  dest.baseAddress!, 1,
                                  n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int8, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt8(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int8, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt8D(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int16, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt16(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int16, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt16D(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int32, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt32(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int32, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt32D(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  public enum RoundingMode {
    case towardZero
    case towardNearestInteger
    public static func == (a: Accelerate.vDSP.RoundingMode, b: Accelerate.vDSP.RoundingMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Int32
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Int32
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.UInt16
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.UInt16
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.UInt32
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.UInt32
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Int16
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Int16
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Int8
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Int8
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.UInt8
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.UInt8
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Double {
            let n = vDSP_Length(min(source.count,
                                    destination.count))
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vspdp(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Float {
            let n = vDSP_Length(min(source.count,
                                    destination.count))
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vdpsp(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_IntegerConvertable {
}
extension Swift.UInt8 : Accelerate.vDSP_IntegerConvertable {
}
extension Swift.UInt16 : Accelerate.vDSP_IntegerConvertable {
}
extension Swift.UInt32 : Accelerate.vDSP_IntegerConvertable {
}
extension Swift.Int8 : Accelerate.vDSP_IntegerConvertable {
}
extension Swift.Int16 : Accelerate.vDSP_IntegerConvertable {
}
extension Swift.Int32 : Accelerate.vDSP_IntegerConvertable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FloatingPointConvertable {
}
extension Swift.Float : Accelerate.vDSP_FloatingPointConvertable {
}
extension Swift.Double : Accelerate.vDSP_FloatingPointConvertable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.UInt8 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.UInt16 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.UInt32 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.Int8 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.Int16 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.Int32 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func floatingPointToInteger<T, U>(_ vector: T, integerType: U.Type, rounding: Accelerate.vDSP.RoundingMode) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_IntegerConvertable, T.Element == Swift.Float {
            
            switch integerType {
            case is UInt8.Type:
                let result = Array<UInt8>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is UInt16.Type:
                let result = Array<UInt16>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is UInt32.Type:
                let result = Array<UInt32>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int8.Type:
                let result = Array<Int8>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int16.Type:
                let result = Array<Int16>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int32.Type:
                let result = Array<Int32>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            default:
                fatalError("\(integerType) not supported as a destination type.")
            }
    }
  @inlinable public static func floatingPointToInteger<T, U>(_ vector: T, integerType: U.Type, rounding: Accelerate.vDSP.RoundingMode) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_IntegerConvertable, T.Element == Swift.Double {
            
            switch integerType {
            case is UInt8.Type:
                let result = Array<UInt8>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is UInt16.Type:
                let result = Array<UInt16>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is UInt32.Type:
                let result = Array<UInt32>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int8.Type:
                let result = Array<Int8>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int16.Type:
                let result = Array<Int16>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int32.Type:
                let result = Array<Int32>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            default:
                fatalError("\(integerType) not supported as a destination type.")
            }
    }
  @inlinable public static func floatToDouble<U>(_ source: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            let result = Array<Double>(unsafeUninitializedCapacity: source.count) {
                buffer, initializedCount in
                
                convertElements(of: source,
                                to: &buffer)
                
                initializedCount = source.count
            }
            
            return result
    }
  @inlinable public static func doubleToFloat<U>(_ source: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            let result = Array<Float>(unsafeUninitializedCapacity: source.count) {
                buffer, initializedCount in
                
                convertElements(of: source,
                                to: &buffer)
                
                initializedCount = source.count
            }
            
            return result
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public static func applyTopK(k: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, bestValues: Accelerate.BNNSNDArrayDescriptor, bestIndices: Accelerate.BNNSNDArrayDescriptor, axis: Swift.Int, batchSize: Swift.Int, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
  public static func applyInTopK(k: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, testIndices: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axis: Swift.Int, batchSize: Swift.Int, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.vDSP {
  @inlinable public static func taperedMerge<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vectorA.count == vectorB.count,
                         "The number of elements in `vectorA` must equal the number of elements in `vectorB`.")
            precondition(vectorA.count == result.count,
                         "The number of elements in `vectorA` must equal the number of elements in `result`.")
            
            let n = vDSP_Length(vectorA.count)
            
            vectorA.withUnsafeBufferPointer { a in
                vectorB.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        
                        vDSP_vtmerg(a.baseAddress!, 1,
                                    b.baseAddress!, 1,
                                    dest.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func taperedMerge<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vectorA.count == vectorB.count,
                         "The number of elements in `vectorA` must equal the number of elements in `vectorB`.")
            precondition(vectorA.count == result.count,
                         "The number of elements in `vectorA` must equal the number of elements in `result`.")
            
            let n = vDSP_Length(vectorA.count)
            
            vectorA.withUnsafeBufferPointer { a in
                vectorB.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        
                        vDSP_vtmergD(a.baseAddress!, 1,
                                     b.baseAddress!, 1,
                                     dest.baseAddress!, 1,
                                     n)
                    }
                }
            }
    }
  @inlinable public static func taperedMerge<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let resultCount = vectorA.count
            
            let result = Array<Float>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.taperedMerge(vectorA,
                                  vectorB,
                                  result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @inlinable public static func taperedMerge<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let resultCount = vectorA.count
            
            let result = Array<Double>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.taperedMerge(vectorA,
                                  vectorB,
                                  result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @inlinable public static func swapElements<T, U>(_ vectorA: inout T, _ vectorB: inout U) where T : Accelerate.AccelerateMutableBuffer, U : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            precondition(vectorA.count == vectorB.count,
                         "The number of elements in `vectorA` must equal the number of elements in `vectorB`.")
            
            let n = vDSP_Length(vectorA.count)
            
            vectorA.withUnsafeMutableBufferPointer { a in
                vectorB.withUnsafeMutableBufferPointer { b in
                    vDSP_vswap(a.baseAddress!, 1,
                               b.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func swapElements<T, U>(_ vectorA: inout T, _ vectorB: inout U) where T : Accelerate.AccelerateMutableBuffer, U : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            precondition(vectorA.count == vectorB.count,
                         "The number of elements in `vectorA` must equal the number of elements in `vectorB`.")
            
            let n = vDSP_Length(vectorA.count)
            
            vectorA.withUnsafeMutableBufferPointer { a in
                vectorB.withUnsafeMutableBufferPointer { b in
                    vDSP_vswapD(a.baseAddress!, 1,
                                b.baseAddress!, 1,
                                n)
                }
            }
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.vDSP {
  @inlinable public static func gather<T, U, V>(_ vector: T, indices: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.UInt, V.Element == Swift.Float {
            precondition(indices.count == result.count,
                         "The number of elements in `indices` must equal the number of elements in `result`.")
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    indices.withUnsafeBufferPointer { i in
                        vDSP_vgathr(v.baseAddress!,
                                    i.baseAddress!, 1,
                                    r.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func gather<T, U, V>(_ vector: T, indices: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.UInt, V.Element == Swift.Double {
            precondition(indices.count == result.count,
                         "The number of elements in `indices` must equal the number of elements in `result`.")
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    indices.withUnsafeBufferPointer { i in
                        vDSP_vgathrD(v.baseAddress!,
                                     i.baseAddress!, 1,
                                     r.baseAddress!, 1,
                                     n)
                    }
                }
            }
    }
  @inlinable public static func gather<T, U>(_ vector: T, indices: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.UInt {
            
            let resultCount = indices.count
            
            let result = Array<Float>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.gather(vector,
                            indices: indices,
                            result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @inlinable public static func gather<T, U>(_ vector: T, indices: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.UInt {
            
            let resultCount = indices.count
            
            let result = Array<Double>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.gather(vector,
                            indices: indices,
                            result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @inlinable public static func compress<T, U, V>(_ vector: T, gatingVector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == gatingVector.count,
                         "The number of elements in `gatingVector` must equal the number of elements in `vector`.")
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    gatingVector.withUnsafeBufferPointer { g in
                        vDSP_vcmprs(v.baseAddress!, 1,
                                    g.baseAddress!, 1,
                                    r.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func compress<T, U, V>(_ vector: T, gatingVector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == gatingVector.count,
                         "The number of elements in `gatingVector` must equal the number of elements in `vector`.")
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    gatingVector.withUnsafeBufferPointer { g in
                        vDSP_vcmprsD(v.baseAddress!, 1,
                                     g.baseAddress!, 1,
                                     r.baseAddress!, 1,
                                     n)
                    }
                }
            }
    }
  @inlinable public static func compress<T, U>(_ vector: T, gatingVector: U, nonZeroGatingCount: Swift.Int?) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let resultCount: Int
            
            if let nonZeroGatingCount = nonZeroGatingCount {
                resultCount = nonZeroGatingCount
            } else {
                // Count elements in `gatingVector` that are non-zero.
                var lowCount: vDSP_Length = 0
                var highCount: vDSP_Length = 0
                var clippingThreshold: Float = 0
                
                _ = Array<Float>(unsafeUninitializedCapacity: gatingVector.count) {
                    buffer, initializedCount in
                    
                    gatingVector.withUnsafeBufferPointer { g in
                        vDSP_vclipc(g.baseAddress!, 1,
                                    &clippingThreshold, &clippingThreshold,
                                    buffer.baseAddress!, 1,
                                    vDSP_Length(gatingVector.count),
                                    &lowCount, &highCount)
                    }
                }
                
                resultCount = Int(lowCount + highCount)
            }
            
            let result = Array<Float>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.compress(vector,
                              gatingVector: gatingVector,
                              result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @inlinable public static func compress<T, U>(_ vector: T, gatingVector: U, nonZeroGatingCount: Swift.Int?) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let resultCount: Int
            
            if let nonZeroGatingCount = nonZeroGatingCount {
                resultCount = nonZeroGatingCount
            } else {
                // Count elements in `gatingVector` that are non-zero.
                var lowCount: vDSP_Length = 0
                var highCount: vDSP_Length = 0
                var clippingThreshold: Double = 0
                
                _ = Array<Double>(unsafeUninitializedCapacity: gatingVector.count) {
                    buffer, initializedCount in
                    
                    gatingVector.withUnsafeBufferPointer { g in
                        vDSP_vclipcD(g.baseAddress!, 1,
                                     &clippingThreshold, &clippingThreshold,
                                     buffer.baseAddress!, 1,
                                     vDSP_Length(gatingVector.count),
                                     &lowCount, &highCount)
                    }
                }
                
                resultCount = Int(lowCount + highCount)
            }
            
            let result = Array<Double>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.compress(vector,
                              gatingVector: gatingVector,
                              result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum Shape {
    public init(_ size: [Swift.Int], dataLayout: Accelerate.BNNS.DataLayout? = nil, stride: [Swift.Int]? = nil)
    case vector(_: Swift.Int, stride: Swift.Int = 0)
    case matrixColumnMajor(_: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int) = (0, 0))
    case matrixRowMajor(_: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int) = (0, 0))
    case matrixFirstMajor(_: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int) = (0, 0))
    case matrixLastMajor(_: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int) = (0, 0))
    case imageCHW(_: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0))
    case tensor3DFirstMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0))
    case tensor3DLastMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0))
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case tensor3DSNE(_: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0))
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case tensor3DNSE(_: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0))
    case convolutionWeightsOIHW(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0))
    case tensor4DFirstMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0))
    case tensor4DLastMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0))
    case tensor5DFirstMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0))
    case tensor5DLastMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0))
    case tensor6DFirstMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0, 0))
    case tensor6DLastMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0, 0))
    case tensor7DFirstMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0, 0, 0))
    case tensor7DLastMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0, 0, 0))
    case tensor8DFirstMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0, 0, 0, 0))
    case tensor8DLastMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0, 0, 0, 0))
    public var rank: Swift.Int {
      get
    }
    public var size: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) {
      get
    }
    public var stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) {
      get
    }
    public var batchStride: Swift.Int {
      get
    }
    public var layout: Accelerate.BNNSDataLayout {
      get
    }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.Shape : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Swift.Int
  public init(arrayLiteral: Accelerate.BNNS.Shape.ArrayLiteralElement...)
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class PermuteLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, permutation: [Swift.Int], filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_hasMissingDesignatedInitializers public class Layer {
    @objc deinit
    final public let bnnsFilter: Accelerate.BNNSFilter
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class UnaryLayer : Accelerate.BNNS.Layer {
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class BinaryLayer : Accelerate.BNNS.Layer {
    public func apply(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputAGradient inputAGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputBGradient inputBGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx2 {
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x2>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 2,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        let fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 2,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        
        withUnsafePointer(to: fauxSource) { srcPtr in
            withUnsafePointer(to: fauxDestination) { destPtr in
                
                _ = vImageConvert_Planar16FtoPlanar8(srcPtr,
                                                     destPtr,
                                                     vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved16Ux2>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 2,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        let fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 2,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        
        withUnsafePointer(to: fauxSource) { srcPtr in
            withUnsafePointer(to: fauxDestination) { destPtr in
                
                _ = vImageConvert_16Fto16U(srcPtr,
                                           destPtr,
                                           vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx2>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 2,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        let fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 2,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        
        withUnsafePointer(to: fauxSource) { srcPtr in
            withUnsafePointer(to: fauxDestination) { destPtr in
                
                _ = vImageConvert_Planar16FtoPlanarF(srcPtr,
                                                     destPtr,
                                                     vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage {
  public enum FloodFillConnectivity : Swift.Int32 {
    case edges
    case edgesAndCorners
    public init?(rawValue: Swift.Int32)
    public typealias RawValue = Swift.Int32
    public var rawValue: Swift.Int32 {
      get
    }
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func floodFill(from seed: CoreFoundation.CGPoint, newColor: Accelerate.Pixel_8, connectivity: Accelerate.vImage.FloodFillConnectivity) {
        
        guard
            let seedX = vImagePixelCount(exactly: seed.x),
            let seedY = vImagePixelCount(exactly: seed.y) else {
            preconditionFailure("Values in seed must be exactly representable as `vImagePixelCount`.")
        }
        
        self.withUnsafePointerToVImageBuffer { srcDest in
            _ = vImageFloodFill_Planar8(srcDest,
                                        nil,
                                        seedX, seedY,
                                        newColor,
                                        connectivity.rawValue,
                                        vImage_Flags(kvImageNoFlags))
        }
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16U {
  @inlinable public func floodFill(from seed: CoreFoundation.CGPoint, newColor: Accelerate.Pixel_16U, connectivity: Accelerate.vImage.FloodFillConnectivity) {
        
        guard
            let seedX = vImagePixelCount(exactly: seed.x),
            let seedY = vImagePixelCount(exactly: seed.y) else {
            preconditionFailure("Values in seed must be exactly representable as `vImagePixelCount`.")
        }
        
        self.withUnsafePointerToVImageBuffer { srcDest in
            _ = vImageFloodFill_Planar16U(srcDest,
                                          nil,
                                          seedX, seedY,
                                          newColor,
                                          connectivity.rawValue,
                                          vImage_Flags(kvImageNoFlags))
        }
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func floodFill(from seed: CoreFoundation.CGPoint, newColor: Accelerate.Pixel_8888, connectivity: Accelerate.vImage.FloodFillConnectivity) {
        
        guard
            let seedX = vImagePixelCount(exactly: seed.x),
            let seedY = vImagePixelCount(exactly: seed.y) else {
            preconditionFailure("Values in seed must be exactly representable as `vImagePixelCount`.")
        }
        
        self.withUnsafePointerToVImageBuffer { srcDest in
            var color = [newColor.0, newColor.1, newColor.2, newColor.3]
            _ = vImageFloodFill_ARGB8888(srcDest,
                                         nil,
                                         seedX, seedY,
                                         &color,
                                         connectivity.rawValue,
                                         vImage_Flags(kvImageNoFlags))
        }
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux4 {
  @inlinable public func floodFill(from seed: CoreFoundation.CGPoint, newColor: Accelerate.Pixel_ARGB_16U, connectivity: Accelerate.vImage.FloodFillConnectivity) {
        
        guard
            let seedX = vImagePixelCount(exactly: seed.x),
            let seedY = vImagePixelCount(exactly: seed.y) else {
            preconditionFailure("Values in seed must be exactly representable as `vImagePixelCount`.")
        }
        
        self.withUnsafePointerToVImageBuffer { srcDest in
            var color = [newColor.0, newColor.1, newColor.2, newColor.3]
            _ = vImageFloodFill_ARGB16U(srcDest,
                                        nil,
                                        seedX, seedY,
                                        &color,
                                        connectivity.rawValue,
                                        vImage_Flags(kvImageNoFlags))
        }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func powerToDecibels<U>(_ power: U, zeroReference: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: power.count) {
                buffer, initializedCount in
                
                convert(power: power,
                        toDecibels: &buffer,
                        zeroReference: zeroReference)
                
                initializedCount = power.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(power: U, toDecibels decibels: inout V, zeroReference: Swift.Float) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = decibels.count
            precondition(power.count == n)
            
            decibels.withUnsafeMutableBufferPointer { db in
                power.withUnsafeBufferPointer { pwr in
                    withUnsafePointer(to: zeroReference) { zref in
                        vDSP_vdbcon(pwr.baseAddress!, 1,
                                    zref,
                                    db.baseAddress!, 1,
                                    vDSP_Length(n),
                                    0)
                    }
                }
            }
    }
  @inlinable public static func powerToDecibels<U>(_ power: U, zeroReference: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: power.count) {
                buffer, initializedCount in
                
                convert(power: power,
                        toDecibels: &buffer,
                        zeroReference: zeroReference)
                
                initializedCount = power.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(power: U, toDecibels decibels: inout V, zeroReference: Swift.Double) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = decibels.count
            precondition(power.count == n)
            
            decibels.withUnsafeMutableBufferPointer { db in
                power.withUnsafeBufferPointer { pwr in
                    withUnsafePointer(to: zeroReference) { zref in
                        vDSP_vdbconD(pwr.baseAddress!, 1,
                                     zref,
                                     db.baseAddress!, 1,
                                     vDSP_Length(n),
                                     0)
                    }
                }
            }
    }
  @inlinable public static func amplitudeToDecibels<U>(_ amplitude: U, zeroReference: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: amplitude.count) {
                buffer, initializedCount in
                
                convert(amplitude: amplitude,
                        toDecibels: &buffer,
                        zeroReference: zeroReference)
                
                initializedCount = amplitude.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(amplitude: U, toDecibels decibels: inout V, zeroReference: Swift.Float) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = decibels.count
            precondition(amplitude.count == n)
            
            decibels.withUnsafeMutableBufferPointer { db in
                amplitude.withUnsafeBufferPointer { amp in
                    withUnsafePointer(to: zeroReference) { zref in
                        vDSP_vdbcon(amp.baseAddress!, 1,
                                    zref,
                                    db.baseAddress!, 1,
                                    vDSP_Length(n),
                                    1)
                    }
                }
            }
    }
  @inlinable public static func amplitudeToDecibels<U>(_ amplitude: U, zeroReference: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: amplitude.count) {
                buffer, initializedCount in
                
                convert(amplitude: amplitude,
                        toDecibels: &buffer,
                        zeroReference: zeroReference)
                
                initializedCount = amplitude.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(amplitude: U, toDecibels decibels: inout V, zeroReference: Swift.Double) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = decibels.count
            precondition(amplitude.count == n)
            
            decibels.withUnsafeMutableBufferPointer { db in
                amplitude.withUnsafeBufferPointer { amp in
                    withUnsafePointer(to: zeroReference) { zref in
                        vDSP_vdbconD(amp.baseAddress!, 1,
                                     zref,
                                     db.baseAddress!, 1,
                                     vDSP_Length(n),
                                     1)
                    }
                }
            }
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol vDSP_DiscreteFourierTransformable {
  associatedtype DiscreteFourierTransformFunctions : Accelerate.vDSP_DiscreteTransformLifecycleFunctions
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol vDSP_DiscreteTransformLifecycleFunctions {
  static func makeDiscreteFourierTransform(previous: Swift.OpaquePointer?, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) throws -> Swift.OpaquePointer
  static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Float : Accelerate.vDSP_DiscreteFourierTransformable {
  public typealias DiscreteFourierTransformFunctions = Accelerate.vDSP.DFTSinglePrecisionSplitComplexFunctions
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Double : Accelerate.vDSP_DiscreteFourierTransformable {
  public typealias DiscreteFourierTransformFunctions = Accelerate.vDSP.DFTDoublePrecisionSplitComplexFunctions
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.DSPComplex : Accelerate.vDSP_DiscreteFourierTransformable {
  public typealias DiscreteFourierTransformFunctions = Accelerate.vDSP.DFTSinglePrecisionInterleavedFunctions
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.DSPDoubleComplex : Accelerate.vDSP_DiscreteFourierTransformable {
  public typealias DiscreteFourierTransformFunctions = Accelerate.vDSP.DFTDoublePrecisionInterleavedFunctions
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.vDSP {
  public struct DFTSinglePrecisionSplitComplexFunctions : Accelerate.vDSP_DiscreteTransformLifecycleFunctions {
    public static func makeDiscreteFourierTransform(previous: Swift.OpaquePointer? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) throws -> Swift.OpaquePointer
    public static func destroySetup(_ setup: Swift.OpaquePointer)
  }
  public struct DFTDoublePrecisionSplitComplexFunctions : Accelerate.vDSP_DiscreteTransformLifecycleFunctions {
    public static func makeDiscreteFourierTransform(previous: Swift.OpaquePointer? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) throws -> Swift.OpaquePointer
    public static func destroySetup(_ setup: Swift.OpaquePointer)
  }
  public struct DFTSinglePrecisionInterleavedFunctions : Accelerate.vDSP_DiscreteTransformLifecycleFunctions {
    public static func makeDiscreteFourierTransform(previous: Swift.OpaquePointer? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) throws -> Swift.OpaquePointer
    public static func destroySetup(_ setup: Swift.OpaquePointer)
  }
  public struct DFTDoublePrecisionInterleavedFunctions : Accelerate.vDSP_DiscreteTransformLifecycleFunctions {
    public static func makeDiscreteFourierTransform(previous: Swift.OpaquePointer? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) throws -> Swift.OpaquePointer
    public static func destroySetup(_ setup: Swift.OpaquePointer)
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.vDSP {
  public enum DFTError : Swift.Error {
    case invalidSplitComplexCount(count: Swift.Int, transformType: Accelerate.vDSP.DFTTransformType)
    case invalidInterleavedCount(count: Swift.Int)
    public var errorDescription: Swift.String? {
      get
    }
  }
  public class DiscreteFourierTransform<T> where T : Accelerate.vDSP_DiscreteFourierTransformable {
    public init(previous: Accelerate.vDSP.DiscreteFourierTransform<Swift.Float>? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType, ofType: T.Type) throws
    @objc deinit
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.vDSP.DiscreteFourierTransform where T == Swift.Float {
  public func transform<U>(real: U, imaginary: U) -> (real: [Swift.Float], imaginary: [Swift.Float]) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float
  public func transform<U, V>(inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.vDSP.DiscreteFourierTransform where T == Swift.Double {
  public func transform<U>(real: U, imaginary: U) -> (real: [Swift.Double], imaginary: [Swift.Double]) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double
  public func transform<U, V>(inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.vDSP.DiscreteFourierTransform where T == Accelerate.DSPComplex {
  public func transform<U>(input: U) -> [Accelerate.DSPComplex] where U : Accelerate.AccelerateBuffer, U.Element == Accelerate.DSPComplex
  public func transform<U, V>(input: U, output: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Accelerate.DSPComplex, V.Element == Accelerate.DSPComplex
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.vDSP.DiscreteFourierTransform where T == Accelerate.DSPDoubleComplex {
  public func transform<U>(input: U) -> [Accelerate.DSPDoubleComplex] where U : Accelerate.AccelerateBuffer, U.Element == Accelerate.DSPDoubleComplex
  public func transform<U, V>(input: U, output: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Accelerate.DSPDoubleComplex, V.Element == Accelerate.DSPDoubleComplex
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.DynamicPixelFormat {
  @inlinable public func makeArray<U>(of scalarType: U.Type, channelCount: Swift.Int) -> [U] {
        let n = width * height * channelCount
        
        let pixels = [U](unsafeUninitializedCapacity: n) {
            buffer, initializedCount in
            
            var dest = vImage_Buffer(
                data: buffer.baseAddress,
                height: vImagePixelCount(height),
                width: vImagePixelCount(width),
                rowBytes: width * MemoryLayout<U>.stride * channelCount)
            
            try! self.vImageBuffer.copy(destinationBuffer: &dest,
                                        pixelSize: MemoryLayout<U>.stride * channelCount)
            
            initializedCount = n
        }
        
        return pixels
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public enum ArithmeticTernaryFunction {
    case multiplyAdd
    public var bnnsArithmeticFunction: Accelerate.BNNSArithmeticFunction {
      get
    }
    public static func == (a: Accelerate.BNNS.ArithmeticTernaryFunction, b: Accelerate.BNNS.ArithmeticTernaryFunction) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class TernaryArithmeticLayer : Accelerate.BNNS.Layer {
    convenience public init?(inputA: Accelerate.BNNSNDArrayDescriptor, inputADescriptorType: Accelerate.BNNS.DescriptorType, inputB: Accelerate.BNNSNDArrayDescriptor, inputBDescriptorType: Accelerate.BNNS.DescriptorType, inputC: Accelerate.BNNSNDArrayDescriptor, inputCDescriptorType: Accelerate.BNNS.DescriptorType, output: Accelerate.BNNSNDArrayDescriptor, outputDescriptorType: Accelerate.BNNS.DescriptorType, function: Accelerate.BNNS.ArithmeticTernaryFunction, activation: Accelerate.BNNS.ActivationFunction = .identity, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, inputC: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, inputC: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputAGradient inputAGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputBGradient inputBGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputCGradient inputCGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class GramLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, alpha: Swift.Float, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8x4 {
  public init(interleavedBuffer: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x4>)
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x4>) {
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: destination.vImageBuffer) { destPtr in
            withUnsafePointer(to: vImageBuffers[0]) { zeroPtr in
                withUnsafePointer(to: vImageBuffers[1]) { onePtr in
                    withUnsafePointer(to: vImageBuffers[2]) { twoPtr in
                        withUnsafePointer(to: vImageBuffers[3]) { threePtr in
                            _ = vImageConvert_Planar8toARGB8888(zeroPtr,
                                                                onePtr,
                                                                twoPtr,
                                                                threePtr,
                                                                destPtr,
                                                                vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
    }
  @inlinable public func interleave(destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x4>) {
            
            self.withUnsafePixelBuffers { planarSourceBuffers in
                
                destination.interleave(planarSourceBuffers: planarSourceBuffers)
            }
        }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func applyGamma(_ gamma: Accelerate.vImage.Gamma, intermediateBuffer: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx4>? = nil, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x4>) {
        
        self._applyGamma(gamma,
                         intermediateBuffer: intermediateBuffer,
                         destination: destination,
                         widthMultiplier: Format.channelCount,
                         pixelFormat: vImage.Interleaved8x4.self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x3 {
  @inlinable public func applyGamma(_ gamma: Accelerate.vImage.Gamma, intermediateBuffer: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx3>? = nil, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x3>) {
        
        self._applyGamma(gamma,
                         intermediateBuffer: intermediateBuffer,
                         destination: destination,
                         widthMultiplier: Format.channelCount,
                         pixelFormat: vImage.Interleaved8x3.self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x2 {
  @inlinable public func applyGamma(_ gamma: Accelerate.vImage.Gamma, intermediateBuffer: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx2>? = nil, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x2>) {
        
        self._applyGamma(gamma,
                         intermediateBuffer: intermediateBuffer,
                         destination: destination,
                         widthMultiplier: Format.channelCount,
                         pixelFormat: vImage.Interleaved8x2.self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func applyGamma(_ gamma: Accelerate.vImage.Gamma, intermediateBuffer: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>? = nil, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>) {
        
        self._applyGamma(gamma,
                         intermediateBuffer: intermediateBuffer,
                         destination: destination,
                         widthMultiplier: Format.channelCount,
                         pixelFormat: vImage.Planar8.self)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat, Format.ComponentType == Swift.UInt8 {
  @usableFromInline
  internal func _applyGamma<DEST, IB>(_ gamma: Accelerate.vImage.Gamma, intermediateBuffer: Accelerate.vImage.PixelBuffer<IB>? = nil, destination: Accelerate.vImage.PixelBuffer<DEST>, widthMultiplier: Swift.Int, pixelFormat: DEST.Type) where DEST : Accelerate.StaticPixelFormat, IB : Accelerate.StaticPixelFormat
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat, Format.ComponentType == Swift.Float {
  @inlinable public func applyGamma(_ gamma: Accelerate.vImage.Gamma, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        self._applyGamma(gamma, destination: destination,
                         widthMultiplier: Format.channelCount,
                         pixelFormat: Format.self)
        
    }
  @usableFromInline
  internal func _applyGamma<DEST>(_ gamma: Accelerate.vImage.Gamma, destination: Accelerate.vImage.PixelBuffer<DEST>, widthMultiplier: Swift.Int, pixelFormat: DEST.Type) where DEST : Accelerate.StaticPixelFormat
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public enum Gamma {
    case fullPrecision(_: Swift.Float)
    case halfPrecision(_: Swift.Float)
    case fiveOverNineHalfPrecision
    case nineOverFiveHalfPrecision
    case fiveOverElevenHalfPrecision
    case elevenOverFiveHalfPrecision
    case sRGBForwardHalfPrecision
    case sRGBReverseHalfPrecision
    case elevenOverNineHalfPrecision
    case nineOverElevenHalfPrecision
    case bt709ForwardHalfPrecision
    case bt709ReverseHalfPrecision
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat, Format.ComponentType == Swift.Float {
  @inlinable public func applyGamma(linearParameters: (scale: Swift.Float, bias: Swift.Float), exponentialParameters: (scale: Swift.Float, preBias: Swift.Float, gamma: Swift.Float, postBias: Swift.Float), boundary: Swift.Float, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSrc = vImage.PixelBuffer(data: self.vImageBuffer.data,
                                         width: self.width * Format.channelCount,
                                         height: self.height,
                                         byteCountPerRow: self.vImageBuffer.rowBytes,
                                         pixelFormat: vImage.PlanarF.self)
        
        let fauxDest = vImage.PixelBuffer(data: destination.vImageBuffer.data,
                                          width: destination.width * Format.channelCount,
                                          height: destination.height,
                                          byteCountPerRow: destination.vImageBuffer.rowBytes,
                                          pixelFormat: vImage.PlanarF.self)
        
        withUnsafePointer(to: fauxSrc.vImageBuffer) { srcPtr in
            withUnsafePointer(to: fauxDest.vImageBuffer) { destPtr in
                
                _ = vImagePiecewiseGamma_PlanarF(srcPtr,
                                                 destPtr,
                                                 [ exponentialParameters.scale,
                                                   exponentialParameters.preBias,
                                                   exponentialParameters.postBias ],
                                                 exponentialParameters.gamma,
                                                 [ linearParameters.scale,
                                                   linearParameters.bias ],
                                                 boundary,
                                                 vImage_Flags(kvImageNoFlags))
                
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat, Format.ComponentType == Swift.UInt8 {
  @inlinable public func applyGamma(linearParameters: (scale: Swift.Float, bias: Swift.Float), exponentialParameters: (scale: Swift.Float, preBias: Swift.Float, gamma: Swift.Float, postBias: Swift.Float), boundary: Accelerate.Pixel_8, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSrc = vImage.PixelBuffer(data: self.vImageBuffer.data,
                                         width: self.width * Format.channelCount,
                                         height: self.height,
                                         byteCountPerRow: self.vImageBuffer.rowBytes,
                                         pixelFormat: vImage.Planar8.self)
        
        let fauxDest = vImage.PixelBuffer(data: destination.vImageBuffer.data,
                                          width: destination.width * Format.channelCount,
                                          height: destination.height,
                                          byteCountPerRow: destination.vImageBuffer.rowBytes,
                                          pixelFormat: vImage.Planar8.self)
        
        withUnsafePointer(to: fauxSrc.vImageBuffer) { srcPtr in
            withUnsafePointer(to: fauxDest.vImageBuffer) { destPtr in
                
                _ = vImagePiecewiseGamma_Planar8(srcPtr,
                                                 destPtr,
                                                 [ exponentialParameters.scale,
                                                   exponentialParameters.preBias,
                                                   exponentialParameters.postBias ],
                                                 exponentialParameters.gamma,
                                                 [ linearParameters.scale,
                                                   linearParameters.bias ],
                                                 boundary,
                                                 vImage_Flags(kvImageNoFlags))
                
            }
        }
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedFullyConnectedParameters : Accelerate.FusableLayerParameters {
    public init(weights: Accelerate.BNNSNDArrayDescriptor, bias: Accelerate.BNNSNDArrayDescriptor?)
    public var weights: Accelerate.BNNSNDArrayDescriptor
    public var bias: Accelerate.BNNSNDArrayDescriptor?
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16U {
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar16F>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
    
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                _ = vImageConvert_16Uto16F(srcPtr,
                                           destPtr,
                                           vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  public init(planarBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>])
  public init(interleavedBuffer: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x4>)
  @inlinable public func planarBuffers() -> [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>] {
        
        let componentCount = 4
        
        let buffers: [vImage.PixelBuffer<vImage.Planar8>] = (0 ..< componentCount).map { _ in
            vImage.PixelBuffer(size: size,
                               pixelFormat: vImage.Planar8.self)
            
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: buffers[0].vImageBuffer) { zeroPtr in
                withUnsafePointer(to: buffers[1].vImageBuffer) { onePtr in
                    withUnsafePointer(to: buffers[2].vImageBuffer) { twoPtr in
                        withUnsafePointer(to: buffers[3].vImageBuffer) { threePtr in
                            _ = vImageConvert_ARGBFFFFtoPlanar8(srcPtr,
                                                                zeroPtr,
                                                                onePtr,
                                                                twoPtr,
                                                                threePtr,
                                                                [1, 1, 1, 1],
                                                                [0, 0, 0, 0],
                                                                vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
        
        return buffers
    }
  @inlinable public func planarBuffers() -> [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>] {
        
        let componentCount = Format.channelCount
        
        let buffers: [vImage.PixelBuffer<vImage.PlanarF>] = (0 ..< componentCount).map { _ in
            vImage.PixelBuffer(size: size,
                               pixelFormat: vImage.PlanarF.self)
            
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: buffers[0].vImageBuffer) { zeroPtr in
                withUnsafePointer(to: buffers[1].vImageBuffer) { onePtr in
                    withUnsafePointer(to: buffers[2].vImageBuffer) { twoPtr in
                        withUnsafePointer(to: buffers[3].vImageBuffer) { threePtr in
                            _ = vImageConvert_ARGBFFFFtoPlanarF(srcPtr,
                                                                zeroPtr,
                                                                onePtr,
                                                                twoPtr,
                                                                threePtr,
                                                                vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
        
        return buffers
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx3>, channelOrdering: Accelerate.vImage.ChannelOrdering) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                switch channelOrdering {
                    case .ARGB:
                        _ = vImageConvert_ARGBFFFFtoRGBFFF(srcPtr,
                                                           destPtr,
                                                           vImage_Flags(kvImageNoFlags))
                    case .RGBA:
                        _ = vImageConvert_RGBAFFFFtoRGBFFF(srcPtr,
                                                           destPtr,
                                                           vImage_Flags(kvImageNoFlags))
                        
                    @unknown default:
                        fatalError("Unsupported channel ordering.")
                }
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x4>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageConvert_ARGBFFFFtoARGB8888_dithered(srcPtr,
                                                              destPtr,
                                                              [1, 1, 1, 1],
                                                              [0, 0, 0, 0],
                                                              Int32(kvImageConvert_DitherNone),
                                                              [0, 1, 2, 3],
                                                              vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved16Ux4>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        var fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 4,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        var fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 4,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        
        let scale = 1 / Float(UInt16.max)
        
        _ = vImageConvert_FTo16U(&fauxSource,
                                 &fauxDestination,
                                 0, scale,
                                 vImage_Flags(kvImageNoFlags))
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved16Fx4>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 4,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        let fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 4,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        
        withUnsafePointer(to: fauxSource) { srcPtr in
            withUnsafePointer(to: fauxDestination) { destPtr in
                
                _ = vImageConvert_PlanarFtoPlanar16F(srcPtr,
                                                     destPtr,
                                                     vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func interleave(planarSourceBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>]) {
        
        precondition(planarSourceBuffers.count == 4,
                     "`planarSourceBuffers` must contain four buffers.")
        
        precondition((self.size == planarSourceBuffers[0].size) &&
                     (self.size == planarSourceBuffers[1].size) &&
                     (self.size == planarSourceBuffers[2].size) &&
                     (self.size == planarSourceBuffers[3].size),
                     "Source and destination buffers must be the same size.")
        
        planarSourceBuffers[0].withUnsafePointerToVImageBuffer { a in
            planarSourceBuffers[1].withUnsafePointerToVImageBuffer { r in
                planarSourceBuffers[2].withUnsafePointerToVImageBuffer { g in
                    planarSourceBuffers[3].withUnsafePointerToVImageBuffer { b in
                        self.withUnsafePointerToVImageBuffer { rgb in
                            
                            _ = vImageConvert_PlanarFtoARGBFFFF(a,
                                                                r,
                                                                g,
                                                                b,
                                                                rgb,
                                                                vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
    }
  @inlinable public func deinterleave(planarDestinationBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>]) {
        
        precondition(planarDestinationBuffers.count == 4,
                     "`planarSourceBuffers` must contain four buffers.")
        
        precondition((self.size == planarDestinationBuffers[0].size) &&
                     (self.size == planarDestinationBuffers[1].size) &&
                     (self.size == planarDestinationBuffers[2].size) &&
                     (self.size == planarDestinationBuffers[3].size),
                     "Source and destination buffers must be the same size.")
        
        planarDestinationBuffers[0].withUnsafePointerToVImageBuffer { a in
            planarDestinationBuffers[1].withUnsafePointerToVImageBuffer { r in
                planarDestinationBuffers[2].withUnsafePointerToVImageBuffer { g in
                    planarDestinationBuffers[3].withUnsafePointerToVImageBuffer { b in
                        self.withUnsafePointerToVImageBuffer { rgb in
                            
                            _ = vImageConvert_ARGBFFFFtoPlanarF(rgb,
                                                                a,
                                                                r,
                                                                g,
                                                                b,
                                                                vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
    }
  @inlinable public func deinterleave(destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarFx4>) {
        
        destination.withUnsafePixelBuffers { planarDestinationBuffers in
            
            self.deinterleave(planarDestinationBuffers: planarDestinationBuffers)
            
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x2 {
  public init(planarBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>])
  @inlinable public func planarBuffers() -> [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>] {
        
        let componentCount = 2
        
        let buffers: [vImage.PixelBuffer<vImage.Planar8>] = (0 ..< componentCount).map { _ in
            vImage.PixelBuffer(size: size,
                               pixelFormat: vImage.Planar8.self)
            
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: buffers[0].vImageBuffer) { zeroPtr in
                withUnsafePointer(to: buffers[1].vImageBuffer) { onePtr in
                    
                    var srcChannels = [UnsafeRawPointer(self.vImageBuffer.data),
                                       UnsafeRawPointer(self.vImageBuffer.data.advanced(by: 1))]
                    
                    var destPlanarBuffers = [Optional(zeroPtr), Optional(onePtr)]
                    
                    vImageConvert_ChunkyToPlanar8(&srcChannels,
                                                  &destPlanarBuffers,
                                                  2,
                                                  2,
                                                  vImagePixelCount(width),
                                                  vImagePixelCount(height),
                                                  self.vImageBuffer.rowBytes,
                                                  vImage_Flags(kvImageNoFlags))
                    
                }
            }
        }
        
        return buffers
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved16Fx2>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 2,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        let fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 2,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        
        withUnsafePointer(to: fauxSource) { srcPtr in
            withUnsafePointer(to: fauxDestination) { destPtr in
                
                _ = vImageConvert_Planar8toPlanar16F(srcPtr,
                                                     destPtr,
                                                     vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func overwriteChannels(withScalar scalar: Accelerate.Pixel_8) {
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            _ = vImageOverwriteChannelsWithScalar_Planar8(scalar,
                                                          srcPtr,
                                                          vImage_Flags(kvImageNoFlags))
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func overwriteChannels(_ channels: [Swift.UInt8], withScalar scalar: Accelerate.Pixel_8, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        // vImage treats the indices backwards, hence `(3 - $0)`.
        // "0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue"
        let copyMask = (channels).map { 1 &<< (3 - $0) }.reduce(0,|)
        
        // Eliminates need to check for `kvImageInvalidParameter`.
        precondition(copyMask <= 15,
                     "`channels` must contain the values `0`, `1`, `2`, `3, in some order.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageOverwriteChannelsWithScalar_ARGB8888(scalar,
                                                               srcPtr,
                                                               destPtr,
                                                               copyMask,
                                                               vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func overwriteChannels(_ channels: [Swift.UInt8], withPixel pixel: Accelerate.Pixel_8888, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        // vImage treats the indices backwards, hence `(3 - $0)`.
        // "0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue"
        let copyMask = (channels).map { 1 &<< (3 - $0) }.reduce(0,|)
        
        // Eliminates need to check for `kvImageInvalidParameter`.
        precondition(copyMask <= 15,
                     "`channels` must contain the values `0`, `1`, `2`, `3, in some order.")
        
        let the_pixel = [pixel.0, pixel.1, pixel.2, pixel.3]
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageOverwriteChannelsWithPixel_ARGB8888(the_pixel,
                                                              srcPtr,
                                                              destPtr,
                                                              copyMask,
                                                              vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func overwriteChannels(_ channels: [Swift.UInt8], withInterleavedBuffer buffer: Accelerate.vImage.PixelBuffer<Format>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        precondition(self.size == buffer.size,
                     "Source and destination buffer must be the same size.")
        
        // vImage treats the indices backwards, hence `(3 - $0)`.
        // "0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue"
        let copyMask = (channels).map { 1 &<< (3 - $0) }.reduce(0,|)
        
        // Eliminates need to check for `kvImageInvalidParameter`.
        precondition(copyMask <= 15,
                     "`channels` must contain the values `0`, `1`, `2`, `3, in some order.")
        
        withUnsafePointer(to: buffer.vImageBuffer) { newPixelsPtr in
            withUnsafePointer(to: self.vImageBuffer) { srcPtr in
                withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                    _ = vImageSelectChannels_ARGB8888(newPixelsPtr,
                                                      srcPtr,
                                                      destPtr,
                                                      copyMask,
                                                      vImage_Flags(kvImageNoFlags))
                }
            }
        }
    }
  @inlinable public func overwriteChannels(_ channels: [Swift.UInt8], withPlanarBuffer buffer: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        precondition(self.size == buffer.size,
                     "Source and destination buffer must be the same size.")
        
        // vImage treats the indices backwards, hence `(3 - $0)`.
        // "0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue"
        let copyMask = (channels).map { 1 &<< (3 - $0) }.reduce(0,|)
        
        // Eliminates need to check for `kvImageInvalidParameter`.
        precondition(copyMask <= 15,
                     "`channels` must contain the values `0`, `1`, `2`, `3, in some order.")
        
        withUnsafePointer(to: buffer.vImageBuffer) { newPixelsPtr in
            withUnsafePointer(to: self.vImageBuffer) { srcPtr in
                withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                    _ = vImageOverwriteChannels_ARGB8888(newPixelsPtr,
                                                         srcPtr,
                                                         destPtr,
                                                         copyMask,
                                                         vImage_Flags(kvImageNoFlags))
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16F {
  @inlinable public func overwriteChannels(withScalar scalar: Accelerate.Pixel_16F) {
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            _ = vImageOverwriteChannelsWithScalar_Planar16F(scalar,
                                                            srcPtr,
                                                            vImage_Flags(kvImageNoFlags))
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux4 {
  @inlinable public func overwriteChannels(_ channels: [Swift.UInt8], withPixel pixel: Accelerate.Pixel_ARGB_16U, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        // vImage treats the indices backwards, hence `(3 - $0)`.
        // "0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue"
        let copyMask = (channels).map { 1 &<< (3 - $0) }.reduce(0,|)
        
        // Eliminates need to check for `kvImageInvalidParameter`.
        precondition(copyMask <= 15,
                     "`channels` must contain the values `0`, `1`, `2`, `3, in some order.")
        
        let the_pixel = [pixel.0, pixel.1, pixel.2, pixel.3]
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageOverwriteChannelsWithPixel_ARGB16U(the_pixel,
                                                             srcPtr,
                                                             destPtr,
                                                             copyMask,
                                                             vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func overwriteChannels(withScalar scalar: Accelerate.Pixel_F) {
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            _ = vImageOverwriteChannelsWithScalar_PlanarF(scalar,
                                                          srcPtr,
                                                          vImage_Flags(kvImageNoFlags))
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func overwriteChannels(_ channels: [Swift.UInt8], withScalar scalar: Accelerate.Pixel_F, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        // vImage treats the indices backwards, hence `(3 - $0)`.
        // "0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue"
        let copyMask = (channels).map { 1 &<< (3 - $0) }.reduce(0,|)
        
        // Eliminates need to check for `kvImageInvalidParameter`.
        precondition(copyMask <= 15,
                     "`channels` must contain the values `0`, `1`, `2`, `3, in some order.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageOverwriteChannelsWithScalar_ARGBFFFF(scalar,
                                                               srcPtr,
                                                               destPtr,
                                                               copyMask,
                                                               vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func overwriteChannels(_ channels: [Swift.UInt8], withPixel pixel: Accelerate.Pixel_FFFF, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        // vImage treats the indices backwards, hence `(3 - $0)`.
        // "0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue"
        let copyMask = (channels).map { 1 &<< (3 - $0) }.reduce(0,|)
        
        // Eliminates need to check for `kvImageInvalidParameter`.
        precondition(copyMask <= 15,
                     "`channels` must contain the values `0`, `1`, `2`, `3, in some order.")
        
        let the_pixel = [pixel.0, pixel.1, pixel.2, pixel.3]
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageOverwriteChannelsWithPixel_ARGBFFFF(the_pixel,
                                                              srcPtr,
                                                              destPtr,
                                                              copyMask,
                                                              vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func overwriteChannels(_ channels: [Swift.UInt8], withInterleavedBuffer buffer: Accelerate.vImage.PixelBuffer<Format>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        precondition(self.size == buffer.size,
                     "Source and destination buffer must be the same size.")
        
        // vImage treats the indices backwards, hence `(3 - $0)`.
        // "0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue"
        let copyMask = (channels).map { 1 &<< (3 - $0) }.reduce(0,|)
        
        // Eliminates need to check for `kvImageInvalidParameter`.
        precondition(copyMask <= 15,
                     "`channels` must contain the values `0`, `1`, `2`, `3, in some order.")
        
        withUnsafePointer(to: buffer.vImageBuffer) { newPixelsPtr in
            withUnsafePointer(to: self.vImageBuffer) { srcPtr in
                withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                    _ = vImageSelectChannels_ARGBFFFF(newPixelsPtr,
                                                      srcPtr,
                                                      destPtr,
                                                      copyMask,
                                                      vImage_Flags(kvImageNoFlags))
                }
            }
        }
    }
  @inlinable public func overwriteChannels(_ channels: [Swift.UInt8], withPlanarBuffer buffer: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        precondition(self.size == buffer.size,
                     "Source and destination buffer must be the same size.")
        
        // vImage treats the indices backwards, hence `(3 - $0)`.
        // "0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue"
        let copyMask = (channels).map { 1 &<< (3 - $0) }.reduce(0,|)
        
        // Eliminates need to check for `kvImageInvalidParameter`.
        precondition(copyMask <= 15,
                     "`channels` must contain the values `0`, `1`, `2`, `3, in some order.")
        
        withUnsafePointer(to: buffer.vImageBuffer) { newPixelsPtr in
            withUnsafePointer(to: self.vImageBuffer) { srcPtr in
                withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                    _ = vImageOverwriteChannels_ARGBFFFF(newPixelsPtr,
                                                         srcPtr,
                                                         destPtr,
                                                         copyMask,
                                                         vImage_Flags(kvImageNoFlags))
                }
            }
        }
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public protocol BNNSOptimizer {
  func step(parameters: [Accelerate.BNNSNDArrayDescriptor], gradients: [Accelerate.BNNSNDArrayDescriptor], accumulators: [Accelerate.BNNSNDArrayDescriptor], filterParameters: Accelerate.BNNSFilterParameters?) throws
  var bnnsOptimizerFunction: Accelerate.BNNSOptimizerFunction { get }
  var accumulatorCountMultiplier: Swift.Int { get }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNSOptimizer {
  public func step(parameters: [Accelerate.BNNSNDArrayDescriptor], gradients: [Accelerate.BNNSNDArrayDescriptor], accumulators: [Accelerate.BNNSNDArrayDescriptor], filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public struct AdamOptimizer : Accelerate.BNNSOptimizer {
    public var accumulatorCountMultiplier: Swift.Int {
      get
    }
    public var learningRate: Swift.Float {
      get
      set
    }
    public var beta1: Swift.Float {
      get
      set
    }
    public var beta2: Swift.Float {
      get
      set
    }
    public var timeStep: Swift.Float {
      get
      set
    }
    public var epsilon: Swift.Float {
      get
      set
    }
    public var gradientScale: Swift.Float {
      get
      set
    }
    public var regularizationScale: Swift.Float {
      get
      set
    }
    public var gradientBounds: Swift.ClosedRange<Swift.Float>? {
      get
      set
    }
    public var regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction {
      get
      set
    }
    public init(learningRate: Swift.Float, beta1: Swift.Float, beta2: Swift.Float, timeStep: Swift.Float, epsilon: Swift.Float, gradientScale: Swift.Float, regularizationScale: Swift.Float, clipsGradientsTo gradientBounds: Swift.ClosedRange<Swift.Float>? = nil, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction)
    public var bnnsOptimizerFunction: Accelerate.BNNSOptimizerFunction {
      get
    }
  }
  public struct RMSPropOptimizer : Accelerate.BNNSOptimizer {
    public var accumulatorCountMultiplier: Swift.Int {
      get
    }
    public var learningRate: Swift.Float {
      get
      set
    }
    public var alpha: Swift.Float {
      get
      set
    }
    public var epsilon: Swift.Float {
      get
      set
    }
    public var centered: Swift.Bool {
      get
      set
    }
    public var momentum: Swift.Float {
      get
      set
    }
    public var gradientScale: Swift.Float {
      get
      set
    }
    public var regularizationScale: Swift.Float {
      get
      set
    }
    public var gradientBounds: Swift.ClosedRange<Swift.Float>? {
      get
      set
    }
    public var regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction {
      get
      set
    }
    public init(learningRate: Swift.Float, alpha: Swift.Float, epsilon: Swift.Float, centered: Swift.Bool, momentum: Swift.Float, gradientScale: Swift.Float, regularizationScale: Swift.Float, clipsGradientsTo gradientBounds: Swift.ClosedRange<Swift.Float>? = nil, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction)
    public var bnnsOptimizerFunction: Accelerate.BNNSOptimizerFunction {
      get
    }
  }
  public struct SGDMomentumOptimizer : Accelerate.BNNSOptimizer {
    public var accumulatorCountMultiplier: Swift.Int {
      get
    }
    public var learningRate: Swift.Float {
      get
      set
    }
    public var momentum: Swift.Float {
      get
      set
    }
    public var gradientScale: Swift.Float {
      get
      set
    }
    public var regularizationScale: Swift.Float {
      get
      set
    }
    public var gradientBounds: Swift.ClosedRange<Swift.Float>? {
      get
      set
    }
    @available(macOS, introduced: 11.0, deprecated: 12.0, renamed: "getter:usesNesterovMomentum(self:)")
    @available(iOS, introduced: 14.0, deprecated: 15.0, renamed: "getter:usesNesterovMomentum(self:)")
    @available(tvOS, introduced: 14.0, deprecated: 15.0, renamed: "getter:usesNesterovMomentum(self:)")
    @available(watchOS, introduced: 7.0, deprecated: 8.0, renamed: "getter:usesNesterovMomentum(self:)")
    @available(*, deprecated, renamed: "getter:usesNesterovMomentum(self:)")
    public var usesNestrovMomentum: Swift.Bool {
      get
      set
    }
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public var usesNesterovMomentum: Swift.Bool {
      get
      set
    }
    public var regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction {
      get
      set
    }
    public var sgdMomentumVariant: Accelerate.BNNSOptimizerSGDMomentumVariant {
      get
      set
    }
    @available(macOS, introduced: 11.0, deprecated: 12.0, renamed: "init(learningRate:momentum:gradientScale:regularizationScale:clipsGradientsTo:usesNesterovMomentum:regularizationFunction:sgdMomentumVariant:)")
    @available(iOS, introduced: 14.0, deprecated: 15.0, renamed: "init(learningRate:momentum:gradientScale:regularizationScale:clipsGradientsTo:usesNesterovMomentum:regularizationFunction:sgdMomentumVariant:)")
    @available(tvOS, introduced: 14.0, deprecated: 15.0, renamed: "init(learningRate:momentum:gradientScale:regularizationScale:clipsGradientsTo:usesNesterovMomentum:regularizationFunction:sgdMomentumVariant:)")
    @available(watchOS, introduced: 7.0, deprecated: 8.0, renamed: "init(learningRate:momentum:gradientScale:regularizationScale:clipsGradientsTo:usesNesterovMomentum:regularizationFunction:sgdMomentumVariant:)")
    @available(*, deprecated, renamed: "init(learningRate:momentum:gradientScale:regularizationScale:clipsGradientsTo:usesNesterovMomentum:regularizationFunction:sgdMomentumVariant:)")
    public init(learningRate: Swift.Float, momentum: Swift.Float, gradientScale: Swift.Float, regularizationScale: Swift.Float, clipsGradientsTo gradientBounds: Swift.ClosedRange<Swift.Float>? = nil, usesNestrovMomentum: Swift.Bool, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction, sgdMomentumVariant: Accelerate.BNNSOptimizerSGDMomentumVariant)
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public init(learningRate: Swift.Float, momentum: Swift.Float, gradientScale: Swift.Float, regularizationScale: Swift.Float, clipsGradientsTo gradientBounds: Swift.ClosedRange<Swift.Float>? = nil, usesNesterovMomentum: Swift.Bool, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction, sgdMomentumVariant: Accelerate.BNNSOptimizerSGDMomentumVariant)
    public var bnnsOptimizerFunction: Accelerate.BNNSOptimizerFunction {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedTernaryArithmeticParameters : Accelerate.FusableLayerParameters {
    public var inputADescriptorType: Accelerate.BNNS.DescriptorType
    public var inputBDescriptorType: Accelerate.BNNS.DescriptorType
    public var inputCDescriptorType: Accelerate.BNNS.DescriptorType
    public var outputDescriptorType: Accelerate.BNNS.DescriptorType
    public var function: Accelerate.BNNS.ArithmeticTernaryFunction
    public init(inputADescriptorType: Accelerate.BNNS.DescriptorType, inputBDescriptorType: Accelerate.BNNS.DescriptorType, inputCDescriptorType: Accelerate.BNNS.DescriptorType, outputDescriptorType: Accelerate.BNNS.DescriptorType, function: Accelerate.BNNS.ArithmeticTernaryFunction)
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.FusedParametersLayer {
  convenience public init?(inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, inputC: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, fusedLayerParameters: [any Accelerate.FusableLayerParameters], filterParameters: Accelerate.BNNSFilterParameters? = nil)
  public func apply(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, inputC: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, for learningPhase: Accelerate.BNNS.LearningPhase) throws
  public func applyBackward(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, inputC: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputAGradient inputAGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputBGradient inputBGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputCGradient inputCGradient: Accelerate.BNNSNDArrayDescriptor, generatingParameterGradients parameterGradients: [Accelerate.BNNSNDArrayDescriptor]) throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class NormalizationLayer : Accelerate.BNNS.Layer {
    convenience public init?(type normalization: Accelerate.BNNS.NormalizationType, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, beta: Accelerate.BNNSNDArrayDescriptor, gamma: Accelerate.BNNSNDArrayDescriptor, momentum: Swift.Float = 0, epsilon: Swift.Float, activation: Accelerate.BNNS.ActivationFunction, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, for learningPhase: Accelerate.BNNS.LearningPhase) throws
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor, generatingBetaGradient betaGradient: Accelerate.BNNSNDArrayDescriptor? = nil, generatingGammaGradient gammaGradient: Accelerate.BNNSNDArrayDescriptor? = nil) throws
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum NormalizationType {
    case batch(movingMean: Accelerate.BNNSNDArrayDescriptor?, movingVariance: Accelerate.BNNSNDArrayDescriptor?)
    case instance(movingMean: Accelerate.BNNSNDArrayDescriptor?, movingVariance: Accelerate.BNNSNDArrayDescriptor?)
    case layer(normalizationAxis: Swift.Int)
    case group(groupCount: Swift.Int)
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func rectangularToPolar<U>(_ rectangularCoordinates: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: rectangularCoordinates.count) {
                buffer, initializedCount in
                
                convert(rectangularCoordinates: rectangularCoordinates,
                        toPolarCoordinates: &buffer)
                
                initializedCount = rectangularCoordinates.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(rectangularCoordinates: U, toPolarCoordinates polarCoordinates: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = rectangularCoordinates.count
            precondition(polarCoordinates.count == n)
            
            polarCoordinates.withUnsafeMutableBufferPointer { dest in
                rectangularCoordinates.withUnsafeBufferPointer { src in
                    vDSP_polar(src.baseAddress!, 2,
                               dest.baseAddress!, 2,
                               vDSP_Length(n / 2))
                }
            }
    }
  @inlinable public static func rectangularToPolar<U>(_ rectangularCoordinates: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: rectangularCoordinates.count) {
                buffer, initializedCount in
                
                convert(rectangularCoordinates: rectangularCoordinates,
                        toPolarCoordinates: &buffer)
                
                initializedCount = rectangularCoordinates.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(rectangularCoordinates: U, toPolarCoordinates polarCoordinates: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = rectangularCoordinates.count
            precondition(polarCoordinates.count == n)
            
            polarCoordinates.withUnsafeMutableBufferPointer { dest in
                rectangularCoordinates.withUnsafeBufferPointer { src in
                    vDSP_polarD(src.baseAddress!, 2,
                                dest.baseAddress!, 2,
                                vDSP_Length(n / 2))
                }
            }
    }
  @inlinable public static func polarToRectangular<U>(_ polarCoordinates: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: polarCoordinates.count) {
                buffer, initializedCount in
                
                convert(polarCoordinates: polarCoordinates,
                        toRectangularCoordinates: &buffer)
                
                initializedCount = polarCoordinates.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(polarCoordinates: U, toRectangularCoordinates rectangularCoordinates: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = rectangularCoordinates.count
            precondition(polarCoordinates.count == n)
            
            rectangularCoordinates.withUnsafeMutableBufferPointer { dest in
                polarCoordinates.withUnsafeBufferPointer { src in
                    vDSP_rect(src.baseAddress!, 2,
                              dest.baseAddress!, 2,
                              vDSP_Length(n / 2))
                }
            }
    }
  @inlinable public static func polarToRectangular<U>(_ polarCoordinates: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: polarCoordinates.count) {
                buffer, initializedCount in
                
                convert(polarCoordinates: polarCoordinates,
                        toRectangularCoordinates: &buffer)
                
                initializedCount = polarCoordinates.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(polarCoordinates: U, toRectangularCoordinates rectangularCoordinates: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = rectangularCoordinates.count
            precondition(polarCoordinates.count == n)
            
            rectangularCoordinates.withUnsafeMutableBufferPointer { dest in
                polarCoordinates.withUnsafeBufferPointer { src in
                    vDSP_rectD(src.baseAddress!, 2,
                               dest.baseAddress!, 2,
                               vDSP_Length(n / 2))
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  public enum DFTTransformType {
    case complexComplex
    case complexReal
    public static func == (a: Accelerate.vDSP.DFTTransformType, b: Accelerate.vDSP.DFTTransformType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
  @available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
  @available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
  @available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
  @available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
  public class DFT<T> where T : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable {
    public init?(previous: Accelerate.vDSP.DFT<T>? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType, ofType: T.Type)
    public func transform<U>(inputReal: U, inputImaginary: U) -> (real: [T], imaginary: [T]) where T == U.Element, U : Accelerate.AccelerateBuffer
    public func transform<U, V>(inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where T == U.Element, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == V.Element
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
public protocol vDSP_FloatingPointDiscreteFourierTransformable : Swift.BinaryFloatingPoint {
  associatedtype DFTFunctions : Accelerate.vDSP_DFTFunctions where Self == Self.DFTFunctions.Scalar
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
extension Swift.Float : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable {
  public typealias DFTFunctions = Accelerate.vDSP.VectorizableFloat
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
extension Swift.Double : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable {
  public typealias DFTFunctions = Accelerate.vDSP.VectorizableDouble
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
public protocol vDSP_DFTFunctions {
  associatedtype Scalar
  static func makeDFTSetup<T>(previous: Accelerate.vDSP.DFT<T>?, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) -> Swift.OpaquePointer? where T : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable
  static func transform<U, V>(dftSetup: Swift.OpaquePointer, inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, Self.Scalar == U.Element, U.Element == V.Element
  static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
extension Accelerate.vDSP.VectorizableFloat : Accelerate.vDSP_DFTFunctions {
  public static func makeDFTSetup<T>(previous: Accelerate.vDSP.DFT<T>? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) -> Swift.OpaquePointer? where T : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable
  public static func transform<U, V>(dftSetup: Swift.OpaquePointer, inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
  public static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
extension Accelerate.vDSP.VectorizableDouble : Accelerate.vDSP_DFTFunctions {
  public static func makeDFTSetup<T>(previous: Accelerate.vDSP.DFT<T>? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) -> Swift.OpaquePointer? where T : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable
  public static func transform<U, V>(dftSetup: Swift.OpaquePointer, inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double
  public static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  public enum IntegrationRule {
    case runningSum
    case simpson
    case trapezoidal
    public static func == (a: Accelerate.vDSP.IntegrationRule, b: Accelerate.vDSP.IntegrationRule) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @inlinable public static func integrate<U>(_ vector: U, using rule: Accelerate.vDSP.IntegrationRule, stepSize: Swift.Float = 1) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                integrate(vector,
                          using: rule,
                          result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  public static func integrate<U, V>(_ vector: U, using rule: Accelerate.vDSP.IntegrationRule, stepSize: Swift.Float = 1, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
  @inlinable public static func integrate<U>(_ vector: U, using rule: Accelerate.vDSP.IntegrationRule, stepSize: Swift.Double = 1) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                integrate(vector,
                          using: rule,
                          result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  public static func integrate<U, V>(_ vector: U, using rule: Accelerate.vDSP.IntegrationRule, stepSize: Swift.Double = 1, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx4 {
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved16Ux4>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 4,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        let fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 4,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        
        withUnsafePointer(to: fauxSource) { srcPtr in
            withUnsafePointer(to: fauxDestination) { destPtr in
                
                _ = vImageConvert_16Fto16U(srcPtr,
                                           destPtr,
                                           vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x4>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 4,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        let fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 4,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        
        withUnsafePointer(to: fauxSource) { srcPtr in
            withUnsafePointer(to: fauxDestination) { destPtr in
                
                _ = vImageConvert_Planar16FtoPlanar8(srcPtr,
                                                     destPtr,
                                                     vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx4>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 4,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        let fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 4,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        
        withUnsafePointer(to: fauxSource) { srcPtr in
            withUnsafePointer(to: fauxDestination) { destPtr in
                
                _ = vImageConvert_Planar16FtoPlanarF(srcPtr,
                                                     destPtr,
                                                     vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func interleave(planarSourceBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar16F>]) {
        
        precondition(planarSourceBuffers.count == 4,
                     "`planarSourceBuffers` must contain four buffers.")
        
        precondition((self.size == planarSourceBuffers[0].size) &&
                     (self.size == planarSourceBuffers[1].size) &&
                     (self.size == planarSourceBuffers[2].size) &&
                     (self.size == planarSourceBuffers[3].size),
                     "Source and destination buffers must be the same size.")
        
        planarSourceBuffers[0].withUnsafePointerToVImageBuffer { a in
            planarSourceBuffers[1].withUnsafePointerToVImageBuffer { r in
                planarSourceBuffers[2].withUnsafePointerToVImageBuffer { g in
                    planarSourceBuffers[3].withUnsafePointerToVImageBuffer { b in
                        self.withUnsafePointerToVImageBuffer { rgb in
                            
                            _ = vImageConvert_Planar16UtoARGB16U(a,
                                                                 r,
                                                                 g,
                                                                 b,
                                                                 rgb,
                                                                 vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
    }
  @inlinable public func deinterleave(planarDestinationBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar16F>]) {
        
        precondition(planarDestinationBuffers.count == 4,
                     "`planarSourceBuffers` must contain four buffers.")
        
        precondition((self.size == planarDestinationBuffers[0].size) &&
                     (self.size == planarDestinationBuffers[1].size) &&
                     (self.size == planarDestinationBuffers[2].size) &&
                     (self.size == planarDestinationBuffers[3].size),
                     "Source and destination buffers must be the same size.")
        
        planarDestinationBuffers[0].withUnsafePointerToVImageBuffer { a in
            planarDestinationBuffers[1].withUnsafePointerToVImageBuffer { r in
                planarDestinationBuffers[2].withUnsafePointerToVImageBuffer { g in
                    planarDestinationBuffers[3].withUnsafePointerToVImageBuffer { b in
                        self.withUnsafePointerToVImageBuffer { rgb in
                            
                            _ = vImageConvert_ARGB16UtoPlanar16U(rgb,
                                                                 a,
                                                                 r,
                                                                 g,
                                                                 b,
                                                                 vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public enum GradientClipping {
    case none
    case byValue(bounds: Swift.ClosedRange<Swift.Float>)
    case byNorm(threshold: Swift.Float)
    case byGlobalNorm(threshold: Swift.Float, globalNorm: Swift.Float = 0)
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct AdamWOptimizer : Accelerate.BNNSOptimizer {
    public var accumulatorCountMultiplier: Swift.Int {
      get
    }
    public var learningRate: Swift.Float {
      get
      set
    }
    public var beta1: Swift.Float {
      get
      set
    }
    public var beta2: Swift.Float {
      get
      set
    }
    public var timeStep: Swift.Float {
      get
      set
    }
    public var epsilon: Swift.Float {
      get
      set
    }
    public var gradientScale: Swift.Float {
      get
      set
    }
    public var weightDecay: Swift.Float {
      get
      set
    }
    public var gradientClipping: Accelerate.BNNS.GradientClipping {
      get
      set
    }
    public init(learningRate: Swift.Float = 0.001, beta1: Swift.Float = 0.9, beta2: Swift.Float = 0.999, timeStep: Swift.Float = 1, epsilon: Swift.Float = 1e-8, gradientScale: Swift.Float, weightDecay: Swift.Float = 1e-2, gradientClipping: Accelerate.BNNS.GradientClipping, usesAMSGrad: Swift.Bool = false)
    public var bnnsOptimizerFunction: Accelerate.BNNSOptimizerFunction {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.AdamOptimizer {
  public init(learningRate: Swift.Float = 0.001, beta1: Swift.Float = 0.9, beta2: Swift.Float = 0.999, timeStep: Swift.Float, epsilon: Swift.Float = 1e-8, gradientScale: Swift.Float, regularizationScale: Swift.Float, gradientClipping: Accelerate.BNNS.GradientClipping, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction, usesAMSGrad: Swift.Bool = false)
  public var usesAMSGrad: Swift.Bool {
    get
    set
  }
  public var gradientClipping: Accelerate.BNNS.GradientClipping {
    get
    set
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.SGDMomentumOptimizer {
  public init(learningRate: Swift.Float, momentum: Swift.Float = 0, gradientScale: Swift.Float, regularizationScale: Swift.Float, gradientClipping: Accelerate.BNNS.GradientClipping, usesNesterovMomentum: Swift.Bool = false, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction, sgdMomentumVariant: Accelerate.BNNSOptimizerSGDMomentumVariant)
  public var gradientClipping: Accelerate.BNNS.GradientClipping {
    get
    set
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.RMSPropOptimizer {
  public init(learningRate: Swift.Float = 1e-2, alpha: Swift.Float = 0.99, epsilon: Swift.Float = 1e-8, centered: Swift.Bool, momentum: Swift.Float = 0, gradientScale: Swift.Float, regularizationScale: Swift.Float, gradientClipping: Accelerate.BNNS.GradientClipping, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction)
  public var gradientClipping: Accelerate.BNNS.GradientClipping {
    get
    set
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func clip<U>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Float>) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                clip(vector,
                     to: bounds,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func clip<U, V>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Float>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: bounds.lowerBound) { lowerBound in
                withUnsafePointer(to: bounds.upperBound) { upperBound in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_vclip(v.baseAddress!, 1,
                                       lowerBound,
                                       upperBound,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func clip<U>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Double>) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                clip(vector,
                     to: bounds,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func clip<U, V>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Double>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: bounds.lowerBound) { lowerBound in
                withUnsafePointer(to: bounds.upperBound) { upperBound in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_vclipD(v.baseAddress!, 1,
                                        lowerBound,
                                        upperBound,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func invertedClip<U>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Float>) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                invertedClip(vector,
                             to: bounds,
                             result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func invertedClip<U, V>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Float>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: bounds.lowerBound) { lowerBound in
                withUnsafePointer(to: bounds.upperBound) { upperBound in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_viclip(v.baseAddress!, 1,
                                        lowerBound,
                                        upperBound,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func invertedClip<U>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Double>) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                invertedClip(vector,
                             to: bounds,
                             result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func invertedClip<U, V>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Double>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: bounds.lowerBound) { lowerBound in
                withUnsafePointer(to: bounds.upperBound) { upperBound in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_viclipD(v.baseAddress!, 1,
                                         lowerBound,
                                         upperBound,
                                         r.baseAddress!, 1,
                                         vDSP_Length(n))
                        }
                    }
                }
            }
    }
  public enum ThresholdRule<T> where T : Swift.BinaryFloatingPoint {
    case clampToThreshold
    case zeroFill
    case signedConstant(_: T)
  }
  @inlinable public static func threshold<U>(_ vector: U, to lowerBound: Swift.Float, with rule: Accelerate.vDSP.ThresholdRule<Swift.Float>) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                threshold(vector,
                          to: lowerBound,
                          with: rule,
                          result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  public static func threshold<U, V>(_ vector: U, to lowerBound: Swift.Float, with rule: Accelerate.vDSP.ThresholdRule<Swift.Float>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
  @inlinable public static func threshold<U>(_ vector: U, to lowerBound: Swift.Double, with rule: Accelerate.vDSP.ThresholdRule<Swift.Double>) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                threshold(vector,
                          to: lowerBound,
                          with: rule,
                          result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  public static func threshold<U, V>(_ vector: U, to lowerBound: Swift.Double, with rule: Accelerate.vDSP.ThresholdRule<Swift.Double>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double
  @inlinable public static func limit<U>(_ vector: U, limit: Swift.Float, withOutputConstant outputConstant: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                vDSP.limit(vector,
                           limit: limit,
                           withOutputConstant: outputConstant,
                           result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func limit<U, V>(_ vector: U, limit: Swift.Float, withOutputConstant outputConstant: Swift.Float, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: limit) { limit in
                withUnsafePointer(to: outputConstant) { x in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_vlim(v.baseAddress!, 1,
                                      limit,
                                      x,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func limit<U>(_ vector: U, limit: Swift.Double, withOutputConstant outputConstant: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                vDSP.limit(vector,
                           limit: limit,
                           withOutputConstant: outputConstant,
                           result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func limit<U, V>(_ vector: U, limit: Swift.Double, withOutputConstant outputConstant: Swift.Double, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: limit) { limit in
                withUnsafePointer(to: outputConstant) { x in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_vlimD(v.baseAddress!, 1,
                                       limit,
                                       x,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                _ = vImageConvert_Planar8toPlanarF(srcPtr, destPtr,
                                                   1,
                                                   0,
                                                   vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar16F>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                _ = vImageConvert_Planar8toPlanar16F(srcPtr, destPtr,
                                                     vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func permuteChannels(to permuteMap: (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let permuteArray = [permuteMap.0,
                            permuteMap.1,
                            permuteMap.2,
                            permuteMap.3]
        
        _permute(permuteArray: permuteArray,
                 destination: destination,
                 permuteFunc: vImagePermuteChannels_ARGB8888)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x3 {
  @inlinable public func permuteChannels(to permuteMap: (Swift.UInt8, Swift.UInt8, Swift.UInt8), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let permuteArray = [permuteMap.0,
                            permuteMap.1,
                            permuteMap.2]
        
        _permute(permuteArray: permuteArray,
                 destination: destination,
                 permuteFunc: vImagePermuteChannels_RGB888)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux4 {
  @inlinable public func permuteChannels(to permuteMap: (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let permuteArray = [permuteMap.0,
                            permuteMap.1,
                            permuteMap.2,
                            permuteMap.3]
        
        _permute(permuteArray: permuteArray,
                 destination: destination,
                 permuteFunc: vImagePermuteChannels_ARGB16U)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx4 {
  @inlinable public func permuteChannels(to permuteMap: (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let permuteArray = [permuteMap.0,
                            permuteMap.1,
                            permuteMap.2,
                            permuteMap.3]
        
        _permute(permuteArray: permuteArray,
                 destination: destination,
                 permuteFunc: vImagePermuteChannels_ARGB16F)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func permuteChannels(to permuteMap: (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let permuteArray = [permuteMap.0,
                            permuteMap.1,
                            permuteMap.2,
                            permuteMap.3]
        
        _permute(permuteArray: permuteArray,
                 destination: destination,
                 permuteFunc: vImagePermuteChannels_ARGBFFFF)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  @usableFromInline
  internal typealias PermuteFunc = (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Swift.UInt8>, Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal func _permute<T>(permuteArray: [Swift.UInt8], destination: Accelerate.vImage.PixelBuffer<T>, permuteFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Swift.UInt8>, Accelerate.vImage_Flags) -> Accelerate.vImage_Error) where T : Accelerate.StaticPixelFormat
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @_silgen_name("_swift_vDSP_dotpr")
  @_alwaysEmitIntoClient public static func dot<T, U>(_ vectorA: T, _ vectorB: U) -> Swift.Float where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
        precondition(vectorA.count == vectorB.count)
        
        let n = vDSP_Length(vectorA.count)
        var result = Float.nan
        
        vectorA.withUnsafeBufferPointer { a in
            vectorB.withUnsafeBufferPointer { b in
                
                vDSP_dotpr(a.baseAddress!, 1,
                           b.baseAddress!, 1,
                           &result, n)
                
            }
        }
        
        return result
    }
  @_silgen_name("_swift_vDSP_dotprD")
  @_alwaysEmitIntoClient public static func dot<T, U>(_ vectorA: T, _ vectorB: U) -> Swift.Double where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
        precondition(vectorA.count == vectorB.count)
        
        let n = vDSP_Length(vectorA.count)
        var result = Double.nan
        
        vectorA.withUnsafeBufferPointer { a in
            vectorB.withUnsafeBufferPointer { b in
                
                vDSP_dotprD(a.baseAddress!, 1,
                            b.baseAddress!, 1,
                            &result, n)
                
            }
        }
        
        return result
    }
  @available(*, unavailable)
  public static func dot<T>(_ vectorA: T, _ vectorB: T) -> Swift.Float where T : Accelerate.AccelerateBuffer, T.Element == Swift.Float
  @available(*, unavailable)
  public static func dot<T>(_ vectorA: T, _ vectorB: T) -> Swift.Double where T : Accelerate.AccelerateBuffer, T.Element == Swift.Double
  @available(*, unavailable)
  @_silgen_name("$s10Accelerate4vDSPO3dotySfx_q_tAA0A6BufferRzAaER_Sf7ElementRtzSfAFRt_r0_lFZ")
  public static func dot_legacySupport<T, U>(_ vectorA: T, _ vectorB: U) -> Swift.Float where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float
  @available(*, unavailable)
  @_silgen_name("$s10Accelerate4vDSPO3dotySdx_q_tAA0A6BufferRzAaER_Sd7ElementRtzSdAFRt_r0_lFZ")
  public static func dot_legacySupport<T, U>(_ vectorA: T, _ vectorB: U) -> Swift.Double where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double
  @inlinable public static func hypot<U, V>(_ x: U, _ y: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(x.count == y.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: x.count) {
                buffer, initializedCount in
                
                hypot(x, y,
                     result: &buffer)
                
                initializedCount = x.count
            }
            
            return result
    }
  @inlinable public static func hypot<T, U, V>(_ x: T, _ y: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(x.count == y.count && y.count == result.count)
            let n = vDSP_Length(result.count)
            
            x.withUnsafeBufferPointer { a in
                y.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        vDSP_vdist(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   dest.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func hypot<U, V>(_ x: U, _ y: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(x.count == y.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: x.count) {
                buffer, initializedCount in
                
                hypot(x, y,
                      result: &buffer)
                
                initializedCount = x.count
            }
            
            return result
    }
  @inlinable public static func hypot<T, U, V>(_ x: T, _ y: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(x.count == y.count && y.count == result.count)
            let n = vDSP_Length(result.count)
            
            x.withUnsafeBufferPointer { a in
                y.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        vDSP_vdistD(a.baseAddress!, 1,
                                    b.baseAddress!, 1,
                                    dest.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func hypot<R, S, T, U>(x0: R, x1: S, y0: T, y1: U) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            precondition(x0.count == x1.count)
            precondition(y0.count == y1.count)
            precondition(x0.count == y0.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: x0.count) {
                buffer, initializedCount in
                
                hypot(x0: x0, x1: x1,
                      y0: y0, y1: y1,
                      result: &buffer)
                
                initializedCount = x0.count
            }
            
            return result
    }
  @inlinable public static func hypot<R, S, T, U, V>(x0: R, x1: S, y0: T, y1: U, result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(x0.count == x1.count && x0.count == result.count)
            precondition(y0.count == y1.count && y0.count == result.count)
            
            let n = vDSP_Length(result.count)
            
            x0.withUnsafeBufferPointer { a in
                x1.withUnsafeBufferPointer { c in
                    y0.withUnsafeBufferPointer { b in
                        y1.withUnsafeBufferPointer { d in
                            result.withUnsafeMutableBufferPointer { dest in
                                vDSP_vpythg(a.baseAddress!, 1,
                                            b.baseAddress!, 1,
                                            c.baseAddress!, 1,
                                            d.baseAddress!, 1,
                                            dest.baseAddress!, 1,
                                            n)
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func hypot<R, S, T, U>(x0: R, x1: S, y0: T, y1: U) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            precondition(x0.count == x1.count)
            precondition(y0.count == y1.count)
            precondition(x0.count == y0.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: x0.count) {
                buffer, initializedCount in
                
                hypot(x0: x0, x1: x1,
                      y0: y0, y1: y1,
                      result: &buffer)
                
                initializedCount = x0.count
            }
            
            return result
    }
  @inlinable public static func hypot<R, S, T, U, V>(x0: R, x1: S, y0: T, y1: U, result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(x0.count == x1.count && x0.count == result.count)
            precondition(y0.count == y1.count && y0.count == result.count)
            
            let n = vDSP_Length(result.count)
            
            x0.withUnsafeBufferPointer { a in
                x1.withUnsafeBufferPointer { c in
                    y0.withUnsafeBufferPointer { b in
                        y1.withUnsafeBufferPointer { d in
                            result.withUnsafeMutableBufferPointer { dest in
                                vDSP_vpythgD(a.baseAddress!, 1,
                                             b.baseAddress!, 1,
                                             c.baseAddress!, 1,
                                             d.baseAddress!, 1,
                                             dest.baseAddress!, 1,
                                             n)
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func distanceSquared<U, V>(_ pointA: U, _ pointB: V) -> Swift.Float where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(pointA.count == pointB.count)
            
            let n = vDSP_Length(pointA.count)
            var result = Float.nan
            
            pointA.withUnsafeBufferPointer { a in
                pointB.withUnsafeBufferPointer { b in
                    vDSP_distancesq(a.baseAddress!, 1,
                                    b.baseAddress!, 1,
                                    &result,
                                    n)
                }
            }
            
            return result
    }
  @inlinable public static func distanceSquared<U, V>(_ pointA: U, _ pointB: V) -> Swift.Double where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(pointA.count == pointB.count)
            
            let n = vDSP_Length(pointA.count)
            var result = Double.nan
            
            pointA.withUnsafeBufferPointer { a in
                pointB.withUnsafeBufferPointer { b in
                    vDSP_distancesqD(a.baseAddress!, 1,
                                     b.baseAddress!, 1,
                                     &result,
                                     n)
                }
            }
            
            return result
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public struct ConvolutionKernel {
    public static let gaussian1Dx3: [Swift.Float]
    public static let gaussian1Dx5: [Swift.Float]
    public static let gaussian1Dx7: [Swift.Float]
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.UInt8 {
  @inlinable public func separableConvolve(horizontalKernel: [Swift.Float], verticalKernel: [Swift.Float], bias: Swift.Float = 0, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_16U>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        precondition(horizontalKernel.count & 1 == 1,
                     "`horizontalKernel` must contain an odd number of elements.")
        precondition(verticalKernel.count & 1 == 1,
                     "`verticalKernel` must contain an odd number of elements.")
        
        for i in 0 ..< Format.planeCount {
            
            precondition(self.vImageBuffers[i].data != destination.vImageBuffers[i].data,
                         "Source and destination buffers must point to different underlying memory.")
            
            withUnsafePointer(to: self.vImageBuffers[i]) { srcPtr in
                withUnsafePointer(to: destination.vImageBuffers[i]) { destPtr in
                    _ = vImageSepConvolve_Planar8(srcPtr, destPtr,
                                                  nil,
                                                  0, 0,
                                                  horizontalKernel, UInt32(horizontalKernel.count),
                                                  verticalKernel, UInt32(verticalKernel.count),
                                                  bias,
                                                  edgeMode.backgroundColor ?? Pixel_16U(0),
                                                  edgeMode.vImageFlags)
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func separableConvolve(horizontalKernel: [Swift.Float], verticalKernel: [Swift.Float], bias: Swift.Float = 0, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_16U>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        precondition(horizontalKernel.count & 1 == 1,
                     "`horizontalKernel` must contain an odd number of elements.")
        precondition(verticalKernel.count & 1 == 1,
                     "`verticalKernel` must contain an odd number of elements.")
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageSepConvolve_Planar8(srcPtr, destPtr,
                                              nil,
                                              0, 0,
                                              horizontalKernel, UInt32(horizontalKernel.count),
                                              verticalKernel, UInt32(verticalKernel.count),
                                              bias,
                                              edgeMode.backgroundColor ?? Pixel_16U(0),
                                              edgeMode.vImageFlags)
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16F {
  @inlinable public func separableConvolve(horizontalKernel: [Swift.Float], verticalKernel: [Swift.Float], bias: Swift.Float = 0, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_16F>, useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        precondition(horizontalKernel.count & 1 == 1,
                     "`horizontalKernel` must contain an odd number of elements.")
        precondition(verticalKernel.count & 1 == 1,
                     "`verticalKernel` must contain an odd number of elements.")
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        let accumulatorFlag = useFloat16Accumulator ? vImage_Flags(kvImageUseFP16Accumulator) : 0
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageSepConvolve_Planar16F(srcPtr, destPtr,
                                              nil,
                                              0, 0,
                                              horizontalKernel, UInt32(horizontalKernel.count),
                                              verticalKernel, UInt32(verticalKernel.count),
                                              bias,
                                              edgeMode.backgroundColor ?? Pixel_16F(0),
                                              edgeMode.vImageFlags | accumulatorFlag)
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.Float {
  @inlinable public func separableConvolve(horizontalKernel: [Swift.Float], verticalKernel: [Swift.Float], bias: Swift.Float = 0, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_F>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        precondition(horizontalKernel.count & 1 == 1,
                     "`horizontalKernel` must contain an odd number of elements.")
        precondition(verticalKernel.count & 1 == 1,
                     "`verticalKernel` must contain an odd number of elements.")
 
        for i in 0 ..< Format.planeCount {
            
            precondition(self.vImageBuffers[i].data != destination.vImageBuffers[i].data,
                         "Source and destination buffers must point to different underlying memory.")
            
            withUnsafePointer(to: self.vImageBuffers[i]) { srcPtr in
                withUnsafePointer(to: destination.vImageBuffers[i]) { destPtr in
                    _ = vImageSepConvolve_PlanarF(srcPtr, destPtr,
                                                  nil,
                                                  0, 0,
                                                  horizontalKernel, UInt32(horizontalKernel.count),
                                                  verticalKernel, UInt32(verticalKernel.count),
                                                  bias,
                                                  edgeMode.backgroundColor ?? Pixel_F(0),
                                                  edgeMode.vImageFlags)
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func separableConvolve(horizontalKernel: [Swift.Float], verticalKernel: [Swift.Float], bias: Swift.Float = 0, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_F>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        precondition(horizontalKernel.count & 1 == 1,
                     "`horizontalKernel` must contain an odd number of elements.")
        precondition(verticalKernel.count & 1 == 1,
                     "`verticalKernel` must contain an odd number of elements.")
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageSepConvolve_PlanarF(srcPtr, destPtr,
                                              nil,
                                              0, 0,
                                              horizontalKernel, UInt32(horizontalKernel.count),
                                              verticalKernel, UInt32(verticalKernel.count),
                                              bias,
                                              edgeMode.backgroundColor ?? Pixel_F(0),
                                              edgeMode.vImageFlags)
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func boxConvolve(kernelSize: Accelerate.vImage.Size, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_8>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        let blurWidth = UInt32(kernelSize.width) | 1
        let blurHeight = UInt32(kernelSize.height) | 1
        
        let backgroundColor: Pixel_8
        if let bg = edgeMode.backgroundColor {
            backgroundColor = bg
        } else {
            backgroundColor = 0
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageBoxConvolve_Planar8(srcPtr, destPtr,
                                              nil,
                                              0, 0,
                                              blurHeight, blurWidth,
                                              backgroundColor,
                                              edgeMode.vImageFlags)
            }
        }
    }
  @inlinable public func tentConvolve(kernelSize: Accelerate.vImage.Size, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_8>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        let blurWidth = UInt32(kernelSize.width) | 1
        let blurHeight = UInt32(kernelSize.height) | 1
        
        let backgroundColor: Pixel_8
        if let bg = edgeMode.backgroundColor {
            backgroundColor = bg
        } else {
            backgroundColor = 0
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageTentConvolve_Planar8(srcPtr, destPtr,
                                               nil,
                                               0, 0,
                                               blurHeight, blurWidth,
                                               backgroundColor,
                                               edgeMode.vImageFlags)
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  public func boxConvolved(kernelSize: Accelerate.vImage.Size, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_8888>) -> Accelerate.vImage.PixelBuffer<Format>
  @inlinable public func boxConvolve(kernelSize: Accelerate.vImage.Size, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_8888>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        let blurWidth = UInt32(kernelSize.width) | 1
        let blurHeight = UInt32(kernelSize.height) | 1
        
        let backgroundColor: [Pixel_8]
        if let bg = edgeMode.backgroundColor {
            backgroundColor = [bg.0, bg.1, bg.2, bg.3]
        } else {
            backgroundColor = []
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageBoxConvolve_ARGB8888(srcPtr, destPtr,
                                               nil,
                                               0, 0,
                                               blurHeight, blurWidth,
                                               backgroundColor,
                                               edgeMode.vImageFlags)
            }
        }
    }
  public func tentConvolved(kernelSize: Accelerate.vImage.Size, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_8888>) -> Accelerate.vImage.PixelBuffer<Format>
  @inlinable public func tentConvolve(kernelSize: Accelerate.vImage.Size, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_8888>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        let blurWidth = UInt32(kernelSize.width) | 1
        let blurHeight = UInt32(kernelSize.height) | 1
        
        let backgroundColor: [Pixel_8]
        if let bg = edgeMode.backgroundColor {
            backgroundColor = [bg.0, bg.1, bg.2, bg.3]
        } else {
            backgroundColor = []
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageTentConvolve_ARGB8888(srcPtr, destPtr,
                                                nil,
                                                0, 0,
                                                blurHeight, blurWidth,
                                                backgroundColor,
                                                edgeMode.vImageFlags)
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.UInt8 {
  @inlinable public func boxConvolve(kernelSize: Accelerate.vImage.Size, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_8>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")

        let blurWidth = UInt32(kernelSize.width) | 1
        let blurHeight = UInt32(kernelSize.height) | 1
        
        let backgroundColor: Pixel_8
        if let bg = edgeMode.backgroundColor {
            backgroundColor = bg
        } else {
            backgroundColor = 0
        }
        
        for i in 0 ..< Format.planeCount {
            
            precondition(self.vImageBuffers[i].data != destination.vImageBuffers[i].data,
                         "Source and destination buffers must point to different underlying memory.")
            
            withUnsafePointer(to: self.vImageBuffers[i]) { srcPtr in
                withUnsafePointer(to: destination.vImageBuffers[i]) { destPtr in
                    _ = vImageBoxConvolve_Planar8(srcPtr, destPtr,
                                                  nil,
                                                  0, 0,
                                                  blurHeight, blurWidth,
                                                  backgroundColor,
                                                  edgeMode.vImageFlags)
                }
            }
        }
    }
  @inlinable public func tentConvolve(kernelSize: Accelerate.vImage.Size, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_8>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")

        let blurWidth = UInt32(kernelSize.width) | 1
        let blurHeight = UInt32(kernelSize.height) | 1
        
        let backgroundColor: Pixel_8
        if let bg = edgeMode.backgroundColor {
            backgroundColor = bg
        } else {
            backgroundColor = 0
        }
        
        for i in 0 ..< Format.planeCount {
            
            precondition(self.vImageBuffers[i].data != destination.vImageBuffers[i].data,
                         "Source and destination buffers must point to different underlying memory.")
            
            withUnsafePointer(to: self.vImageBuffers[i]) { srcPtr in
                withUnsafePointer(to: destination.vImageBuffers[i]) { destPtr in
                    _ = vImageTentConvolve_Planar8(srcPtr, destPtr,
                                                   nil,
                                                   0, 0,
                                                   blurHeight, blurWidth,
                                                   backgroundColor,
                                                   edgeMode.vImageFlags)
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public struct ConvolutionKernel2D<ComponentType> {
    public let width: Accelerate.vImagePixelCount
    public let height: Accelerate.vImagePixelCount
    public let values: [ComponentType]
    public init(values: [ComponentType], width: Swift.Int, height: Swift.Int)
    public init(values: [ComponentType], size: Accelerate.vImage.Size)
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func convolve(with kernel: Accelerate.vImage.ConvolutionKernel2D<Swift.Int16>, divisor: Swift.Int32?, bias: Swift.Int32? = nil, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_8888>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let div = divisor ?? kernel.values.map { Int32($0) }.reduce(0, +)
        let backgroundColor: [Pixel_8]
        if let bg = edgeMode.backgroundColor {
            backgroundColor = [bg.0, bg.1, bg.2, bg.3]
        } else {
            backgroundColor = []
        }
        
        self._convolve(kernel: kernel,
                       divisor: div,
                       bias: bias,
                       backgroundColor: backgroundColor,
                       flags: edgeMode.vImageFlags,
                       destination: destination,
                       convolveFunc: vImageConvolve_ARGB8888,
                       convolveWithBiasFunc: vImageConvolveWithBias_ARGB8888)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func convolve(with kernel: Accelerate.vImage.ConvolutionKernel2D<Swift.Int16>, divisor: Swift.Int32?, bias: Swift.Int32? = nil, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_8>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let div = divisor ?? kernel.values.map { Int32($0) }.reduce(0, +)
        let backgroundColor: Pixel_8
        if let bg = edgeMode.backgroundColor {
            backgroundColor = bg
        } else {
            backgroundColor = 0
        }
        
        self._convolve(kernel: kernel,
                       divisor: div,
                       bias: bias,
                       backgroundColor: backgroundColor,
                       flags: edgeMode.vImageFlags,
                       destination: destination,
                       convolveFunc: vImageConvolve_Planar8,
                       convolveWithBiasFunc: vImageConvolveWithBias_Planar8)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.UInt8 {
  @inlinable public func convolve(with kernel: Accelerate.vImage.ConvolutionKernel2D<Swift.Int16>, divisor: Swift.Int32?, bias: Swift.Int32? = nil, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_8>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let div = divisor ?? kernel.values.map { Int32($0) }.reduce(0, +)
        let backgroundColor: Pixel_8
        if let bg = edgeMode.backgroundColor {
            backgroundColor = bg
        } else {
            backgroundColor = 0
        }
        
        for i in 0 ..< Format.planeCount {
            
            let src = self[i] as vImage.PixelBuffer<Format.PlanarPixelFormat>
            let dest = destination[i] as vImage.PixelBuffer<Format.PlanarPixelFormat>
            
            src._convolve(kernel: kernel,
                          divisor: div,
                          bias: bias,
                          backgroundColor: backgroundColor,
                          flags: edgeMode.vImageFlags,
                          destination: dest,
                          convolveFunc: vImageConvolve_Planar8,
                          convolveWithBiasFunc: vImageConvolveWithBias_Planar8)
            
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func convolve(with kernel: Accelerate.vImage.ConvolutionKernel2D<Swift.Float>, bias: Swift.Float? = nil, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_FFFF>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let backgroundColor: [Pixel_F]
        if let bg = edgeMode.backgroundColor {
            backgroundColor = [bg.0, bg.1, bg.2, bg.3]
        } else {
            backgroundColor = []
        }
        
        self._convolve(kernel: kernel,
                       divisor: Float(),
                       bias: bias,
                       backgroundColor: backgroundColor,
                       flags: edgeMode.vImageFlags,
                       destination: destination,
                       convolveFunc: vImageConvolve_ARGBFFFF_wrapper,
                       convolveWithBiasFunc: vImageConvolveWithBias_ARGBFFFF_wrapper)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func convolve(with kernel: Accelerate.vImage.ConvolutionKernel2D<Swift.Float>, bias: Swift.Float? = nil, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_F>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let backgroundColor: Pixel_F
        if let bg = edgeMode.backgroundColor {
            backgroundColor = bg
        } else {
            backgroundColor = 0
        }
        
        self._convolve(kernel: kernel,
                       divisor: Float(),
                       bias: bias,
                       backgroundColor: backgroundColor,
                       flags: edgeMode.vImageFlags,
                       destination: destination,
                       convolveFunc: vImageConvolve_PlanarF_wrapper,
                       convolveWithBiasFunc: vImageConvolveWithBias_PlanarF_wrapper)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx4 {
  @inlinable public func convolve(with kernel: Accelerate.vImage.ConvolutionKernel2D<Swift.Float>, bias: Swift.Float? = nil, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_ARGB_16F>, useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let kernelWidth = kernel.width
        let kernelHeight = kernel.height
        
        let backgroundColor: [Pixel_16F]
        if let bg = edgeMode.backgroundColor {
            backgroundColor = [bg.0, bg.1, bg.2, bg.3]
        } else {
            backgroundColor = []
        }
        
        let accumulatorFlag = useFloat16Accumulator ? vImage_Flags(kvImageUseFP16Accumulator) : 0
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                if let bias = bias {
                    _ = vImageConvolveWithBias_ARGB16F(srcPtr,
                                                       destPtr,
                                                       nil,
                                                       0, 0,
                                                       kernel.values,
                                                       UInt32(kernelHeight),
                                                       UInt32(kernelWidth),
                                                       bias,
                                                       backgroundColor,
                                                       edgeMode.vImageFlags | accumulatorFlag)
                } else {
                    _ = vImageConvolve_ARGB16F(srcPtr,
                                               destPtr,
                                               nil,
                                               0, 0,
                                               kernel.values,
                                               UInt32(kernelHeight),
                                               UInt32(kernelWidth),
                                               backgroundColor,
                                               edgeMode.vImageFlags | accumulatorFlag)
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16F {
  @inlinable public func convolve(with kernel: Accelerate.vImage.ConvolutionKernel2D<Swift.Float>, bias: Swift.Float? = nil, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_16F>, useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let accumulatorFlag = useFloat16Accumulator ? vImage_Flags(kvImageUseFP16Accumulator) : 0
        
        let kernelWidth = kernel.width
        let kernelHeight = kernel.height
        
        let backgroundColor: Pixel_16F
        if let bg = edgeMode.backgroundColor {
            backgroundColor = bg
        } else {
            backgroundColor = 0
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                if let bias = bias {
                    _ = vImageConvolveWithBias_Planar16F(srcPtr,
                                                         destPtr,
                                                         nil,
                                                         0, 0,
                                                         kernel.values,
                                                         UInt32(kernelHeight),
                                                         UInt32(kernelWidth),
                                                         bias,
                                                         backgroundColor,
                                                         edgeMode.vImageFlags | accumulatorFlag)
                } else {
                    _ = vImageConvolve_Planar16F(srcPtr,
                                                 destPtr,
                                                 nil,
                                                 0, 0,
                                                 kernel.values,
                                                 UInt32(kernelHeight),
                                                 UInt32(kernelWidth),
                                                 backgroundColor,
                                                 edgeMode.vImageFlags | accumulatorFlag)
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.Float {
  @inlinable public func convolve(with kernel: Accelerate.vImage.ConvolutionKernel2D<Swift.Float>, bias: Swift.Float? = nil, edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_F>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let backgroundColor: Pixel_F
        if let bg = edgeMode.backgroundColor {
            backgroundColor = bg
        } else {
            backgroundColor = 0
        }
        
        for i in 0 ..< Format.planeCount {
            
            let src = self[i] as vImage.PixelBuffer<Format.PlanarPixelFormat>
            let dest = destination[i] as vImage.PixelBuffer<Format.PlanarPixelFormat>
            
            src._convolve(kernel: kernel,
                          divisor: Float(),
                          bias: bias,
                          backgroundColor: backgroundColor,
                          flags: edgeMode.vImageFlags,
                          destination: dest,
                          convolveFunc: vImageConvolve_PlanarF_wrapper,
                          convolveWithBiasFunc: vImageConvolveWithBias_PlanarF_wrapper)
            
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  @usableFromInline
  internal typealias ConvolveFunc<K, BIAS_DIVISOR, BG> = (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutableRawPointer?, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Swift.UnsafePointer<K>?, Swift.UInt32, Swift.UInt32, BIAS_DIVISOR, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal typealias ConvolveWithBiasFunc<K, BIAS_DIVISOR, BG> = (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutableRawPointer?, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Swift.UnsafePointer<K>?, Swift.UInt32, Swift.UInt32, BIAS_DIVISOR, BIAS_DIVISOR, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal func _convolve<T, K, BIAS_DIVISOR, BG>(kernel: Accelerate.vImage.ConvolutionKernel2D<K>, divisor: BIAS_DIVISOR, bias: BIAS_DIVISOR? = nil, backgroundColor: BG, flags: Accelerate.vImage_Flags, destination: Accelerate.vImage.PixelBuffer<T>, convolveFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutableRawPointer?, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Swift.UnsafePointer<K>?, Swift.UInt32, Swift.UInt32, BIAS_DIVISOR, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error, convolveWithBiasFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutableRawPointer?, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Swift.UnsafePointer<K>?, Swift.UInt32, Swift.UInt32, BIAS_DIVISOR, BIAS_DIVISOR, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error) where T : Accelerate.StaticPixelFormat
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format.ComponentType == Swift.Float {
  @usableFromInline
  internal func vImageConvolve_ARGBFFFF_wrapper(_ src: Swift.UnsafePointer<Accelerate.vImage_Buffer>, _ dest: Swift.UnsafePointer<Accelerate.vImage_Buffer>, _ tempBuffer: Swift.UnsafeMutableRawPointer!, _ srcOffsetToROI_X: Accelerate.vImagePixelCount, _ srcOffsetToROI_Y: Accelerate.vImagePixelCount, _ kernel: Swift.UnsafePointer<Swift.Float>!, _ kernel_height: Swift.UInt32, _ kernel_width: Swift.UInt32, unusedDivisor: Swift.Float, _ backgroundColor: Swift.UnsafePointer<Swift.Float>!, _ flags: Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal func vImageConvolveWithBias_ARGBFFFF_wrapper(_ src: Swift.UnsafePointer<Accelerate.vImage_Buffer>, _ dest: Swift.UnsafePointer<Accelerate.vImage_Buffer>, _ tempBuffer: Swift.UnsafeMutableRawPointer!, _ srcOffsetToROI_X: Accelerate.vImagePixelCount, _ srcOffsetToROI_Y: Accelerate.vImagePixelCount, _ kernel: Swift.UnsafePointer<Swift.Float>!, _ kernel_height: Swift.UInt32, _ kernel_width: Swift.UInt32, unusedDivisor: Swift.Float, _ bias: Swift.Float, _ backgroundColor: Swift.UnsafePointer<Swift.Float>!, _ flags: Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal func vImageConvolve_PlanarF_wrapper(_ src: Swift.UnsafePointer<Accelerate.vImage_Buffer>, _ dest: Swift.UnsafePointer<Accelerate.vImage_Buffer>, _ tempBuffer: Swift.UnsafeMutableRawPointer!, _ srcOffsetToROI_X: Accelerate.vImagePixelCount, _ srcOffsetToROI_Y: Accelerate.vImagePixelCount, _ kernel: Swift.UnsafePointer<Swift.Float>!, _ kernel_height: Swift.UInt32, _ kernel_width: Swift.UInt32, unusedDivisor: Swift.Float, _ backgroundColor: Swift.Float!, _ flags: Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal func vImageConvolveWithBias_PlanarF_wrapper(_ src: Swift.UnsafePointer<Accelerate.vImage_Buffer>, _ dest: Swift.UnsafePointer<Accelerate.vImage_Buffer>, _ tempBuffer: Swift.UnsafeMutableRawPointer!, _ srcOffsetToROI_X: Accelerate.vImagePixelCount, _ srcOffsetToROI_Y: Accelerate.vImagePixelCount, _ kernel: Swift.UnsafePointer<Swift.Float>!, _ kernel_height: Swift.UInt32, _ kernel_width: Swift.UInt32, unusedDivisor: Swift.Float, _ bias: Swift.Float, _ backgroundColor: Swift.Float!, _ flags: Accelerate.vImage_Flags) -> Accelerate.vImage_Error
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  public func convolve(with kernels: (Accelerate.vImage.ConvolutionKernel2D<Swift.Int16>, Accelerate.vImage.ConvolutionKernel2D<Swift.Int16>, Accelerate.vImage.ConvolutionKernel2D<Swift.Int16>, Accelerate.vImage.ConvolutionKernel2D<Swift.Int16>), divisors: (Swift.Int32, Swift.Int32, Swift.Int32, Swift.Int32)?, biases: (Swift.Int32, Swift.Int32, Swift.Int32, Swift.Int32) = (0, 0, 0, 0), edgeMode: Accelerate.vImage.EdgeMode<Accelerate.Pixel_8888>, destination: Accelerate.vImage.PixelBuffer<Format>)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public enum EdgeMode<PixelType> {
    case copyInPlace
    case truncateKernel
    case fill(backgroundColor: PixelType)
    case extend
    @usableFromInline
    internal var vImageFlags: Accelerate.vImage_Flags {
      get
    }
    @usableFromInline
    internal var backgroundColor: PixelType? {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16F {
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar16U>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
    
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                _ = vImageConvert_16Fto16U(srcPtr,
                                           destPtr,
                                           vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                _ = vImageConvert_Planar16FtoPlanar8(srcPtr,
                                                     destPtr,
                                                     vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                _ = vImageConvert_Planar16FtoPlanarF(srcPtr,
                                                     destPtr,
                                                     vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func add<U>(_ scalar: Swift.Float, _ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(scalar,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<U, V>(_ scalar: Swift.Float, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsadd(v.baseAddress!, 1,
                                   s,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func add<U>(_ scalar: Swift.Double, _ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(scalar,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<U, V>(_ scalar: Swift.Double, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsaddD(v.baseAddress!, 1,
                                    s,
                                    r.baseAddress!, 1,
                                    vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                add(vectorA,
                    vectorB,
                    result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vadd(a.baseAddress!, 1,
                                  b.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                add(vectorA,
                    vectorB,
                    result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vaddD(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func subtract<T, U>(_ vectorA: U, _ vectorB: T) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                subtract(vectorA,
                         vectorB,
                         result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func subtract<T, U, V>(_ vectorA: U, _ vectorB: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                vectorB.withUnsafeBufferPointer { b in
                    vectorA.withUnsafeBufferPointer { a in
                        vDSP_vsub(b.baseAddress!, 1,
                                  a.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func subtract<T, U>(_ vectorA: U, _ vectorB: T) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                subtract(vectorA,
                         vectorB,
                         result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func subtract<T, U, V>(_ vectorA: U, _ vectorB: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                vectorB.withUnsafeBufferPointer { b in
                    vectorA.withUnsafeBufferPointer { a in
                        vDSP_vsubD(b.baseAddress!, 1,
                                   a.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func multiply<U>(_ scalar: Swift.Float, _ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(scalar,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<U, V>(_ scalar: Swift.Float, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsmul(v.baseAddress!, 1,
                                   s,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func multiply<U>(_ scalar: Swift.Double, _ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(scalar,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<U, V>(_ scalar: Swift.Double, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsmulD(v.baseAddress!, 1,
                                    s,
                                    r.baseAddress!, 1,
                                    vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                multiply(vectorA,
                         vectorB,
                         result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmul(a.baseAddress!, 1,
                                  b.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                multiply(vectorA,
                         vectorB,
                         result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmulD(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<U>(_ vector: U, _ scalar: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                divide(vector,
                       scalar,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func divide<U, V>(_ vector: U, _ scalar: Swift.Float, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsdiv(v.baseAddress!, 1,
                                   [scalar],
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<U>(_ vector: U, _ scalar: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                divide(vector,
                       scalar,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func divide<U, V>(_ vector: U, _ scalar: Swift.Double, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsdivD(v.baseAddress!, 1,
                                    s,
                                    r.baseAddress!, 1,
                                    vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<U>(_ scalar: Swift.Float, _ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                divide(scalar,
                       vector,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func divide<U, V>(_ scalar: Swift.Float, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_svdiv(s,
                                   v.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<U>(_ scalar: Swift.Double, _ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                divide(scalar,
                       vector,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func divide<U, V>(_ scalar: Swift.Double, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_svdivD(s,
                                    v.baseAddress!, 1,
                                    r.baseAddress!, 1,
                                    vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                divide(vectorA,
                       vectorB,
                       result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func divide<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vdiv(b.baseAddress!, 1,
                                  a.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                divide(vectorA,
                       vectorB,
                       result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func divide<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vdivD(b.baseAddress!, 1,
                                   a.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func addSubtract<S, T, U, V>(_ vectorA: S, _ vectorB: T, addResult: inout U, subtractResult: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateMutableBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = addResult.count
            precondition(vectorA.count == n &&
                vectorB.count == n &&
                subtractResult.count == n)
            
            addResult.withUnsafeMutableBufferPointer { o0 in
                subtractResult.withUnsafeMutableBufferPointer { o1 in
                    vectorA.withUnsafeBufferPointer { i1 in
                        vectorB.withUnsafeBufferPointer { i0 in
                            vDSP_vaddsub(i0.baseAddress!, 1,
                                         i1.baseAddress!, 1,
                                         o0.baseAddress!, 1,
                                         o1.baseAddress!, 1,
                                         vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func addSubtract<S, T, U, V>(_ vectorA: S, _ vectorB: T, addResult: inout U, subtractResult: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateMutableBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = addResult.count
            precondition(vectorA.count == n &&
                vectorB.count == n &&
                subtractResult.count == n)
            
            addResult.withUnsafeMutableBufferPointer { o0 in
                subtractResult.withUnsafeMutableBufferPointer { o1 in
                    vectorA.withUnsafeBufferPointer { i1 in
                        vectorB.withUnsafeBufferPointer { i0 in
                            vDSP_vaddsubD(i0.baseAddress!, 1,
                                          i1.baseAddress!, 1,
                                          o0.baseAddress!, 1,
                                          o1.baseAddress!, 1,
                                          vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(addition: (a: T, b: U), _ scalar: Swift.Float) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: addition.a.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         scalar,
                         result: &buffer)
                
                initializedCount = addition.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(addition: (a: T, b: U), _ scalar: Swift.Float, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vasm(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      s,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(addition: (a: T, b: U), _ scalar: Swift.Double) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: addition.a.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         scalar,
                         result: &buffer)
                
                initializedCount = addition.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(addition: (a: T, b: U), _ scalar: Swift.Double, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vasmD(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       s,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(addition: (a: S, b: T), _ vector: U) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(addition: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vam(a.baseAddress!, 1,
                                     b.baseAddress!, 1,
                                     c.baseAddress!, 1,
                                     r.baseAddress!, 1,
                                     vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(addition: (a: S, b: T), _ vector: U) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(addition: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vamD(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(subtraction: (a: T, b: U), _ scalar: Swift.Float) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: subtraction.a.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtraction,
                         scalar,
                         result: &buffer)
                
                initializedCount = subtraction.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(subtraction: (a: T, b: U), _ scalar: Swift.Float, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(subtraction.a.count == n &&
                subtraction.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtraction.a.withUnsafeBufferPointer { a in
                    subtraction.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vsbsm(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       s,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(subtraction: (a: T, b: U), _ scalar: Swift.Double) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: subtraction.a.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtraction,
                         scalar,
                         result: &buffer)
                
                initializedCount = subtraction.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(subtraction: (a: T, b: U), _ scalar: Swift.Double, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(subtraction.a.count == n &&
                subtraction.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtraction.a.withUnsafeBufferPointer { a in
                    subtraction.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vsbsmD(a.baseAddress!, 1,
                                        b.baseAddress!, 1,
                                        s,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(subtraction: (a: S, b: T), _ vector: U) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtraction,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(subtraction: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(subtraction.a.count == n &&
                subtraction.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtraction.a.withUnsafeBufferPointer { a in
                    subtraction.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vsbm(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(subtraction: (a: S, b: T), _ vector: U) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtraction,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(subtraction: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(subtraction.a.count == n &&
                subtraction.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtraction.a.withUnsafeBufferPointer { a in
                    subtraction.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vsbmD(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       c.baseAddress!, 1,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication: (a: T, b: U), _ scalar: Swift.Float) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplication.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    scalar,
                    result: &buffer)
                
                initializedCount = multiplication.a.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication: (a: T, b: U), _ scalar: Swift.Float, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vmsa(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      s,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication: (a: T, b: U), _ scalar: Swift.Double) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplication.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    scalar,
                    result: &buffer)
                
                initializedCount = multiplication.a.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication: (a: T, b: U), _ scalar: Swift.Double, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vmsaD(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       s,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication: (a: T, b: Swift.Float), _ vector: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication: (a: T, b: Swift.Float), _ vector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    vector.withUnsafeBufferPointer { c in
                        withUnsafePointer(to: multiplication.b) { b in
                            vDSP_vsma(a.baseAddress!, 1,
                                      b,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication: (a: T, b: Swift.Double), _ vector: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication: (a: T, b: Swift.Double), _ vector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    vector.withUnsafeBufferPointer { c in
                        withUnsafePointer(to: multiplication.b) { b in
                            vDSP_vsmaD(a.baseAddress!, 1,
                                       b,
                                       c.baseAddress!, 1,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<S, T, U>(multiplication: (a: S, b: T), _ vector: U) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<S, T, U, V>(multiplication: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vma(a.baseAddress!, 1,
                                     b.baseAddress!, 1,
                                     c.baseAddress!, 1,
                                     r.baseAddress!, 1,
                                     vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<S, T, U>(multiplication: (a: S, b: T), _ vector: U) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<S, T, U, V>(multiplication: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vmaD(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<S, T, U>(multiplication: (a: T, b: U), _ vector: S) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplication,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func subtract<S, T, U, V>(multiplication: (a: T, b: U), _ vector: S, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vmsb(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<S, T, U>(multiplication: (a: T, b: U), _ vector: S) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplication,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func subtract<S, T, U, V>(multiplication: (a: T, b: U), _ vector: S, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vmsbD(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       c.baseAddress!, 1,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication multiplicationAB: (a: T, b: Swift.Float), multiplication multiplicationCD: (c: U, d: Swift.Float)) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplicationAB,
                    multiplication: multiplicationCD,
                    result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication multiplicationAB: (a: T, b: Swift.Float), multiplication multiplicationCD: (c: U, d: Swift.Float), result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationCD.c.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationCD.c.withUnsafeBufferPointer { c in
                        withUnsafePointer(to: multiplicationAB.b) { b in
                            withUnsafePointer(to: multiplicationCD.d) { d in
                                vDSP_vsmsma(a.baseAddress!, 1,
                                            b,
                                            c.baseAddress!, 1,
                                            d,
                                            r.baseAddress!, 1,
                                            vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication multiplicationAB: (a: T, b: Swift.Double), multiplication multiplicationCD: (c: U, d: Swift.Double)) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplicationAB,
                    multiplication: multiplicationCD,
                    result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication multiplicationAB: (a: T, b: Swift.Double), multiplication multiplicationCD: (c: U, d: Swift.Double), result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationCD.c.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationCD.c.withUnsafeBufferPointer { c in
                        withUnsafePointer(to: multiplicationAB.b) { b in
                            withUnsafePointer(to: multiplicationCD.d) { d in
                                vDSP_vsmsmaD(a.baseAddress!, 1,
                                             b,
                                             c.baseAddress!, 1,
                                             d,
                                             r.baseAddress!, 1,
                                             vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func add<R, S, T, U>(multiplication multiplicationAB: (a: R, b: S), multiplication multiplicationCD: (c: T, d: U)) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplicationAB,
                    multiplication: multiplicationCD,
                    result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func add<R, S, T, U, V>(multiplication multiplicationAB: (a: R, b: S), multiplication multiplicationCD: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationAB.b.count == n &&
                multiplicationCD.c.count == n &&
                multiplicationCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationAB.b.withUnsafeBufferPointer { b in
                        multiplicationCD.c.withUnsafeBufferPointer { c in
                            multiplicationCD.d.withUnsafeBufferPointer { d in
                                vDSP_vmma(a.baseAddress!, 1,
                                          b.baseAddress!, 1,
                                          c.baseAddress!, 1,
                                          d.baseAddress!, 1,
                                          r.baseAddress!, 1,
                                          vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func add<R, S, T, U>(multiplication multiplicationAB: (a: R, b: S), multiplication multiplicationCD: (c: T, d: U)) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplicationAB,
                    multiplication: multiplicationCD,
                    result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func add<R, S, T, U, V>(multiplication multiplicationAB: (a: R, b: S), multiplication multiplicationCD: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationAB.b.count == n &&
                multiplicationCD.c.count == n &&
                multiplicationCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationAB.b.withUnsafeBufferPointer { b in
                        multiplicationCD.c.withUnsafeBufferPointer { c in
                            multiplicationCD.d.withUnsafeBufferPointer { d in
                                vDSP_vmmaD(a.baseAddress!, 1,
                                           b.baseAddress!, 1,
                                           c.baseAddress!, 1,
                                           d.baseAddress!, 1,
                                           r.baseAddress!, 1,
                                           vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(addition additionAB: (a: S, b: T), addition additionCD: (c: U, d: U)) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: additionAB.a.count) {
                buffer, initializedCount in
                
                multiply(addition: additionAB,
                         addition: additionCD,
                         result: &buffer)
                
                initializedCount = additionAB.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(addition additionAB: (a: S, b: T), addition additionCD: (c: U, d: U), result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(additionAB.a.count == n &&
                additionAB.b.count == n &&
                additionCD.c.count == n &&
                additionCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                additionAB.a.withUnsafeBufferPointer { a in
                    additionAB.b.withUnsafeBufferPointer { b in
                        additionCD.c.withUnsafeBufferPointer { c in
                            additionCD.d.withUnsafeBufferPointer { d in
                                vDSP_vaam(a.baseAddress!, 1,
                                          b.baseAddress!, 1,
                                          c.baseAddress!, 1,
                                          d.baseAddress!, 1,
                                          r.baseAddress!, 1,
                                          vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(addition additionAB: (a: S, b: T), addition additionCD: (c: U, d: U)) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: additionAB.a.count) {
                buffer, initializedCount in
                
                multiply(addition: additionAB,
                         addition: additionCD,
                         result: &buffer)
                
                initializedCount = additionAB.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(addition additionAB: (a: S, b: T), addition additionCD: (c: U, d: U), result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(additionAB.a.count == n &&
                additionAB.b.count == n &&
                additionCD.c.count == n &&
                additionCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                additionAB.a.withUnsafeBufferPointer { a in
                    additionAB.b.withUnsafeBufferPointer { b in
                        additionCD.c.withUnsafeBufferPointer { c in
                            additionCD.d.withUnsafeBufferPointer { d in
                                vDSP_vaamD(a.baseAddress!, 1,
                                           b.baseAddress!, 1,
                                           c.baseAddress!, 1,
                                           d.baseAddress!, 1,
                                           r.baseAddress!, 1,
                                           vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<R, S, T, U>(multiplication multiplicationAB: (a: T, b: U), multiplication multiplicationCD: (c: R, d: S)) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplicationAB,
                         multiplication: multiplicationCD,
                         result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func subtract<R, S, T, U, V>(multiplication multiplicationAB: (a: T, b: U), multiplication multiplicationCD: (c: R, d: S), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationAB.b.count == n &&
                multiplicationCD.c.count == n &&
                multiplicationCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationAB.b.withUnsafeBufferPointer { b in
                        multiplicationCD.c.withUnsafeBufferPointer { c in
                            multiplicationCD.d.withUnsafeBufferPointer { d in
                                vDSP_vmmsb(a.baseAddress!, 1,
                                           b.baseAddress!, 1,
                                           c.baseAddress!, 1,
                                           d.baseAddress!, 1,
                                           r.baseAddress!, 1,
                                           vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<R, S, T, U>(multiplication multiplicationAB: (a: T, b: U), multiplication multiplicationCD: (c: R, d: S)) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplicationAB,
                         multiplication: multiplicationCD,
                         result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func subtract<R, S, T, U, V>(multiplication multiplicationAB: (a: T, b: U), multiplication multiplicationCD: (c: R, d: S), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationAB.b.count == n &&
                multiplicationCD.c.count == n &&
                multiplicationCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationAB.b.withUnsafeBufferPointer { b in
                        multiplicationCD.c.withUnsafeBufferPointer { c in
                            multiplicationCD.d.withUnsafeBufferPointer { d in
                                vDSP_vmmsbD(a.baseAddress!, 1,
                                            b.baseAddress!, 1,
                                            c.baseAddress!, 1,
                                            d.baseAddress!, 1,
                                            r.baseAddress!, 1,
                                            vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<R, S, T, U>(subtraction subtractionAB: (a: R, b: S), subtraction subtractionCD: (c: T, d: U)) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: subtractionAB.a.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtractionAB,
                         subtraction: subtractionCD,
                         result: &buffer)
                
                initializedCount = subtractionAB.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<R, S, T, U, V>(subtraction subtractionAB: (a: R, b: S), subtraction subtractionCD: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(subtractionAB.a.count == n &&
                subtractionAB.b.count == n &&
                subtractionCD.c.count == n &&
                subtractionCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtractionAB.a.withUnsafeBufferPointer { a in
                    subtractionAB.b.withUnsafeBufferPointer { b in
                        subtractionCD.c.withUnsafeBufferPointer { c in
                            subtractionCD.d.withUnsafeBufferPointer { d in
                                vDSP_vsbsbm(a.baseAddress!, 1,
                                            b.baseAddress!, 1,
                                            c.baseAddress!, 1,
                                            d.baseAddress!, 1,
                                            r.baseAddress!, 1,
                                            vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<R, S, T, U>(subtraction subtractionAB: (a: R, b: S), subtraction subtractionCD: (c: T, d: U)) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: subtractionAB.a.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtractionAB,
                         subtraction: subtractionCD,
                         result: &buffer)
                
                initializedCount = subtractionAB.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<R, S, T, U, V>(subtraction subtractionAB: (a: R, b: S), subtraction subtractionCD: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(subtractionAB.a.count == n &&
                subtractionAB.b.count == n &&
                subtractionCD.c.count == n &&
                subtractionCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtractionAB.a.withUnsafeBufferPointer { a in
                    subtractionAB.b.withUnsafeBufferPointer { b in
                        subtractionCD.c.withUnsafeBufferPointer { c in
                            subtractionCD.d.withUnsafeBufferPointer { d in
                                vDSP_vsbsbmD(a.baseAddress!, 1,
                                             b.baseAddress!, 1,
                                             c.baseAddress!, 1,
                                             d.baseAddress!, 1,
                                             r.baseAddress!, 1,
                                             vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<R, S, T, U>(addition: (a: R, b: S), subtraction: (c: T, d: U)) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: addition.a.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         subtraction: subtraction,
                         result: &buffer)
                
                initializedCount = addition.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<R, S, T, U, V>(addition: (a: R, b: S), subtraction: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n &&
                subtraction.c.count == n &&
                subtraction.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        subtraction.c.withUnsafeBufferPointer { c in
                            subtraction.d.withUnsafeBufferPointer { d in
                                vDSP_vasbm(a.baseAddress!, 1,
                                           b.baseAddress!, 1,
                                           c.baseAddress!, 1,
                                           d.baseAddress!, 1,
                                           r.baseAddress!, 1,
                                           vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<R, S, T, U>(addition: (a: R, b: S), subtraction: (c: T, d: U)) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: addition.a.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         subtraction: subtraction,
                         result: &buffer)
                
                initializedCount = addition.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<R, S, T, U, V>(addition: (a: R, b: S), subtraction: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n &&
                subtraction.c.count == n &&
                subtraction.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        subtraction.c.withUnsafeBufferPointer { c in
                            subtraction.d.withUnsafeBufferPointer { d in
                                vDSP_vasbmD(a.baseAddress!, 1,
                                            b.baseAddress!, 1,
                                            c.baseAddress!, 1,
                                            d.baseAddress!, 1,
                                            r.baseAddress!, 1,
                                            vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func add<U>(multiplication: (a: U, b: Swift.Float), _ scalar: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplication.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    scalar,
                    result: &buffer)
                
                initializedCount =  multiplication.a.count
            }
            
            return result
    }
  @inlinable public static func add<U, V>(multiplication: (a: U, b: Swift.Float), _ scalar: Swift.Float, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            let n = result.count
            precondition(multiplication.a.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    withUnsafePointer(to: multiplication.b) { b in
                        withUnsafePointer(to: scalar) { c in
                            vDSP_vsmsa(a.baseAddress!, 1,
                                       b,
                                       c,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<U>(multiplication: (a: U, b: Swift.Double), _ scalar: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplication.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    scalar,
                    result: &buffer)
                
                initializedCount =  multiplication.a.count
            }
            
            return result
    }
  @inlinable public static func add<U, V>(multiplication: (a: U, b: Swift.Double), _ scalar: Swift.Double, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            let n = result.count
            precondition(multiplication.a.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    withUnsafePointer(to: multiplication.b) { b in
                        withUnsafePointer(to: scalar) { c in
                            vDSP_vsmsaD(a.baseAddress!, 1,
                                        b,
                                        c,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<T, U>(multiplication: (a: U, b: Swift.Float), _ vector: T) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplication,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func subtract<T, U, V>(multiplication: (a: U, b: Swift.Float), _ vector: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n)
            precondition(vector.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    withUnsafePointer(to: multiplication.b) { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vsmsb(a.baseAddress!, 1,
                                       b,
                                       c.baseAddress!, 1,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<T, U>(multiplication: (a: U, b: Swift.Double), _ vector: T) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplication,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func subtract<T, U, V>(multiplication: (a: U, b: Swift.Double), _ vector: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n)
            precondition(vector.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    withUnsafePointer(to: multiplication.b) { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vsmsbD(a.baseAddress!, 1,
                                        b,
                                        c.baseAddress!, 1,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public static func applyReduction(_ reductionFunction: Accelerate.BNNS.ReductionFunction, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, weights: Accelerate.BNNSNDArrayDescriptor?, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ReductionLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(function reductionFunction: Accelerate.BNNS.ReductionFunction, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, weights: Accelerate.BNNSNDArrayDescriptor?, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor, generatingWeightsGradient weightsGradient: Accelerate.BNNSNDArrayDescriptor? = nil) throws
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum ReductionFunction {
    case max
    case min
    @available(macOS, deprecated, introduced: 11.0, message: "Use `argMax`.")
    @available(iOS, deprecated, introduced: 14.0, message: "Use `argMax`.")
    @available(watchOS, deprecated, introduced: 7.0, message: "Use `argMax`.")
    @available(tvOS, deprecated, introduced: 14.0, message: "Use `argMax`.")
    @available(*, deprecated, message: "Use `argMax`.")
    case maxIndex
    case argMax
    @available(macOS, deprecated, introduced: 11.0, message: "Use `argMin`.")
    @available(iOS, deprecated, introduced: 14.0, message: "Use `argMin`.")
    @available(watchOS, deprecated, introduced: 7.0, message: "Use `argMin`.")
    @available(tvOS, deprecated, introduced: 14.0, message: "Use `argMin`.")
    @available(*, deprecated, message: "Use `argMin`.")
    case minIndex
    case argMin
    case mean
    case meanNonZero
    case sum
    case sumOfSquares
    case sumOfLogs(epsilon: Swift.Float)
    case sumOfAbsolutes
    case logicalOr
    case any
    case logicalAnd
    case all
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case l2Norm
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case logSumExp
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case product
    public var bnnsReduceFunction: Accelerate.BNNSReduceFunction {
      get
    }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.vImage_Buffer {
  public init(size: CoreFoundation.CGSize, bitsPerPixel: Swift.UInt32) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage_Buffer {
  public var size: CoreFoundation.CGSize {
    get
  }
  public static func preferredAlignmentAndRowBytes(width: Swift.Int, height: Swift.Int, bitsPerPixel: Swift.UInt32) throws -> (alignment: Swift.Int, rowBytes: Swift.Int)
  public init(width: Swift.Int, height: Swift.Int, bitsPerPixel: Swift.UInt32) throws
  public func free()
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage_Buffer {
  public init(cgImage: CoreGraphics.CGImage, flags options: Accelerate.vImage.Options = .noFlags) throws
  public init(cgImage: CoreGraphics.CGImage, format: Accelerate.vImage_CGImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws
  public func createCGImage(format: Accelerate.vImage_CGImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws -> CoreGraphics.CGImage
  public func copy(destinationBuffer: inout Accelerate.vImage_Buffer, pixelSize: Swift.Int, flags options: Accelerate.vImage.Options = .noFlags) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage_PerpsectiveTransform : Swift.Equatable {
  public static func == (lhs: Accelerate.vImage_PerpsectiveTransform, rhs: Accelerate.vImage_PerpsectiveTransform) -> Swift.Bool
  public enum Interpolation {
    case nearest
    case linear
    @usableFromInline
    internal var vImageWarpInterpolation: Accelerate.vImage_WarpInterpolation {
      get
    }
    public static func == (a: Accelerate.vImage_PerpsectiveTransform.Interpolation, b: Accelerate.vImage_PerpsectiveTransform.Interpolation) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public typealias QuadrilateralPoints = (CoreFoundation.CGPoint, CoreFoundation.CGPoint, CoreFoundation.CGPoint, CoreFoundation.CGPoint)
  public init?(source: Accelerate.vImage_PerpsectiveTransform.QuadrilateralPoints, destination: Accelerate.vImage_PerpsectiveTransform.QuadrilateralPoints)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func transform(_ transform: Accelerate.vImage_PerpsectiveTransform, interpolation: Accelerate.vImage_PerpsectiveTransform.Interpolation, backgroundColor: Accelerate.Pixel_8, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                withUnsafePointer(to: transform) { tx in
                    _ = vImagePerspectiveWarp_Planar8(
                        src,
                        dst,
                        nil,
                        tx,
                        interpolation.vImageWarpInterpolation,
                        backgroundColor,
                        vImage_Flags(kvImageBackgroundColorFill))
                }
            }
        }
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16F {
  @inlinable public func transform(_ transform: Accelerate.vImage_PerpsectiveTransform, interpolation: Accelerate.vImage_PerpsectiveTransform.Interpolation, backgroundColor: Accelerate.Pixel_16F, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                withUnsafePointer(to: transform) { tx in
                    _ = vImagePerspectiveWarp_Planar16F(
                        src,
                        dst,
                        nil,
                        tx,
                        interpolation.vImageWarpInterpolation,
                        backgroundColor,
                        vImage_Flags(kvImageBackgroundColorFill))
                }
            }
        }
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16U {
  @inlinable public func transform(_ transform: Accelerate.vImage_PerpsectiveTransform, interpolation: Accelerate.vImage_PerpsectiveTransform.Interpolation, backgroundColor: Accelerate.Pixel_16U, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                withUnsafePointer(to: transform) { tx in
                    _ = vImagePerspectiveWarp_Planar16U(
                        src,
                        dst,
                        nil,
                        tx,
                        interpolation.vImageWarpInterpolation,
                        backgroundColor,
                        vImage_Flags(kvImageBackgroundColorFill))
                }
            }
        }
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func transform(_ transform: Accelerate.vImage_PerpsectiveTransform, interpolation: Accelerate.vImage_PerpsectiveTransform.Interpolation, backgroundColor: Accelerate.Pixel_8888, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                withUnsafePointer(to: transform) { tx in
                    var bg = [backgroundColor.0, backgroundColor.1, backgroundColor.2, backgroundColor.3]
                    _ = vImagePerspectiveWarp_ARGB8888(
                        src,
                        dst,
                        nil,
                        tx,
                        interpolation.vImageWarpInterpolation,
                        &bg,
                        vImage_Flags(kvImageBackgroundColorFill))
                }
            }
        }
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx4 {
  @inlinable public func transform(_ transform: Accelerate.vImage_PerpsectiveTransform, interpolation: Accelerate.vImage_PerpsectiveTransform.Interpolation, backgroundColor: Accelerate.Pixel_ARGB_16F, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                withUnsafePointer(to: transform) { tx in
                    var bg = [backgroundColor.0, backgroundColor.1, backgroundColor.2, backgroundColor.3]
                    _ = vImagePerspectiveWarp_ARGB16F(
                        src,
                        dst,
                        nil,
                        tx,
                        interpolation.vImageWarpInterpolation,
                        &bg,
                        vImage_Flags(kvImageBackgroundColorFill))
                }
            }
        }
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux4 {
  @inlinable public func transform(_ transform: Accelerate.vImage_PerpsectiveTransform, interpolation: Accelerate.vImage_PerpsectiveTransform.Interpolation, backgroundColor: Accelerate.Pixel_ARGB_16U, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.vImageBuffer.data != destination.vImageBuffer.data,
                     "Source and destination buffers must point to different underlying memory.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                withUnsafePointer(to: transform) { tx in
                    var bg = [backgroundColor.0, backgroundColor.1, backgroundColor.2, backgroundColor.3]
                    _ = vImagePerspectiveWarp_ARGB16U(
                        src,
                        dst,
                        nil,
                        tx,
                        interpolation.vImageWarpInterpolation,
                        &bg,
                        vImage_Flags(kvImageBackgroundColorFill))
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  public init(lumaSource: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>, chromaSource: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x2>, conversionInfo: Accelerate.vImage_YpCbCrToARGB)
  public init(planarBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>])
  public init(planarBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>])
  @inlinable public func planarBuffers() -> [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>] {
        
        let componentCount = 4
        
        let buffers: [vImage.PixelBuffer<vImage.Planar8>] = (0 ..< componentCount).map { _ in
            vImage.PixelBuffer(size: size,
                               pixelFormat: vImage.Planar8.self)
            
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: buffers[0].vImageBuffer) { zeroPtr in
                withUnsafePointer(to: buffers[1].vImageBuffer) { onePtr in
                    withUnsafePointer(to: buffers[2].vImageBuffer) { twoPtr in
                        withUnsafePointer(to: buffers[3].vImageBuffer) { threePtr in
                            _ = vImageConvert_ARGB8888toPlanar8(srcPtr,
                                                                zeroPtr,
                                                                onePtr,
                                                                twoPtr,
                                                                threePtr,
                                                                vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
        
        return buffers
    }
  @inlinable public func planarBuffers() -> [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>] {
        
        let componentCount = 4
        
        let buffers: [vImage.PixelBuffer<vImage.PlanarF>] = (0 ..< componentCount).map { _ in
            vImage.PixelBuffer(size: size,
                               pixelFormat: vImage.PlanarF.self)
            
        }
        
        let max: [Float] = [1, 1, 1, 1]
        let min: [Float] = [0, 0, 0, 0]
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: buffers[0].vImageBuffer) { zeroPtr in
                withUnsafePointer(to: buffers[1].vImageBuffer) { onePtr in
                    withUnsafePointer(to: buffers[2].vImageBuffer) { twoPtr in
                        withUnsafePointer(to: buffers[3].vImageBuffer) { threePtr in
                            _ = vImageConvert_ARGB8888toPlanarF(srcPtr,
                                                                zeroPtr,
                                                                onePtr,
                                                                twoPtr,
                                                                threePtr,
                                                                max, min,
                                                                vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
        
        return buffers
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x3>, channelOrdering: Accelerate.vImage.ChannelOrdering) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                switch channelOrdering {
                    case .ARGB:
                        _ = vImageConvert_ARGB8888toRGB888(srcPtr,
                                                           destPtr,
                                                           vImage_Flags(kvImageNoFlags))
                    case .RGBA:
                        _ = vImageConvert_RGBA8888toRGB888(srcPtr,
                                                           destPtr,
                                                           vImage_Flags(kvImageNoFlags))
                        
                    @unknown default:
                        fatalError("Unsupported channel ordering.")
                }
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx4>) {
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSrc = vImage.PixelBuffer(data: self.vImageBuffer.data,
                                         width: self.width * 4,
                                         height: self.height,
                                         byteCountPerRow: self.vImageBuffer.rowBytes,
                                         pixelFormat: vImage.Planar8.self)
        
        let fauxDest = vImage.PixelBuffer(data: destination.vImageBuffer.data,
                                          width: destination.width * 4,
                                          height: destination.height,
                                          byteCountPerRow: destination.vImageBuffer.rowBytes,
                                          pixelFormat: vImage.PlanarF.self)
        
        withUnsafePointer(to: fauxSrc.vImageBuffer) { srcPtr in
            withUnsafePointer(to: fauxDest.vImageBuffer) { destPtr in
                
                _ = vImageConvert_Planar8toPlanarF(srcPtr, destPtr,
                                                   1,
                                                   0,
                                                   vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved16Ux4>) {
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                _ = vImageConvert_ARGB8888ToARGB16U(srcPtr, destPtr,
                                                    [0, 1, 2, 3],
                                                    UInt8(), [0],
                                                    vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved16Fx4>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 4,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        let fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 4,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        
        withUnsafePointer(to: fauxSource) { srcPtr in
            withUnsafePointer(to: fauxDestination) { destPtr in
                
                _ = vImageConvert_Planar8toPlanar16F(srcPtr,
                                                     destPtr,
                                                     vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func convert(lumaSource: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>, chromaSource: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x2>, conversionInfo: Accelerate.vImage_YpCbCrToARGB) {
        
        precondition(lumaSource.width <= self.width && lumaSource.height <= self.height,
                     "`lumaSource` dimensions must not be greater than corresponding source dimensions.")
        precondition(chromaSource.width <= self.width && chromaSource.height <= self.height,
                     "`chromaSource` dimensions must not be greater than corresponding source dimensions.")
        withUnsafePointer(to: self.vImageBuffer) { selfPtr in
            withUnsafePointer(to: chromaSource.vImageBuffer) { chromaPtr in
                withUnsafePointer(to: lumaSource.vImageBuffer) { lumaPtr in
                    withUnsafePointer(to: conversionInfo) { infoPtr in
                        _ = vImageConvert_420Yp8_CbCr8ToARGB8888(lumaPtr,
                                                                 chromaPtr,
                                                                 selfPtr,
                                                                 infoPtr,
                                                                 nil,
                                                                 255,
                                                                 vImage_Flags(kvImageNoFlags))
                    }
                }
            }
        }
    }
  @inlinable public func withCVPixelBuffer(readOnly: Swift.Bool, body: (CoreVideo.CVPixelBuffer) -> Swift.Void) {
        
        var cvPixelBuffer: CVPixelBuffer!
        
        // pixel format type support is limited, see:
        // https://developer.apple.com/library/archive/qa/qa1501/_index.html
        CVPixelBufferCreateWithBytes(nil,
                                     width, height,
                                     kCVPixelFormatType_32BGRA,
                                     vImageBuffer.data,
                                     vImageBuffer.rowBytes,
                                     nil, nil, nil,
                                     &cvPixelBuffer)
        
        let flag = readOnly ? CVPixelBufferLockFlags.readOnly : CVPixelBufferLockFlags(rawValue: 0)
        
        CVPixelBufferLockBaseAddress(cvPixelBuffer!,
                                     flag)
        
        body(cvPixelBuffer)
        
        CVPixelBufferUnlockBaseAddress(cvPixelBuffer!,
                                       flag)
    }
  @inlinable public func interleave(planarSourceBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>]) {
        
        precondition(planarSourceBuffers.count == 4,
                     "`planarSourceBuffers` must contain four buffers.")
        
        precondition((self.size == planarSourceBuffers[0].size) &&
                     (self.size == planarSourceBuffers[1].size) &&
                     (self.size == planarSourceBuffers[2].size) &&
                     (self.size == planarSourceBuffers[3].size),
                     "Source and destination buffers must be the same size.")
        
        planarSourceBuffers[0].withUnsafePointerToVImageBuffer { a in
            planarSourceBuffers[1].withUnsafePointerToVImageBuffer { r in
                planarSourceBuffers[2].withUnsafePointerToVImageBuffer { g in
                    planarSourceBuffers[3].withUnsafePointerToVImageBuffer { b in
                        self.withUnsafePointerToVImageBuffer { rgb in
                            
                            _ = vImageConvert_Planar8toARGB8888(a,
                                                                r,
                                                                g,
                                                                b,
                                                                rgb,
                                                                vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
    }
  @inlinable public func deinterleave(planarDestinationBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>]) {
        
        precondition(planarDestinationBuffers.count == 4,
                     "`planarSourceBuffers` must contain four buffers.")
        
        precondition((self.size == planarDestinationBuffers[0].size) &&
                     (self.size == planarDestinationBuffers[1].size) &&
                     (self.size == planarDestinationBuffers[2].size) &&
                     (self.size == planarDestinationBuffers[3].size),
                     "Source and destination buffers must be the same size.")
        
        planarDestinationBuffers[0].withUnsafePointerToVImageBuffer { a in
            planarDestinationBuffers[1].withUnsafePointerToVImageBuffer { r in
                planarDestinationBuffers[2].withUnsafePointerToVImageBuffer { g in
                    planarDestinationBuffers[3].withUnsafePointerToVImageBuffer { b in
                        self.withUnsafePointerToVImageBuffer { rgb in
                            
                            _ = vImageConvert_ARGB8888toPlanar8(rgb,
                                                                a,
                                                                r,
                                                                g,
                                                                b,
                                                                vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
    }
  @inlinable public func deinterleave(destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8x4>) {
        
        destination.withUnsafePixelBuffers { planarDestinationBuffers in
            
            self.deinterleave(planarDestinationBuffers: planarDestinationBuffers)
            
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x3 {
  public init(planarBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>])
  @inlinable public func planarBuffers() -> [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>] {
        
        let componentCount = 3
        
        let buffers: [vImage.PixelBuffer<vImage.Planar8>] = (0 ..< componentCount).map { _ in
            vImage.PixelBuffer(size: size,
                               pixelFormat: vImage.Planar8.self)
            
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: buffers[0].vImageBuffer) { zeroPtr in
                withUnsafePointer(to: buffers[1].vImageBuffer) { onePtr in
                    withUnsafePointer(to: buffers[2].vImageBuffer) { twoPtr in
                        _ = vImageConvert_RGB888toPlanar8(srcPtr,
                                                          zeroPtr,
                                                          onePtr,
                                                          twoPtr,
                                                          vImage_Flags(kvImageNoFlags))
                    }
                }
            }
        }
        
        return buffers
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx3>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSrc = vImage.PixelBuffer(data: self.vImageBuffer.data,
                                         width: self.width * 3,
                                         height: self.height,
                                         byteCountPerRow: self.vImageBuffer.rowBytes,
                                         pixelFormat: vImage.Planar8.self)
        
        let fauxDest = vImage.PixelBuffer(data: destination.vImageBuffer.data,
                                          width: destination.width * 3,
                                          height: destination.height,
                                          byteCountPerRow: destination.vImageBuffer.rowBytes,
                                          pixelFormat: vImage.PlanarF.self)
        
        withUnsafePointer(to: fauxSrc.vImageBuffer) { srcPtr in
            withUnsafePointer(to: fauxDest.vImageBuffer) { destPtr in
                
                _ = vImageConvert_Planar8toPlanarF(srcPtr, destPtr,
                                                   1,
                                                   0,
                                                   vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func interleave(planarSourceBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>]) {
        
        precondition(planarSourceBuffers.count == 3,
                     "`planarSourceBuffers` must contain three buffers.")
        
        precondition((self.size == planarSourceBuffers[0].size) &&
                     (self.size == planarSourceBuffers[1].size) &&
                     (self.size == planarSourceBuffers[2].size),
                     "Source and destination buffers must be the same size.")
        
        planarSourceBuffers[0].withUnsafePointerToVImageBuffer { r in
            planarSourceBuffers[1].withUnsafePointerToVImageBuffer { g in
                planarSourceBuffers[2].withUnsafePointerToVImageBuffer { b in
                    self.withUnsafePointerToVImageBuffer { rgb in
                        
                        _ = vImageConvert_Planar8toRGB888(r,
                                                          g,
                                                          b,
                                                          rgb,
                                                          vImage_Flags(kvImageNoFlags))
                    }
                }
            }
        }
    }
  @inlinable public func deinterleave(planarDestinationBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>]) {
        
        precondition(planarDestinationBuffers.count == 3,
                     "`planarSourceBuffers` must contain three buffers.")
        
        precondition((self.size == planarDestinationBuffers[0].size) &&
                     (self.size == planarDestinationBuffers[1].size) &&
                     (self.size == planarDestinationBuffers[2].size),
                     "Source and destination buffers must be the same size.")
        
        planarDestinationBuffers[0].withUnsafePointerToVImageBuffer { r in
            planarDestinationBuffers[1].withUnsafePointerToVImageBuffer { g in
                planarDestinationBuffers[2].withUnsafePointerToVImageBuffer { b in
                    self.withUnsafePointerToVImageBuffer { rgb in
                        
                        _ = vImageConvert_RGB888toPlanar8(rgb,
                                                          r,
                                                          g,
                                                          b,
                                                          vImage_Flags(kvImageNoFlags))
                    }
                }
            }
        }
    }
  @inlinable public func deinterleave(destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8x3>) {
        
        destination.withUnsafePixelBuffers { planarDestinationBuffers in
            
            self.deinterleave(planarDestinationBuffers: planarDestinationBuffers)
            
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public enum Rotation {
    case clockwise0Degrees
    case clockwise90Degrees
    case clockwise180Degrees
    case clockwise270Degrees
    case counterClockwise0Degrees
    case counterClockwise90Degrees
    case counterClockwise180Degrees
    case counterClockwise270Degrees
    case angleInRadians(_: Swift.Float)
    case angleInDegrees(_: Swift.Float)
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func rotate(_ rotation: Accelerate.vImage.Rotation, backgroundColor: Accelerate.Pixel_8? = Pixel_8(0), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        _rotate(rotation,
                destination: destination,
                backgroundColor: backgroundColor,
                nullBackgroundColor: Pixel_8(),
                rotateFunc: vImageRotate_Planar8,
                rotate90Func: vImageRotate90_Planar8)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func rotate(_ rotation: Accelerate.vImage.Rotation, backgroundColor: Accelerate.Pixel_8888? = (0, 0, 0, 0), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let bg: [Pixel_8]?
        if let backgroundColor = backgroundColor {
            bg = [backgroundColor.0,
                  backgroundColor.1,
                  backgroundColor.2,
                  backgroundColor.3]
        } else {
            bg = nil
        }
        
        _rotate(rotation,
                destination: destination,
                backgroundColor: bg,
                nullBackgroundColor: [Pixel_8()],
                rotateFunc: vImageRotate_ARGB8888,
                rotate90Func: vImageRotate90_ARGB8888)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux4 {
  @inlinable public func rotate(_ rotation: Accelerate.vImage.Rotation, backgroundColor: Accelerate.Pixel_ARGB_16U? = (0, 0, 0, 0), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let bg: [Pixel_16U]?
        if let backgroundColor = backgroundColor {
            bg = [backgroundColor.0,
                  backgroundColor.1,
                  backgroundColor.2,
                  backgroundColor.3]
        } else {
            bg = nil
        }
        
        _rotate(rotation,
                destination: destination,
                backgroundColor: bg,
                nullBackgroundColor:[Pixel_16U()],
                rotateFunc: vImageRotate_ARGB16U,
                rotate90Func: vImageRotate90_ARGB16U)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func rotate(_ rotation: Accelerate.vImage.Rotation, backgroundColor: Accelerate.Pixel_FFFF? = (0, 0, 0, 0), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let bg: [Pixel_F]?
        if let backgroundColor = backgroundColor {
            bg = [backgroundColor.0,
                  backgroundColor.1,
                  backgroundColor.2,
                  backgroundColor.3]
        } else {
            bg = nil
        }
        
        _rotate(rotation,
                destination: destination,
                backgroundColor: bg,
                nullBackgroundColor: [Pixel_F()],
                rotateFunc: vImageRotate_ARGBFFFF,
                rotate90Func: vImageRotate90_ARGBFFFF)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func rotate(_ rotation: Accelerate.vImage.Rotation, backgroundColor: Accelerate.Pixel_F? = Pixel_F(0), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        _rotate(rotation,
                destination: destination,
                backgroundColor: backgroundColor,
                nullBackgroundColor: Pixel_F(),
                rotateFunc: vImageRotate_PlanarF,
                rotate90Func: vImageRotate90_PlanarF)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16F {
  @inlinable public func rotate(_ rotation: Accelerate.vImage.Rotation, backgroundColor: Accelerate.Pixel_16F? = Pixel_16F(0), useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        _rotate(rotation,
                destination: destination,
                backgroundColor: backgroundColor,
                nullBackgroundColor: Pixel_16F(),
                rotateFunc: vImageRotate_Planar16F,
                rotate90Func: vImageRotate90_Planar16F,
                useFloat16Accumulator: useFloat16Accumulator)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx2 {
  @inlinable public func rotate(_ rotation: Accelerate.vImage.Rotation, backgroundColor: Accelerate.Pixel_16F16F? = (0, 0), useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let bg: [Pixel_16F]?
        if let backgroundColor = backgroundColor {
            bg = [backgroundColor.0,
                  backgroundColor.1]
        } else {
            bg = nil
        }
        
        _rotate(rotation,
                destination: destination,
                backgroundColor: bg,
                nullBackgroundColor: [Pixel_16F()],
                rotateFunc: vImageRotate_CbCr16F,
                rotate90Func: vImageRotate90_CbCr16F,
                useFloat16Accumulator: useFloat16Accumulator)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx4 {
  @inlinable public func rotate(_ rotation: Accelerate.vImage.Rotation, backgroundColor: Accelerate.Pixel_ARGB_16F? = (0, 0, 0, 0), useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let bg: [Pixel_16F]?
        if let backgroundColor = backgroundColor {
            bg = [backgroundColor.0,
                  backgroundColor.1,
                  backgroundColor.2,
                  backgroundColor.3]
        } else {
            bg = nil
        }
        
        _rotate(rotation,
                destination: destination,
                backgroundColor: bg,
                nullBackgroundColor: [Pixel_16F()],
                rotateFunc: vImageRotate_ARGB16F,
                rotate90Func: vImageRotate90_ARGB16F,
                useFloat16Accumulator: useFloat16Accumulator)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  @usableFromInline
  internal typealias RotateFunc<BG> = (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutableRawPointer?, Swift.Float, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal typealias Rotate90Func<BG> = (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UInt8, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal func _rotate<T, BG>(_ rotation: Accelerate.vImage.Rotation, destination: Accelerate.vImage.PixelBuffer<T>, backgroundColor: BG?, nullBackgroundColor: BG, rotateFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutableRawPointer?, Swift.Float, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error, rotate90Func: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UInt8, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error, useFloat16Accumulator: Swift.Bool = false) where T : Accelerate.StaticPixelFormat
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public enum ShearDirection {
    case vertical
    case horizontal
    public static func == (a: Accelerate.vImage.ShearDirection, b: Accelerate.vImage.ShearDirection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x2 {
  @inlinable public func shear(direction: Accelerate.vImage.ShearDirection, translate: Swift.Float, slope: Swift.Float, resamplingFilter: Accelerate.ResamplingFilter, backgroundColor: Accelerate.Pixel_88? = (0, 0), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let bg: [Pixel_8]?
        if let backgroundColor = backgroundColor {
            bg = [backgroundColor.0,
                  backgroundColor.1]
        } else {
            bg = nil
        }
        
        _shear(direction: direction,
               translate: translate,
               slope: slope,
               resamplingFilter: resamplingFilter,
               destination: destination,
               backgroundColor: bg,
               nullBackgroundColor: [Pixel_8()],
               verticalShearFunc: vImageVerticalShear_CbCr8,
               horizontalShearFunc: vImageHorizontalShear_CbCr8)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16U {
  @inlinable public func shear(direction: Accelerate.vImage.ShearDirection, translate: Swift.Float, slope: Swift.Float, resamplingFilter: Accelerate.ResamplingFilter, backgroundColor: Accelerate.Pixel_16U? = Pixel_16U(0), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        _shear(direction: direction,
               translate: translate,
               slope: slope,
               resamplingFilter: resamplingFilter,
               destination: destination,
               backgroundColor: backgroundColor,
               nullBackgroundColor: Pixel_16U(),
               verticalShearFunc: vImageVerticalShear_Planar16U,
               horizontalShearFunc: vImageHorizontalShear_Planar16U)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  @usableFromInline
  internal typealias ShearFunc<BG> = (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Swift.Float, Swift.Float, Accelerate.ResamplingFilter, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal func _shear<T, BG>(direction: Accelerate.vImage.ShearDirection, translate: Swift.Float, slope: Swift.Float, resamplingFilter: Accelerate.ResamplingFilter, destination: Accelerate.vImage.PixelBuffer<T>, backgroundColor: BG?, nullBackgroundColor: BG, verticalShearFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Swift.Float, Swift.Float, Accelerate.ResamplingFilter, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error, horizontalShearFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Swift.Float, Swift.Float, Accelerate.ResamplingFilter, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error, useFloat16Accumulator: Swift.Bool = false) where T : Accelerate.StaticPixelFormat
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux2 {
  @inlinable public func shear<T>(direction: Accelerate.vImage.ShearDirection, translate: T, slope: T, resamplingFilter: Accelerate.ResamplingFilter, backgroundColor: Accelerate.Pixel_16U16U? = (0, 0), destination: Accelerate.vImage.PixelBuffer<Format>) where T : Swift.BinaryFloatingPoint {
            
            let bg: [Pixel_16U]?
            if let backgroundColor = backgroundColor {
                bg = [backgroundColor.0,
                      backgroundColor.1]
            } else {
                bg = nil
            }
            
            _shearD(direction: direction,
                    translate: Double(translate),
                    slope: Double(slope),
                    resamplingFilter: resamplingFilter,
                    destination: destination,
                    backgroundColor: bg,
                    nullBackgroundColor: [Pixel_16U()],
                    verticalShearFunc: vImageVerticalShearD_CbCr16U,
                    horizontalShearFunc: vImageHorizontalShearD_CbCr16U)
        }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func shear<T>(direction: Accelerate.vImage.ShearDirection, translate: T, slope: T, resamplingFilter: Accelerate.ResamplingFilter, backgroundColor: Accelerate.Pixel_8? = Pixel_8(0), destination: Accelerate.vImage.PixelBuffer<Format>) where T : Swift.BinaryFloatingPoint {
            
            _shearD(direction: direction,
                    translate: Double(translate),
                    slope: Double(slope),
                    resamplingFilter: resamplingFilter,
                    destination: destination,
                    backgroundColor: backgroundColor,
                    nullBackgroundColor: Pixel_8(),
                    verticalShearFunc: vImageVerticalShearD_Planar8,
                    horizontalShearFunc: vImageHorizontalShearD_Planar8)
        }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16F {
  @inlinable public func shear<T>(direction: Accelerate.vImage.ShearDirection, translate: T, slope: T, resamplingFilter: Accelerate.ResamplingFilter, backgroundColor: Accelerate.Pixel_16F? = Pixel_16F(0), useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) where T : Swift.BinaryFloatingPoint {
            
            _shearD(direction: direction,
                    translate: Double(translate),
                    slope: Double(slope),
                    resamplingFilter: resamplingFilter,
                    destination: destination,
                    backgroundColor: backgroundColor,
                    nullBackgroundColor: Pixel_16F(),
                    verticalShearFunc: vImageVerticalShearD_Planar16F,
                    horizontalShearFunc: vImageHorizontalShearD_Planar16F,
                    useFloat16Accumulator: useFloat16Accumulator)
        }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx2 {
  @inlinable public func shear<T>(direction: Accelerate.vImage.ShearDirection, translate: T, slope: T, resamplingFilter: Accelerate.ResamplingFilter, backgroundColor: Accelerate.Pixel_16F16F? = (0, 0), useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) where T : Swift.BinaryFloatingPoint {
            
            let bg: [Pixel_16F]?
            if let backgroundColor = backgroundColor {
                bg = [backgroundColor.0,
                      backgroundColor.1]
            } else {
                bg = nil
            }
            
            _shearD(direction: direction,
                    translate: Double(translate),
                    slope: Double(slope),
                    resamplingFilter: resamplingFilter,
                    destination: destination,
                    backgroundColor: bg,
                    nullBackgroundColor: [Pixel_16F()],
                    verticalShearFunc: vImageVerticalShearD_CbCr16F,
                    horizontalShearFunc: vImageHorizontalShearD_CbCr16F,
                    useFloat16Accumulator: useFloat16Accumulator)
        }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func shear<T>(direction: Accelerate.vImage.ShearDirection, translate: T, slope: T, resamplingFilter: Accelerate.ResamplingFilter, backgroundColor: Accelerate.Pixel_8888? = (0, 0, 0, 0), destination: Accelerate.vImage.PixelBuffer<Format>) where T : Swift.BinaryFloatingPoint {
            
            let bg: [Pixel_8]?
            if let backgroundColor = backgroundColor {
                bg = [backgroundColor.0,
                      backgroundColor.1,
                      backgroundColor.2,
                      backgroundColor.3]
            } else {
                bg = nil
            }
            
            _shearD(direction: direction,
                    translate: Double(translate),
                    slope: Double(slope),
                    resamplingFilter: resamplingFilter,
                    destination: destination,
                    backgroundColor: bg,
                    nullBackgroundColor: [Pixel_8()],
                    verticalShearFunc: vImageVerticalShearD_ARGB8888,
                    horizontalShearFunc: vImageHorizontalShearD_ARGB8888)
        }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx4 {
  @inlinable public func shear<T>(direction: Accelerate.vImage.ShearDirection, translate: T, slope: T, resamplingFilter: Accelerate.ResamplingFilter, backgroundColor: Accelerate.Pixel_ARGB_16F? = (0, 0, 0, 0), useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) where T : Swift.BinaryFloatingPoint {
            
            let bg: [Pixel_16F]?
            if let backgroundColor = backgroundColor {
                bg = [backgroundColor.0,
                      backgroundColor.1,
                      backgroundColor.2,
                      backgroundColor.3]
            } else {
                bg = nil
            }
            
            _shearD(direction: direction,
                    translate: Double(translate),
                    slope: Double(slope),
                    resamplingFilter: resamplingFilter,
                    destination: destination,
                    backgroundColor: bg,
                    nullBackgroundColor: [Pixel_16F()],
                    verticalShearFunc: vImageVerticalShearD_ARGB16F,
                    horizontalShearFunc: vImageHorizontalShearD_ARGB16F,
                    useFloat16Accumulator: useFloat16Accumulator)
        }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux4 {
  @inlinable public func shear<T>(direction: Accelerate.vImage.ShearDirection, translate: T, slope: T, resamplingFilter: Accelerate.ResamplingFilter, backgroundColor: Accelerate.Pixel_ARGB_16U? = (0, 0, 0, 0), destination: Accelerate.vImage.PixelBuffer<Format>) where T : Swift.BinaryFloatingPoint {
            
            let bg: [Pixel_16U]?
            if let backgroundColor = backgroundColor {
                bg = [backgroundColor.0,
                      backgroundColor.1,
                      backgroundColor.2,
                      backgroundColor.3]
            } else {
                bg = nil
            }
            
            _shearD(direction: direction,
                    translate: Double(translate),
                    slope: Double(slope),
                    resamplingFilter: resamplingFilter,
                    destination: destination,
                    backgroundColor: bg,
                    nullBackgroundColor: [Pixel_16U()],
                    verticalShearFunc: vImageVerticalShearD_ARGB16U,
                    horizontalShearFunc: vImageHorizontalShearD_ARGB16U)
        }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func shear<T>(direction: Accelerate.vImage.ShearDirection, translate: T, slope: T, resamplingFilter: Accelerate.ResamplingFilter, backgroundColor: Accelerate.Pixel_F? = Pixel_F(0), destination: Accelerate.vImage.PixelBuffer<Format>) where T : Swift.BinaryFloatingPoint {
            
            _shearD(direction: direction,
                    translate: Double(translate),
                    slope: Double(slope),
                    resamplingFilter: resamplingFilter,
                    destination: destination,
                    backgroundColor: backgroundColor,
                    nullBackgroundColor: Pixel_F(),
                    verticalShearFunc: vImageVerticalShearD_PlanarF,
                    horizontalShearFunc: vImageHorizontalShearD_PlanarF)
        }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func shear<T>(direction: Accelerate.vImage.ShearDirection, translate: T, slope: T, resamplingFilter: Accelerate.ResamplingFilter, backgroundColor: Accelerate.Pixel_FFFF? = (0, 0, 0, 0), destination: Accelerate.vImage.PixelBuffer<Format>) where T : Swift.BinaryFloatingPoint {
            
            let bg: [Pixel_F]?
            if let backgroundColor = backgroundColor {
                bg = [backgroundColor.0,
                      backgroundColor.1,
                      backgroundColor.2,
                      backgroundColor.3]
            } else {
                bg = nil
            }
            
            _shearD(direction: direction,
                    translate: Double(translate),
                    slope: Double(slope),
                    resamplingFilter: resamplingFilter,
                    destination: destination,
                    backgroundColor: bg,
                    nullBackgroundColor: [Pixel_F()],
                    verticalShearFunc: vImageVerticalShearD_ARGBFFFF,
                    horizontalShearFunc: vImageHorizontalShearD_ARGBFFFF)
        }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  @usableFromInline
  internal typealias ShearFuncD<BG> = (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Swift.Double, Swift.Double, Accelerate.ResamplingFilter, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal func _shearD<T, BG>(direction: Accelerate.vImage.ShearDirection, translate: Swift.Double, slope: Swift.Double, resamplingFilter: Accelerate.ResamplingFilter, destination: Accelerate.vImage.PixelBuffer<T>, backgroundColor: BG?, nullBackgroundColor: BG, verticalShearFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Swift.Double, Swift.Double, Accelerate.ResamplingFilter, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error, horizontalShearFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Swift.Double, Swift.Double, Accelerate.ResamplingFilter, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error, useFloat16Accumulator: Swift.Bool = false) where T : Accelerate.StaticPixelFormat
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public enum ReflectionAxis {
    case vertical
    case horizontal
    public static func == (a: Accelerate.vImage.ReflectionAxis, b: Accelerate.vImage.ReflectionAxis) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func reflect(over axis: Accelerate.vImage.ReflectionAxis, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let reflectFunc: (UnsafePointer<vImage_Buffer>, UnsafePointer<vImage_Buffer>, vImage_Flags) -> vImage_Error
        
        switch axis {
            case .vertical:
                reflectFunc = vImageVerticalReflect_Planar8
            case .horizontal:
                reflectFunc = vImageHorizontalReflect_Planar8
            @unknown default:
                fatalError("Unsupported reflection axis.")
        }
        
        _reflect(reflectFunc: reflectFunc,
                 destination: destination)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16F {
  @inlinable public func reflect(over axis: Accelerate.vImage.ReflectionAxis, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let reflectFunc: (UnsafePointer<vImage_Buffer>, UnsafePointer<vImage_Buffer>, vImage_Flags) -> vImage_Error
        
        switch axis {
            case .vertical:
                reflectFunc = vImageVerticalReflect_Planar16F
            case .horizontal:
                reflectFunc = vImageHorizontalReflect_Planar16F
            @unknown default:
                fatalError("Unsupported reflection axis.")
        }
        
        _reflect(reflectFunc: reflectFunc,
                 destination: destination)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx2 {
  @inlinable public func reflect(over axis: Accelerate.vImage.ReflectionAxis, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let reflectFunc: (UnsafePointer<vImage_Buffer>, UnsafePointer<vImage_Buffer>, vImage_Flags) -> vImage_Error
        
        switch axis {
            case .vertical:
                reflectFunc = vImageVerticalReflect_CbCr16F
            case .horizontal:
                reflectFunc = vImageHorizontalReflect_CbCr16F
            @unknown default:
                fatalError("Unsupported reflection axis.")
        }
        
        _reflect(reflectFunc: reflectFunc,
                 destination: destination)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx4 {
  @inlinable public func reflect(over axis: Accelerate.vImage.ReflectionAxis, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let reflectFunc: (UnsafePointer<vImage_Buffer>, UnsafePointer<vImage_Buffer>, vImage_Flags) -> vImage_Error
        
        switch axis {
            case .vertical:
                reflectFunc = vImageVerticalReflect_ARGB16F
            case .horizontal:
                reflectFunc = vImageHorizontalReflect_ARGB16F
            @unknown default:
                fatalError("Unsupported reflection axis.")
        }
        
        _reflect(reflectFunc: reflectFunc,
                 destination: destination)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func reflect(over axis: Accelerate.vImage.ReflectionAxis, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let reflectFunc: (UnsafePointer<vImage_Buffer>, UnsafePointer<vImage_Buffer>, vImage_Flags) -> vImage_Error
        
        switch axis {
            case .vertical:
                reflectFunc = vImageVerticalReflect_ARGB8888
            case .horizontal:
                reflectFunc = vImageHorizontalReflect_ARGB8888
            @unknown default:
                fatalError("Unsupported reflection axis.")
        }
        
        _reflect(reflectFunc: reflectFunc,
                 destination: destination)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux4 {
  @inlinable public func reflect(over axis: Accelerate.vImage.ReflectionAxis, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let reflectFunc: (UnsafePointer<vImage_Buffer>, UnsafePointer<vImage_Buffer>, vImage_Flags) -> vImage_Error
        
        switch axis {
            case .vertical:
                reflectFunc = vImageVerticalReflect_ARGB16U
            case .horizontal:
                reflectFunc = vImageHorizontalReflect_ARGB16U
            @unknown default:
                fatalError("Unsupported reflection axis.")
        }
        
        _reflect(reflectFunc: reflectFunc,
                 destination: destination)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func reflect(over axis: Accelerate.vImage.ReflectionAxis, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let reflectFunc: (UnsafePointer<vImage_Buffer>, UnsafePointer<vImage_Buffer>, vImage_Flags) -> vImage_Error
        
        switch axis {
            case .vertical:
                reflectFunc = vImageVerticalReflect_PlanarF
            case .horizontal:
                reflectFunc = vImageHorizontalReflect_PlanarF
            @unknown default:
                fatalError("Unsupported reflection axis.")
        }
        
        _reflect(reflectFunc: reflectFunc,
                 destination: destination)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func reflect(over axis: Accelerate.vImage.ReflectionAxis, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let reflectFunc: (UnsafePointer<vImage_Buffer>,
                          UnsafePointer<vImage_Buffer>,
                          vImage_Flags) -> vImage_Error
        
        switch axis {
            case .vertical:
                reflectFunc = vImageVerticalReflect_ARGBFFFF
            case .horizontal:
                reflectFunc = vImageHorizontalReflect_ARGBFFFF
            @unknown default:
                fatalError("Unsupported reflection axis.")
        }
        
        _reflect(reflectFunc: reflectFunc,
                 destination: destination)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  @usableFromInline
  internal func _reflect(reflectFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Accelerate.vImage_Flags) -> Accelerate.vImage_Error, destination: Accelerate.vImage.PixelBuffer<Format>)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func scale(destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageScale_Planar8(srcPtr, destPtr,
                                        nil,
                                        vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16F {
  @inlinable public func scale(useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let accumulatorFlag = useFloat16Accumulator ? vImage_Flags(kvImageUseFP16Accumulator) : 0
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageScale_Planar16F(srcPtr, destPtr,
                                          nil,
                                          accumulatorFlag)
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x2 {
  @inlinable public func scale(destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageScale_CbCr8(srcPtr, destPtr,
                                      nil,
                                      vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx2 {
  @inlinable public func scale(useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let accumulatorFlag = useFloat16Accumulator ? vImage_Flags(kvImageUseFP16Accumulator) : 0
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageScale_CbCr16F(srcPtr, destPtr,
                                        nil,
                                        accumulatorFlag)
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func scale(destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageScale_ARGB8888(srcPtr, destPtr,
                                         nil,
                                         vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx4 {
  @inlinable public func scale(useFloat16Accumulator: Swift.Bool, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let accumulatorFlag = useFloat16Accumulator ? vImage_Flags(kvImageUseFP16Accumulator) : 0
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageScale_ARGB16F(srcPtr, destPtr,
                                        nil,
                                        accumulatorFlag)
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16U {
  @inlinable public func scale(destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageScale_Planar16U(srcPtr, destPtr,
                                          nil,
                                          vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux2 {
  @inlinable public func scale(destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageScale_CbCr16U(srcPtr, destPtr,
                                        nil,
                                        vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux4 {
  @inlinable public func scale(destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageScale_ARGB16U(srcPtr, destPtr,
                                        nil,
                                        vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func scale(destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageScale_PlanarF(srcPtr, destPtr,
                                        nil,
                                        vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func scale(destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageScale_ARGBFFFF(srcPtr, destPtr,
                                         nil,
                                         vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func transform(_ transform: CoreFoundation.CGAffineTransform, backgroundColor: Accelerate.Pixel_8? = Pixel_8(0), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        _affineWarp(transform,
                    destination: destination,
                    backgroundColor: backgroundColor,
                    nullBackgroundColor: Pixel_8(),
                    affineWarpFunc: vImageAffineWarpCG_Planar8)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16F {
  @inlinable public func transform(_ transform: CoreFoundation.CGAffineTransform, backgroundColor: Accelerate.Pixel_16F? = Pixel_16F(0), useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        _affineWarpD(transform,
                     destination: destination,
                     backgroundColor: backgroundColor,
                     nullBackgroundColor: Pixel_16F(),
                     affineWarpFunc: vImageAffineWarpD_Planar16F,
                     useFloat16Accumulator: useFloat16Accumulator)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx2 {
  @inlinable public func transform(_ transform: CoreFoundation.CGAffineTransform, backgroundColor: Accelerate.Pixel_16F16F? = (0, 0), useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let bg: [Pixel_16F]?
        if let backgroundColor = backgroundColor {
            bg = [backgroundColor.0,
                  backgroundColor.1]
        } else {
            bg = nil
        }
        
        _affineWarpD(transform,
                     destination: destination,
                     backgroundColor: bg,
                     nullBackgroundColor: [Pixel_16F()],
                     affineWarpFunc: vImageAffineWarpD_CbCr16F,
                     useFloat16Accumulator: useFloat16Accumulator)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx4 {
  @inlinable public func transform(_ transform: CoreFoundation.CGAffineTransform, backgroundColor: Accelerate.Pixel_ARGB_16F? = (0, 0, 0, 0), useFloat16Accumulator: Swift.Bool = false, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let bg: [Pixel_16F]?
        if let backgroundColor = backgroundColor {
            bg = [backgroundColor.0,
                  backgroundColor.1,
                  backgroundColor.2,
                  backgroundColor.3]
        } else {
            bg = nil
        }
        
        _affineWarpD(transform,
                     destination: destination,
                     backgroundColor: bg,
                     nullBackgroundColor: [Pixel_16F()],
                     affineWarpFunc: vImageAffineWarpD_ARGB16F,
                     useFloat16Accumulator: useFloat16Accumulator)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func transform(_ transform: CoreFoundation.CGAffineTransform, backgroundColor: Accelerate.Pixel_8888? = (0, 0, 0, 0), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let bg: [Pixel_8]?
        if let backgroundColor = backgroundColor {
            bg = [backgroundColor.0,
                  backgroundColor.1,
                  backgroundColor.2,
                  backgroundColor.3]
        } else {
            bg = nil
        }
        
        _affineWarp(transform,
                    destination: destination,
                    backgroundColor: bg,
                    nullBackgroundColor: [Pixel_8()],
                    affineWarpFunc: vImageAffineWarpCG_ARGB8888)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux4 {
  @inlinable public func transform(_ transform: CoreFoundation.CGAffineTransform, backgroundColor: Accelerate.Pixel_ARGB_16U? = (0, 0, 0, 0), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let bg: [Pixel_16U]?
        if let backgroundColor = backgroundColor {
            bg = [backgroundColor.0,
                  backgroundColor.1,
                  backgroundColor.2,
                  backgroundColor.3]
        } else {
            bg = nil
        }
        
        _affineWarp(transform,
                    destination: destination,
                    backgroundColor: bg,
                    nullBackgroundColor: [Pixel_16U()],
                    affineWarpFunc: vImageAffineWarpCG_ARGB16U)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func transform(_ transform: CoreFoundation.CGAffineTransform, backgroundColor: Accelerate.Pixel_F? = Pixel_F(0), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        _affineWarp(transform,
                    destination: destination,
                    backgroundColor: backgroundColor,
                    nullBackgroundColor: Pixel_F(),
                    affineWarpFunc: vImageAffineWarpCG_PlanarF)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func transform(_ transform: CoreFoundation.CGAffineTransform, backgroundColor: Accelerate.Pixel_FFFF? = (0, 0, 0, 0), destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let bg: [Pixel_F]?
        if let backgroundColor = backgroundColor {
            bg = [backgroundColor.0,
                  backgroundColor.1,
                  backgroundColor.2,
                  backgroundColor.3]
        } else {
            bg = nil
        }
        
        _affineWarp(transform,
                    destination: destination,
                    backgroundColor: bg,
                    nullBackgroundColor: [Pixel_F()],
                    affineWarpFunc: vImageAffineWarpCG_ARGBFFFF)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  @usableFromInline
  internal typealias AffineWarpFunc<BG> = (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutableRawPointer?, Swift.UnsafePointer<Accelerate.vImage_CGAffineTransform>, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal func _affineWarp<BG>(_ transform: CoreFoundation.CGAffineTransform, destination: Accelerate.vImage.PixelBuffer<Format>, backgroundColor: BG?, nullBackgroundColor: BG, affineWarpFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutableRawPointer?, Swift.UnsafePointer<Accelerate.vImage_CGAffineTransform>, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error)
  @usableFromInline
  internal typealias AffineWarpFuncD<BG> = (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutableRawPointer?, Swift.UnsafePointer<Accelerate.vImage_AffineTransform_Double>, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal func _affineWarpD<BG>(_ transform: CoreFoundation.CGAffineTransform, destination: Accelerate.vImage.PixelBuffer<Format>, backgroundColor: BG?, nullBackgroundColor: BG, affineWarpFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutableRawPointer?, Swift.UnsafePointer<Accelerate.vImage_AffineTransform_Double>, BG, Accelerate.vImage_Flags) -> Accelerate.vImage_Error, useFloat16Accumulator: Swift.Bool = false)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage_AffineTransform_Double {
  public init(a: CoreFoundation.CGFloat, b: CoreFoundation.CGFloat, c: CoreFoundation.CGFloat, d: CoreFoundation.CGFloat, tx: CoreFoundation.CGFloat, ty: CoreFoundation.CGFloat)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage_AffineTransform {
  public init(a: CoreFoundation.CGFloat, b: CoreFoundation.CGFloat, c: CoreFoundation.CGFloat, d: CoreFoundation.CGFloat, tx: CoreFoundation.CGFloat, ty: CoreFoundation.CGFloat)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedBinaryArithmeticParameters : Accelerate.FusableLayerParameters {
    public var inputADescriptorType: Accelerate.BNNS.DescriptorType
    public var inputBDescriptorType: Accelerate.BNNS.DescriptorType
    public var outputDescriptorType: Accelerate.BNNS.DescriptorType
    public var function: Accelerate.BNNS.ArithmeticBinaryFunction
    public init(inputADescriptorType: Accelerate.BNNS.DescriptorType, inputBDescriptorType: Accelerate.BNNS.DescriptorType, outputDescriptorType: Accelerate.BNNS.DescriptorType, function: Accelerate.BNNS.ArithmeticBinaryFunction)
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.FusedParametersLayer {
  convenience public init?(inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, fusedLayerParameters: [any Accelerate.FusableLayerParameters], filterParameters: Accelerate.BNNSFilterParameters? = nil)
  public func apply(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, for learningPhase: Accelerate.BNNS.LearningPhase) throws
  public func applyBackward(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputAGradient inputAGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputBGradient inputBGradient: Accelerate.BNNSNDArrayDescriptor, generatingParameterGradients parameterGradients: [Accelerate.BNNSNDArrayDescriptor]) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public struct Quadrature {
  public init(integrator: Accelerate.Quadrature.Integrator, absoluteTolerance: Swift.Double = 1.0e-8, relativeTolerance: Swift.Double = 1.0e-2)
  public var absoluteTolerance: Swift.Double {
    get
    set
  }
  public var relativeTolerance: Swift.Double {
    get
    set
  }
  public func integrate(over interval: Swift.ClosedRange<Swift.Double>, integrand: (_ input: Swift.UnsafeBufferPointer<Swift.Double>, _ result: Swift.UnsafeMutableBufferPointer<Swift.Double>) -> ()) -> Swift.Result<(integralResult: Swift.Double, estimatedAbsoluteError: Swift.Double), Accelerate.Quadrature.Error>
  public func integrate(over interval: Swift.ClosedRange<Swift.Double>, integrand: (Swift.Double) -> Swift.Double) -> Swift.Result<(integralResult: Swift.Double, estimatedAbsoluteError: Swift.Double), Accelerate.Quadrature.Error>
  public enum Integrator {
    case qng
    public static let nonAdaptive: Accelerate.Quadrature.Integrator
    case qag(pointsPerInterval: Accelerate.Quadrature.QAGPointsPerInterval, maxIntervals: Swift.Int)
    public static func adaptive(pointsPerInterval: Accelerate.Quadrature.QAGPointsPerInterval, maxIntervals: Swift.Int) -> Accelerate.Quadrature.Integrator
    case qags(maxIntervals: Swift.Int)
    public static func adaptiveWithSingularities(maxIntervals: Swift.Int) -> Accelerate.Quadrature.Integrator
  }
  public struct QAGPointsPerInterval {
    public let points: Swift.Int
    public static let fifteen: Accelerate.Quadrature.QAGPointsPerInterval
    public static let twentyOne: Accelerate.Quadrature.QAGPointsPerInterval
    public static let thirtyOne: Accelerate.Quadrature.QAGPointsPerInterval
    public static let fortyOne: Accelerate.Quadrature.QAGPointsPerInterval
    public static let fiftyOne: Accelerate.Quadrature.QAGPointsPerInterval
    public static let sixtyOne: Accelerate.Quadrature.QAGPointsPerInterval
  }
  public enum Error : Swift.Error {
    case generic
    case invalidArgument
    case `internal`
    case integrateMaxEval
    case badIntegrandBehaviour
    public init(quadratureStatus: Accelerate.quadrature_status)
    public var errorDescription: Swift.String {
      get
    }
    public static func == (a: Accelerate.Quadrature.Error, b: Accelerate.Quadrature.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func evaluatePolynomial<U>(usingCoefficients coefficients: [Swift.Float], withVariables variables: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: variables.count) {
                buffer, initializedCount in
                
                evaluatePolynomial(usingCoefficients: coefficients,
                                   withVariables: variables,
                                   result: &buffer)
                
                initializedCount = variables.count
            }
            
            return result
    }
  @inlinable public static func evaluatePolynomial<U, V>(usingCoefficients coefficients: [Swift.Float], withVariables variables: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = vDSP_Length(min(variables.count,
                                    result.count))
            
            let degreeOfPolynomial = vDSP_Length(coefficients.count - 1)
            
            result.withUnsafeMutableBufferPointer { dest in
                variables.withUnsafeBufferPointer { src in
                    vDSP_vpoly(coefficients, 1,
                               src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n,
                               degreeOfPolynomial)
                }
            }
    }
  @inlinable public static func evaluatePolynomial<U>(usingCoefficients coefficients: [Swift.Double], withVariables variables: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: variables.count) {
                buffer, initializedCount in
                
                evaluatePolynomial(usingCoefficients: coefficients,
                                   withVariables: variables,
                                   result: &buffer)
                
                initializedCount = variables.count
            }
            
            return result
    }
  @inlinable public static func evaluatePolynomial<U, V>(usingCoefficients coefficients: [Swift.Double], withVariables variables: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = vDSP_Length(min(variables.count,
                                    result.count))
            
            let degreeOfPolynomial = vDSP_Length(coefficients.count - 1)
            
            result.withUnsafeMutableBufferPointer { dest in
                variables.withUnsafeBufferPointer { src in
                    vDSP_vpolyD(coefficients, 1,
                                src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n,
                                degreeOfPolynomial)
                }
            }
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedConvolutionParameters : Accelerate.FusableLayerParameters {
    public init(type: Accelerate.BNNS.ConvolutionType, weights: Accelerate.BNNSNDArrayDescriptor, bias: Accelerate.BNNSNDArrayDescriptor?, stride: (x: Swift.Int, y: Swift.Int), dilationStride: (x: Swift.Int, y: Swift.Int), groupSize: Swift.Int, padding: Accelerate.BNNS.ConvolutionPadding)
    public var type: Accelerate.BNNS.ConvolutionType
    public var weights: Accelerate.BNNSNDArrayDescriptor
    public var bias: Accelerate.BNNSNDArrayDescriptor?
    public var stride: (x: Swift.Int, y: Swift.Int)
    public var dilationStride: (x: Swift.Int, y: Swift.Int)
    public var groupSize: Swift.Int
    public var padding: Accelerate.BNNS.ConvolutionPadding
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  public enum Radix {
    case radix2
    case radix3
    case radix5
    public var fftRadix: Accelerate.FFTRadix {
      get
    }
    public static func == (a: Accelerate.vDSP.Radix, b: Accelerate.vDSP.Radix) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public class FFT<T> where T : Accelerate.vDSP_FourierTransformable {
    public init?(log2n: Accelerate.vDSP_Length, radix: Accelerate.vDSP.Radix, ofType: T.Type)
    public func transform<T>(input: T, output: inout T, direction: Accelerate.vDSP.FourierTransformDirection) where T : Accelerate.vDSP_FourierTransformable
    public func forward(input: Accelerate.DSPSplitComplex, output: inout Accelerate.DSPSplitComplex)
    public func inverse(input: Accelerate.DSPSplitComplex, output: inout Accelerate.DSPSplitComplex)
    @objc deinit
  }
  public class FFT2D<T> : Accelerate.vDSP.FFT<T> where T : Accelerate.vDSP_FourierTransformable {
    required public init?(width: Swift.Int, height: Swift.Int, ofType: T.Type)
    override public func transform<T>(input: T, output: inout T, direction: Accelerate.vDSP.FourierTransformDirection) where T : Accelerate.vDSP_FourierTransformable
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FourierTransformFunctions {
  associatedtype SplitComplex
  static func makeFFTSetup(log2n: Accelerate.vDSP_Length, radix: Accelerate.vDSP.Radix) -> Swift.OpaquePointer?
  static func transform(fftSetup: Swift.OpaquePointer, log2n: Accelerate.vDSP_Length, source: Swift.UnsafePointer<Self.SplitComplex>, destination: Swift.UnsafeMutablePointer<Self.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  static func transform2D(fftSetup: Swift.OpaquePointer, width: Swift.Int, height: Swift.Int, source: Swift.UnsafePointer<Self.SplitComplex>, destination: Swift.UnsafeMutablePointer<Self.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public struct vDSP_SplitComplexFloat : Accelerate.vDSP_FourierTransformFunctions {
  public typealias SplitComplex = Accelerate.DSPSplitComplex
  public static func makeFFTSetup(log2n: Accelerate.vDSP_Length, radix: Accelerate.vDSP.Radix) -> Swift.OpaquePointer?
  public static func transform(fftSetup: Swift.OpaquePointer, log2n: Accelerate.vDSP_Length, source: Swift.UnsafePointer<Accelerate.vDSP_SplitComplexFloat.SplitComplex>, destination: Swift.UnsafeMutablePointer<Accelerate.vDSP_SplitComplexFloat.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  public static func transform2D(fftSetup: Swift.OpaquePointer, width: Swift.Int, height: Swift.Int, source: Swift.UnsafePointer<Accelerate.vDSP_SplitComplexFloat.SplitComplex>, destination: Swift.UnsafeMutablePointer<Accelerate.vDSP_SplitComplexFloat.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  public static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public struct vDSP_SplitComplexDouble : Accelerate.vDSP_FourierTransformFunctions {
  public typealias SplitComplex = Accelerate.DSPDoubleSplitComplex
  public static func makeFFTSetup(log2n: Accelerate.vDSP_Length, radix: Accelerate.vDSP.Radix) -> Swift.OpaquePointer?
  public static func transform(fftSetup: Swift.OpaquePointer, log2n: Accelerate.vDSP_Length, source: Swift.UnsafePointer<Accelerate.vDSP_SplitComplexDouble.SplitComplex>, destination: Swift.UnsafeMutablePointer<Accelerate.vDSP_SplitComplexDouble.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  public static func transform2D(fftSetup: Swift.OpaquePointer, width: Swift.Int, height: Swift.Int, source: Swift.UnsafePointer<Accelerate.vDSP_SplitComplexDouble.SplitComplex>, destination: Swift.UnsafeMutablePointer<Accelerate.vDSP_SplitComplexDouble.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  public static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FourierTransformable {
  associatedtype FFTFunctions : Accelerate.vDSP_FourierTransformFunctions where Self == Self.FFTFunctions.SplitComplex
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.DSPSplitComplex : Accelerate.vDSP_FourierTransformable {
  public typealias FFTFunctions = Accelerate.vDSP_SplitComplexFloat
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.DSPDoubleSplitComplex : Accelerate.vDSP_FourierTransformable {
  public typealias FFTFunctions = Accelerate.vDSP_SplitComplexDouble
}
@available(macOS, deprecated, introduced: 10.15, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(iOS, deprecated, introduced: 13.0, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(*, deprecated, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
extension Accelerate.DSPSplitComplex {
  public init(fromInputArray inputArray: [Swift.Float], realParts: inout [Swift.Float], imaginaryParts: inout [Swift.Float])
}
@available(macOS, deprecated, introduced: 10.15, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(iOS, deprecated, introduced: 13.0, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(*, deprecated, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
extension Accelerate.DSPDoubleSplitComplex {
  public init(fromInputArray inputArray: [Swift.Double], realParts: inout [Swift.Double], imaginaryParts: inout [Swift.Double])
}
extension Swift.Array where Element == Swift.Float {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(fromSplitComplex splitComplex: Accelerate.DSPSplitComplex, scale: Swift.Float, count: Swift.Int)
}
extension Swift.Array where Element == Swift.Double {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(fromSplitComplex splitComplex: Accelerate.DSPDoubleSplitComplex, scale: Swift.Double, count: Swift.Int)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public enum RandomGeneratorMethod {
    case aesCtr
    public static func == (a: Accelerate.BNNS.RandomGeneratorMethod, b: Accelerate.BNNS.RandomGeneratorMethod) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers public class RandomGeneratorState {
    @objc deinit
  }
  public class RandomGenerator {
    public init?(method: Accelerate.BNNS.RandomGeneratorMethod, seed: Swift.UInt64? = nil, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
    public var state: Accelerate.BNNS.RandomGeneratorState {
      get
      set
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNSNDArrayDescriptor {
  public static func allocate<Scalar>(randomUniformUsing: Accelerate.BNNS.RandomGenerator, range: Swift.ClosedRange<Scalar>, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor? where Scalar : Accelerate.BNNSScalar, Scalar : Swift.BinaryFloatingPoint
  public static func allocate<Scalar>(randomUniformUsing: Accelerate.BNNS.RandomGenerator, range: Swift.ClosedRange<Scalar>, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor? where Scalar : Accelerate.BNNSScalar, Scalar : Swift.FixedWidthInteger
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat, Format.ComponentType == Swift.Float {
  public func clip(to bounds: Swift.ClosedRange<Swift.Float>, destination: Accelerate.vImage.PixelBuffer<Format>)
  public func colorThreshold(_ threshold: Swift.Float, destination: Accelerate.vImage.PixelBuffer<Format>)
  public func linearInterpolate(bufferB: Accelerate.vImage.PixelBuffer<Format>, interpolationConstant: Swift.Float, destination: Accelerate.vImage.PixelBuffer<Format>)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage {
  public enum Error : Swift.Int, Swift.Error {
    case noError
    case roiLargerThanInputBuffer
    case invalidKernelSize
    case invalidEdgeStyle
    case invalidOffset_X
    case invalidOffset_Y
    case memoryAllocationError
    case nullPointerArgument
    case invalidParameter
    case bufferSizeMismatch
    case unknownFlagsBit
    case internalError
    case invalidRowBytes
    case invalidImageFormat
    case colorSyncIsAbsent
    case outOfPlaceOperationRequired
    case invalidImageObject
    case invalidCVImageFormat
    case unsupportedConversion
    case coreVideoIsAbsent
    public init(vImageError: Accelerate.vImage_Error)
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public static func quantize(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axis: Swift.Int? = nil, scale: Accelerate.BNNSNDArrayDescriptor?, bias: Accelerate.BNNSNDArrayDescriptor?, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
  public static func dequantize(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axis: Swift.Int? = nil, scale: Accelerate.BNNSNDArrayDescriptor?, bias: Accelerate.BNNSNDArrayDescriptor?, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public static func computeNorm(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axes: [Swift.Int]? = nil) throws
  public static func computeNormBackward(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axes: [Swift.Int]? = nil, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageConverter {
  public func sourceBuffers(colorSpace: CoreGraphics.CGColorSpace) -> [Accelerate.vImage.BufferType?]
  public func destinationBuffers(colorSpace: CoreGraphics.CGColorSpace) -> [Accelerate.vImage.BufferType?]
  public var sourceBufferCount: Swift.Int {
    get
  }
  public var destinationBufferCount: Swift.Int {
    get
  }
  public func mustOperateOutOfPlace(source: Accelerate.vImage_Buffer, destination: Accelerate.vImage_Buffer, flags options: Accelerate.vImage.Options = .noFlags) throws -> Swift.Bool
  public static func make(sourceFormat: Accelerate.vImage_CGImageFormat, destinationFormat: Accelerate.vImage_CGImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws -> Accelerate.vImageConverter
  public static func make(sourceFormat: Accelerate.vImage_CGImageFormat, destinationFormat: Accelerate.vImageCVImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws -> Accelerate.vImageConverter
  public static func make(sourceFormat: Accelerate.vImageCVImageFormat, destinationFormat: Accelerate.vImage_CGImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws -> Accelerate.vImageConverter
  public func convert(source: Accelerate.vImage_Buffer, destination: inout Accelerate.vImage_Buffer, flags options: Accelerate.vImage.Options = .noFlags) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux2 {
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved16Fx2>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 2,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        let fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 2,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        
        withUnsafePointer(to: fauxSource) { srcPtr in
            withUnsafePointer(to: fauxDestination) { destPtr in
                
                _ = vImageConvert_16Uto16F(srcPtr,
                                           destPtr,
                                           vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  public struct Biquad<T> where T : Accelerate.vDSP_FloatingPointBiquadFilterable {
    public init?(coefficients: [Swift.Double], channelCount: Accelerate.vDSP_Length, sectionCount: Accelerate.vDSP_Length, ofType: T.Type)
    public mutating func apply<U>(input: U) -> [T] where T == U.Element, U : Accelerate.AccelerateBuffer
    public mutating func apply<U, V>(input: U, output: inout V) where T == U.Element, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == V.Element
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FloatingPointBiquadFilterable : Swift.BinaryFloatingPoint {
  associatedtype BiquadFunctions : Accelerate.vDSP_BiquadFunctions where Self == Self.BiquadFunctions.Scalar
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Float : Accelerate.vDSP_FloatingPointBiquadFilterable {
  public typealias BiquadFunctions = Accelerate.vDSP.VectorizableFloat
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Double : Accelerate.vDSP_FloatingPointBiquadFilterable {
  public typealias BiquadFunctions = Accelerate.vDSP.VectorizableDouble
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_BiquadFunctions {
  associatedtype Scalar
  static func makeBiquadSetup(channelCount: Accelerate.vDSP_Length, coefficients: [Swift.Double], sectionCount: Accelerate.vDSP_Length) -> Swift.OpaquePointer?
  static func applySingle<U, V>(source: U, destination: inout V, delays: Swift.UnsafeMutablePointer<Self.Scalar>, setup: Accelerate.vDSP_biquad_Setup, sectionCount: Accelerate.vDSP_Length, count: Accelerate.vDSP_Length) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, Self.Scalar == U.Element, U.Element == V.Element
  static func applyMulti(setup: Accelerate.vDSP_biquadm_SetupD, pInputs: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Self.Scalar>>, pOutputs: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Self.Scalar>>, count: Accelerate.vDSP_Length)
  static func destroySetup(channelCount: Swift.UInt, biquadSetup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.VectorizableFloat : Accelerate.vDSP_BiquadFunctions {
  @inlinable public static func makeBiquadSetup(channelCount: Swift.UInt, coefficients: [Swift.Double], sectionCount: Swift.UInt) -> Swift.OpaquePointer? {
        if channelCount == 1 {
            return vDSP_biquad_CreateSetup(coefficients,
                                           sectionCount)
        } else {
            return vDSP_biquadm_CreateSetup(coefficients,
                                            sectionCount,
                                            channelCount)
        }
    }
  @inlinable public static func applySingle<U, V>(source: U, destination: inout V, delays: Swift.UnsafeMutablePointer<Accelerate.vDSP.VectorizableFloat.Scalar>, setup: Accelerate.vDSP_biquad_Setup, sectionCount: Accelerate.vDSP_Length, count: Accelerate.vDSP_Length) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_biquad(setup,
                                delays,
                                src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                count)
                }
            }
    }
  @inlinable public static func applyMulti(setup: Accelerate.vDSP_biquadm_SetupD, pInputs: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Accelerate.vDSP.VectorizableFloat.Scalar>>, pOutputs: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Accelerate.vDSP.VectorizableFloat.Scalar>>, count: Accelerate.vDSP_Length) {
        vDSP_biquadm(setup,
                     pInputs, 1,
                     pOutputs, 1,
                     count)
    }
  @inlinable public static func destroySetup(channelCount: Swift.UInt, biquadSetup: Swift.OpaquePointer) {
        if channelCount == 1 {
            vDSP_biquad_DestroySetup(biquadSetup)
        } else {
            vDSP_biquadm_DestroySetup(biquadSetup)
        }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.VectorizableDouble : Accelerate.vDSP_BiquadFunctions {
  @inlinable public static func makeBiquadSetup(channelCount: Accelerate.vDSP_Length, coefficients: [Swift.Double], sectionCount: Accelerate.vDSP_Length) -> Swift.OpaquePointer? {
        if channelCount == 1 {
            return vDSP_biquad_CreateSetupD(coefficients,
                                            sectionCount)
        } else {
            return vDSP_biquadm_CreateSetupD(coefficients,
                                             sectionCount,
                                             channelCount)
        }
    }
  @inlinable public static func applySingle<U, V>(source: U, destination: inout V, delays: Swift.UnsafeMutablePointer<Accelerate.vDSP.VectorizableDouble.Scalar>, setup: Accelerate.vDSP_biquad_Setup, sectionCount: Accelerate.vDSP_Length, count: Accelerate.vDSP_Length) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_biquadD(setup,
                                 delays,
                                 src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 count)
                }
            }
    }
  @inlinable public static func applyMulti(setup: Accelerate.vDSP_biquadm_SetupD, pInputs: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Accelerate.vDSP.VectorizableDouble.Scalar>>, pOutputs: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Accelerate.vDSP.VectorizableDouble.Scalar>>, count: Accelerate.vDSP_Length) {
        vDSP_biquadmD(setup,
                      pInputs, 1,
                      pOutputs, 1,
                      count)
    }
  @inlinable public static func destroySetup(channelCount: Swift.UInt, biquadSetup: Swift.OpaquePointer) {
        if channelCount == 1 {
            vDSP_biquad_DestroySetupD(biquadSetup)
        } else {
            vDSP_biquadm_DestroySetupD(biquadSetup)
        }
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DropoutLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, rate: Swift.Float, seed: Swift.UInt32, control: Swift.UInt8, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FullyConnectedLayer : Accelerate.BNNS.ConvolutionLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, weights: Accelerate.BNNSNDArrayDescriptor, bias: Accelerate.BNNSNDArrayDescriptor?, activation: Accelerate.BNNS.ActivationFunction, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImageConverter {
  @inlinable public func convert<Src, Dest>(from source: Accelerate.vImage.PixelBuffer<Src>, to destination: Accelerate.vImage.PixelBuffer<Dest>) throws where Src : Accelerate.SinglePlanePixelFormat, Dest : Accelerate.SinglePlanePixelFormat {
        
        var error = kvImageNoError
        
        withUnsafePointer(to: source.vImageBuffer) { src in
            withUnsafePointer(to: destination.vImageBuffer) { dest in
                error = vImageConvert_AnyToAny(self,
                                               src,
                                               dest,
                                               nil,
                                               vImage_Flags(kvImagePrintDiagnosticsToConsole))
            }
        }
        
        if error != kvImageNoError {
            throw vImage.Error(vImageError: error)
        }
    }
  @inlinable public func convert<F1, F2>(from sources: [Accelerate.vImage.PixelBuffer<F1>], to destinations: [Accelerate.vImage.PixelBuffer<F2>]) throws where F1 : Accelerate.SinglePlanePixelFormat, F2 : Accelerate.SinglePlanePixelFormat {
        
        var error = kvImageNoError
        
        let src = sources.map{ $0.vImageBuffer }
        let dest = destinations.map{ $0.vImageBuffer }
        
        src.withUnsafeBufferPointer { srcPtr in
            dest.withUnsafeBufferPointer { destPtr in
                error = vImageConvert_AnyToAny(self,
                                               srcPtr.baseAddress!,
                                               destPtr.baseAddress!,
                                               nil,
                                               vImage_Flags(kvImagePrintDiagnosticsToConsole))
            }
        }
        
        if error != kvImageNoError {
            throw vImage.Error(vImageError: error)
        }
    }
  public static func make(sourceFormat: Accelerate.vImage_CGImageFormat, destinationFormat: Accelerate.vImage_CGImageFormat, colorConversionInfo: CoreGraphics.CGColorConversionInfo) throws -> Accelerate.vImageConverter
  public func makeCVToCGPixelBuffers(referencing lockedCVPixelBuffer: CoreVideo.CVPixelBuffer) throws -> [Accelerate.vImage.PixelBuffer<Accelerate.vImage.DynamicPixelFormat>]
  public func makeCGToCVPixelBuffers(referencing lockedCVPixelBuffer: CoreVideo.CVPixelBuffer) throws -> [Accelerate.vImage.PixelBuffer<Accelerate.vImage.DynamicPixelFormat>]
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension Accelerate.BNNSDataType {
  public static var float16: Accelerate.BNNSDataType {
    get
  }
  public static var float: Accelerate.BNNSDataType {
    get
  }
  public static var int8: Accelerate.BNNSDataType {
    get
  }
  public static var int16: Accelerate.BNNSDataType {
    get
  }
  public static var int32: Accelerate.BNNSDataType {
    get
  }
  public static var indexed8: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension Accelerate.BNNSDataType {
  public static var uint8: Accelerate.BNNSDataType {
    get
  }
  public static var uint16: Accelerate.BNNSDataType {
    get
  }
  public static var uint32: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.float16")
public var BNNSDataTypeFloat16: Accelerate.BNNSDataType
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.float")
public var BNNSDataTypeFloat32: Accelerate.BNNSDataType
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.int8")
public var BNNSDataTypeInt8: Accelerate.BNNSDataType
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.int16")
public var BNNSDataTypeInt16: Accelerate.BNNSDataType
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.int32")
public var BNNSDataTypeInt32: Accelerate.BNNSDataType
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.indexed8")
public var BNNSDataTypeIndexed8: Accelerate.BNNSDataType
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension Accelerate.BNNSPoolingFunction {
  public static var max: Accelerate.BNNSPoolingFunction {
    get
  }
  @available(macOS, introduced: 10.15, deprecated: 12.0, message: "Use 'BNNSPoolingFunctionAverageCountIncludePadding' instead.")
  @available(iOS, introduced: 13.0, deprecated: 15.0, message: "Use 'BNNSPoolingFunctionAverageCountIncludePadding' instead.")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, message: "Use 'BNNSPoolingFunctionAverageCountIncludePadding' instead.")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, message: "Use 'BNNSPoolingFunctionAverageCountIncludePadding' instead.")
  @available(*, deprecated, message: "Use 'BNNSPoolingFunctionAverageCountIncludePadding' instead.")
  public static var average: Accelerate.BNNSPoolingFunction {
    get
  }
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSPoolingFunction.max")
public var BNNSPoolingFunctionMax: Accelerate.BNNSPoolingFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSPoolingFunction.average")
public var BNNSPoolingFunctionAverage: Accelerate.BNNSPoolingFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension Accelerate.BNNSActivationFunction {
  public static var identity: Accelerate.BNNSActivationFunction {
    get
  }
  public static var rectifiedLinear: Accelerate.BNNSActivationFunction {
    get
  }
  public static var leakyRectifiedLinear: Accelerate.BNNSActivationFunction {
    get
  }
  public static var sigmoid: Accelerate.BNNSActivationFunction {
    get
  }
  public static var tanh: Accelerate.BNNSActivationFunction {
    get
  }
  public static var scaledTanh: Accelerate.BNNSActivationFunction {
    get
  }
  public static var abs: Accelerate.BNNSActivationFunction {
    get
  }
}
@available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension Accelerate.BNNSActivationFunction {
  public static var linear: Accelerate.BNNSActivationFunction {
    get
  }
  public static var clamp: Accelerate.BNNSActivationFunction {
    get
  }
  public static var integerLinearSaturate: Accelerate.BNNSActivationFunction {
    get
  }
  public static var integerLinearSaturatePerChannel: Accelerate.BNNSActivationFunction {
    get
  }
  public static var softmax: Accelerate.BNNSActivationFunction {
    get
  }
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.identity")
public var BNNSActivationFunctionIdentity: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.rectifiedLinear")
public var BNNSActivationFunctionRectifiedLinear: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.leakyRectifiedLinear")
public var BNNSActivationFunctionLeakyRectifiedLinear: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.sigmoid")
public var BNNSActivationFunctionSigmoid: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.tanh")
public var BNNSActivationFunctionTanh: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.scaledTanh")
public var BNNSActivationFunctionScaledTanh: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.abs")
public var BNNSActivationFunctionAbs: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension Accelerate.BNNSFlags {
  public static var useClientPointer: Accelerate.BNNSFlags {
    get
  }
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSFlags.useClientPointer")
public var BNNSFlagsUseClientPtr: Accelerate.BNNSFlags
@available(macOS, introduced: 10.12, deprecated: 12.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(iOS, introduced: 10.0, deprecated: 15.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(watchOS, introduced: 3.0, deprecated: 8.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(tvOS, introduced: 10.0, deprecated: 15.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(*, deprecated, message: "BNNS switched to new Layer Parameters data structures.")
extension Accelerate.BNNSImageStackDescriptor {
  public init(width: Swift.Int, height: Swift.Int, channels: Swift.Int, row_stride: Swift.Int, image_stride: Swift.Int, data_type: Accelerate.BNNSDataType)
}
@available(macOS, introduced: 10.12, deprecated: 12.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(iOS, introduced: 10.0, deprecated: 15.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(watchOS, introduced: 3.0, deprecated: 8.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(tvOS, introduced: 10.0, deprecated: 15.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(*, deprecated, message: "BNNS switched to new Layer Parameters data structures.")
extension Accelerate.BNNSVectorDescriptor {
  public init(size: Swift.Int, data_type: Accelerate.BNNSDataType)
}
@available(macOS, introduced: 10.12, deprecated: 12.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(iOS, introduced: 10.0, deprecated: 15.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(watchOS, introduced: 3.0, deprecated: 8.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(tvOS, introduced: 10.0, deprecated: 15.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(*, deprecated, message: "BNNS switched to new Layer Parameters data structures.")
extension Accelerate.BNNSLayerData {
  public init(data: Swift.UnsafeRawPointer?, data_type: Accelerate.BNNSDataType, data_scale: Swift.Float = 1, data_bias: Swift.Float = 0)
  public static var zero: Accelerate.BNNSLayerData {
    get
  }
  public static func indexed8(data: Swift.UnsafePointer<Swift.Int8>?, data_table: Swift.UnsafePointer<Swift.Float>) -> Accelerate.BNNSLayerData
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension Accelerate.BNNSActivation {
  public init(function: Accelerate.BNNSActivationFunction, alpha: Swift.Float = .nan, beta: Swift.Float = .nan)
  public static var identity: Accelerate.BNNSActivation {
    get
  }
}
@available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension Accelerate.BNNSActivation {
  public static func integerLinearSaturate(scale: Swift.Int32 = 1, offset: Swift.Int32 = 0, shift: Swift.Int32 = 0) -> Accelerate.BNNSActivation
  public static func integerLinearSaturatePerChannel(scale: Swift.UnsafePointer<Swift.Int32>, offset: Swift.UnsafePointer<Swift.Int32>, shift: Swift.UnsafePointer<Swift.Int32>) -> Accelerate.BNNSActivation
}
@available(macOS, introduced: 10.12, deprecated: 12.0, message: "Use 'BNNSLayerParametersConvolution' instead.")
@available(iOS, introduced: 10.0, deprecated: 15.0, message: "Use 'BNNSLayerParametersConvolution' instead")
@available(watchOS, introduced: 3.0, deprecated: 8.0, message: "Use 'BNNSLayerParametersConvolution' instead")
@available(tvOS, introduced: 10.0, deprecated: 15.0, message: "Use 'BNNSLayerParametersConvolution' instead")
@available(*, deprecated, message: "Use 'BNNSLayerParametersConvolution' instead")
extension Accelerate.BNNSConvolutionLayerParameters {
  public init(x_stride: Swift.Int, y_stride: Swift.Int, x_padding: Swift.Int, y_padding: Swift.Int, k_width: Swift.Int, k_height: Swift.Int, in_channels: Swift.Int, out_channels: Swift.Int, weights: Accelerate.BNNSLayerData)
}
@available(macOS, introduced: 10.12, deprecated: 12.0, message: "Use 'BNNSLayerParametersPooling' instead.")
@available(iOS, introduced: 10.0, deprecated: 15.0, message: "Use 'BNNSLayerParametersPooling' instead")
@available(watchOS, introduced: 3.0, deprecated: 8.0, message: "Use 'BNNSLayerParametersPooling' instead")
@available(tvOS, introduced: 10.0, deprecated: 15.0, message: "Use 'BNNSLayerParametersPooling' instead")
@available(*, deprecated, message: "Use 'BNNSLayerParametersPooling' instead")
extension Accelerate.BNNSPoolingLayerParameters {
  public init(x_stride: Swift.Int, y_stride: Swift.Int, x_padding: Swift.Int, y_padding: Swift.Int, k_width: Swift.Int, k_height: Swift.Int, in_channels: Swift.Int, out_channels: Swift.Int, pooling_function: Accelerate.BNNSPoolingFunction)
}
@available(macOS, introduced: 10.12, deprecated: 12.0, message: "Use 'BNNSLayerParametersFullyConnected' instead.")
@available(iOS, introduced: 10.0, deprecated: 15.0, message: "Use 'BNNSLayerParametersFullyConnected' instead")
@available(watchOS, introduced: 3.0, deprecated: 8.0, message: "Use 'BNNSLayerParametersFullyConnected' instead")
@available(tvOS, introduced: 10.0, deprecated: 15.0, message: "Use 'BNNSLayerParametersFullyConnected' instead")
@available(*, deprecated, message: "Use 'BNNSLayerParametersFullyConnected' instead")
extension Accelerate.BNNSFullyConnectedLayerParameters {
  public init(in_size: Swift.Int, out_size: Swift.Int, weights: Accelerate.BNNSLayerData)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol AccelerateBuffer {
  associatedtype Element
  var count: Swift.Int { get }
  func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol AccelerateMutableBuffer : Accelerate.AccelerateBuffer {
  mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.AccelerateBuffer where Self : Swift.Collection {
  @_silgen_name("$s10Accelerate0A6BufferPAASlRzrlE010withUnsafeB7Pointeryqd__qd__SRy7ElementSTQzGKXEKlF")
  @inlinable public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R {
        return try withContiguousStorageIfAvailable(body)!
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.AccelerateMutableBuffer where Self : Swift.MutableCollection {
  @_silgen_name("$s10Accelerate0A13MutableBufferPAASMRzrlE010withUnsafebC7Pointeryqd__qd__Sry7ElementSTQzGzKXEKlF")
  @inlinable public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R {
        return try withContiguousMutableStorageIfAvailable(body)!
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Array : Accelerate.AccelerateMutableBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.ContiguousArray : Accelerate.AccelerateMutableBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.ArraySlice : Accelerate.AccelerateMutableBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.UnsafeBufferPointer : Accelerate.AccelerateBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.UnsafeMutableBufferPointer : Accelerate.AccelerateMutableBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Slice : Accelerate.AccelerateBuffer where Base : Accelerate.AccelerateBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Slice : Accelerate.AccelerateMutableBuffer where Base : Accelerate.AccelerateMutableBuffer, Base : Swift.MutableCollection {
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public protocol BNNSScalar {
  static var bnnsDataType: Accelerate.BNNSDataType { get }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.Float : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(iOS 14, tvOS 14, watchOS 7, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
extension Swift.Float16 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.Int8 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.Int16 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.Int32 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.UInt8 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.UInt16 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.UInt32 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.Bool : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Int64 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.UInt64 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNSNDArrayDescriptor {
  public init(dataType: Accelerate.BNNSDataType, shape: Accelerate.BNNS.Shape)
  public init?(data: Swift.UnsafeMutableRawBufferPointer, scalarType: any Accelerate.BNNSScalar.Type, shape: Accelerate.BNNS.Shape)
  public init?<T>(data: Swift.UnsafeMutableBufferPointer<T>, shape: Accelerate.BNNS.Shape) where T : Accelerate.BNNSScalar
  public static func allocateUninitialized(scalarType: any Accelerate.BNNSScalar.Type, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor
  public static func allocate<C>(initializingFrom source: C, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor where C : Swift.Collection, C.Element : Accelerate.BNNSScalar
  public static func allocate<Scalar>(randomIn range: Swift.ClosedRange<Scalar>, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor where Scalar : Accelerate.BNNSScalar, Scalar : Swift.FixedWidthInteger
  public static func allocate<Scalar>(randomIn range: Swift.ClosedRange<Scalar>, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor where Scalar : Accelerate.BNNSScalar, Scalar : Swift.BinaryFloatingPoint, Scalar.RawSignificand : Swift.FixedWidthInteger
  public static func allocate<Scalar, Generator>(randomIn range: Swift.ClosedRange<Scalar>, using generator: inout Generator, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor where Scalar : Accelerate.BNNSScalar, Scalar : Swift.FixedWidthInteger, Generator : Swift.RandomNumberGenerator
  public static func allocate<Scalar, Generator>(randomIn range: Swift.ClosedRange<Scalar>, using generator: inout Generator, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor where Scalar : Accelerate.BNNSScalar, Scalar : Swift.BinaryFloatingPoint, Generator : Swift.RandomNumberGenerator, Scalar.RawSignificand : Swift.FixedWidthInteger
  public static func allocate<T>(repeating repeatedValue: T, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor where T : Accelerate.BNNSScalar
  public func makeArray<T>(of scalarType: T.Type, batchSize: Swift.Int = 1) -> [T]?
  public var shape: Accelerate.BNNS.Shape {
    get
  }
  public func deallocate()
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNSNDArrayDescriptor {
  public init?(data: Swift.UnsafeMutableRawBufferPointer, scalarType: any Accelerate.BNNSScalar.Type, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int)
  public init?<T>(data: Swift.UnsafeMutableBufferPointer<T>, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int) where T : Accelerate.BNNSScalar
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx3 {
  public init(planarBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>])
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x3>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageConvert_RGBFFFtoRGB888_dithered(srcPtr,
                                                          destPtr,
                                                          [1, 1, 1],
                                                          [0, 0, 0],
                                                          Int32(kvImageConvert_DitherNone),
                                                          vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func planarBuffers() -> [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>] {
        
        let componentCount = Format.channelCount
        
        let buffers: [vImage.PixelBuffer<vImage.PlanarF>] = (0 ..< componentCount).map { _ in
            vImage.PixelBuffer(size: size,
                               pixelFormat: vImage.PlanarF.self)
            
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: buffers[0].vImageBuffer) { zeroPtr in
                withUnsafePointer(to: buffers[1].vImageBuffer) { onePtr in
                    withUnsafePointer(to: buffers[2].vImageBuffer) { twoPtr in
                        _ = vImageConvert_RGBFFFtoPlanarF(srcPtr,
                                                          zeroPtr,
                                                          onePtr,
                                                          twoPtr,
                                                          vImage_Flags(kvImageNoFlags))
                    }
                }
            }
        }
        
        return buffers
    }
  @inlinable public func interleave(planarSourceBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>]) {
        
        precondition(planarSourceBuffers.count == 3,
                     "`planarSourceBuffers` must contain three buffers.")
        
        precondition((self.size == planarSourceBuffers[0].size) &&
                     (self.size == planarSourceBuffers[1].size) &&
                     (self.size == planarSourceBuffers[2].size),
                     "Source and destination buffers must be the same size.")
        
        planarSourceBuffers[0].withUnsafePointerToVImageBuffer { r in
            planarSourceBuffers[1].withUnsafePointerToVImageBuffer { g in
                planarSourceBuffers[2].withUnsafePointerToVImageBuffer { b in
                    self.withUnsafePointerToVImageBuffer { rgb in
                        
                        _ = vImageConvert_PlanarFtoRGBFFF(r,
                                                          g,
                                                          b,
                                                          rgb,
                                                          vImage_Flags(kvImageNoFlags))
                    }
                }
            }
        }
    }
  @inlinable public func deinterleave(planarDestinationBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>]) {
        
        precondition(planarDestinationBuffers.count == 3,
                     "`planarSourceBuffers` must contain three buffers.")
        
        precondition((self.size == planarDestinationBuffers[0].size) &&
                     (self.size == planarDestinationBuffers[1].size) &&
                     (self.size == planarDestinationBuffers[2].size),
                     "Source and destination buffers must be the same size.")
        
        planarDestinationBuffers[0].withUnsafePointerToVImageBuffer { r in
            planarDestinationBuffers[1].withUnsafePointerToVImageBuffer { g in
                planarDestinationBuffers[2].withUnsafePointerToVImageBuffer { b in
                    self.withUnsafePointerToVImageBuffer { rgb in
                        
                        _ = vImageConvert_RGBFFFtoPlanarF(rgb,
                                                          r,
                                                          g,
                                                          b,
                                                          vImage_Flags(kvImageNoFlags))
                    }
                }
            }
        }
    }
  @inlinable public func deinterleave(destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarFx3>) {
        
        destination.withUnsafePixelBuffers { planarDestinationBuffers in
            
            self.deinterleave(planarDestinationBuffers: planarDestinationBuffers)
            
        }
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @frozen public struct RelationalOperator {
    @usableFromInline
    internal var value: Accelerate.BNNSRelationalOperator
    @usableFromInline
    @inline(__always) internal init(_ value: Accelerate.BNNSRelationalOperator)
    @inlinable public static var equal: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorEqual) }
    }
    @inlinable public static var less: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLess) }
    }
    @inlinable public static var lessEqual: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLessEqual) }
    }
    @inlinable public static var greater: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorGreater) }
    }
    @inlinable public static var greaterEqual: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorGreaterEqual) }
    }
    @inlinable public static var notEqual: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorNotEqual) }
    }
    @inlinable public static var and: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLogicalAND) }
    }
    @inlinable public static var or: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLogicalOR) }
    }
    @inlinable public static var not: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLogicalNOT) }
    }
    @inlinable public static var nand: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLogicalNAND) }
    }
    @inlinable public static var nor: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLogicalNOR) }
    }
    @inlinable public static var xor: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLogicalXOR) }
    }
  }
  public static func compare(_ inputA: Accelerate.BNNSNDArrayDescriptor, _ inputB: Accelerate.BNNSNDArrayDescriptor, using relationalOperator: Accelerate.BNNS.RelationalOperator, output: Accelerate.BNNSNDArrayDescriptor) throws
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func applyLookup(_ lookupTable: [Accelerate.Pixel_8], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>) {
        
        precondition(lookupTable.count == 256,
                     "The lookup table must contain 256 values.")
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                _ = vImageTableLookUp_Planar8(
                    src,
                    dst,
                    lookupTable,
                    vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func applyLookup(_ lookupTable: [Accelerate.Pixel_16U], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar16U>) {
        
        precondition(lookupTable.count == 256,
                     "The lookup table must contain 256 values.")
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                _ = vImageLookupTable_Planar8toPlanar16(
                    src,
                    dst,
                    lookupTable,
                    vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func applyLookup(_ lookupTable: [Accelerate.Pixel_F], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>) {
        
        precondition(lookupTable.count == 256,
                     "The lookup table must contain 256 values.")
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                _ = vImageLookupTable_Planar8toPlanarF(
                    src,
                    dst,
                    lookupTable,
                    vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func applyLookup(_ lookupTable: [Accelerate.Pixel_8888], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x3>) {
        
        precondition(lookupTable.count == 256,
                     "The lookup table must contain 256 values.")
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        lookupTable.withUnsafeBytes { ptr in
            let tbl = ptr.assumingMemoryBound(to: UInt32.self)
            
            self.withUnsafePointerToVImageBuffer { src in
                destination.withUnsafePointerToVImageBuffer { dst in
                    
                    _ = vImageLookupTable_Planar8toPlanar24(
                        src,
                        dst,
                        tbl.baseAddress!,
                        vImage_Flags(kvImageNoFlags))
                }
            }
        }
    }
  @inlinable public func applyLookup(_ lookupTable: [Accelerate.Pixel_FFFF], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx3>) {
        
        precondition(lookupTable.count == 256,
                     "The lookup table must contain 256 values.")
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                
                _ = vImageLookupTable_Planar8toPlanar96(
                    src,
                    dst,
                    lookupTable,
                    vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func applyLookup(alphaTable: [Accelerate.Pixel_8]?, redTable: [Accelerate.Pixel_8]?, greenTable: [Accelerate.Pixel_8]?, blueTable: [Accelerate.Pixel_8]?, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x4>) {
        
        precondition(alphaTable?.count ?? 256 == 256,
                     "The alpha lookup table must contain 256 values.")
        precondition(redTable?.count ?? 256 == 256,
                     "The red lookup table must contain 256 values.")
        precondition(greenTable?.count ?? 256 == 256,
                     "The green lookup table must contain 256 values.")
        precondition(blueTable?.count ?? 256 == 256,
                     "The blue lookup table must contain 256 values.")
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                _ = vImageTableLookUp_ARGB8888(
                    src,
                    dst,
                    alphaTable,
                    redTable,
                    greenTable,
                    blueTable,
                    vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func applyLookup(_ lookupTable: [Accelerate.Pixel_8], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>) {
        
        precondition(lookupTable.count == 4096,
                     "The lookup table must contain 4096 values.")
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                _ = vImageLookupTable_PlanarFtoPlanar8(
                    src,
                    dst,
                    lookupTable,
                    vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func applyLookup(_ lookupTable: [Accelerate.Pixel_F], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>) {
        
        precondition(lookupTable.count != 0,
                     "The lookup table must contain at least one value.")
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                _ = vImageInterpolatedLookupTable_PlanarF(
                    src,
                    dst,
                    lookupTable,
                    vImagePixelCount(lookupTable.count),
                    1,
                    0,
                    vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar16U {
  @inlinable public func applyLookup(_ lookupTable: [Accelerate.Pixel_16U], destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar16U>) {
        
        precondition(lookupTable.count == 65536,
                     "The lookup table must contain 65536 values.")
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        self.withUnsafePointerToVImageBuffer { src in
            destination.withUnsafePointerToVImageBuffer { dst in
                _ = vImageLookupTable_Planar16(
                    src,
                    dst,
                    lookupTable,
                    vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum DescriptorType {
    case constant
    case sample
    case parameter
    public static func == (a: Accelerate.BNNS.DescriptorType, b: Accelerate.BNNS.DescriptorType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArithmeticUnaryFunction : Swift.CaseIterable {
    case squareRoot
    case reciprocalSquareRoot
    case floor
    case ceil
    case round
    case sin
    case cos
    case tan
    case asin
    case acos
    case atan
    case sinh
    case cosh
    case tanh
    case asinh
    case acosh
    case atanh
    case exp
    case exp2
    case log
    case log2
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case abs
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case sign
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case negate
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case reciprocal
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case square
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case erf
    public var bnnsArithmeticFunction: Accelerate.BNNSArithmeticFunction {
      get
    }
    public static var allCases: [Accelerate.BNNS.ArithmeticUnaryFunction] {
      get
    }
    public static func == (a: Accelerate.BNNS.ArithmeticUnaryFunction, b: Accelerate.BNNS.ArithmeticUnaryFunction) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [Accelerate.BNNS.ArithmeticUnaryFunction]
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArithmeticBinaryFunction : Swift.CaseIterable {
    case add
    case subtract
    case multiply
    case multiplyNoNaN
    case divide
    case divideNoNaN
    case pow
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case max
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case min
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case flooringDivide
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case truncatingDivide
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    case truncatingRemainder
    public static var allCases: [Accelerate.BNNS.ArithmeticBinaryFunction] {
      get
    }
    public static func == (a: Accelerate.BNNS.ArithmeticBinaryFunction, b: Accelerate.BNNS.ArithmeticBinaryFunction) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [Accelerate.BNNS.ArithmeticBinaryFunction]
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class UnaryArithmeticLayer : Accelerate.BNNS.Layer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, inputDescriptorType: Accelerate.BNNS.DescriptorType, output: Accelerate.BNNSNDArrayDescriptor, outputDescriptorType: Accelerate.BNNS.DescriptorType, function: Accelerate.BNNS.ArithmeticUnaryFunction, activation: Accelerate.BNNS.ActivationFunction = .identity, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class BinaryArithmeticLayer : Accelerate.BNNS.Layer {
    convenience public init?(inputA: Accelerate.BNNSNDArrayDescriptor, inputADescriptorType: Accelerate.BNNS.DescriptorType, inputB: Accelerate.BNNSNDArrayDescriptor, inputBDescriptorType: Accelerate.BNNS.DescriptorType, output: Accelerate.BNNSNDArrayDescriptor, outputDescriptorType: Accelerate.BNNS.DescriptorType, function: Accelerate.BNNS.ArithmeticBinaryFunction, activation: Accelerate.BNNS.ActivationFunction = .identity, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputAGradient inputAGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputBGradient inputBGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func linearInterpolate<T, U>(_ vectorA: T, _ vectorB: U, using interpolationConstant: Swift.Float) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                linearInterpolate(vectorA,
                                  vectorB,
                                  using: interpolationConstant,
                                  result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func linearInterpolate<T, U, V>(_ vectorA: T, _ vectorB: U, using interpolationConstant: Swift.Float, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vectorA.count == result.count)
            precondition(vectorB.count == result.count)
            let n = vDSP_Length(result.count)
            
            vectorA.withUnsafeBufferPointer { a in
                vectorB.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        
                        vDSP_vintb(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   [interpolationConstant],
                                   dest.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func linearInterpolate<T, U>(_ vectorA: T, _ vectorB: U, using interpolationConstant: Swift.Double) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                linearInterpolate(vectorA,
                                  vectorB,
                                  using: interpolationConstant,
                                  result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func linearInterpolate<T, U, V>(_ vectorA: T, _ vectorB: U, using interpolationConstant: Swift.Double, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vectorA.count == result.count)
            precondition(vectorB.count == result.count)
            let n = vDSP_Length(result.count)
            
            vectorA.withUnsafeBufferPointer { a in
                vectorB.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        
                        vDSP_vintbD(a.baseAddress!, 1,
                                    b.baseAddress!, 1,
                                    [interpolationConstant],
                                    dest.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func linearInterpolate<T, U>(elementsOf vector: T, using controlVector: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: controlVector.count) {
                buffer, initializedCount in
                
                linearInterpolate(elementsOf: vector,
                                  using: controlVector,
                                  result: &buffer)
                
                initializedCount = controlVector.count
            }
            
            return result
    }
  @inlinable public static func linearInterpolate<T, U, V>(elementsOf vector: T, using controlVector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(controlVector.count == result.count)
            
            let n = vDSP_Length(result.count)
            let m = vDSP_Length(vector.count)
            
            vector.withUnsafeBufferPointer { a in
                controlVector.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        vDSP_vlint(a.baseAddress!,
                                   b.baseAddress!, 1,
                                   dest.baseAddress!, 1,
                                   n, m)
                    }
                }
            }
    }
  @inlinable public static func linearInterpolate<T, U>(elementsOf vector: T, using controlVector: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: controlVector.count) {
                buffer, initializedCount in
                
                linearInterpolate(elementsOf: vector,
                                  using: controlVector,
                                  result: &buffer)
                
                initializedCount = controlVector.count
            }
            
            return result
    }
  @inlinable public static func linearInterpolate<T, U, V>(elementsOf vector: T, using controlVector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(controlVector.count == result.count)
            
            let n = vDSP_Length(result.count)
            let m = vDSP_Length(vector.count)
            
            vector.withUnsafeBufferPointer { a in
                controlVector.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        vDSP_vlintD(a.baseAddress!,
                                    b.baseAddress!, 1,
                                    dest.baseAddress!, 1,
                                    n, m)
                    }
                }
            }
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum InterpolationMethod {
    case linear
    case nearestNeighbor
    public static func == (a: Accelerate.BNNS.InterpolationMethod, b: Accelerate.BNNS.InterpolationMethod) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ResizeLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(interpolationMethod: Accelerate.BNNS.InterpolationMethod, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, alignsCorners: Swift.Bool, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vForce {
  @inlinable public static func ceil<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                ceil(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func ceil<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvceilf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func ceil<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                ceil(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func ceil<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvceil(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func floor<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                floor(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func floor<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvfloorf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func floor<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                floor(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func floor<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvfloor(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func copysign<U, V>(magnitudes: U, signs: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(magnitudes.count == signs.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: magnitudes.count) {
                buffer, initializedCount in
                
                copysign(magnitudes: magnitudes,
                         signs: signs,
                         result: &buffer)
                
                initializedCount = magnitudes.count
            }
            
            return result
    }
  @inlinable public static func copysign<T, U, V>(magnitudes: T, signs: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(magnitudes.count == signs.count && signs.count == result.count)
            
            var n = Int32(magnitudes.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                magnitudes.withUnsafeBufferPointer { mag in
                    signs.withUnsafeBufferPointer { sgn in
                        vvcopysignf(dest.baseAddress!,
                                    mag.baseAddress!,
                                    sgn.baseAddress!,
                                    &n)
                    }
                }
            }
    }
  @inlinable public static func copysign<U, V>(magnitudes: U, signs: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(magnitudes.count == signs.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: magnitudes.count) {
                buffer, initializedCount in
                
                copysign(magnitudes: magnitudes,
                         signs: signs,
                         result: &buffer)
                
                initializedCount = magnitudes.count
            }
            
            return result
    }
  @inlinable public static func copysign<T, U, V>(magnitudes: T, signs: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(magnitudes.count == signs.count && signs.count == result.count)
            
            var n = Int32(magnitudes.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                magnitudes.withUnsafeBufferPointer { mag in
                    signs.withUnsafeBufferPointer { sgn in
                        vvcopysign(dest.baseAddress!,
                                   mag.baseAddress!,
                                   sgn.baseAddress!,
                                   &n)
                    }
                }
            }
    }
  @inlinable public static func truncatingRemainder<U, V>(dividends: U, divisors: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(dividends.count == divisors.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: dividends.count) {
                buffer, initializedCount in
                
                truncatingRemainder(dividends: dividends,
                                    divisors: divisors,
                                    result: &buffer)
                
                initializedCount = dividends.count
            }
            
            return result
    }
  @inlinable public static func truncatingRemainder<T, U, V>(dividends: T, divisors: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(dividends.count == divisors.count && divisors.count == result.count)
            
            var n = Int32(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                dividends.withUnsafeBufferPointer { a in
                    divisors.withUnsafeBufferPointer { b in
                        vvfmodf(dest.baseAddress!,
                                a.baseAddress!,
                                b.baseAddress!,
                                &n)
                    }
                }
            }
    }
  @inlinable public static func truncatingRemainder<U, V>(dividends: U, divisors: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(dividends.count == divisors.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: dividends.count) {
                buffer, initializedCount in
                
                truncatingRemainder(dividends: dividends,
                                    divisors: divisors,
                                    result: &buffer)
                
                initializedCount = dividends.count
            }
            
            return result
    }
  @inlinable public static func truncatingRemainder<T, U, V>(dividends: T, divisors: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(dividends.count == divisors.count && divisors.count == result.count)
            
            var n = Int32(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                dividends.withUnsafeBufferPointer { a in
                    divisors.withUnsafeBufferPointer { b in
                        vvfmod(dest.baseAddress!,
                               a.baseAddress!,
                               b.baseAddress!,
                               &n)
                    }
                }
            }
    }
  @inlinable public static func remainder<U, V>(dividends: U, divisors: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(dividends.count == divisors.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: dividends.count) {
                buffer, initializedCount in
                
                remainder(dividends: dividends,
                          divisors: divisors,
                          result: &buffer)
                
                initializedCount = dividends.count
            }
            
            return result
    }
  @inlinable public static func remainder<T, U, V>(dividends: T, divisors: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(dividends.count == divisors.count && divisors.count == result.count)
            
            var n = Int32(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                dividends.withUnsafeBufferPointer { a in
                    divisors.withUnsafeBufferPointer { b in
                        vvremainderf(dest.baseAddress!,
                                     a.baseAddress!,
                                     b.baseAddress!,
                                     &n)
                    }
                }
            }
    }
  @inlinable public static func remainder<U, V>(dividends: U, divisors: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(dividends.count == divisors.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: dividends.count) {
                buffer, initializedCount in
                
                remainder(dividends: dividends,
                          divisors: divisors,
                          result: &buffer)
                
                initializedCount = dividends.count
            }
            
            return result
    }
  @inlinable public static func remainder<T, U, V>(dividends: T, divisors: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(dividends.count == divisors.count && divisors.count == result.count)
            
            var n = Int32(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                dividends.withUnsafeBufferPointer { a in
                    divisors.withUnsafeBufferPointer { b in
                        vvremainder(dest.baseAddress!,
                                    a.baseAddress!,
                                    b.baseAddress!,
                                    &n)
                    }
                }
            }
    }
  @inlinable public static func trunc<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                trunc(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func trunc<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvintf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func trunc<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                trunc(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func trunc<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvint(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func nearestInteger<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                nearestInteger(vector,
                               result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func nearestInteger<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvnintf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func nearestInteger<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                nearestInteger(vector,
                               result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func nearestInteger<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvnint(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func rsqrt<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                rsqrt(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func rsqrt<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvrsqrtf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func rsqrt<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                rsqrt(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func rsqrt<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvrsqrt(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func sqrt<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sqrt(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sqrt<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsqrtf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func sqrt<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sqrt(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sqrt<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsqrt(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func reciprocal<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                reciprocal(vector,
                           result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func reciprocal<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvrecf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func reciprocal<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                reciprocal(vector,
                           result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func reciprocal<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvrec(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vForce {
  @inlinable public static func exp<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                exp(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func exp<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexpf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func expm1<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                expm1(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func expm1<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexpm1f(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func exp2<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                exp2(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func exp2<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexp2f(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func exp<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                exp(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func exp<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexp(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func expm1<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                expm1(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func expm1<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexpm1(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func exp2<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                exp2(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func exp2<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexp2(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func log2<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                log2(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func log2<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlog2f(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func log10<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                log10(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func log10<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlog10f(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func log2<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                log2(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func log2<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlog2(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func log10<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                log10(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func log10<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlog10(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func logb<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                logb(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func logb<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlogbf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func logb<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                logb(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func logb<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlogb(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vForce {
  @inlinable public static func pow<U, V>(bases: U, exponents: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(bases.count == exponents.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: exponents.count) {
                buffer, initializedCount in
                
                pow(bases: bases,
                    exponents: exponents,
                    result: &buffer)
                
                initializedCount = exponents.count
            }
            
            return result
    }
  @inlinable public static func pow<T, U, V>(bases: T, exponents: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(bases.count == exponents.count && exponents.count == result.count)
            
            var n = Int32(bases.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                bases.withUnsafeBufferPointer { bases in
                    exponents.withUnsafeBufferPointer { exponents in
                        vvpowf(dest.baseAddress!,
                               exponents.baseAddress!,
                               bases.baseAddress!,
                               &n)
                    }
                }
            }
    }
  @inlinable public static func pow<U, V>(bases: U, exponents: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(bases.count == exponents.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: exponents.count) {
                buffer, initializedCount in
                
                pow(bases: bases,
                    exponents: exponents,
                    result: &buffer)
                
                initializedCount = exponents.count
            }
            
            return result
    }
  @inlinable public static func pow<T, U, V>(bases: T, exponents: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(bases.count == exponents.count && exponents.count == result.count)
            
            var n = Int32(bases.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                bases.withUnsafeBufferPointer { bases in
                    exponents.withUnsafeBufferPointer { exponents in
                        vvpow(dest.baseAddress!,
                              exponents.baseAddress!,
                              bases.baseAddress!,
                              &n)
                    }
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vForce {
  @inlinable public static func sin<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sin(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sin<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func sin<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sin(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sin<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsin(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func sinPi<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sinPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sinPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinpif(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func sinPi<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sinPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sinPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinpi(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func cos<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cos(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cos<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcosf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func cos<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cos(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cos<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcos(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func cosPi<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cosPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cosPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcospif(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func cosPi<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cosPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cosPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcospi(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func sincos<T, U, V>(_ vector: T, sinResult: inout U, cosResult: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateMutableBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == sinResult.count && sinResult.count == cosResult.count)
            
            var n = Int32(vector.count)
            
            sinResult.withUnsafeMutableBufferPointer { sinDest in
                cosResult.withUnsafeMutableBufferPointer { cosDest in
                    vector.withUnsafeBufferPointer { src in
                        vvsincosf(sinDest.baseAddress!,
                                  cosDest.baseAddress!,
                                  src.baseAddress!,
                                  &n)
                    }
                }
            }
    }
  @inlinable public static func sincos<T, U, V>(_ vector: T, sinResult: inout U, cosResult: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateMutableBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == sinResult.count && sinResult.count == cosResult.count)
            
            var n = Int32(vector.count)
            
            sinResult.withUnsafeMutableBufferPointer { sinDest in
                cosResult.withUnsafeMutableBufferPointer { cosDest in
                    vector.withUnsafeBufferPointer { src in
                        vvsincos(sinDest.baseAddress!,
                                 cosDest.baseAddress!,
                                 src.baseAddress!,
                                 &n)
                    }
                }
            }
    }
  @inlinable public static func tan<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tan(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tan<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func tan<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tan(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tan<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtan(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func tanPi<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tanPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tanPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanpif(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func tanPi<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tanPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tanPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanpi(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func asin<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                asin(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func asin<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvasinf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func asin<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                asin(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func asin<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvasin(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func acos<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                acos(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func acos<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvacosf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func acos<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                acos(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func acos<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvacos(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func atan<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                atan(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func atan<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvatanf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func atan<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                atan(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func atan<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvatan(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vForce {
  @inlinable public static func sinh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sinh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sinh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinhf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func sinh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sinh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sinh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinh(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func cosh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cosh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cosh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcoshf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func cosh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cosh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cosh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcosh(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func tanh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tanh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tanh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanhf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func tanh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tanh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tanh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanh(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func asinh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                asinh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func asinh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvasinhf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func asinh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                asinh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func asinh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvasinh(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func acosh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                acosh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func acosh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvacoshf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func acosh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                acosh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func acosh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvacosh(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func atanh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                atanh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func atanh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvatanhf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func atanh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                atanh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func atanh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvatanh(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public enum SparsityType {
    case unstructured
    public static func == (a: Accelerate.BNNS.SparsityType, b: Accelerate.BNNS.SparsityType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public struct SparseParameters {
    public init(type: Accelerate.BNNS.SparsityType = .unstructured, ratio: (numerator: Swift.UInt32, denominator: Swift.UInt32), targetSystem: Accelerate.BNNSTargetSystem)
    public let type: Accelerate.BNNS.SparsityType
    public let ratio: (numerator: Swift.UInt32, denominator: Swift.UInt32)
    public let targetSystem: Accelerate.BNNSTargetSystem
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public enum SparseLayout {
    case coo(indices: Accelerate.BNNSNDArrayDescriptor)
    case csr(columnIndices: Accelerate.BNNSNDArrayDescriptor, rowStarts: Accelerate.BNNSNDArrayDescriptor)
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS.FullyConnectedLayer {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func sparsify(batchSize: Swift.Int = 1, inputLayout layout: Accelerate.BNNS.SparseLayout, inputDenseShape: Accelerate.BNNSNDArrayDescriptor, inputValues: Accelerate.BNNSNDArrayDescriptor, output: inout Accelerate.BNNSNDArrayDescriptor, sparseParameters: Accelerate.BNNS.SparseParameters? = nil, workspace: Swift.UnsafeMutableRawBufferPointer? = nil, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedUnaryArithmeticParameters : Accelerate.FusableLayerParameters {
    public var inputDescriptorType: Accelerate.BNNS.DescriptorType
    public var outputDescriptorType: Accelerate.BNNS.DescriptorType
    public var function: Accelerate.BNNS.ArithmeticUnaryFunction
    public init(inputDescriptorType: Accelerate.BNNS.DescriptorType, outputDescriptorType: Accelerate.BNNS.DescriptorType, function: Accelerate.BNNS.ArithmeticUnaryFunction)
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol PixelFormat {
  associatedtype ComponentType : Swift.Equatable
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol SinglePlanePixelFormat : Accelerate.PixelFormat {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol MultiplePlanePixelFormat : Accelerate.PixelFormat {
  associatedtype PlanarPixelFormat : Accelerate.StaticPixelFormat
  static var planeCount: Swift.Int { get }
  static var bitCountPerPlanarPixel: Swift.Int { get }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol StaticPixelFormat : Accelerate.SinglePlanePixelFormat {
  static var bitCountPerPixel: Swift.Int { get }
  static var channelCount: Swift.Int { get }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol InitializableFromCGImage : Accelerate.SinglePlanePixelFormat {
  static var bitCountPerComponent: Swift.Int { get }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public struct Planar8x2 : Accelerate.PixelFormat, Accelerate.MultiplePlanePixelFormat {
    public typealias ComponentType = Accelerate.Pixel_8
    public typealias PlanarPixelFormat = Accelerate.vImage.Planar8
    public static var bitCountPerPlanarPixel: Swift.Int {
      get
    }
    public static var planeCount: Swift.Int {
      get
    }
  }
  public struct Planar8x3 : Accelerate.PixelFormat, Accelerate.MultiplePlanePixelFormat {
    public typealias ComponentType = Accelerate.Pixel_8
    public typealias PlanarPixelFormat = Accelerate.vImage.Planar8
    public static var bitCountPerPlanarPixel: Swift.Int {
      get
    }
    public static var planeCount: Swift.Int {
      get
    }
  }
  public struct Planar8x4 : Accelerate.PixelFormat, Accelerate.MultiplePlanePixelFormat {
    public typealias ComponentType = Accelerate.Pixel_8
    public typealias PlanarPixelFormat = Accelerate.vImage.Planar8
    public static var bitCountPerPlanarPixel: Swift.Int {
      get
    }
    public static var planeCount: Swift.Int {
      get
    }
  }
  public struct PlanarFx2 : Accelerate.PixelFormat, Accelerate.MultiplePlanePixelFormat {
    public typealias ComponentType = Accelerate.Pixel_F
    public typealias PlanarPixelFormat = Accelerate.vImage.PlanarF
    public static var bitCountPerPlanarPixel: Swift.Int {
      get
    }
    public static var planeCount: Swift.Int {
      get
    }
  }
  public struct PlanarFx3 : Accelerate.PixelFormat, Accelerate.MultiplePlanePixelFormat {
    public typealias ComponentType = Accelerate.Pixel_F
    public typealias PlanarPixelFormat = Accelerate.vImage.PlanarF
    public static var bitCountPerPlanarPixel: Swift.Int {
      get
    }
    public static var planeCount: Swift.Int {
      get
    }
  }
  public struct PlanarFx4 : Accelerate.PixelFormat, Accelerate.MultiplePlanePixelFormat {
    public typealias ComponentType = Accelerate.Pixel_F
    public typealias PlanarPixelFormat = Accelerate.vImage.PlanarF
    public static var bitCountPerPlanarPixel: Swift.Int {
      get
    }
    public static var planeCount: Swift.Int {
      get
    }
  }
  public struct DynamicPixelFormat : Accelerate.SinglePlanePixelFormat {
    public typealias ComponentType = Swift.Never
  }
  public struct Planar8 : Accelerate.InitializableFromCGImage, Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_8
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerComponent: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
  public struct Interleaved8x2 : Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_8
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
  public struct Interleaved8x3 : Accelerate.InitializableFromCGImage, Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_8
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerComponent: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
  public struct Interleaved8x4 : Accelerate.InitializableFromCGImage, Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_8
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerComponent: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
  public struct Planar16F : Accelerate.InitializableFromCGImage, Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_16F
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerComponent: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
  public struct Interleaved16Fx2 : Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_16F
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
  public struct Interleaved16Fx4 : Accelerate.InitializableFromCGImage, Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_16F
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerComponent: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
  public struct PlanarF : Accelerate.InitializableFromCGImage, Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_F
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerComponent: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
  public struct InterleavedFx2 : Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_F
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
  public struct InterleavedFx3 : Accelerate.InitializableFromCGImage, Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_F
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerComponent: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
  public struct InterleavedFx4 : Accelerate.InitializableFromCGImage, Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_F
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerComponent: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
  public struct Planar16U : Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_16U
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
  public struct Interleaved16Ux2 : Accelerate.InitializableFromCGImage, Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_16U
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerComponent: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
  public struct Interleaved16Ux4 : Accelerate.InitializableFromCGImage, Accelerate.StaticPixelFormat {
    public typealias ComponentType = Accelerate.Pixel_16U
    public static var channelCount: Swift.Int {
      get
    }
    public static var bitCountPerComponent: Swift.Int {
      get
    }
    public static var bitCountPerPixel: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.Planar16F {
  @inlinable public static func makePixel(_ source: Accelerate.Pixel_F) -> Accelerate.Pixel_16F {
        
        var dest = Pixel_16F(0)
        
        convert(src: source, dest: &dest,
                convertFunc: vImageConvert_PlanarFtoPlanar16F,
                channelCount: Self.channelCount)
        
        return dest
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.Interleaved16Fx2 {
  @inlinable public static func makePixel(_ source: Accelerate.Pixel_FF) -> Accelerate.Pixel_16F16F {
 
        var dest = Pixel_16F16F(0, 0)
        
        convert(src: source, dest: &dest,
                convertFunc: vImageConvert_PlanarFtoPlanar16F,
                channelCount: Self.channelCount)
        
        return dest
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.Interleaved16Fx4 {
  @inlinable public static func makePixel(_ source: Accelerate.Pixel_FFFF) -> Accelerate.Pixel_ARGB_16F {
 
        var dest = Pixel_ARGB_16F(0, 0, 0, 0)
        
        convert(src: source, dest: &dest,
                convertFunc: vImageConvert_PlanarFtoPlanar16F,
                channelCount: Self.channelCount)
        
        return dest
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PlanarF {
  @inlinable public static func makePixel(_ source: Accelerate.Pixel_16F) -> Accelerate.Pixel_F {

        var dest = Pixel_F(0)
        
        convert(src: source, dest: &dest,
                convertFunc: vImageConvert_Planar16FtoPlanarF,
                channelCount: Self.channelCount)
        
        return dest
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.InterleavedFx2 {
  @inlinable public static func makePixel(_ source: Accelerate.Pixel_16F16F) -> Accelerate.Pixel_FF {
        
        var dest = Pixel_FF(0, 0)
        
        convert(src: source, dest: &dest,
                convertFunc: vImageConvert_Planar16FtoPlanarF,
                channelCount: Self.channelCount)
        
        return dest
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.InterleavedFx4 {
  @inlinable public static func makePixel(_ source: Accelerate.Pixel_ARGB_16F) -> Accelerate.Pixel_FFFF {

        var dest = Pixel_FFFF(0, 0, 0, 0)
        
        convert(src: source, dest: &dest,
                convertFunc: vImageConvert_Planar16FtoPlanarF,
                channelCount: Self.channelCount)
        
        return dest
    }
}
@usableFromInline
internal func convert<Src, Dest>(src: Src, dest: inout Dest, convertFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Accelerate.vImage_Flags) -> Swift.Int, channelCount: Swift.Int)
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public static func copy(_ source: Accelerate.BNNSNDArrayDescriptor, to destination: Accelerate.BNNSNDArrayDescriptor, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func applyMorphology(operation: Accelerate.vImage.MorphologyOperation<Accelerate.Pixel_8>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        self._applyMorphology(operation: operation,
                              destination: destination,
                              erodeFunc: vImageErode_ARGB8888,
                              dilateFunc: vImageDilate_ARGB8888,
                              minFunc: vImageMin_ARGB8888,
                              maxFunc: vImageMax_ARGB8888)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func applyMorphology(operation: Accelerate.vImage.MorphologyOperation<Accelerate.Pixel_8>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        self._applyMorphology(operation: operation,
                              destination: destination,
                              erodeFunc: vImageErode_Planar8,
                              dilateFunc: vImageDilate_Planar8,
                              minFunc: vImageMin_Planar8,
                              maxFunc: vImageMax_Planar8)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.UInt8, Format.PlanarPixelFormat.ComponentType == Swift.UInt8 {
  @inlinable public func applyMorphology(operation: Accelerate.vImage.MorphologyOperation<Format.ComponentType>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        for i in 0 ..< Format.planeCount {
            self[i]._applyMorphology(operation: operation,
                                     destination: destination[i],
                                     erodeFunc: vImageErode_Planar8,
                                     dilateFunc: vImageDilate_Planar8,
                                     minFunc: vImageMin_Planar8,
                                     maxFunc: vImageMax_Planar8)
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func applyMorphology(operation: Accelerate.vImage.MorphologyOperation<Accelerate.Pixel_F>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        self._applyMorphology(operation: operation,
                              destination: destination,
                              erodeFunc: vImageErode_ARGBFFFF,
                              dilateFunc: vImageDilate_ARGBFFFF,
                              minFunc: vImageMin_ARGBFFFF,
                              maxFunc: vImageMax_ARGBFFFF)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func applyMorphology(operation: Accelerate.vImage.MorphologyOperation<Accelerate.Pixel_F>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        self._applyMorphology(operation: operation,
                              destination: destination,
                              erodeFunc: vImageErode_PlanarF,
                              dilateFunc: vImageDilate_PlanarF,
                              minFunc: vImageMin_PlanarF,
                              maxFunc: vImageMax_PlanarF)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.Float, Format.PlanarPixelFormat.ComponentType == Swift.Float {
  @inlinable public func applyMorphology(operation: Accelerate.vImage.MorphologyOperation<Format.ComponentType>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        for i in 0 ..< Format.planeCount {
            self[i]._applyMorphology(operation: operation,
                                     destination: destination[i],
                                     erodeFunc: vImageErode_PlanarF,
                                     dilateFunc: vImageDilate_PlanarF,
                                     minFunc: vImageMin_PlanarF,
                                     maxFunc: vImageMax_PlanarF)
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  @usableFromInline
  internal typealias MorphologyErodeDilateFunc<T> = (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Swift.UnsafePointer<T>, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal typealias MorphologyMinMaxFunc = (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutableRawPointer?, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Accelerate.vImage_Flags) -> Accelerate.vImage_Error
  @usableFromInline
  internal func _applyMorphology<T, U>(operation: Accelerate.vImage.MorphologyOperation<U>, destination: Accelerate.vImage.PixelBuffer<T>, erodeFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Swift.UnsafePointer<U>, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Accelerate.vImage_Flags) -> Accelerate.vImage_Error, dilateFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Swift.UnsafePointer<U>, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Accelerate.vImage_Flags) -> Accelerate.vImage_Error, minFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutableRawPointer?, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Accelerate.vImage_Flags) -> Accelerate.vImage_Error, maxFunc: (Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafePointer<Accelerate.vImage_Buffer>, Swift.UnsafeMutableRawPointer?, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Accelerate.vImagePixelCount, Accelerate.vImage_Flags) -> Accelerate.vImage_Error) where T : Accelerate.StaticPixelFormat, U == T.ComponentType
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public typealias StructuringElement = Accelerate.vImage.ConvolutionKernel2D
  public enum MorphologyOperation<ComponentType> {
    case maximize(kernelSize: Accelerate.vImage.Size)
    case minimize(kernelSize: Accelerate.vImage.Size)
    case dilate(structuringElement: Accelerate.vImage.ConvolutionKernel2D<ComponentType>)
    case erode(structuringElement: Accelerate.vImage.ConvolutionKernel2D<ComponentType>)
    public var structuringElement: Accelerate.vImage.ConvolutionKernel2D<ComponentType>? {
      get
    }
    public var width: Accelerate.vImagePixelCount {
      get
    }
    public var height: Accelerate.vImagePixelCount {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS {
  public static func matrixMultiplicationWorkspaceSize(inputA: Accelerate.BNNSNDArrayDescriptor, transposed transposeA: Swift.Bool, inputB: Accelerate.BNNSNDArrayDescriptor, transposed transposeB: Swift.Bool, output: Accelerate.BNNSNDArrayDescriptor, alpha: Swift.Float, filterParameters: Accelerate.BNNSFilterParameters? = nil) -> Swift.Int?
  public static func applyMatrixMultiplication(inputA: Accelerate.BNNSNDArrayDescriptor, transposed transposeA: Swift.Bool, inputB: Accelerate.BNNSNDArrayDescriptor, transposed transposeB: Swift.Bool, output: Accelerate.BNNSNDArrayDescriptor, alpha: Swift.Float, workspace: Swift.UnsafeMutableRawBufferPointer?, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedQuantizationParameters : Accelerate.FusableLayerParameters {
    public init(scale: Accelerate.BNNSNDArrayDescriptor?, bias: Accelerate.BNNSNDArrayDescriptor?)
    public var axis: Swift.Int?
    public var scale: Accelerate.BNNSNDArrayDescriptor?
    public var bias: Accelerate.BNNSNDArrayDescriptor?
  }
  public struct FusedDequantizationParameters : Accelerate.FusableLayerParameters {
    public init(scale: Accelerate.BNNSNDArrayDescriptor?, bias: Accelerate.BNNSNDArrayDescriptor?)
    public var axis: Swift.Int?
    public var scale: Accelerate.BNNSNDArrayDescriptor?
    public var bias: Accelerate.BNNSNDArrayDescriptor?
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format.ComponentType == Swift.UInt8 {
  public typealias Histogram888 = ([Accelerate.vImagePixelCount], [Accelerate.vImagePixelCount], [Accelerate.vImagePixelCount])
  public typealias Histogram8888 = ([Accelerate.vImagePixelCount], [Accelerate.vImagePixelCount], [Accelerate.vImagePixelCount], [Accelerate.vImagePixelCount])
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format.ComponentType == Swift.Float {
  public typealias HistogramFFF = (binCount: Swift.Int, [Accelerate.vImagePixelCount], [Accelerate.vImagePixelCount], [Accelerate.vImagePixelCount])
  public typealias HistogramFFFF = (binCount: Swift.Int, [Accelerate.vImagePixelCount], [Accelerate.vImagePixelCount], [Accelerate.vImagePixelCount], [Accelerate.vImagePixelCount])
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func histogram() -> Accelerate.vImage.PixelBuffer<Format>.Histogram8888 {
        var histogramBinZero = [vImagePixelCount](repeating: 0, count: 256)
        var histogramBinOne = [vImagePixelCount](repeating: 0, count: 256)
        var histogramBinTwo = [vImagePixelCount](repeating: 0, count: 256)
        var histogramBinThree = [vImagePixelCount](repeating: 0, count: 256)
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            histogramBinZero.withUnsafeMutableBufferPointer { zeroPtr in
                histogramBinOne.withUnsafeMutableBufferPointer { onePtr in
                    histogramBinTwo.withUnsafeMutableBufferPointer { twoPtr in
                        histogramBinThree.withUnsafeMutableBufferPointer { threePtr in
                            
                            var histogramBins = [zeroPtr.baseAddress, onePtr.baseAddress,
                                                 twoPtr.baseAddress, threePtr.baseAddress]
                            
                            histogramBins.withUnsafeMutableBufferPointer { histogramBinsPtr in
                                _ = vImageHistogramCalculation_ARGB8888(srcPtr,
                                                                        histogramBinsPtr.baseAddress!,
                                                                        vImage_Flags(kvImageNoFlags))
                            }
                        }
                    }
                }
            }
        }
        return (histogramBinZero, histogramBinOne, histogramBinTwo, histogramBinThree)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func histogram(binCount: Swift.Int) -> Accelerate.vImage.PixelBuffer<Format>.HistogramFFFF {
        var histogramBinZero = [vImagePixelCount](repeating: 0, count: binCount)
        var histogramBinOne = [vImagePixelCount](repeating: 0, count: binCount)
        var histogramBinTwo = [vImagePixelCount](repeating: 0, count: binCount)
        var histogramBinThree = [vImagePixelCount](repeating: 0, count: binCount)
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            histogramBinZero.withUnsafeMutableBufferPointer { zeroPtr in
                histogramBinOne.withUnsafeMutableBufferPointer { onePtr in
                    histogramBinTwo.withUnsafeMutableBufferPointer { twoPtr in
                        histogramBinThree.withUnsafeMutableBufferPointer { threePtr in
                            
                            var histogramBins = [zeroPtr.baseAddress, onePtr.baseAddress,
                                                 twoPtr.baseAddress, threePtr.baseAddress]
                            
                            histogramBins.withUnsafeMutableBufferPointer { histogramBinsPtr in
                                _ = vImageHistogramCalculation_ARGBFFFF(srcPtr,
                                                                        histogramBinsPtr.baseAddress!,
                                                                        UInt32(binCount),
                                                                        0, 1,
                                                                        vImage_Flags(kvImageNoFlags))
                            }
                        }
                    }
                }
            }
        }
        
        return (binCount,
                histogramBinZero, histogramBinOne,
                histogramBinTwo, histogramBinThree)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func specifyHistogram(_ histogram: Accelerate.vImage.PixelBuffer<Format>.HistogramFFFF, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                histogram.1.withUnsafeBufferPointer { zeroPtr in
                    histogram.2.withUnsafeBufferPointer { onePtr in
                        histogram.3.withUnsafeBufferPointer { twoPtr in
                            histogram.4.withUnsafeBufferPointer { threePtr in
                                
                                var histogramBins = [zeroPtr.baseAddress, onePtr.baseAddress,
                                                     twoPtr.baseAddress, threePtr.baseAddress]
                                
                                histogramBins.withUnsafeMutableBufferPointer { histogramBinsPtr in
                                    _ = vImageHistogramSpecification_ARGBFFFF(srcPtr,
                                                                              destPtr,
                                                                              nil,
                                                                              histogramBinsPtr.baseAddress!,
                                                                              UInt32(histogram.binCount),
                                                                              0, 1,
                                                                              vImage_Flags(kvImageNoFlags))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func specifyHistogram(_ histogram: Accelerate.vImage.PixelBuffer<Format>.Histogram8888, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                histogram.0.withUnsafeBufferPointer { zeroPtr in
                    histogram.1.withUnsafeBufferPointer { onePtr in
                        histogram.2.withUnsafeBufferPointer { twoPtr in
                            histogram.3.withUnsafeBufferPointer { threePtr in
                                
                                var histogramBins = [zeroPtr.baseAddress, onePtr.baseAddress,
                                                     twoPtr.baseAddress, threePtr.baseAddress]
                                
                                histogramBins.withUnsafeMutableBufferPointer { histogramBinsPtr in
                                    _ = vImageHistogramSpecification_ARGB8888(srcPtr,
                                                                              destPtr,
                                                                              histogramBinsPtr.baseAddress!,
                                                                              vImage_Flags(kvImageNoFlags))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func equalizeHistogram(destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageEqualization_Planar8(srcPtr, destPtr,
                                               vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.UInt8 {
  @inlinable public func equalizeHistogram(destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        for i in 0 ..< Format.planeCount {
            withUnsafePointer(to: self.vImageBuffers[i]) { srcPtr in
                withUnsafePointer(to: destination.vImageBuffers[i]) { destPtr in
                    
                    precondition(vImageBuffers[i].width == destination.vImageBuffers[i].width &&
                                 vImageBuffers[i].height == destination.vImageBuffers[i].height,
                                 "Source and destination buffer must be the same size.")
                    
                    _ = vImageEqualization_Planar8(srcPtr,
                                                   destPtr,
                                                   vImage_Flags(kvImageNoFlags))
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func equalizeHistogram(destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageEqualization_ARGB8888(srcPtr, destPtr,
                                                vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func equalizeHistogram(binCount: Swift.Int, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageEqualization_PlanarF(srcPtr, destPtr,
                                               nil,
                                               UInt32(binCount),
                                               0, 1,
                                               vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.Float {
  @inlinable public func equalizeHistogram(binCount: Swift.Int, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        for i in 0 ..< Format.planeCount {
            withUnsafePointer(to: self.vImageBuffers[i]) { srcPtr in
                withUnsafePointer(to: destination.vImageBuffers[i]) { destPtr in
                    
                    precondition(vImageBuffers[i].width == destination.vImageBuffers[i].width &&
                                 vImageBuffers[i].height == destination.vImageBuffers[i].height,
                                 "Source and destination buffer must be the same size.")
                    
                    _ = vImageEqualization_PlanarF(srcPtr, destPtr,
                                                   nil,
                                                   UInt32(binCount),
                                                   0, 1,
                                                   vImage_Flags(kvImageNoFlags))
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func equalizeHistogram(binCount: Swift.Int, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx4>) {
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageEqualization_ARGBFFFF(srcPtr, destPtr,
                                                nil,
                                                UInt32(binCount),
                                                0, 1,
                                                vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func contrastStretch(destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageContrastStretch_Planar8(srcPtr, destPtr,
                                                  vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.UInt8 {
  @inlinable public func contrastStretch(destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        for i in 0 ..< Format.planeCount {
            withUnsafePointer(to: self.vImageBuffers[i]) { srcPtr in
                withUnsafePointer(to: destination.vImageBuffers[i]) { destPtr in
                    
                    precondition(vImageBuffers[i].width == destination.vImageBuffers[i].width &&
                                 vImageBuffers[i].height == destination.vImageBuffers[i].height,
                                 "Source and destination buffer must be the same size.")
                    
                    _ = vImageContrastStretch_Planar8(srcPtr,
                                                      destPtr,
                                                      vImage_Flags(kvImageNoFlags))
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func contrastStretch(destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x4>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageContrastStretch_ARGB8888(srcPtr, destPtr,
                                                   vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func contrastStretch(binCount: Swift.Int, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageContrastStretch_PlanarF(srcPtr, destPtr,
                                                  nil,
                                                  UInt32(binCount),
                                                  0, 1,
                                                  vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.Float {
  @inlinable public func contrastStretch(binCount: Swift.Int, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        for i in 0 ..< Format.planeCount {
            withUnsafePointer(to: self.vImageBuffers[i]) { srcPtr in
                withUnsafePointer(to: destination.vImageBuffers[i]) { destPtr in
                    
                    precondition(vImageBuffers[i].width == destination.vImageBuffers[i].width &&
                                 vImageBuffers[i].height == destination.vImageBuffers[i].height,
                                 "Source and destination buffer must be the same size.")
                    
                    _ = vImageContrastStretch_PlanarF(srcPtr, destPtr,
                                                      nil,
                                                      UInt32(binCount),
                                                      0, 1,
                                                      vImage_Flags(kvImageNoFlags))
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func contrastStretch(binCount: Swift.Int, destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx4>) {
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageContrastStretch_ARGBFFFF(srcPtr, destPtr,
                                                   nil,
                                                   UInt32(binCount),
                                                   0, 1,
                                                   vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8x3 {
  @inlinable public func histogram() -> Accelerate.vImage.PixelBuffer<Format>.Histogram888 {
        
        let h = _calculateHistogram()
        return (h[0], h[1], h[2])
    }
  public func specifyHistogram(_ histogram: Accelerate.vImage.PixelBuffer<Format>.Histogram888, destination: Accelerate.vImage.PixelBuffer<Format>)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8x4 {
  @inlinable public func histogram() -> Accelerate.vImage.PixelBuffer<Format>.Histogram8888 {
        
        let h = _calculateHistogram()
        return (h[0], h[1], h[2], h[3])
    }
  @inlinable public func specifyHistogram(_ histogram: Accelerate.vImage.PixelBuffer<Format>.Histogram8888, destination: Accelerate.vImage.PixelBuffer<Format>) {
      
        _specifyHistogram([histogram.0, histogram.1, histogram.2, histogram.3],
                          destination: destination)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.UInt8 {
  @usableFromInline
  internal func _calculateHistogram() -> [[Accelerate.vImagePixelCount]]
  @usableFromInline
  internal func _specifyHistogram(_ histogram: [[Accelerate.vImagePixelCount]], destination: Accelerate.vImage.PixelBuffer<Format>)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarFx3 {
  @inlinable public func histogram(binCount: Swift.Int) -> Accelerate.vImage.PixelBuffer<Format>.HistogramFFF {
        
        let h = _calculateHistogram(binCount: binCount)
        return (binCount: binCount,
                h[0], h[1], h[2])
    }
  @inlinable public func specifyHistogram(_ histogram: Accelerate.vImage.PixelBuffer<Format>.HistogramFFF, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        _specifyHistogram([histogram.1, histogram.2, histogram.3],
                          binCount: histogram.binCount,
                          destination: destination)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarFx4 {
  @inlinable public func histogram(binCount: Swift.Int) -> Accelerate.vImage.PixelBuffer<Format>.HistogramFFFF {
        
        let h = _calculateHistogram(binCount: binCount)
        return (binCount: binCount,
                h[0], h[1], h[2], h[3])
    }
  @inlinable public func specifyHistogram(_ histogram: Accelerate.vImage.PixelBuffer<Format>.HistogramFFFF, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        _specifyHistogram([histogram.1, histogram.2, histogram.3, histogram.4],
                          binCount: histogram.binCount,
                          destination: destination)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat, Format.ComponentType == Swift.Float {
  @usableFromInline
  internal func _calculateHistogram(binCount: Swift.Int) -> [[Accelerate.vImagePixelCount]]
  @usableFromInline
  internal func _specifyHistogram(_ histogram: [[Accelerate.vImagePixelCount]], binCount: Swift.Int, destination: Accelerate.vImage.PixelBuffer<Format>)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public struct PixelBuffer<Format> where Format : Accelerate.PixelFormat {
    public var size: Accelerate.vImage.Size {
      get
    }
    public var width: Swift.Int {
      get
    }
    public var height: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.SinglePlanePixelFormat {
  @usableFromInline
  internal var vImageBuffer: Accelerate.vImage_Buffer {
    get
  }
  public func withUnsafeVImageBuffer<R>(_ body: (Accelerate.vImage_Buffer) throws -> R) rethrows -> R
  public func withUnsafePointerToVImageBuffer<R>(_ body: (Swift.UnsafePointer<Accelerate.vImage_Buffer>) throws -> R) rethrows -> R
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat {
  @usableFromInline
  internal var vImageBuffers: [Accelerate.vImage_Buffer] {
    get
  }
  public func withUnsafeVImageBuffers<R>(_ body: ([Accelerate.vImage_Buffer]) throws -> R) rethrows -> R
  public func withUnsafePixelBuffers<R>(_ body: ([Accelerate.vImage.PixelBuffer<Format.PlanarPixelFormat>]) throws -> R) rethrows -> R
  public func withUnsafePixelBuffer<R>(at index: Swift.Int, _ body: (Accelerate.vImage.PixelBuffer<Format.PlanarPixelFormat>) throws -> R) rethrows -> R
  @usableFromInline
  internal var pixelBuffers: [Accelerate.vImage.PixelBuffer<Format.PlanarPixelFormat>] {
    get
  }
  @usableFromInline
  internal subscript(index: Swift.Int) -> Accelerate.vImage.PixelBuffer<Format.PlanarPixelFormat> {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.SinglePlanePixelFormat {
  public init(data: Swift.UnsafeMutableRawPointer, width: Swift.Int, height: Swift.Int, byteCountPerRow: Swift.Int, pixelFormat: Format.Type)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  public init(data: Swift.UnsafeMutableRawPointer, width: Swift.Int, height: Swift.Int, byteCountPerRow: Swift.Int? = nil, pixelFormat: Format.Type = Format.self)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.MultiplePlanePixelFormat {
  public init(size: Accelerate.vImage.Size, pixelFormat: Format.Type = Format.self)
  public init(planarBuffers: [Accelerate.vImage.PixelBuffer<Format.PlanarPixelFormat>], pixelFormat: Format.Type = Format.self)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  public init(width: Swift.Int, height: Swift.Int, pixelFormat: Format.Type = Format.self)
  public init(size: Accelerate.vImage.Size, pixelFormat: Format.Type = Format.self)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  public var channelCount: Swift.Int {
    get
  }
  public var byteCountPerPixel: Swift.Int {
    get
  }
  public func copy(to destinationBuffer: Accelerate.vImage.PixelBuffer<Format>)
  @inlinable public func cropped(to rect: CoreFoundation.CGRect) -> Accelerate.vImage.PixelBuffer<Format> {
        let selfRect = CGRect(origin: .zero,
                              size: CGSize(width: width, height: height))
        
        let intersection = selfRect.intersection(rect.integral)
        
        let destination = vImage.PixelBuffer(size: vImage.Size(exactly: intersection.size)!,
                                             pixelFormat: Format.self)
        
        crop(at: intersection.origin,
             destination: destination)
        
        return destination
    }
  @inlinable public func crop(at origin: CoreFoundation.CGPoint, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        let selfRect = CGRect(origin: .zero,
                              size: CGSize(width: width, height: height))
        
        let cropRect = CGRect(origin: origin,
                              size: CGSize(width: destination.width,
                                           height: destination.height))
        
        let intersection = selfRect.intersection(cropRect.integral)
        
        precondition(!intersection.isEmpty)
        
        let start = Int(intersection.origin.y) * vImageBuffer.rowBytes +
        Int(intersection.origin.x) * (Format.bitCountPerPixel / 8)
        
        let source = vImage.PixelBuffer(data: vImageBuffer.data.advanced(by: start),
                                        width: Int(intersection.width),
                                        height: Int(intersection.height),
                                        byteCountPerRow: self.vImageBuffer.rowBytes,
                                        pixelFormat: Format.self)
        
        withUnsafePointer(to: source.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                _ = vImageCopyBuffer(srcPtr,
                                     destPtr,
                                     byteCountPerPixel,
                                     vImage_Flags(kvImageNoFlags))
            }
        }
    }
  public func withUnsafeRegionOfInterest<R>(_ regionOfInterest: CoreFoundation.CGRect, _ body: (Accelerate.vImage.PixelBuffer<Format>) throws -> R) rethrows -> R
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.DynamicPixelFormat {
  public static func makeDynamicPixelBufferAndCGImageFormat(cgImage: CoreGraphics.CGImage) throws -> (pixelBuffer: Accelerate.vImage.PixelBuffer<Accelerate.vImage.DynamicPixelFormat>, cgImageFormat: Accelerate.vImage_CGImageFormat)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.InitializableFromCGImage, Format : Accelerate.StaticPixelFormat {
  @inlinable public static func makePixelBufferAndCGImageFormat(cgImage: CoreGraphics.CGImage, pixelFormat: Format.Type = Format.self) throws -> (pixelBuffer: Accelerate.vImage.PixelBuffer<Format>, cgImageFormat: Accelerate.vImage_CGImageFormat) {
        
        var format = vImage_CGImageFormat()
        let buffer = try vImage.PixelBuffer(cgImage: cgImage,
                                            cgImageFormat: &format,
                                            pixelFormat: pixelFormat)
        return (buffer, format)
    }
  public init(cgImage: CoreGraphics.CGImage, cgImageFormat: inout Accelerate.vImage_CGImageFormat, pixelFormat: Format.Type = Format.self) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.StaticPixelFormat {
  public func makeCGImage(cgImageFormat: Accelerate.vImage_CGImageFormat) -> CoreGraphics.CGImage?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format : Accelerate.SinglePlanePixelFormat {
  public init(referencing lockedCVPixelBuffer: CoreVideo.CVPixelBuffer, planeIndex: Swift.Int, overrideSize: Accelerate.vImage.Size? = nil, pixelFormat: Format.Type = Format.self)
  public init(copying cvPixelBuffer: CoreVideo.CVPixelBuffer, cvImageFormat: Accelerate.vImageCVImageFormat, cgImageFormat: inout Accelerate.vImage_CGImageFormat, pixelFormat: Format.Type = Format.self) throws
  public init(referencing lockedCVPixelBuffer: CoreVideo.CVPixelBuffer, converter: Accelerate.vImageConverter, destinationPixelFormat: Format.Type = Format.self)
  public func copy(to cvPixelBuffer: CoreVideo.CVPixelBuffer, cvImageFormat: Accelerate.vImageCVImageFormat, cgImageFormat: Accelerate.vImage_CGImageFormat) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer : Accelerate.AccelerateBuffer, Accelerate.AccelerateMutableBuffer where Format : Accelerate.StaticPixelFormat {
  public typealias Element = Format.ComponentType
  public var count: Swift.Int {
    get
  }
  public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Format.ComponentType>) throws -> R) rethrows -> R
  public func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Format.ComponentType>) throws -> R) rethrows -> R
  public init<U>(pixelValues: U, size: Accelerate.vImage.Size, pixelFormat: Format.Type = Format.self) where U : Accelerate.AccelerateBuffer, Format.ComponentType == U.Element
  public var array: [Format.ComponentType] {
    get
  }
  public var rowStride: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImageCVImageFormat {
  public static func make(format: Accelerate.vImageCVImageFormat.Format, colorSpace: CoreGraphics.CGColorSpace, alphaIsOpaqueHint: Swift.Bool) -> Accelerate.vImageCVImageFormat?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public struct Size : Swift.Equatable {
    public let width: Swift.Int
    public let height: Swift.Int
    public init?<T>(exactWidth: T, height: T) where T : Swift.BinaryInteger
    public init?<T>(exactWidth: T, height: T) where T : Swift.BinaryFloatingPoint
    public init(width: Swift.Int, height: Swift.Int)
    public init(width: Accelerate.vImagePixelCount, height: Accelerate.vImagePixelCount)
    public init?(exactly size: CoreFoundation.CGSize)
    public init(cvPixelBuffer: CoreVideo.CVPixelBuffer)
    public static func == (a: Accelerate.vImage.Size, b: Accelerate.vImage.Size) -> Swift.Bool
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public struct MultidimensionalLookupTable {
    @_hasMissingDesignatedInitializers @usableFromInline
    internal class LookupTableReference {
      @usableFromInline
      final internal let lookupTable: Accelerate.vImage_MultidimensionalTable
      @objc deinit
    }
    @usableFromInline
    internal var lookupTableReference: Accelerate.vImage.MultidimensionalLookupTable.LookupTableReference!
    public let entryCountPerSourceChannel: [Swift.UInt8]
    public let sourceChannelCount: Swift.Int
    public let destinationChannelCount: Swift.Int
    public init<T>(entryCountPerSourceChannel: [Swift.UInt8], destinationChannelCount: Swift.Int, data: T) where T : Accelerate.AccelerateBuffer, T.Element == Swift.UInt16
    public enum InterpolationMethod {
      case none
      case full
      case half
      @usableFromInline
      internal var vImageInterpolationMethod: Accelerate.vImage_InterpolationMethod {
        get
      }
      public static func == (a: Accelerate.vImage.MultidimensionalLookupTable.InterpolationMethod, b: Accelerate.vImage.MultidimensionalLookupTable.InterpolationMethod) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @inlinable public func apply(sources: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>], destinations: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.PlanarF>], interpolation: Accelerate.vImage.MultidimensionalLookupTable.InterpolationMethod) {
            
            precondition(sources.count == self.sourceChannelCount,
                         "`sources` must contain `lookupTable.sourceChannelCount` buffers.")
            precondition(destinations.count == self.destinationChannelCount,
                         "`destinations` must contain `lookupTable.destinationChannelCount` buffers.")
            
            let srcs = sources.map { $0.vImageBuffer }
            let dests = destinations.map { $0.vImageBuffer }
            
            vImageMultiDimensionalInterpolatedLookupTable_PlanarF(
                srcs,
                dests,
                nil,
                self.lookupTableReference.lookupTable,
                interpolation.vImageInterpolationMethod,
                vImage_Flags(kvImageNoFlags))
        }
    @inlinable public func apply<SrcFormat, DestFormat>(source: Accelerate.vImage.PixelBuffer<SrcFormat>, destination: Accelerate.vImage.PixelBuffer<DestFormat>, interpolation: Accelerate.vImage.MultidimensionalLookupTable.InterpolationMethod) where SrcFormat : Accelerate.MultiplePlanePixelFormat, DestFormat : Accelerate.MultiplePlanePixelFormat, SrcFormat.ComponentType == Swift.Float, DestFormat.ComponentType == Swift.Float {
                  
                  precondition(SrcFormat.planeCount == self.sourceChannelCount,
                               "`sources` must contain `lookupTable.sourceChannelCount` buffers.")
                  precondition(DestFormat.planeCount == self.destinationChannelCount,
                               "`destinations` must contain `lookupTable.destinationChannelCount` buffers.")
                  
                  vImageMultiDimensionalInterpolatedLookupTable_PlanarF(
                    source.vImageBuffers,
                    destination.vImageBuffers,
                    nil,
                    self.lookupTableReference.lookupTable,
                    interpolation.vImageInterpolationMethod,
                    vImage_Flags(kvImageNoFlags))
              }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol FusableLayerParameters {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FusedParametersLayer : Accelerate.BNNS.FusedLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, fusedLayerParameters: [any Accelerate.FusableLayerParameters], filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum PaddingMode {
    case constantBitPattern(Swift.UInt32)
    case constantScalar(Swift.Float)
    case reflect
    case symmetric
    public var bnnsPaddingMode: Accelerate.BNNSPaddingMode {
      get
    }
    public var paddingBitPattern: Swift.UInt32 {
      get
    }
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class PaddingLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, mode: Accelerate.BNNS.PaddingMode, size: [(x: Swift.Int, y: Swift.Int)], filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func slidingWindowSum<U>(_ vector: U, usingWindowLength windowLength: Swift.Int) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vector.count - windowLength + 1
            
            let result = Array<Float>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                slidingWindowSum(vector,
                                 usingWindowLength: windowLength,
                                 result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func slidingWindowSum<U, V>(_ vector: U, usingWindowLength windowLength: Swift.Int, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n + windowLength - 1)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vswsum(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                vDSP_Length(n),
                                vDSP_Length(windowLength))
                }
            }
            
    }
  @inlinable public static func slidingWindowSum<U>(_ vector: U, usingWindowLength windowLength: Swift.Int) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vector.count - windowLength + 1
            
            let result = Array<Double>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                slidingWindowSum(vector,
                                 usingWindowLength: windowLength,
                                 result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func slidingWindowSum<U, V>(_ vector: U, usingWindowLength windowLength: Swift.Int, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n + windowLength - 1)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vswsumD(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 vDSP_Length(n),
                                 vDSP_Length(windowLength))
                }
            }
            
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.vForce {
  @inlinable public static func log<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
        
        let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
            buffer, initializedCount in
            
            log(vector,
                result: &buffer)
            
            initializedCount = vector.count
        }
        
        return result
    }
  @inlinable public static func log<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
        
        precondition(vector.count == result.count)
        
        var n = Int32(vector.count)
        
        result.withUnsafeMutableBufferPointer { dest in
            vector.withUnsafeBufferPointer { src in
                vvlogf(dest.baseAddress!,
                       src.baseAddress!,
                       &n)
            }
        }
    }
  @inlinable public static func log<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
        
        let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
            buffer, initializedCount in
            
            log(vector,
                result: &buffer)
            
            initializedCount = vector.count
        }
        
        return result
    }
  @inlinable public static func log<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
        
        precondition(vector.count == result.count)
        
        var n = Int32(vector.count)
        
        result.withUnsafeMutableBufferPointer { dest in
            vector.withUnsafeBufferPointer { src in
                vvlog(dest.baseAddress!,
                      src.baseAddress!,
                      &n)
            }
        }
    }
  @inlinable public static func log1p<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
        
        let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
            buffer, initializedCount in
            
            log1p(vector,
                  result: &buffer)
            
            initializedCount = vector.count
        }
        
        return result
    }
  @inlinable public static func log1p<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
        
        precondition(vector.count == result.count)
        
        var n = Int32(vector.count)
        
        result.withUnsafeMutableBufferPointer { dest in
            vector.withUnsafeBufferPointer { src in
                vvlog1pf(dest.baseAddress!,
                         src.baseAddress!,
                         &n)
            }
        }
    }
  @inlinable public static func log1p<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
        
        let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
            buffer, initializedCount in
            
            log1p(vector,
                  result: &buffer)
            
            initializedCount = vector.count
        }
        
        return result
    }
  @inlinable public static func log1p<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
        
        precondition(vector.count == result.count)
        
        var n = Int32(vector.count)
        
        result.withUnsafeMutableBufferPointer { dest in
            vector.withUnsafeBufferPointer { src in
                vvlog1p(dest.baseAddress!,
                        src.baseAddress!,
                        &n)
            }
        }
    }
  @inlinable public static func atan2<T, U, V>(x: T, y: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
        
        precondition(x.count == result.count && y.count == result.count)
        
        var n = Int32(result.count)
        
        result.withUnsafeMutableBufferPointer { dest in
            x.withUnsafeBufferPointer { xPtr in
                y.withUnsafeBufferPointer { yPtr in
                    vvatan2f(dest.baseAddress!,
                             yPtr.baseAddress!,
                             xPtr.baseAddress!,
                             &n)
                }
            }
        }
    }
  @inlinable public static func atan2<U, V>(x: U, y: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
        
        precondition(x.count == y.count)
        
        let result = Array<Float>(unsafeUninitializedCapacity: x.count) {
            buffer, initializedCount in
            
            atan2(x: x,
                  y: y,
                  result: &buffer)
            
            initializedCount = x.count
        }
        
        return result
    }
  @inlinable public static func atan2<T, U, V>(x: T, y: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
        
        precondition(x.count == result.count && y.count == result.count)
        
        var n = Int32(result.count)
        
        result.withUnsafeMutableBufferPointer { dest in
            x.withUnsafeBufferPointer { xPtr in
                y.withUnsafeBufferPointer { yPtr in
                    vvatan2(dest.baseAddress!,
                            yPtr.baseAddress!,
                            xPtr.baseAddress!,
                            &n)
                }
            }
        }
    }
  @inlinable public static func atan2<U, V>(x: U, y: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
        
        precondition(x.count == y.count)
        
        let result = Array<Double>(unsafeUninitializedCapacity: x.count) {
            buffer, initializedCount in
            
            atan2(x: x,
                  y: y,
                  result: &buffer)
            
            initializedCount = x.count
        }
        
        return result
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  public enum FourierTransformDirection {
    case forward
    case inverse
    public var dftDirection: Accelerate.vDSP_DFT_Direction {
      get
    }
    public var fftDirection: Accelerate.FFTDirection {
      get
    }
    public static func == (a: Accelerate.vDSP.FourierTransformDirection, b: Accelerate.vDSP.FourierTransformDirection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarFx4 {
  public init(interleavedBuffer: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx4>)
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx4>) {
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: destination.vImageBuffer) { destPtr in
            withUnsafePointer(to: vImageBuffers[0]) { zeroPtr in
                withUnsafePointer(to: vImageBuffers[1]) { onePtr in
                    withUnsafePointer(to: vImageBuffers[2]) { twoPtr in
                        withUnsafePointer(to: vImageBuffers[3]) { threePtr in
                            _ = vImageConvert_PlanarFtoARGBFFFF(zeroPtr,
                                                                onePtr,
                                                                twoPtr,
                                                                threePtr,
                                                                destPtr,
                                                                vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
    }
  @inlinable public func interleave(destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx4>) {
            
            self.withUnsafePixelBuffers { planarSourceBuffers in
                
                destination.interleave(planarSourceBuffers: planarSourceBuffers)
            }
        }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux4 {
  public init(planarBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar16U>])
  @inlinable public func planarBuffers() -> [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar16U>] {
        
        let componentCount = 4
        
        let buffers: [vImage.PixelBuffer<vImage.Planar16U>] = (0 ..< componentCount).map { _ in
            vImage.PixelBuffer(size: size,
                               pixelFormat: vImage.Planar16U.self)
            
        }
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: buffers[0].vImageBuffer) { zeroPtr in
                withUnsafePointer(to: buffers[1].vImageBuffer) { onePtr in
                    withUnsafePointer(to: buffers[2].vImageBuffer) { twoPtr in
                        withUnsafePointer(to: buffers[3].vImageBuffer) { threePtr in
                            _ = vImageConvert_ARGB16UtoPlanar16U(srcPtr,
                                                                 zeroPtr,
                                                                 onePtr,
                                                                 twoPtr,
                                                                 threePtr,
                                                                 vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
        
        return buffers
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.InterleavedFx4>) {
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        var fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 4,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        var fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 4,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        let scale = 1 / Float(UInt16.max)
        
        _ =  vImageConvert_16UToF(&fauxSource,
                                  &fauxDestination,
                                  0, scale,
                                  vImage_Flags(kvImageNoFlags))
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x4>) {
        
        // Eliminates need to check for `kvImageRoiLargerThanInputBuffer`.
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                _ = vImageConvert_ARGB16UToARGB8888(srcPtr,
                                                    destPtr,
                                                    [0, 1, 2, 3],
                                                    0,
                                                    [0, 0, 0, 0],
                                                    vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved16Fx4>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        let fauxSource = vImage_Buffer(data: self.vImageBuffer.data,
                                       height: self.vImageBuffer.height,
                                       width: self.vImageBuffer.width * 4,
                                       rowBytes: self.vImageBuffer.rowBytes)
        
        let fauxDestination = vImage_Buffer(data: destination.vImageBuffer.data,
                                            height: destination.vImageBuffer.height,
                                            width: destination.vImageBuffer.width * 4,
                                            rowBytes: destination.vImageBuffer.rowBytes)
        
        withUnsafePointer(to: fauxSource) { srcPtr in
            withUnsafePointer(to: fauxDestination) { destPtr in
                
                _ = vImageConvert_16Uto16F(srcPtr,
                                           destPtr,
                                           vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func interleave(planarSourceBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar16U>]) {
        
        precondition(planarSourceBuffers.count == 4,
                     "`planarSourceBuffers` must contain four buffers.")
        
        precondition((self.size == planarSourceBuffers[0].size) &&
                     (self.size == planarSourceBuffers[1].size) &&
                     (self.size == planarSourceBuffers[2].size) &&
                     (self.size == planarSourceBuffers[3].size),
                     "Source and destination buffers must be the same size.")
        
        planarSourceBuffers[0].withUnsafePointerToVImageBuffer { a in
            planarSourceBuffers[1].withUnsafePointerToVImageBuffer { r in
                planarSourceBuffers[2].withUnsafePointerToVImageBuffer { g in
                    planarSourceBuffers[3].withUnsafePointerToVImageBuffer { b in
                        self.withUnsafePointerToVImageBuffer { rgb in
                            
                            _ = vImageConvert_Planar16UtoARGB16U(a,
                                                                 r,
                                                                 g,
                                                                 b,
                                                                 rgb,
                                                                 vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
    }
  @inlinable public func deinterleave(planarDestinationBuffers: [Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar16U>]) {
        
        precondition(planarDestinationBuffers.count == 4,
                     "`planarSourceBuffers` must contain four buffers.")
        
        precondition((self.size == planarDestinationBuffers[0].size) &&
                     (self.size == planarDestinationBuffers[1].size) &&
                     (self.size == planarDestinationBuffers[2].size) &&
                     (self.size == planarDestinationBuffers[3].size),
                     "Source and destination buffers must be the same size.")
        
        planarDestinationBuffers[0].withUnsafePointerToVImageBuffer { a in
            planarDestinationBuffers[1].withUnsafePointerToVImageBuffer { r in
                planarDestinationBuffers[2].withUnsafePointerToVImageBuffer { g in
                    planarDestinationBuffers[3].withUnsafePointerToVImageBuffer { b in
                        self.withUnsafePointerToVImageBuffer { rgb in
                            
                            _ = vImageConvert_ARGB16UtoPlanar16U(rgb,
                                                                 a,
                                                                 r,
                                                                 g,
                                                                 b,
                                                                 vImage_Flags(kvImageNoFlags))
                        }
                    }
                }
            }
        }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func twoPoleTwoZeroFilter<U>(_ source: U, coefficients: (Swift.Float, Swift.Float, Swift.Float, Swift.Float, Swift.Float)) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: source.count) {
                buffer, initializedCount in
                
                buffer[0] = 0
                buffer[1] = 0
                
                twoPoleTwoZeroFilter(source,
                                     coefficients: coefficients,
                                     result: &buffer)
                
                initializedCount = source.count
            }
            
            return result
    }
  @inlinable public static func twoPoleTwoZeroFilter<U, V>(_ source: U, coefficients: (Swift.Float, Swift.Float, Swift.Float, Swift.Float, Swift.Float), result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(source.count == result.count)
            
            let n = vDSP_Length(source.count - 2)
            
            result.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_deq22(src.baseAddress!, 1,
                               [coefficients.0, coefficients.1,
                                coefficients.2, coefficients.3,
                                coefficients.4],
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func twoPoleTwoZeroFilter<U>(_ source: U, coefficients: (Swift.Double, Swift.Double, Swift.Double, Swift.Double, Swift.Double)) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: source.count) {
                buffer, initializedCount in
                
                buffer[0] = 0
                buffer[1] = 0
                
                twoPoleTwoZeroFilter(source,
                                     coefficients: coefficients,
                                     result: &buffer)
                
                initializedCount = source.count
            }
            
            return result
    }
  @inlinable public static func twoPoleTwoZeroFilter<U, V>(_ source: U, coefficients: (Swift.Double, Swift.Double, Swift.Double, Swift.Double, Swift.Double), result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(source.count == result.count)
            
            let n = vDSP_Length(source.count - 2)
            
            result.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_deq22D(src.baseAddress!, 1,
                                [coefficients.0, coefficients.1,
                                 coefficients.2, coefficients.3,
                                 coefficients.4],
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8 {
  @inlinable public func premultiply(alpha: Accelerate.vImage.PixelBuffer<Format>) {
        
        withUnsafePointer(to: self.vImageBuffer) { selfPtr in
            withUnsafePointer(to: alpha.vImageBuffer) { alphaPtr in
                _ = vImagePremultiplyData_Planar8(selfPtr,
                                                  alphaPtr,
                                                  selfPtr,
                                                  vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func unpremultiply(alpha: Accelerate.vImage.PixelBuffer<Format>) {
        
        withUnsafePointer(to: self.vImageBuffer) { selfPtr in
            withUnsafePointer(to: alpha.vImageBuffer) { alphaPtr in
                _ = vImageUnpremultiplyData_Planar8(selfPtr,
                                                    alphaPtr,
                                                    selfPtr,
                                                    vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func premultiply(channelOrdering: Accelerate.vImage.ChannelOrdering) {
        
        withUnsafePointer(to: self.vImageBuffer) { selfPtr in
            switch channelOrdering {
                case .ARGB:
                    _ = vImagePremultiplyData_ARGB8888(selfPtr,
                                                       selfPtr,
                                                       vImage_Flags(kvImageNoFlags))
                case .RGBA:
                    _ = vImagePremultiplyData_RGBA8888(selfPtr,
                                                       selfPtr,
                                                       vImage_Flags(kvImageNoFlags))
                    
                @unknown default:
                    fatalError("Unsupported channel ordering.")
            }
        }
    }
  @inlinable public func unpremultiply(channelOrdering: Accelerate.vImage.ChannelOrdering) {
        
        withUnsafePointer(to: self.vImageBuffer) { selfPtr in
            switch channelOrdering {
                case .ARGB:
                    _ = vImageUnpremultiplyData_ARGB8888(selfPtr,
                                                         selfPtr,
                                                         vImage_Flags(kvImageNoFlags))
                case .RGBA:
                    _ = vImageUnpremultiplyData_RGBA8888(selfPtr,
                                                         selfPtr,
                                                         vImage_Flags(kvImageNoFlags))
                    
                @unknown default:
                    fatalError("Unsupported channel ordering.")
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Ux4 {
  @inlinable public func premultiply(channelOrdering: Accelerate.vImage.ChannelOrdering) {
        withUnsafePointer(to: self.vImageBuffer) { selfPtr in
            
            switch channelOrdering {
                case .ARGB:
                    _ = vImagePremultiplyData_ARGB16U(selfPtr,
                                                      selfPtr,
                                                      vImage_Flags(kvImageNoFlags))
                case .RGBA:
                    _ = vImagePremultiplyData_RGBA16U(selfPtr,
                                                      selfPtr,
                                                      vImage_Flags(kvImageNoFlags))
                    
                @unknown default:
                    fatalError("Unsupported channel ordering.")
            }
        }
    }
  @inlinable public func unpremultiply(channelOrdering: Accelerate.vImage.ChannelOrdering) {
        
        withUnsafePointer(to: self.vImageBuffer) { selfPtr in
            
            switch channelOrdering {
                case .ARGB:
                    _ = vImageUnpremultiplyData_ARGB16U(selfPtr,
                                                        selfPtr,
                                                        vImage_Flags(kvImageNoFlags))
                case .RGBA:
                    _ = vImageUnpremultiplyData_RGBA16U(selfPtr,
                                                        selfPtr,
                                                        vImage_Flags(kvImageNoFlags))
                    
                @unknown default:
                    fatalError("Unsupported channel ordering.")
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved16Fx4 {
  @inlinable public func premultiply() {
        
        withUnsafePointer(to: self.vImageBuffer) { selfPtr in
            _ = vImagePremultiplyData_RGBA16F(selfPtr,
                                               selfPtr,
                                               vImage_Flags(kvImageNoFlags))
        }
    }
  @inlinable public func unpremultiply() {
        
        withUnsafePointer(to: self.vImageBuffer) { selfPtr in
            _ = vImageUnpremultiplyData_RGBA16F(selfPtr,
                                                selfPtr,
                                                vImage_Flags(kvImageNoFlags))
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func premultiply(alpha: Accelerate.vImage.PixelBuffer<Format>) {
        
        withUnsafePointer(to: self.vImageBuffer) { selfPtr in
            withUnsafePointer(to: alpha.vImageBuffer) { alphaPtr in
                _ = vImagePremultiplyData_PlanarF(selfPtr,
                                                  alphaPtr,
                                                  selfPtr,
                                                  vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func unpremultiply(alpha: Accelerate.vImage.PixelBuffer<Format>) {
        
        withUnsafePointer(to: self.vImageBuffer) { selfPtr in
            withUnsafePointer(to: alpha.vImageBuffer) { alphaPtr in
                _ = vImageUnpremultiplyData_PlanarF(selfPtr,
                                                    alphaPtr,
                                                    selfPtr,
                                                    vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func premultiply(channelOrdering: Accelerate.vImage.ChannelOrdering) {
        withUnsafePointer(to: self.vImageBuffer) { selfPtr in
            
            switch channelOrdering {
                case .ARGB:
                    _ = vImagePremultiplyData_ARGBFFFF(selfPtr,
                                                       selfPtr,
                                                       vImage_Flags(kvImageNoFlags))
                case .RGBA:
                    _ = vImagePremultiplyData_RGBAFFFF(selfPtr,
                                                       selfPtr,
                                                       vImage_Flags(kvImageNoFlags))
                    
                @unknown default:
                    fatalError("Unsupported channel ordering.")
            }
        }
    }
  @inlinable public func unpremultiply(channelOrdering: Accelerate.vImage.ChannelOrdering) {
        
        withUnsafePointer(to: self.vImageBuffer) { selfPtr in
            
            switch channelOrdering {
                case .ARGB:
                    _ = vImageUnpremultiplyData_ARGBFFFF(selfPtr,
                                                         selfPtr,
                                                         vImage_Flags(kvImageNoFlags))
                case .RGBA:
                    _ = vImageUnpremultiplyData_RGBAFFFF(selfPtr,
                                                         selfPtr,
                                                         vImage_Flags(kvImageNoFlags))
                    
                @unknown default:
                    fatalError("Unsupported channel ordering.")
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Interleaved8x4 {
  @inlinable public func premultipliedAlphaBlend(_ blendMode: Accelerate.vImage.BlendMode, topLayer: Accelerate.vImage.PixelBuffer<Format>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(topLayer.size == destination.size,
                     "Source and destination buffer must be the same size.")
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { bottomPtr in
            withUnsafePointer(to: topLayer.vImageBuffer) { topPtr in
                withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                    switch blendMode {
                        case .multiply:
                            _ = vImagePremultipliedAlphaBlendMultiply_RGBA8888(topPtr,
                                                                               bottomPtr,
                                                                               destPtr,
                                                                               vImage_Flags(kvImageNoFlags))
                        case .screen:
                            _ = vImagePremultipliedAlphaBlendScreen_RGBA8888(topPtr,
                                                                             bottomPtr,
                                                                             destPtr,
                                                                             vImage_Flags(kvImageNoFlags))
                        case .darken:
                            _ = vImagePremultipliedAlphaBlendDarken_RGBA8888(topPtr,
                                                                             bottomPtr,
                                                                             destPtr,
                                                                             vImage_Flags(kvImageNoFlags))
                        case .lighten:
                            _ = vImagePremultipliedAlphaBlendLighten_RGBA8888(topPtr,
                                                                              bottomPtr,
                                                                              destPtr,
                                                                              vImage_Flags(kvImageNoFlags))
                            
                        @unknown default:
                            fatalError("Unsupported composite mode.")
                    }
                }
            }
        }
    }
  @inlinable public func alphaComposite(_ compositeMode: Accelerate.vImage.CompositeMode<Accelerate.Pixel_8>, topLayer: Accelerate.vImage.PixelBuffer<Format>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(topLayer.size == destination.size,
                     "Source and destination buffer must be the same size.")
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { bottomPtr in
            withUnsafePointer(to: topLayer.vImageBuffer) { topPtr in
                withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                    switch compositeMode {
                            
                        case .nonpremultiplied:
                            _ = vImageAlphaBlend_ARGB8888(topPtr,
                                                          bottomPtr,
                                                          destPtr,
                                                          vImage_Flags(kvImageNoFlags))
                        case .premultiplied:
                            _ = vImagePremultipliedAlphaBlend_ARGB8888(topPtr,
                                                                       bottomPtr,
                                                                       destPtr,
                                                                       vImage_Flags(kvImageNoFlags))
                        case .nonpremultipliedToPremultiplied:
                            _ = vImageAlphaBlend_NonpremultipliedToPremultiplied_ARGB8888(topPtr,
                                                                                          bottomPtr,
                                                                                          destPtr,
                                                                                          vImage_Flags(kvImageNoFlags))
                        case .premultipliedWithConstantAlpha(let constAlpha):
                            _ = vImagePremultipliedConstAlphaBlend_ARGB8888(topPtr,
                                                                            constAlpha,
                                                                            bottomPtr,
                                                                            destPtr,
                                                                            vImage_Flags(kvImageNoFlags))
                            
                        @unknown default:
                            fatalError("Unsupported composite mode.")
                    }
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.InterleavedFx4 {
  @inlinable public func alphaComposite(_ compositeMode: Accelerate.vImage.CompositeMode<Accelerate.Pixel_F>, topLayer: Accelerate.vImage.PixelBuffer<Format>, destination: Accelerate.vImage.PixelBuffer<Format>) {
        
        precondition(topLayer.size == destination.size,
                     "Source and destination buffer must be the same size.")
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { bottomPtr in
            withUnsafePointer(to: topLayer.vImageBuffer) { topPtr in
                withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                    switch compositeMode {
                            
                        case .nonpremultiplied:
                            _ = vImageAlphaBlend_ARGBFFFF(topPtr,
                                                          bottomPtr,
                                                          destPtr,
                                                          vImage_Flags(kvImageNoFlags))
                        case .premultiplied:
                            _ = vImagePremultipliedAlphaBlend_ARGBFFFF(topPtr,
                                                                       bottomPtr,
                                                                       destPtr,
                                                                       vImage_Flags(kvImageNoFlags))
                        case .nonpremultipliedToPremultiplied:
                            _ = vImageAlphaBlend_NonpremultipliedToPremultiplied_ARGBFFFF(topPtr,
                                                                                          bottomPtr,
                                                                                          destPtr,
                                                                                          vImage_Flags(kvImageNoFlags))
                        case .premultipliedWithConstantAlpha(let constAlpha):
                            _ = vImagePremultipliedConstAlphaBlend_ARGBFFFF(topPtr,
                                                                            constAlpha,
                                                                            bottomPtr,
                                                                            destPtr,
                                                                            vImage_Flags(kvImageNoFlags))
                        @unknown default:
                            fatalError("Unsupported composite mode.")
                    }
                }
            }
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage {
  public enum BlendMode {
    case multiply
    case screen
    case darken
    case lighten
    public static func == (a: Accelerate.vImage.BlendMode, b: Accelerate.vImage.BlendMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum CompositeMode<ComponentType> {
    case nonpremultiplied
    case premultiplied
    case nonpremultipliedToPremultiplied
    case premultipliedWithConstantAlpha(_: ComponentType)
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func minimum<U>(_ vectorA: U, _ vectorB: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            precondition(vectorA.count == vectorB.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                minimum(vectorA,
                        vectorB,
                        result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func minimum<U, V>(_ vectorA: U, _ vectorB: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = vDSP_Length(min(vectorA.count,
                                    vectorB.count,
                                    result.count))
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmin(a.baseAddress!, 1,
                                  b.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  n)
                    }
                }
            }
    }
  @inlinable public static func minimum<U>(_ vectorA: U, _ vectorB: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            precondition(vectorA.count == vectorB.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                minimum(vectorA,
                        vectorB,
                        result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func minimum<U, V>(_ vectorA: U, _ vectorB: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = vDSP_Length(min(vectorA.count,
                                    vectorB.count,
                                    result.count))
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vminD(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func maximum<U>(_ vectorA: U, _ vectorB: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            precondition(vectorA.count == vectorB.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                maximum(vectorA,
                        vectorB,
                        result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func maximum<U, V>(_ vectorA: U, _ vectorB: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = vDSP_Length(min(vectorA.count,
                                    vectorB.count,
                                    result.count))
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmax(a.baseAddress!, 1,
                                  b.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  n)
                    }
                }
            }
    }
  @inlinable public static func maximum<U>(_ vectorA: U, _ vectorB: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            precondition(vectorA.count == vectorB.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                maximum(vectorA,
                        vectorB,
                        result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func maximum<U, V>(_ vectorA: U, _ vectorB: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = vDSP_Length(min(vectorA.count,
                                    vectorB.count,
                                    result.count))
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmaxD(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func absolute<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                absolute(vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func absolute<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vabs(v.baseAddress!, 1,
                              r.baseAddress!, 1,
                              vDSP_Length(n))
                }
            }
            
    }
  @inlinable public static func absolute<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                absolute(vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func absolute<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vabsD(v.baseAddress!, 1,
                               r.baseAddress!, 1,
                               vDSP_Length(n))
                }
            }
    }
  @inlinable public static func negativeAbsolute<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                negativeAbsolute(vector,
                                 result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func negativeAbsolute<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vnabs(v.baseAddress!, 1,
                               r.baseAddress!, 1,
                               vDSP_Length(n))
                }
            }
    }
  @inlinable public static func negativeAbsolute<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                negativeAbsolute(vector,
                                 result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func negativeAbsolute<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vnabsD(v.baseAddress!, 1,
                                r.baseAddress!, 1,
                                vDSP_Length(n))
                }
            }
    }
  @inlinable public static func negative<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                negative(vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func negative<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vneg(v.baseAddress!, 1,
                              r.baseAddress!, 1,
                              vDSP_Length(n))
                }
            }
    }
  @inlinable public static func negative<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                negative(vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func negative<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vnegD(v.baseAddress!, 1,
                               r.baseAddress!, 1,
                               vDSP_Length(n))
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func reverse<V>(_ vector: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vrvrs(v.baseAddress!, 1,
                           n)
            }
    }
  @inlinable public static func reverse<V>(_ vector: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vrvrsD(v.baseAddress!, 1,
                            n)
            }
    }
  public enum SortOrder : Swift.Int32 {
    case ascending
    case descending
    public init?(rawValue: Swift.Int32)
    public typealias RawValue = Swift.Int32
    public var rawValue: Swift.Int32 {
      get
    }
  }
  @inlinable public static func sort<V>(_ vector: inout V, sortOrder: Accelerate.vDSP.SortOrder) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vsort(v.baseAddress!,
                           n,
                           sortOrder.rawValue)
            }
    }
  @inlinable public static func sort<V>(_ vector: inout V, sortOrder: Accelerate.vDSP.SortOrder) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vsortD(v.baseAddress!,
                            n,
                            sortOrder.rawValue)
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func square<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                square(vector,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func square<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vsq(src.baseAddress!, 1,
                             dest.baseAddress!, 1,
                             n)
                }
            }
    }
  @inlinable public static func square<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                square(vector,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func square<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vsqD(src.baseAddress!, 1,
                              dest.baseAddress!, 1,
                              n)
                }
            }
    }
  @inlinable public static func signedSquare<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                signedSquare(vector,
                             result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func signedSquare<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vssq(src.baseAddress!, 1,
                              dest.baseAddress!, 1,
                              n)
                }
            }
    }
  @inlinable public static func signedSquare<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                signedSquare(vector,
                             result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func signedSquare<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vssqD(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func trunc<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                trunc(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func trunc<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vfrac(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func trunc<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                trunc(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func trunc<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vfracD(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func countZeroCrossings<U>(_ vector: U) -> Swift.UInt where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var crossingCount: vDSP_Length = 0
            var lastCrossingIndex: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { src in
                vDSP_nzcros(src.baseAddress!, 1,
                            n,
                            &lastCrossingIndex,
                            &crossingCount,
                            n)
            }
            
            return crossingCount
    }
  @inlinable public static func countZeroCrossings<U>(_ vector: U) -> Swift.UInt where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var crossingCount: vDSP_Length = 0
            var lastCrossingIndex: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { src in
                vDSP_nzcrosD(src.baseAddress!, 1,
                             n,
                             &lastCrossingIndex,
                             &crossingCount,
                             n)
            }
            
            return crossingCount
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage_CGImageFormat {
  public init?(cgImage: CoreGraphics.CGImage)
  public init?(bitsPerComponent: Swift.Int, bitsPerPixel: Swift.Int, colorSpace: CoreGraphics.CGColorSpace, bitmapInfo: CoreGraphics.CGBitmapInfo, renderingIntent: CoreGraphics.CGColorRenderingIntent = .defaultIntent)
  public var componentCount: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func phase<V>(_ splitComplex: Accelerate.DSPSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                withUnsafePointer(to: splitComplex) { src in
                    vDSP_zvphas(src, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func phase<V>(_ splitComplex: Accelerate.DSPDoubleSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                withUnsafePointer(to: splitComplex) { src in
                    vDSP_zvphasD(src, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func copy(_ source: Accelerate.DSPSplitComplex, to destination: inout Accelerate.DSPSplitComplex, count: Swift.Int) {
        
        let n = vDSP_Length(count)
        
        withUnsafePointer(to: source) { src in
            vDSP_zvmov(src, 1,
                       &destination, 1,
                       n)
        }
    }
  @inlinable public static func copy(_ source: Accelerate.DSPDoubleSplitComplex, to destination: inout Accelerate.DSPDoubleSplitComplex, count: Swift.Int) {
        
        let n = vDSP_Length(count)
        
        withUnsafePointer(to: source) { src in
            vDSP_zvmovD(src, 1,
                        &destination, 1,
                        n)
        }
    }
  @inlinable public static func conjugate(_ splitComplex: Accelerate.DSPSplitComplex, count: Swift.Int, result: inout Accelerate.DSPSplitComplex) {
        
        withUnsafePointer(to: splitComplex) { a in
            vDSP_zvconj(a, 1,
                        &result, 1,
                        vDSP_Length(count))
        }
    }
  @inlinable public static func conjugate(_ splitComplex: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        withUnsafePointer(to: splitComplex) { a in
            vDSP_zvconjD(a, 1,
                         &result, 1,
                         vDSP_Length(count))
        }
    }
  @inlinable public static func divide<U>(_ splitComplex: Accelerate.DSPSplitComplex, by vector: U, result: inout Accelerate.DSPSplitComplex) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            withUnsafePointer(to: splitComplex) { a in
                vector.withUnsafeBufferPointer { b in
                    vDSP_zrvdiv(a, 1,
                                b.baseAddress!, 1,
                                &result, 1,
                                vDSP_Length(vector.count))
                }
            }
    }
  @inlinable public static func divide<U>(_ splitComplex: Accelerate.DSPDoubleSplitComplex, by vector: U, result: inout Accelerate.DSPDoubleSplitComplex) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            withUnsafePointer(to: splitComplex) { a in
                vector.withUnsafeBufferPointer { b in
                    vDSP_zrvdivD(a, 1,
                                 b.baseAddress!, 1,
                                 &result, 1,
                                 vDSP_Length(vector.count))
                }
            }
    }
  @inlinable public static func multiply<U>(_ splitComplex: Accelerate.DSPSplitComplex, by vector: U, result: inout Accelerate.DSPSplitComplex) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            withUnsafePointer(to: splitComplex) { a in
                vector.withUnsafeBufferPointer { b in
                    vDSP_zrvmul(a, 1,
                                b.baseAddress!, 1,
                                &result, 1,
                                vDSP_Length(vector.count))
                }
            }
    }
  @inlinable public static func multiply<U>(_ splitComplex: Accelerate.DSPDoubleSplitComplex, by vector: U, result: inout Accelerate.DSPDoubleSplitComplex) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            withUnsafePointer(to: splitComplex) { a in
                vector.withUnsafeBufferPointer { b in
                    vDSP_zrvmulD(a, 1,
                                 b.baseAddress!, 1,
                                 &result, 1,
                                 vDSP_Length(vector.count))
                }
            }
    }
  @inlinable public static func multiply(_ splitComplexA: Accelerate.DSPSplitComplex, by splitComplexB: Accelerate.DSPSplitComplex, count: Swift.Int, useConjugate: Swift.Bool, result: inout Accelerate.DSPSplitComplex) {
        
        let conjugate: Int32 = useConjugate ? -1 : 1
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvmul(a, 1,
                           b, 1,
                           &result, 1,
                           vDSP_Length(count),
                           conjugate)
            }
        }
    }
  @inlinable public static func multiply(_ splitComplexA: Accelerate.DSPDoubleSplitComplex, by splitComplexB: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, useConjugate: Swift.Bool, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        let conjugate: Int32 = useConjugate ? -1 : 1
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvmulD(a, 1,
                            b, 1,
                            &result, 1,
                            vDSP_Length(count),
                            conjugate)
            }
        }
    }
  @inlinable public static func add(_ splitComplexA: Accelerate.DSPSplitComplex, to splitComplexB: Accelerate.DSPSplitComplex, count: Swift.Int, result: inout Accelerate.DSPSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvadd(a, 1,
                           b, 1,
                           &result, 1,
                           vDSP_Length(count))
            }
        }
    }
  @inlinable public static func add(_ splitComplexA: Accelerate.DSPDoubleSplitComplex, to splitComplexB: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvaddD(a, 1,
                            b, 1,
                            &result, 1,
                            vDSP_Length(count))
            }
        }
    }
  @inlinable public static func divide(_ splitComplexA: Accelerate.DSPSplitComplex, by splitComplexB: Accelerate.DSPSplitComplex, count: Swift.Int, result: inout Accelerate.DSPSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvdiv(b, 1,
                           a, 1,
                           &result, 1,
                           vDSP_Length(count))
            }
        }
    }
  @inlinable public static func divide(_ splitComplexA: Accelerate.DSPDoubleSplitComplex, by splitComplexB: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvdivD(b, 1,
                            a, 1,
                            &result, 1,
                            vDSP_Length(count))
            }
        }
    }
  @inlinable public static func subtract(_ splitComplexB: Accelerate.DSPSplitComplex, from splitComplexA: Accelerate.DSPSplitComplex, count: Swift.Int, result: inout Accelerate.DSPSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvsub(b, 1,
                           a, 1,
                           &result, 1,
                           vDSP_Length(count))
            }
        }
    }
  @inlinable public static func subtract(_ splitComplexB: Accelerate.DSPDoubleSplitComplex, from splitComplexA: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvsubD(b, 1,
                            a, 1,
                            &result, 1,
                            vDSP_Length(count))
            }
        }
    }
  @inlinable public static func absolute<V>(_ vector: Accelerate.DSPSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = result.count
            
            result.withUnsafeMutableBufferPointer { r in
                withUnsafePointer(to: vector) { v in
                    vDSP_zvabs(v, 1,
                               r.baseAddress!, 1,
                               vDSP_Length(n))
                }
            }
    }
  @inlinable public static func absolute<V>(_ vector: Accelerate.DSPDoubleSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = result.count
            
            result.withUnsafeMutableBufferPointer { r in
                withUnsafePointer(to: vector) { v in
                    vDSP_zvabsD(v, 1,
                                r.baseAddress!, 1,
                                vDSP_Length(n))
                }
            }
    }
  @inlinable public static func squareMagnitudes<V>(_ splitComplex: Accelerate.DSPSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                withUnsafePointer(to: splitComplex) { src in
                    vDSP_zvmags(src, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func squareMagnitudes<V>(_ splitComplex: Accelerate.DSPDoubleSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                withUnsafePointer(to: splitComplex) { src in
                    vDSP_zvmagsD(src, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
}
@available(macOS 14.0, iOS 17, tvOS 17, watchOS 10, *)
extension Accelerate.BNNS {
  public struct NearestNeighbors {
    public init(capacity: Swift.Int, dimensionCount: Swift.Int, neighborCount: Swift.Int, dataType: Accelerate.BNNSDataType)
    public func append(samples: Accelerate.BNNSNDArrayDescriptor)
    public func apply(index: Swift.Int?, outputIndices: Accelerate.BNNSNDArrayDescriptor, outputDistances: Accelerate.BNNSNDArrayDescriptor)
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  public enum DCTTransformType : Swift.CaseIterable {
    case II
    case III
    case IV
    public var dctType: Accelerate.vDSP_DCT_Type {
      get
    }
    public static func == (a: Accelerate.vDSP.DCTTransformType, b: Accelerate.vDSP.DCTTransformType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [Accelerate.vDSP.DCTTransformType]
    public static var allCases: [Accelerate.vDSP.DCTTransformType] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public class DCT {
    public init?(previous: Accelerate.vDSP.DCT? = nil, count: Swift.Int, transformType: Accelerate.vDSP.DCTTransformType)
    public func transform<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float
    public func transform<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FloatingPointGeneratable : Swift.BinaryFloatingPoint {
}
extension Swift.Float : Accelerate.vDSP_FloatingPointGeneratable {
}
extension Swift.Double : Accelerate.vDSP_FloatingPointGeneratable {
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.vDSP {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U, V>(values: T, atIndices indices: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(indices.count == values.count,
                         "The number of elements in `values` must equal the number of elements in `indices`.")
            
            let n = vDSP_Length(result.count)
            let m = vDSP_Length(indices.count)
            
            result.withUnsafeMutableBufferPointer { r in
                values.withUnsafeBufferPointer { v in
                    indices.withUnsafeBufferPointer { i in
                        vDSP_vgenp(v.baseAddress!, 1,
                                   i.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   n,
                                   m)
                    }
                }
            }
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U>(values: T, atIndices indices: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let resultCount = 1 + Int(Accelerate.vDSP.maximum(indices))
            
            let result = Array<Float>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.linearInterpolate(values: values,
                                       atIndices: indices,
                                       result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U, V>(values: T, atIndices indices: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(indices.count == values.count,
                         "The number of elements in `values` must equal the number of elements in `indices`.")
            
            let n = vDSP_Length(result.count)
            let m = vDSP_Length(indices.count)
            
            result.withUnsafeMutableBufferPointer { r in
                values.withUnsafeBufferPointer { v in
                    indices.withUnsafeBufferPointer { i in
                        vDSP_vgenpD(v.baseAddress!, 1,
                                    i.baseAddress!, 1,
                                    r.baseAddress!, 1,
                                    n,
                                    m)
                    }
                }
            }
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U>(values: T, atIndices indices: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let resultCount = 1 + Int(Accelerate.vDSP.maximum(indices))
            
            let result = Array<Double>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.linearInterpolate(values: values,
                                       atIndices: indices,
                                       result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U, V>(lookupTable: T, withOffsets offsets: U, scale: Swift.Float = 1, baseOffset: Swift.Float = 0, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(offsets.count == result.count,
                         "The number of elements in `offsets` must equal the number of elements in `result`.")
            
            let m = vDSP_Length(lookupTable.count)
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { r in
                lookupTable.withUnsafeBufferPointer { lut in
                    offsets.withUnsafeBufferPointer { o in
                        vDSP_vtabi(o.baseAddress!, 1,
                                   [scale],
                                   [baseOffset],
                                   lut.baseAddress!, m,
                                   r.baseAddress!, 1, n)
                    }
                }
            }
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U>(lookupTable: T, withOffsets offsets: U, scale: Swift.Float = 1, baseOffset: Swift.Float = 0) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: offsets.count) {
                buffer, initializedCount in
                
                vDSP.linearInterpolate(lookupTable: lookupTable,
                                       withOffsets: offsets,
                                       scale: scale,
                                       baseOffset: baseOffset,
                                       result: &buffer)
                
                initializedCount = offsets.count
            }
            
            return result
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U, V>(lookupTable: T, withOffsets offsets: U, scale: Swift.Double = 1, baseOffset: Swift.Double = 0, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(offsets.count == result.count,
                         "The number of elements in `offsets` must equal the number of elements in `result`.")
            
            let m = vDSP_Length(lookupTable.count)
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { r in
                lookupTable.withUnsafeBufferPointer { lut in
                    offsets.withUnsafeBufferPointer { o in
                        vDSP_vtabiD(o.baseAddress!, 1,
                                    [scale],
                                    [baseOffset],
                                    lut.baseAddress!, m,
                                    r.baseAddress!, 1, n)
                    }
                }
            }
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U>(lookupTable: T, withOffsets offsets: U, scale: Swift.Double = 1, baseOffset: Swift.Double = 0) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: offsets.count) {
                buffer, initializedCount in
                
                vDSP.linearInterpolate(lookupTable: lookupTable,
                                       withOffsets: offsets,
                                       scale: scale,
                                       baseOffset: baseOffset,
                                       result: &buffer)
                
                initializedCount = offsets.count
            }
            
            return result
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func fill<V>(_ vector: inout V, with value: Swift.Float) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                withUnsafePointer(to: value) {
                    vDSP_vfill($0,
                               v.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func fill<V>(_ vector: inout V, with value: Swift.Double) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                withUnsafePointer(to: value) {
                    vDSP_vfillD($0,
                                v.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func clear<V>(_ vector: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vclr(v.baseAddress!, 1,
                          n)
            }
    }
  @inlinable public static func clear<V>(_ vector: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vclrD(v.baseAddress!, 1,
                           n)
            }
    }
  public enum WindowSequence {
    case hanningNormalized
    case hanningDenormalized
    case hamming
    case blackman
    public static func == (a: Accelerate.vDSP.WindowSequence, b: Accelerate.vDSP.WindowSequence) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @inlinable public static func window<T>(ofType: T.Type, usingSequence sequence: Accelerate.vDSP.WindowSequence, count: Swift.Int, isHalfWindow: Swift.Bool) -> [T] where T : Accelerate.vDSP_FloatingPointGeneratable {
        
        precondition(count > 0)
        
        if T.self == Float.self {
            
            let result = Array<Float>(unsafeUninitializedCapacity: count) {
                buffer, initializedCount in
                
                formWindow(usingSequence: sequence,
                           result: &buffer,
                           isHalfWindow: isHalfWindow)
                
                initializedCount = count
            }
            return result as! [T]
            
        } else if T.self == Double.self {
            
            let result = Array<Double>(unsafeUninitializedCapacity: count) {
                buffer, initializedCount in
                
                formWindow(usingSequence: sequence,
                           result: &buffer,
                           isHalfWindow: isHalfWindow)
                
                initializedCount = count
            }
            return result as! [T]
            
        } else {
            fatalError("This operation only supports `Float` and `Double` types.")
        }
    }
  public static func formWindow<V>(usingSequence sequence: Accelerate.vDSP.WindowSequence, result: inout V, isHalfWindow: Swift.Bool) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float
  public static func formWindow<V>(usingSequence sequence: Accelerate.vDSP.WindowSequence, result: inout V, isHalfWindow: Swift.Bool) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double
  @inlinable public static func ramp(withInitialValue initialValue: Swift.Float, increment: Swift.Float, count: Swift.Int) -> [Swift.Float] {
        
        precondition(count > 0)
        
        let result = Array<Float>(unsafeUninitializedCapacity: count) {
            buffer, initializedCount in
            
            formRamp(withInitialValue: initialValue,
                     increment: increment,
                     result: &buffer)
            
            initializedCount = count
        }
        
        return result
    }
  @inlinable public static func formRamp<V>(withInitialValue initialValue: Swift.Float, increment: Swift.Float, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(result.count)
            
            withUnsafePointer(to: initialValue) { a in
                withUnsafePointer(to: increment) { b in
                    result.withUnsafeMutableBufferPointer { c in
                        vDSP_vramp(a,
                                   b,
                                   c.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func ramp(withInitialValue initialValue: Swift.Double, increment: Swift.Double, count: Swift.Int) -> [Swift.Double] {
        
        precondition(count > 0)
        
        let result = Array<Double>(unsafeUninitializedCapacity: count) {
            buffer, initializedCount in
            
            formRamp(withInitialValue: initialValue,
                     increment: increment,
                     result: &buffer)
            
            initializedCount = count
        }
        
        return result
    }
  @inlinable public static func formRamp<V>(withInitialValue initialValue: Swift.Double, increment: Swift.Double, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(result.count)
            
            withUnsafePointer(to: initialValue) { a in
                withUnsafePointer(to: increment) { b in
                    result.withUnsafeMutableBufferPointer { c in
                        vDSP_vrampD(a,
                                    b,
                                    c.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func ramp(in range: Swift.ClosedRange<Swift.Float>, count: Swift.Int) -> [Swift.Float] {
        
        precondition(count > 0)
        
        let result = Array<Float>(unsafeUninitializedCapacity: count) {
            buffer, initializedCount in
            
            formRamp(in: range,
                     result: &buffer)
            
            initializedCount = count
        }
        
        return result
    }
  @inlinable public static func formRamp<V>(in range: Swift.ClosedRange<Swift.Float>, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(result.count)
            
            withUnsafePointer(to: range.lowerBound) { a in
                withUnsafePointer(to: range.upperBound) { b in
                    result.withUnsafeMutableBufferPointer { c in
                        vDSP_vgen(a,
                                  b,
                                  c.baseAddress!, 1,
                                  n)
                    }
                }
            }
    }
  @inlinable public static func ramp(in range: Swift.ClosedRange<Swift.Double>, count: Swift.Int) -> [Swift.Double] {
        
        precondition(count > 0)
        
        let result = Array<Double>(unsafeUninitializedCapacity: count) {
            buffer, initializedCount in
            
            formRamp(in: range,
                     result: &buffer)
            
            initializedCount = count
        }
        
        return result
    }
  @inlinable public static func formRamp<V>(in range: Swift.ClosedRange<Swift.Double>, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(result.count)
            
            withUnsafePointer(to: range.lowerBound) { a in
                withUnsafePointer(to: range.upperBound) { b in
                    result.withUnsafeMutableBufferPointer { c in
                        vDSP_vgenD(a,
                                   b,
                                   c.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func ramp<U>(withInitialValue initialValue: inout Swift.Float, multiplyingBy vector: U, increment: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                formRamp(withInitialValue: &initialValue,
                         multiplyingBy: vector,
                         increment: increment,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func formRamp<U, V>(withInitialValue initialValue: inout Swift.Float, multiplyingBy vector: U, increment: Swift.Float, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    withUnsafePointer(to: increment) { step in
                        vDSP_vrampmul(src.baseAddress!, 1,
                                      &initialValue,
                                      step,
                                      dest.baseAddress!, 1,
                                      n)
                    }
                }
            }
    }
  @inlinable public static func ramp<U>(withInitialValue initialValue: inout Swift.Double, multiplyingBy vector: U, increment: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                formRamp(withInitialValue: &initialValue,
                         multiplyingBy: vector,
                         increment: increment,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func formRamp<U, V>(withInitialValue initialValue: inout Swift.Double, multiplyingBy vector: U, increment: Swift.Double, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    withUnsafePointer(to: increment) { step in
                        vDSP_vrampmulD(src.baseAddress!, 1,
                                       &initialValue,
                                       step,
                                       dest.baseAddress!, 1,
                                       n)
                    }
                }
            }
    }
  @inlinable public static func stereoRamp<U>(withInitialValue initialValue: inout Swift.Float, multiplyingBy multiplierOne: U, _ multiplierTwo: U, increment: Swift.Float) -> (firstOutput: [Swift.Float], secondOutput: [Swift.Float]) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = multiplierOne.count
            
            var firstOutput: Array<Float>!
            
            let secondOutput = Array<Float>(unsafeUninitializedCapacity: n) {
                secondBuffer, secondInitializedCount in
                
                firstOutput = Array<Float>(unsafeUninitializedCapacity: n) {
                    firstBuffer, firstInitializedCount in
                    
                    formStereoRamp(withInitialValue: &initialValue,
                                   multiplyingBy: multiplierOne, multiplierTwo,
                                   increment: increment,
                                   results: &firstBuffer, &secondBuffer)
                    
                    firstInitializedCount = n
                }
                
                secondInitializedCount = n
            }
            
            return (firstOutput: firstOutput,
                    secondOutput: secondOutput)
    }
  @inlinable public static func formStereoRamp<U, V>(withInitialValue initialValue: inout Swift.Float, multiplyingBy multiplierOne: U, _ multiplierTwo: U, increment: Swift.Float, results resultOne: inout V, _ resultTwo: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(multiplierOne.count == multiplierTwo.count)
            precondition(resultOne.count == resultTwo.count)
            precondition(multiplierOne.count == resultOne.count)
            let n = vDSP_Length(resultTwo.count)
            
            resultOne.withUnsafeMutableBufferPointer { o0 in
                resultTwo.withUnsafeMutableBufferPointer { o1 in
                    multiplierOne.withUnsafeBufferPointer { i0 in
                        multiplierTwo.withUnsafeBufferPointer { i1 in
                            withUnsafePointer(to: increment) { step in
                                vDSP_vrampmul2(i0.baseAddress!,
                                               i1.baseAddress!, 1,
                                               &initialValue,
                                               step,
                                               o0.baseAddress!,
                                               o1.baseAddress!, 1,
                                               n)
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func stereoRamp<U>(withInitialValue initialValue: inout Swift.Double, multiplyingBy multiplierOne: U, _ multiplierTwo: U, increment: Swift.Double) -> (firstOutput: [Swift.Double], secondOutput: [Swift.Double]) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = multiplierOne.count
            
            var firstOutput: Array<Double>!
            
            let secondOutput = Array<Double>(unsafeUninitializedCapacity: n) {
                secondBuffer, secondInitializedCount in
                
                firstOutput = Array<Double>(unsafeUninitializedCapacity: n) {
                    firstBuffer, firstInitializedCount in
                    
                    formStereoRamp(withInitialValue: &initialValue,
                                   multiplyingBy: multiplierOne, multiplierTwo,
                                   increment: increment,
                                   results: &firstBuffer, &secondBuffer)
                    
                    firstInitializedCount = n
                }
                
                secondInitializedCount = n
            }
            
            return (firstOutput: firstOutput,
                    secondOutput: secondOutput)
    }
  @inlinable public static func formStereoRamp<U, V>(withInitialValue initialValue: inout Swift.Double, multiplyingBy multiplierOne: U, _ multiplierTwo: U, increment: Swift.Double, results resultOne: inout V, _ resultTwo: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(multiplierOne.count == multiplierTwo.count)
            precondition(resultOne.count == resultTwo.count)
            precondition(multiplierOne.count == resultOne.count)
            let n = vDSP_Length(resultTwo.count)
            
            resultOne.withUnsafeMutableBufferPointer { o0 in
                resultTwo.withUnsafeMutableBufferPointer { o1 in
                    multiplierOne.withUnsafeBufferPointer { i0 in
                        multiplierTwo.withUnsafeBufferPointer { i1 in
                            withUnsafePointer(to: increment) { step in
                                vDSP_vrampmul2D(i0.baseAddress!,
                                                i1.baseAddress!, 1,
                                                &initialValue,
                                                step,
                                                o0.baseAddress!,
                                                o1.baseAddress!, 1,
                                                n)
                            }
                        }
                    }
                }
            }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.PlanarF {
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar8>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                _ = vImageConvert_PlanarFtoPlanar8(srcPtr, destPtr,
                                                   1,
                                                   0,
                                                   vImage_Flags(kvImageNoFlags))
            }
        }
    }
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Planar16F>) {
        
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: self.vImageBuffer) { srcPtr in
            withUnsafePointer(to: destination.vImageBuffer) { destPtr in
                
                _ = vImageConvert_PlanarFtoPlanar16F(srcPtr, destPtr,
                                                     vImage_Flags(kvImageNoFlags))
            }
        }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat {
  public static func make(format: Accelerate.vImageCVImageFormat.Format, matrix: Accelerate.vImage_ARGBToYpCbCrMatrix, chromaSiting: Accelerate.vImageCVImageFormat.ChromaSiting, colorSpace: CoreGraphics.CGColorSpace, alphaIsOpaqueHint: Swift.Bool) -> Accelerate.vImageCVImageFormat?
  public static func make(buffer: CoreVideo.CVPixelBuffer) -> Accelerate.vImageCVImageFormat?
  public var alphaIsOpaqueHint: Swift.Bool {
    get
    set
  }
  public var channelCount: Swift.UInt32 {
    get
  }
  public var channels: [Accelerate.vImage.BufferType] {
    get
  }
  public func channelDescription(bufferType: Accelerate.vImage.BufferType) -> Accelerate.vImageChannelDescription?
  public var chromaSiting: Accelerate.vImageCVImageFormat.ChromaSiting? {
    get
    set
  }
  public var colorSpace: CoreGraphics.CGColorSpace? {
    get
    set
  }
  public var formatCode: Swift.UInt32 {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage {
  public enum BufferType : Swift.Int {
    case alpha
    case coreGraphics
    case cmykBlack
    case cmykCyan
    case cmykMagenta
    case cmykYellow
    case YCbCr
    case Cb
    case Cr
    case chroma
    case chunky
    case indexed
    case labA
    case labB
    case labL
    case luminance
    case monochrome
    case rgbRed
    case rgbGreen
    case rgbBlue
    case xyzX
    case xyzY
    case xyzZ
    public init?(rawValue: Swift.Int)
    public init?(bufferTypeCode: Swift.Int, model: CoreGraphics.CGColorSpaceModel?)
    public var bufferTypeCode: Accelerate.vImageBufferTypeCode {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat {
  public enum Format {
    case format1Monochrome
    case format2Indexed
    case format4Indexed
    case format8Indexed
    case format1IndexedGray_WhiteIsZero
    case format2IndexedGray_WhiteIsZero
    case format4IndexedGray_WhiteIsZero
    case format8IndexedGray_WhiteIsZero
    case format16BE555
    case format16LE555
    case format16LE5551
    case format16BE565
    case format16LE565
    case format24RGB
    case format24BGR
    case format32ARGB
    case format32BGRA
    case format32ABGR
    case format32RGBA
    case format64ARGB
    case format48RGB
    case format32AlphaGray
    case format16Gray
    case format30RGB
    case format422YpCbCr8
    case format4444YpCbCrA8
    case format4444YpCbCrA8R
    case format4444AYpCbCr8
    case format4444AYpCbCr16
    case format444YpCbCr8
    case format422YpCbCr16
    case format422YpCbCr10
    case format444YpCbCr10
    case format420YpCbCr8Planar
    case format420YpCbCr8PlanarFullRange
    case format422YpCbCr_4A_8BiPlanar
    case format420YpCbCr8BiPlanarVideoRange
    case format420YpCbCr8BiPlanarFullRange
    case format422YpCbCr8_yuvs
    case format422YpCbCr8FullRange
    case formatOneComponent8
    case formatTwoComponent8
    case format30RGBLEPackedWideGamut
    case formatARGB2101010LEPacked
    case formatOneComponent16Half
    case formatOneComponent32Float
    case formatTwoComponent16Half
    case formatTwoComponent32Float
    case format64RGBAHalf
    case format128RGBAFloat
    case format14Bayer_GRBG
    case format14Bayer_RGGB
    case format14Bayer_BGGR
    case format14Bayer_GBRG
    case formatDisparityFloat16
    case formatDisparityFloat32
    case formatDepthFloat16
    case formatDepthFloat32
    case format420YpCbCr10BiPlanarVideoRange
    case format422YpCbCr10BiPlanarVideoRange
    case format444YpCbCr10BiPlanarVideoRange
    case format420YpCbCr10BiPlanarFullRange
    case format422YpCbCr10BiPlanarFullRange
    case format444YpCbCr10BiPlanarFullRange
    public static func == (a: Accelerate.vImageCVImageFormat.Format, b: Accelerate.vImageCVImageFormat.Format) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ChromaSiting {
    case left
    case center
    case topLeft
    case top
    case bottomLeft
    case bottom
    case dv420
    public static func == (a: Accelerate.vImageCVImageFormat.ChromaSiting, b: Accelerate.vImageCVImageFormat.ChromaSiting) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class LossLayer : Accelerate.BNNS.Layer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, lossFunction: Accelerate.BNNS.LossFunction, lossReduction: Accelerate.BNNS.LossReduction, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, labels: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.LossLayer {
  public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, labels: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, weights: Accelerate.BNNSNDArrayDescriptor?, broadcastsWeights: Swift.Bool, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor) throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum LossFunction {
    public struct YoloParameters {
      @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
      public init(huberDelta: Swift.Float, gridColumnCount: Swift.Int, gridRowsCount: Swift.Int, anchorBoxCount: Swift.Int, anchorBoxSize: Swift.Int, rescore: Swift.Bool, xyScale: Swift.Float, whScale: Swift.Float, objectScale: Swift.Float, noObjectScale: Swift.Float, classificationScale: Swift.Float, objectMinimumIoU: Swift.Float, noObjectMaximumIoU: Swift.Float, anchorsData: Swift.UnsafeMutablePointer<Swift.Float>)
      public let huberDelta: Swift.Float
      public let gridColumnCount: Swift.Int
      public let gridRowsCount: Swift.Int
      public let anchorBoxCount: Swift.Int
      public let anchorBoxSize: Swift.Int
      public let rescore: Swift.Bool
      public let xyScale: Swift.Float
      public let whScale: Swift.Float
      public let objectScale: Swift.Float
      public let noObjectScale: Swift.Float
      public let classificationScale: Swift.Float
      public let objectMinimumIoU: Swift.Float
      public let noObjectMaximumIoU: Swift.Float
      public let anchorsData: Swift.UnsafeMutablePointer<Swift.Float>
    }
    case softmaxCrossEntropy(labelSmoothing: Swift.Float)
    case sigmoidCrossEntropy(labelSmoothing: Swift.Float)
    case huber(huberDelta: Swift.Float)
    case yolo(parameters: Accelerate.BNNS.LossFunction.YoloParameters)
    case meanSquareError
    case log
    case cosineDistance
    case hinge
    case meanAbsoluteError
    case categoricalCrossEntropy
    public var bnnsLossFunction: Accelerate.BNNSLossFunction {
      get
    }
  }
  public enum LossReduction {
    case none
    case sum
    case weightedMean
    case reductionMean
    case zeroWeightMean
    public var bnnsLossReductionFunction: Accelerate.BNNSLossReductionFunction {
      get
    }
    public static func == (a: Accelerate.BNNS.LossReduction, b: Accelerate.BNNS.LossReduction) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public static func clipByGlobalNorm(threshold: Swift.Float, inputs: [Accelerate.BNNSNDArrayDescriptor], outputs: [Accelerate.BNNSNDArrayDescriptor], globalNorm: Swift.Float = 0) throws
  public static func clip(to bounds: Swift.ClosedRange<Swift.Float>, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
  public static func clipByNorm(threshold: Swift.Float, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axes: [Swift.Int]? = nil) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.PixelBuffer where Format == Accelerate.vImage.Planar8x3 {
  public init(interleavedBuffer: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x3>)
  @inlinable public func convert(to destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x3>) {
        precondition(self.size == destination.size,
                     "Source and destination buffer must be the same size.")
        
        withUnsafePointer(to: destination.vImageBuffer) { destPtr in
            withUnsafePointer(to: vImageBuffers[0]) { zeroPtr in
                withUnsafePointer(to: vImageBuffers[1]) { onePtr in
                    withUnsafePointer(to: vImageBuffers[2]) { twoPtr in
                        _ = vImageConvert_Planar8toRGB888(zeroPtr,
                                                          onePtr,
                                                          twoPtr,
                                                          destPtr,
                                                          vImage_Flags(kvImageNoFlags))
                    }
                }
            }
        }
    }
  @inlinable public func interleave(destination: Accelerate.vImage.PixelBuffer<Accelerate.vImage.Interleaved8x3>) {
            
            self.withUnsafePixelBuffers { planarSourceBuffers in
                
                destination.interleave(planarSourceBuffers: planarSourceBuffers)
            }
        }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.Norm : Swift.Sendable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.DataLayout : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.DataLayout : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.Error : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.Error : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.ConvolutionType : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.ConvolutionType : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.LearningPhase : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.LearningPhase : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.LearningPhase : Swift.Sendable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.ChannelOrdering : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.ChannelOrdering : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS.CropResizeLayer.BoxCoordinateMode : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS.CropResizeLayer.BoxCoordinateMode : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS.CropResizeLayer.LinearSamplingMode : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS.CropResizeLayer.LinearSamplingMode : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS.ShuffleType : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS.ShuffleType : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.RoundingMode : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.RoundingMode : Swift.Hashable {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.FloodFillConnectivity : Swift.Equatable {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.FloodFillConnectivity : Swift.Hashable {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage.FloodFillConnectivity : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.ArithmeticTernaryFunction : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.ArithmeticTernaryFunction : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.DFTTransformType : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.DFTTransformType : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.IntegrationRule : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.IntegrationRule : Swift.Hashable {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage_PerpsectiveTransform.Interpolation : Swift.Equatable {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Accelerate.vImage_PerpsectiveTransform.Interpolation : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.ShearDirection : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.ShearDirection : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.ReflectionAxis : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.ReflectionAxis : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.Quadrature.Error : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.Quadrature.Error : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.Radix : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.Radix : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.RandomGeneratorMethod : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.RandomGeneratorMethod : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.Error : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.Error : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.Error : Swift.RawRepresentable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.RelationalOperator : Swift.Sendable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.DescriptorType : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.DescriptorType : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.ArithmeticUnaryFunction : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.ArithmeticUnaryFunction : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.ArithmeticBinaryFunction : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.ArithmeticBinaryFunction : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.InterpolationMethod : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.InterpolationMethod : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS.SparsityType : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.BNNS.SparsityType : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.MultidimensionalLookupTable.InterpolationMethod : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.MultidimensionalLookupTable.InterpolationMethod : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.FourierTransformDirection : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.FourierTransformDirection : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.BlendMode : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Accelerate.vImage.BlendMode : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.SortOrder : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.SortOrder : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.SortOrder : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.DCTTransformType : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.DCTTransformType : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.WindowSequence : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.WindowSequence : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.BufferType : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.BufferType : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.BufferType : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat.Format : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat.Format : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat.ChromaSiting : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat.ChromaSiting : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.LossReduction : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.LossReduction : Swift.Hashable {}
